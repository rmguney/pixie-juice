(async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);
        new MutationObserver((i)=>{
            for (const a of i)if (a.type === "childList") for (const l of a.addedNodes)l.tagName === "LINK" && l.rel === "modulepreload" && n(l);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function t(i) {
            const a = {};
            return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
        }
        function n(i) {
            if (i.ep) return;
            i.ep = !0;
            const a = t(i);
            fetch(i.href, a);
        }
    })();
    function hy(r) {
        return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
    }
    var N_ = {
        exports: {}
    }, Wp = {};
    var Kb;
    function Hw() {
        if (Kb) return Wp;
        Kb = 1;
        var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
        function t(n, i, a) {
            var l = null;
            if (a !== void 0 && (l = "" + a), i.key !== void 0 && (l = "" + i.key), "key" in i) {
                a = {};
                for(var f in i)f !== "key" && (a[f] = i[f]);
            } else a = i;
            return i = a.ref, {
                $$typeof: r,
                type: n,
                key: l,
                ref: i !== void 0 ? i : null,
                props: a
            };
        }
        return Wp.Fragment = e, Wp.jsx = t, Wp.jsxs = t, Wp;
    }
    var Qb;
    function Fw() {
        return Qb || (Qb = 1, N_.exports = Hw()), N_.exports;
    }
    var ae = Fw(), U_ = {
        exports: {}
    }, nn = {};
    var Jb;
    function Gw() {
        if (Jb) return nn;
        Jb = 1;
        var r = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), l = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), y = Symbol.iterator;
        function _(X) {
            return X === null || typeof X != "object" ? null : (X = y && X[y] || X["@@iterator"], typeof X == "function" ? X : null);
        }
        var x = {
            isMounted: function() {
                return !1;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        }, M = Object.assign, R = {};
        function T(X, $, me) {
            this.props = X, this.context = $, this.refs = R, this.updater = me || x;
        }
        T.prototype.isReactComponent = {}, T.prototype.setState = function(X, $) {
            if (typeof X != "object" && typeof X != "function" && X != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, X, $, "setState");
        }, T.prototype.forceUpdate = function(X) {
            this.updater.enqueueForceUpdate(this, X, "forceUpdate");
        };
        function E() {}
        E.prototype = T.prototype;
        function C(X, $, me) {
            this.props = X, this.context = $, this.refs = R, this.updater = me || x;
        }
        var N = C.prototype = new E;
        N.constructor = C, M(N, T.prototype), N.isPureReactComponent = !0;
        var D = Array.isArray, I = {
            H: null,
            A: null,
            T: null,
            S: null,
            V: null
        }, O = Object.prototype.hasOwnProperty;
        function P(X, $, me, ve, J, ue) {
            return me = ue.ref, {
                $$typeof: r,
                type: X,
                key: $,
                ref: me !== void 0 ? me : null,
                props: ue
            };
        }
        function F(X, $) {
            return P(X.type, $, void 0, void 0, void 0, X.props);
        }
        function z(X) {
            return typeof X == "object" && X !== null && X.$$typeof === r;
        }
        function L(X) {
            var $ = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + X.replace(/[=:]/g, function(me) {
                return $[me];
            });
        }
        var q = /\/+/g;
        function oe(X, $) {
            return typeof X == "object" && X !== null && X.key != null ? L("" + X.key) : $.toString(36);
        }
        function se() {}
        function ge(X) {
            switch(X.status){
                case "fulfilled":
                    return X.value;
                case "rejected":
                    throw X.reason;
                default:
                    switch(typeof X.status == "string" ? X.then(se, se) : (X.status = "pending", X.then(function($) {
                        X.status === "pending" && (X.status = "fulfilled", X.value = $);
                    }, function($) {
                        X.status === "pending" && (X.status = "rejected", X.reason = $);
                    })), X.status){
                        case "fulfilled":
                            return X.value;
                        case "rejected":
                            throw X.reason;
                    }
            }
            throw X;
        }
        function _e(X, $, me, ve, J) {
            var ue = typeof X;
            (ue === "undefined" || ue === "boolean") && (X = null);
            var he = !1;
            if (X === null) he = !0;
            else switch(ue){
                case "bigint":
                case "string":
                case "number":
                    he = !0;
                    break;
                case "object":
                    switch(X.$$typeof){
                        case r:
                        case e:
                            he = !0;
                            break;
                        case g:
                            return he = X._init, _e(he(X._payload), $, me, ve, J);
                    }
            }
            if (he) return J = J(X), he = ve === "" ? "." + oe(X, 0) : ve, D(J) ? (me = "", he != null && (me = he.replace(q, "$&/") + "/"), _e(J, $, me, "", function(_t) {
                return _t;
            })) : J != null && (z(J) && (J = F(J, me + (J.key == null || X && X.key === J.key ? "" : ("" + J.key).replace(q, "$&/") + "/") + he)), $.push(J)), 1;
            he = 0;
            var De = ve === "" ? "." : ve + ":";
            if (D(X)) for(var Pe = 0; Pe < X.length; Pe++)ve = X[Pe], ue = De + oe(ve, Pe), he += _e(ve, $, me, ue, J);
            else if (Pe = _(X), typeof Pe == "function") for(X = Pe.call(X), Pe = 0; !(ve = X.next()).done;)ve = ve.value, ue = De + oe(ve, Pe++), he += _e(ve, $, me, ue, J);
            else if (ue === "object") {
                if (typeof X.then == "function") return _e(ge(X), $, me, ve, J);
                throw $ = String(X), Error("Objects are not valid as a React child (found: " + ($ === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : $) + "). If you meant to render a collection of children, use an array instead.");
            }
            return he;
        }
        function H(X, $, me) {
            if (X == null) return X;
            var ve = [], J = 0;
            return _e(X, ve, "", "", function(ue) {
                return $.call(me, ue, J++);
            }), ve;
        }
        function K(X) {
            if (X._status === -1) {
                var $ = X._result;
                $ = $(), $.then(function(me) {
                    (X._status === 0 || X._status === -1) && (X._status = 1, X._result = me);
                }, function(me) {
                    (X._status === 0 || X._status === -1) && (X._status = 2, X._result = me);
                }), X._status === -1 && (X._status = 0, X._result = $);
            }
            if (X._status === 1) return X._result.default;
            throw X._result;
        }
        var Q = typeof reportError == "function" ? reportError : function(X) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var $ = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof X == "object" && X !== null && typeof X.message == "string" ? String(X.message) : String(X),
                    error: X
                });
                if (!window.dispatchEvent($)) return;
            } else if (typeof process == "object" && typeof process.emit == "function") {
                process.emit("uncaughtException", X);
                return;
            }
            console.error(X);
        };
        function fe() {}
        return nn.Children = {
            map: H,
            forEach: function(X, $, me) {
                H(X, function() {
                    $.apply(this, arguments);
                }, me);
            },
            count: function(X) {
                var $ = 0;
                return H(X, function() {
                    $++;
                }), $;
            },
            toArray: function(X) {
                return H(X, function($) {
                    return $;
                }) || [];
            },
            only: function(X) {
                if (!z(X)) throw Error("React.Children.only expected to receive a single React element child.");
                return X;
            }
        }, nn.Component = T, nn.Fragment = t, nn.Profiler = i, nn.PureComponent = C, nn.StrictMode = n, nn.Suspense = d, nn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = I, nn.__COMPILER_RUNTIME = {
            __proto__: null,
            c: function(X) {
                return I.H.useMemoCache(X);
            }
        }, nn.cache = function(X) {
            return function() {
                return X.apply(null, arguments);
            };
        }, nn.cloneElement = function(X, $, me) {
            if (X == null) throw Error("The argument must be a React element, but you passed " + X + ".");
            var ve = M({}, X.props), J = X.key, ue = void 0;
            if ($ != null) for(he in $.ref !== void 0 && (ue = void 0), $.key !== void 0 && (J = "" + $.key), $)!O.call($, he) || he === "key" || he === "__self" || he === "__source" || he === "ref" && $.ref === void 0 || (ve[he] = $[he]);
            var he = arguments.length - 2;
            if (he === 1) ve.children = me;
            else if (1 < he) {
                for(var De = Array(he), Pe = 0; Pe < he; Pe++)De[Pe] = arguments[Pe + 2];
                ve.children = De;
            }
            return P(X.type, J, void 0, void 0, ue, ve);
        }, nn.createContext = function(X) {
            return X = {
                $$typeof: l,
                _currentValue: X,
                _currentValue2: X,
                _threadCount: 0,
                Provider: null,
                Consumer: null
            }, X.Provider = X, X.Consumer = {
                $$typeof: a,
                _context: X
            }, X;
        }, nn.createElement = function(X, $, me) {
            var ve, J = {}, ue = null;
            if ($ != null) for(ve in $.key !== void 0 && (ue = "" + $.key), $)O.call($, ve) && ve !== "key" && ve !== "__self" && ve !== "__source" && (J[ve] = $[ve]);
            var he = arguments.length - 2;
            if (he === 1) J.children = me;
            else if (1 < he) {
                for(var De = Array(he), Pe = 0; Pe < he; Pe++)De[Pe] = arguments[Pe + 2];
                J.children = De;
            }
            if (X && X.defaultProps) for(ve in he = X.defaultProps, he)J[ve] === void 0 && (J[ve] = he[ve]);
            return P(X, ue, void 0, void 0, null, J);
        }, nn.createRef = function() {
            return {
                current: null
            };
        }, nn.forwardRef = function(X) {
            return {
                $$typeof: f,
                render: X
            };
        }, nn.isValidElement = z, nn.lazy = function(X) {
            return {
                $$typeof: g,
                _payload: {
                    _status: -1,
                    _result: X
                },
                _init: K
            };
        }, nn.memo = function(X, $) {
            return {
                $$typeof: p,
                type: X,
                compare: $ === void 0 ? null : $
            };
        }, nn.startTransition = function(X) {
            var $ = I.T, me = {};
            I.T = me;
            try {
                var ve = X(), J = I.S;
                J !== null && J(me, ve), typeof ve == "object" && ve !== null && typeof ve.then == "function" && ve.then(fe, Q);
            } catch (ue) {
                Q(ue);
            } finally{
                I.T = $;
            }
        }, nn.unstable_useCacheRefresh = function() {
            return I.H.useCacheRefresh();
        }, nn.use = function(X) {
            return I.H.use(X);
        }, nn.useActionState = function(X, $, me) {
            return I.H.useActionState(X, $, me);
        }, nn.useCallback = function(X, $) {
            return I.H.useCallback(X, $);
        }, nn.useContext = function(X) {
            return I.H.useContext(X);
        }, nn.useDebugValue = function() {}, nn.useDeferredValue = function(X, $) {
            return I.H.useDeferredValue(X, $);
        }, nn.useEffect = function(X, $, me) {
            var ve = I.H;
            if (typeof me == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
            return ve.useEffect(X, $);
        }, nn.useId = function() {
            return I.H.useId();
        }, nn.useImperativeHandle = function(X, $, me) {
            return I.H.useImperativeHandle(X, $, me);
        }, nn.useInsertionEffect = function(X, $) {
            return I.H.useInsertionEffect(X, $);
        }, nn.useLayoutEffect = function(X, $) {
            return I.H.useLayoutEffect(X, $);
        }, nn.useMemo = function(X, $) {
            return I.H.useMemo(X, $);
        }, nn.useOptimistic = function(X, $) {
            return I.H.useOptimistic(X, $);
        }, nn.useReducer = function(X, $, me) {
            return I.H.useReducer(X, $, me);
        }, nn.useRef = function(X) {
            return I.H.useRef(X);
        }, nn.useState = function(X) {
            return I.H.useState(X);
        }, nn.useSyncExternalStore = function(X, $, me) {
            return I.H.useSyncExternalStore(X, $, me);
        }, nn.useTransition = function() {
            return I.H.useTransition();
        }, nn.version = "19.1.0", nn;
    }
    var $b;
    function Ad() {
        return $b || ($b = 1, U_.exports = Gw()), U_.exports;
    }
    var qe = Ad();
    const EE = hy(qe);
    var L_ = {
        exports: {}
    }, Zp = {}, O_ = {
        exports: {}
    }, z_ = {};
    var eM;
    function Vw() {
        return eM || (eM = 1, (function(r) {
            function e(H, K) {
                var Q = H.length;
                H.push(K);
                e: for(; 0 < Q;){
                    var fe = Q - 1 >>> 1, X = H[fe];
                    if (0 < i(X, K)) H[fe] = K, H[Q] = X, Q = fe;
                    else break e;
                }
            }
            function t(H) {
                return H.length === 0 ? null : H[0];
            }
            function n(H) {
                if (H.length === 0) return null;
                var K = H[0], Q = H.pop();
                if (Q !== K) {
                    H[0] = Q;
                    e: for(var fe = 0, X = H.length, $ = X >>> 1; fe < $;){
                        var me = 2 * (fe + 1) - 1, ve = H[me], J = me + 1, ue = H[J];
                        if (0 > i(ve, Q)) J < X && 0 > i(ue, ve) ? (H[fe] = ue, H[J] = Q, fe = J) : (H[fe] = ve, H[me] = Q, fe = me);
                        else if (J < X && 0 > i(ue, Q)) H[fe] = ue, H[J] = Q, fe = J;
                        else break e;
                    }
                }
                return K;
            }
            function i(H, K) {
                var Q = H.sortIndex - K.sortIndex;
                return Q !== 0 ? Q : H.id - K.id;
            }
            if (r.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
                var a = performance;
                r.unstable_now = function() {
                    return a.now();
                };
            } else {
                var l = Date, f = l.now();
                r.unstable_now = function() {
                    return l.now() - f;
                };
            }
            var d = [], p = [], g = 1, y = null, _ = 3, x = !1, M = !1, R = !1, T = !1, E = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null;
            function D(H) {
                for(var K = t(p); K !== null;){
                    if (K.callback === null) n(p);
                    else if (K.startTime <= H) n(p), K.sortIndex = K.expirationTime, e(d, K);
                    else break;
                    K = t(p);
                }
            }
            function I(H) {
                if (R = !1, D(H), !M) if (t(d) !== null) M = !0, O || (O = !0, oe());
                else {
                    var K = t(p);
                    K !== null && _e(I, K.startTime - H);
                }
            }
            var O = !1, P = -1, F = 5, z = -1;
            function L() {
                return T ? !0 : !(r.unstable_now() - z < F);
            }
            function q() {
                if (T = !1, O) {
                    var H = r.unstable_now();
                    z = H;
                    var K = !0;
                    try {
                        e: {
                            M = !1, R && (R = !1, C(P), P = -1), x = !0;
                            var Q = _;
                            try {
                                t: {
                                    for(D(H), y = t(d); y !== null && !(y.expirationTime > H && L());){
                                        var fe = y.callback;
                                        if (typeof fe == "function") {
                                            y.callback = null, _ = y.priorityLevel;
                                            var X = fe(y.expirationTime <= H);
                                            if (H = r.unstable_now(), typeof X == "function") {
                                                y.callback = X, D(H), K = !0;
                                                break t;
                                            }
                                            y === t(d) && n(d), D(H);
                                        } else n(d);
                                        y = t(d);
                                    }
                                    if (y !== null) K = !0;
                                    else {
                                        var $ = t(p);
                                        $ !== null && _e(I, $.startTime - H), K = !1;
                                    }
                                }
                                break e;
                            } finally{
                                y = null, _ = Q, x = !1;
                            }
                            K = void 0;
                        }
                    } finally{
                        K ? oe() : O = !1;
                    }
                }
            }
            var oe;
            if (typeof N == "function") oe = function() {
                N(q);
            };
            else if (typeof MessageChannel < "u") {
                var se = new MessageChannel, ge = se.port2;
                se.port1.onmessage = q, oe = function() {
                    ge.postMessage(null);
                };
            } else oe = function() {
                E(q, 0);
            };
            function _e(H, K) {
                P = E(function() {
                    H(r.unstable_now());
                }, K);
            }
            r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(H) {
                H.callback = null;
            }, r.unstable_forceFrameRate = function(H) {
                0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < H ? Math.floor(1e3 / H) : 5;
            }, r.unstable_getCurrentPriorityLevel = function() {
                return _;
            }, r.unstable_next = function(H) {
                switch(_){
                    case 1:
                    case 2:
                    case 3:
                        var K = 3;
                        break;
                    default:
                        K = _;
                }
                var Q = _;
                _ = K;
                try {
                    return H();
                } finally{
                    _ = Q;
                }
            }, r.unstable_requestPaint = function() {
                T = !0;
            }, r.unstable_runWithPriority = function(H, K) {
                switch(H){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        H = 3;
                }
                var Q = _;
                _ = H;
                try {
                    return K();
                } finally{
                    _ = Q;
                }
            }, r.unstable_scheduleCallback = function(H, K, Q) {
                var fe = r.unstable_now();
                switch(typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? fe + Q : fe) : Q = fe, H){
                    case 1:
                        var X = -1;
                        break;
                    case 2:
                        X = 250;
                        break;
                    case 5:
                        X = 1073741823;
                        break;
                    case 4:
                        X = 1e4;
                        break;
                    default:
                        X = 5e3;
                }
                return X = Q + X, H = {
                    id: g++,
                    callback: K,
                    priorityLevel: H,
                    startTime: Q,
                    expirationTime: X,
                    sortIndex: -1
                }, Q > fe ? (H.sortIndex = Q, e(p, H), t(d) === null && H === t(p) && (R ? (C(P), P = -1) : R = !0, _e(I, Q - fe))) : (H.sortIndex = X, e(d, H), M || x || (M = !0, O || (O = !0, oe()))), H;
            }, r.unstable_shouldYield = L, r.unstable_wrapCallback = function(H) {
                var K = _;
                return function() {
                    var Q = _;
                    _ = K;
                    try {
                        return H.apply(this, arguments);
                    } finally{
                        _ = Q;
                    }
                };
            };
        })(z_)), z_;
    }
    var tM;
    function kw() {
        return tM || (tM = 1, O_.exports = Vw()), O_.exports;
    }
    var B_ = {
        exports: {}
    }, Us = {};
    var nM;
    function Xw() {
        if (nM) return Us;
        nM = 1;
        var r = Ad();
        function e(d) {
            var p = "https://react.dev/errors/" + d;
            if (1 < arguments.length) {
                p += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var g = 2; g < arguments.length; g++)p += "&args[]=" + encodeURIComponent(arguments[g]);
            }
            return "Minified React error #" + d + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function t() {}
        var n = {
            d: {
                f: t,
                r: function() {
                    throw Error(e(522));
                },
                D: t,
                C: t,
                L: t,
                m: t,
                X: t,
                S: t,
                M: t
            },
            p: 0,
            findDOMNode: null
        }, i = Symbol.for("react.portal");
        function a(d, p, g) {
            var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
                $$typeof: i,
                key: y == null ? null : "" + y,
                children: d,
                containerInfo: p,
                implementation: g
            };
        }
        var l = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        function f(d, p) {
            if (d === "font") return "";
            if (typeof p == "string") return p === "use-credentials" ? p : "";
        }
        return Us.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n, Us.createPortal = function(d, p) {
            var g = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
            if (!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11) throw Error(e(299));
            return a(d, p, null, g);
        }, Us.flushSync = function(d) {
            var p = l.T, g = n.p;
            try {
                if (l.T = null, n.p = 2, d) return d();
            } finally{
                l.T = p, n.p = g, n.d.f();
            }
        }, Us.preconnect = function(d, p) {
            typeof d == "string" && (p ? (p = p.crossOrigin, p = typeof p == "string" ? p === "use-credentials" ? p : "" : void 0) : p = null, n.d.C(d, p));
        }, Us.prefetchDNS = function(d) {
            typeof d == "string" && n.d.D(d);
        }, Us.preinit = function(d, p) {
            if (typeof d == "string" && p && typeof p.as == "string") {
                var g = p.as, y = f(g, p.crossOrigin), _ = typeof p.integrity == "string" ? p.integrity : void 0, x = typeof p.fetchPriority == "string" ? p.fetchPriority : void 0;
                g === "style" ? n.d.S(d, typeof p.precedence == "string" ? p.precedence : void 0, {
                    crossOrigin: y,
                    integrity: _,
                    fetchPriority: x
                }) : g === "script" && n.d.X(d, {
                    crossOrigin: y,
                    integrity: _,
                    fetchPriority: x,
                    nonce: typeof p.nonce == "string" ? p.nonce : void 0
                });
            }
        }, Us.preinitModule = function(d, p) {
            if (typeof d == "string") if (typeof p == "object" && p !== null) {
                if (p.as == null || p.as === "script") {
                    var g = f(p.as, p.crossOrigin);
                    n.d.M(d, {
                        crossOrigin: g,
                        integrity: typeof p.integrity == "string" ? p.integrity : void 0,
                        nonce: typeof p.nonce == "string" ? p.nonce : void 0
                    });
                }
            } else p == null && n.d.M(d);
        }, Us.preload = function(d, p) {
            if (typeof d == "string" && typeof p == "object" && p !== null && typeof p.as == "string") {
                var g = p.as, y = f(g, p.crossOrigin);
                n.d.L(d, g, {
                    crossOrigin: y,
                    integrity: typeof p.integrity == "string" ? p.integrity : void 0,
                    nonce: typeof p.nonce == "string" ? p.nonce : void 0,
                    type: typeof p.type == "string" ? p.type : void 0,
                    fetchPriority: typeof p.fetchPriority == "string" ? p.fetchPriority : void 0,
                    referrerPolicy: typeof p.referrerPolicy == "string" ? p.referrerPolicy : void 0,
                    imageSrcSet: typeof p.imageSrcSet == "string" ? p.imageSrcSet : void 0,
                    imageSizes: typeof p.imageSizes == "string" ? p.imageSizes : void 0,
                    media: typeof p.media == "string" ? p.media : void 0
                });
            }
        }, Us.preloadModule = function(d, p) {
            if (typeof d == "string") if (p) {
                var g = f(p.as, p.crossOrigin);
                n.d.m(d, {
                    as: typeof p.as == "string" && p.as !== "script" ? p.as : void 0,
                    crossOrigin: g,
                    integrity: typeof p.integrity == "string" ? p.integrity : void 0
                });
            } else n.d.m(d);
        }, Us.requestFormReset = function(d) {
            n.d.r(d);
        }, Us.unstable_batchedUpdates = function(d, p) {
            return d(p);
        }, Us.useFormState = function(d, p, g) {
            return l.H.useFormState(d, p, g);
        }, Us.useFormStatus = function() {
            return l.H.useHostTransitionStatus();
        }, Us.version = "19.1.0", Us;
    }
    var iM;
    function jw() {
        if (iM) return B_.exports;
        iM = 1;
        function r() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r);
            } catch (e) {
                console.error(e);
            }
        }
        return r(), B_.exports = Xw(), B_.exports;
    }
    var sM;
    function qw() {
        if (sM) return Zp;
        sM = 1;
        var r = kw(), e = Ad(), t = jw();
        function n(s) {
            var o = "https://react.dev/errors/" + s;
            if (1 < arguments.length) {
                o += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var h = 2; h < arguments.length; h++)o += "&args[]=" + encodeURIComponent(arguments[h]);
            }
            return "Minified React error #" + s + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function i(s) {
            return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
        }
        function a(s) {
            var o = s, h = s;
            if (s.alternate) for(; o.return;)o = o.return;
            else {
                s = o;
                do o = s, (o.flags & 4098) !== 0 && (h = o.return), s = o.return;
                while (s);
            }
            return o.tag === 3 ? h : null;
        }
        function l(s) {
            if (s.tag === 13) {
                var o = s.memoizedState;
                if (o === null && (s = s.alternate, s !== null && (o = s.memoizedState)), o !== null) return o.dehydrated;
            }
            return null;
        }
        function f(s) {
            if (a(s) !== s) throw Error(n(188));
        }
        function d(s) {
            var o = s.alternate;
            if (!o) {
                if (o = a(s), o === null) throw Error(n(188));
                return o !== s ? null : s;
            }
            for(var h = s, m = o;;){
                var S = h.return;
                if (S === null) break;
                var A = S.alternate;
                if (A === null) {
                    if (m = S.return, m !== null) {
                        h = m;
                        continue;
                    }
                    break;
                }
                if (S.child === A.child) {
                    for(A = S.child; A;){
                        if (A === h) return f(S), s;
                        if (A === m) return f(S), o;
                        A = A.sibling;
                    }
                    throw Error(n(188));
                }
                if (h.return !== m.return) h = S, m = A;
                else {
                    for(var B = !1, V = S.child; V;){
                        if (V === h) {
                            B = !0, h = S, m = A;
                            break;
                        }
                        if (V === m) {
                            B = !0, m = S, h = A;
                            break;
                        }
                        V = V.sibling;
                    }
                    if (!B) {
                        for(V = A.child; V;){
                            if (V === h) {
                                B = !0, h = A, m = S;
                                break;
                            }
                            if (V === m) {
                                B = !0, m = A, h = S;
                                break;
                            }
                            V = V.sibling;
                        }
                        if (!B) throw Error(n(189));
                    }
                }
                if (h.alternate !== m) throw Error(n(190));
            }
            if (h.tag !== 3) throw Error(n(188));
            return h.stateNode.current === h ? s : o;
        }
        function p(s) {
            var o = s.tag;
            if (o === 5 || o === 26 || o === 27 || o === 6) return s;
            for(s = s.child; s !== null;){
                if (o = p(s), o !== null) return o;
                s = s.sibling;
            }
            return null;
        }
        var g = Object.assign, y = Symbol.for("react.element"), _ = Symbol.for("react.transitional.element"), x = Symbol.for("react.portal"), M = Symbol.for("react.fragment"), R = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), C = Symbol.for("react.consumer"), N = Symbol.for("react.context"), D = Symbol.for("react.forward_ref"), I = Symbol.for("react.suspense"), O = Symbol.for("react.suspense_list"), P = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), z = Symbol.for("react.activity"), L = Symbol.for("react.memo_cache_sentinel"), q = Symbol.iterator;
        function oe(s) {
            return s === null || typeof s != "object" ? null : (s = q && s[q] || s["@@iterator"], typeof s == "function" ? s : null);
        }
        var se = Symbol.for("react.client.reference");
        function ge(s) {
            if (s == null) return null;
            if (typeof s == "function") return s.$$typeof === se ? null : s.displayName || s.name || null;
            if (typeof s == "string") return s;
            switch(s){
                case M:
                    return "Fragment";
                case T:
                    return "Profiler";
                case R:
                    return "StrictMode";
                case I:
                    return "Suspense";
                case O:
                    return "SuspenseList";
                case z:
                    return "Activity";
            }
            if (typeof s == "object") switch(s.$$typeof){
                case x:
                    return "Portal";
                case N:
                    return (s.displayName || "Context") + ".Provider";
                case C:
                    return (s._context.displayName || "Context") + ".Consumer";
                case D:
                    var o = s.render;
                    return s = s.displayName, s || (s = o.displayName || o.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
                case P:
                    return o = s.displayName || null, o !== null ? o : ge(s.type) || "Memo";
                case F:
                    o = s._payload, s = s._init;
                    try {
                        return ge(s(o));
                    } catch  {}
            }
            return null;
        }
        var _e = Array.isArray, H = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Q = {
            pending: !1,
            data: null,
            method: null,
            action: null
        }, fe = [], X = -1;
        function $(s) {
            return {
                current: s
            };
        }
        function me(s) {
            0 > X || (s.current = fe[X], fe[X] = null, X--);
        }
        function ve(s, o) {
            X++, fe[X] = s.current, s.current = o;
        }
        var J = $(null), ue = $(null), he = $(null), De = $(null);
        function Pe(s, o) {
            switch(ve(he, o), ve(ue, s), ve(J, null), o.nodeType){
                case 9:
                case 11:
                    s = (s = o.documentElement) && (s = s.namespaceURI) ? Eb(s) : 0;
                    break;
                default:
                    if (s = o.tagName, o = o.namespaceURI) o = Eb(o), s = Tb(o, s);
                    else switch(s){
                        case "svg":
                            s = 1;
                            break;
                        case "math":
                            s = 2;
                            break;
                        default:
                            s = 0;
                    }
            }
            me(J), ve(J, s);
        }
        function _t() {
            me(J), me(ue), me(he);
        }
        function xt(s) {
            s.memoizedState !== null && ve(De, s);
            var o = J.current, h = Tb(o, s.type);
            o !== h && (ve(ue, s), ve(J, h));
        }
        function on(s) {
            ue.current === s && (me(J), me(ue)), De.current === s && (me(De), kp._currentValue = Q);
        }
        var Vt = Object.prototype.hasOwnProperty, Nt = r.unstable_scheduleCallback, W = r.unstable_cancelCallback, et = r.unstable_shouldYield, Ye = r.unstable_requestPaint, We = r.unstable_now, Be = r.unstable_getCurrentPriorityLevel, ut = r.unstable_ImmediatePriority, Xe = r.unstable_UserBlockingPriority, ot = r.unstable_NormalPriority, It = r.unstable_LowPriority, Z = r.unstable_IdlePriority, G = r.log, Se = r.unstable_setDisableYieldValue, Ue = null, Le = null;
        function Ne(s) {
            if (typeof G == "function" && Se(s), Le && typeof Le.setStrictMode == "function") try {
                Le.setStrictMode(Ue, s);
            } catch  {}
        }
        var lt = Math.clz32 ? Math.clz32 : yt, it = Math.log, vt = Math.LN2;
        function yt(s) {
            return s >>>= 0, s === 0 ? 32 : 31 - (it(s) / vt | 0) | 0;
        }
        var He = 256, st = 4194304;
        function St(s) {
            var o = s & 42;
            if (o !== 0) return o;
            switch(s & -s){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                    return 128;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return s & 4194048;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return s & 62914560;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return s;
            }
        }
        function ie(s, o, h) {
            var m = s.pendingLanes;
            if (m === 0) return 0;
            var S = 0, A = s.suspendedLanes, B = s.pingedLanes;
            s = s.warmLanes;
            var V = m & 134217727;
            return V !== 0 ? (m = V & ~A, m !== 0 ? S = St(m) : (B &= V, B !== 0 ? S = St(B) : h || (h = V & ~s, h !== 0 && (S = St(h))))) : (V = m & ~A, V !== 0 ? S = St(V) : B !== 0 ? S = St(B) : h || (h = m & ~s, h !== 0 && (S = St(h)))), S === 0 ? 0 : o !== 0 && o !== S && (o & A) === 0 && (A = S & -S, h = o & -o, A >= h || A === 32 && (h & 4194048) !== 0) ? o : S;
        }
        function xe(s, o) {
            return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & o) === 0;
        }
        function Ze(s, o) {
            switch(s){
                case 1:
                case 2:
                case 4:
                case 8:
                case 64:
                    return o + 250;
                case 16:
                case 32:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return o + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function te() {
            var s = He;
            return He <<= 1, (He & 4194048) === 0 && (He = 256), s;
        }
        function Qe() {
            var s = st;
            return st <<= 1, (st & 62914560) === 0 && (st = 4194304), s;
        }
        function Ve(s) {
            for(var o = [], h = 0; 31 > h; h++)o.push(s);
            return o;
        }
        function rt(s, o) {
            s.pendingLanes |= o, o !== 268435456 && (s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0);
        }
        function Ke(s, o, h, m, S, A) {
            var B = s.pendingLanes;
            s.pendingLanes = h, s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0, s.expiredLanes &= h, s.entangledLanes &= h, s.errorRecoveryDisabledLanes &= h, s.shellSuspendCounter = 0;
            var V = s.entanglements, ee = s.expirationTimes, Me = s.hiddenUpdates;
            for(h = B & ~h; 0 < h;){
                var ze = 31 - lt(h), ke = 1 << ze;
                V[ze] = 0, ee[ze] = -1;
                var Te = Me[ze];
                if (Te !== null) for(Me[ze] = null, ze = 0; ze < Te.length; ze++){
                    var Re = Te[ze];
                    Re !== null && (Re.lane &= -536870913);
                }
                h &= ~ke;
            }
            m !== 0 && Fe(s, m, 0), A !== 0 && S === 0 && s.tag !== 0 && (s.suspendedLanes |= A & ~(B & ~o));
        }
        function Fe(s, o, h) {
            s.pendingLanes |= o, s.suspendedLanes &= ~o;
            var m = 31 - lt(o);
            s.entangledLanes |= o, s.entanglements[m] = s.entanglements[m] | 1073741824 | h & 4194090;
        }
        function ct(s, o) {
            var h = s.entangledLanes |= o;
            for(s = s.entanglements; h;){
                var m = 31 - lt(h), S = 1 << m;
                S & o | s[m] & o && (s[m] |= o), h &= ~S;
            }
        }
        function Mt(s) {
            switch(s){
                case 2:
                    s = 1;
                    break;
                case 8:
                    s = 4;
                    break;
                case 32:
                    s = 16;
                    break;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    s = 128;
                    break;
                case 268435456:
                    s = 134217728;
                    break;
                default:
                    s = 0;
            }
            return s;
        }
        function tn(s) {
            return s &= -s, 2 < s ? 8 < s ? (s & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
        }
        function Zt() {
            var s = K.p;
            return s !== 0 ? s : (s = window.event, s === void 0 ? 32 : Xb(s.type));
        }
        function gi(s, o) {
            var h = K.p;
            try {
                return K.p = s, o();
            } finally{
                K.p = h;
            }
        }
        var Zn = Math.random().toString(36).slice(2), vi = "__reactFiber$" + Zn, Ei = "__reactProps$" + Zn, ns = "__reactContainer$" + Zn, Ms = "__reactEvents$" + Zn, nu = "__reactListeners$" + Zn, Ma = "__reactHandles$" + Zn, fs = "__reactResources$" + Zn, Ea = "__reactMarker$" + Zn;
        function Un(s) {
            delete s[vi], delete s[Ei], delete s[Ms], delete s[nu], delete s[Ma];
        }
        function Ta(s) {
            var o = s[vi];
            if (o) return o;
            for(var h = s.parentNode; h;){
                if (o = h[ns] || h[vi]) {
                    if (h = o.alternate, o.child !== null || h !== null && h.child !== null) for(s = Cb(s); s !== null;){
                        if (h = s[vi]) return h;
                        s = Cb(s);
                    }
                    return o;
                }
                s = h, h = s.parentNode;
            }
            return null;
        }
        function Aa(s) {
            if (s = s[vi] || s[ns]) {
                var o = s.tag;
                if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3) return s;
            }
            return null;
        }
        function ro(s) {
            var o = s.tag;
            if (o === 5 || o === 26 || o === 27 || o === 6) return s.stateNode;
            throw Error(n(33));
        }
        function Ar(s) {
            var o = s[fs];
            return o || (o = s[fs] = {
                hoistableStyles: new Map,
                hoistableScripts: new Map
            }), o;
        }
        function yi(s) {
            s[Ea] = !0;
        }
        var Pl = new Set, Hl = {};
        function wa(s, o) {
            k(s, o), k(s + "Capture", o);
        }
        function k(s, o) {
            for(Hl[s] = o, s = 0; s < o.length; s++)Pl.add(o[s]);
        }
        var ce = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Ae = {}, we = {};
        function pe(s) {
            return Vt.call(we, s) ? !0 : Vt.call(Ae, s) ? !1 : ce.test(s) ? we[s] = !0 : (Ae[s] = !0, !1);
        }
        function je(s, o, h) {
            if (pe(o)) if (h === null) s.removeAttribute(o);
            else {
                switch(typeof h){
                    case "undefined":
                    case "function":
                    case "symbol":
                        s.removeAttribute(o);
                        return;
                    case "boolean":
                        var m = o.toLowerCase().slice(0, 5);
                        if (m !== "data-" && m !== "aria-") {
                            s.removeAttribute(o);
                            return;
                        }
                }
                s.setAttribute(o, "" + h);
            }
        }
        function at(s, o, h) {
            if (h === null) s.removeAttribute(o);
            else {
                switch(typeof h){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        s.removeAttribute(o);
                        return;
                }
                s.setAttribute(o, "" + h);
            }
        }
        function dt(s, o, h, m) {
            if (m === null) s.removeAttribute(h);
            else {
                switch(typeof m){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        s.removeAttribute(h);
                        return;
                }
                s.setAttributeNS(o, h, "" + m);
            }
        }
        var mt, Lt;
        function wt(s) {
            if (mt === void 0) try {
                throw Error();
            } catch (h) {
                var o = h.stack.trim().match(/\n( *(at )?)/);
                mt = o && o[1] || "", Lt = -1 < h.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < h.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
            return `
` + mt + s + Lt;
        }
        var Et = !1;
        function Kt(s, o) {
            if (!s || Et) return "";
            Et = !0;
            var h = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                var m = {
                    DetermineComponentFrameRoot: function() {
                        try {
                            if (o) {
                                var ke = function() {
                                    throw Error();
                                };
                                if (Object.defineProperty(ke.prototype, "props", {
                                    set: function() {
                                        throw Error();
                                    }
                                }), typeof Reflect == "object" && Reflect.construct) {
                                    try {
                                        Reflect.construct(ke, []);
                                    } catch (Re) {
                                        var Te = Re;
                                    }
                                    Reflect.construct(s, [], ke);
                                } else {
                                    try {
                                        ke.call();
                                    } catch (Re) {
                                        Te = Re;
                                    }
                                    s.call(ke.prototype);
                                }
                            } else {
                                try {
                                    throw Error();
                                } catch (Re) {
                                    Te = Re;
                                }
                                (ke = s()) && typeof ke.catch == "function" && ke.catch(function() {});
                            }
                        } catch (Re) {
                            if (Re && Te && typeof Re.stack == "string") return [
                                Re.stack,
                                Te.stack
                            ];
                        }
                        return [
                            null,
                            null
                        ];
                    }
                };
                m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var S = Object.getOwnPropertyDescriptor(m.DetermineComponentFrameRoot, "name");
                S && S.configurable && Object.defineProperty(m.DetermineComponentFrameRoot, "name", {
                    value: "DetermineComponentFrameRoot"
                });
                var A = m.DetermineComponentFrameRoot(), B = A[0], V = A[1];
                if (B && V) {
                    var ee = B.split(`
`), Me = V.split(`
`);
                    for(S = m = 0; m < ee.length && !ee[m].includes("DetermineComponentFrameRoot");)m++;
                    for(; S < Me.length && !Me[S].includes("DetermineComponentFrameRoot");)S++;
                    if (m === ee.length || S === Me.length) for(m = ee.length - 1, S = Me.length - 1; 1 <= m && 0 <= S && ee[m] !== Me[S];)S--;
                    for(; 1 <= m && 0 <= S; m--, S--)if (ee[m] !== Me[S]) {
                        if (m !== 1 || S !== 1) do if (m--, S--, 0 > S || ee[m] !== Me[S]) {
                            var ze = `
` + ee[m].replace(" at new ", " at ");
                            return s.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", s.displayName)), ze;
                        }
                        while (1 <= m && 0 <= S);
                        break;
                    }
                }
            } finally{
                Et = !1, Error.prepareStackTrace = h;
            }
            return (h = s ? s.displayName || s.name : "") ? wt(h) : "";
        }
        function En(s) {
            switch(s.tag){
                case 26:
                case 27:
                case 5:
                    return wt(s.type);
                case 16:
                    return wt("Lazy");
                case 13:
                    return wt("Suspense");
                case 19:
                    return wt("SuspenseList");
                case 0:
                case 15:
                    return Kt(s.type, !1);
                case 11:
                    return Kt(s.type.render, !1);
                case 1:
                    return Kt(s.type, !0);
                case 31:
                    return wt("Activity");
                default:
                    return "";
            }
        }
        function Gn(s) {
            try {
                var o = "";
                do o += En(s), s = s.return;
                while (s);
                return o;
            } catch (h) {
                return `
Error generating stack: ` + h.message + `
` + h.stack;
            }
        }
        function Jt(s) {
            switch(typeof s){
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                    return s;
                case "object":
                    return s;
                default:
                    return "";
            }
        }
        function Tn(s) {
            var o = s.type;
            return (s = s.nodeName) && s.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
        }
        function Rt(s) {
            var o = Tn(s) ? "checked" : "value", h = Object.getOwnPropertyDescriptor(s.constructor.prototype, o), m = "" + s[o];
            if (!s.hasOwnProperty(o) && typeof h < "u" && typeof h.get == "function" && typeof h.set == "function") {
                var S = h.get, A = h.set;
                return Object.defineProperty(s, o, {
                    configurable: !0,
                    get: function() {
                        return S.call(this);
                    },
                    set: function(B) {
                        m = "" + B, A.call(this, B);
                    }
                }), Object.defineProperty(s, o, {
                    enumerable: h.enumerable
                }), {
                    getValue: function() {
                        return m;
                    },
                    setValue: function(B) {
                        m = "" + B;
                    },
                    stopTracking: function() {
                        s._valueTracker = null, delete s[o];
                    }
                };
            }
        }
        function Dn(s) {
            s._valueTracker || (s._valueTracker = Rt(s));
        }
        function ln(s) {
            if (!s) return !1;
            var o = s._valueTracker;
            if (!o) return !0;
            var h = o.getValue(), m = "";
            return s && (m = Tn(s) ? s.checked ? "true" : "false" : s.value), s = m, s !== h ? (o.setValue(s), !0) : !1;
        }
        function Ti(s) {
            if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
            try {
                return s.activeElement || s.body;
            } catch  {
                return s.body;
            }
        }
        var Wa = /[\n"\\]/g;
        function zn(s) {
            return s.replace(Wa, function(o) {
                return "\\" + o.charCodeAt(0).toString(16) + " ";
            });
        }
        function Za(s, o, h, m, S, A, B, V) {
            s.name = "", B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" ? s.type = B : s.removeAttribute("type"), o != null ? B === "number" ? (o === 0 && s.value === "" || s.value != o) && (s.value = "" + Jt(o)) : s.value !== "" + Jt(o) && (s.value = "" + Jt(o)) : B !== "submit" && B !== "reset" || s.removeAttribute("value"), o != null ? Xi(s, B, Jt(o)) : h != null ? Xi(s, B, Jt(h)) : m != null && s.removeAttribute("value"), S == null && A != null && (s.defaultChecked = !!A), S != null && (s.checked = S && typeof S != "function" && typeof S != "symbol"), V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" ? s.name = "" + Jt(V) : s.removeAttribute("name");
        }
        function Ln(s, o, h, m, S, A, B, V) {
            if (A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" && (s.type = A), o != null || h != null) {
                if (!(A !== "submit" && A !== "reset" || o != null)) return;
                h = h != null ? "" + Jt(h) : "", o = o != null ? "" + Jt(o) : h, V || o === s.value || (s.value = o), s.defaultValue = o;
            }
            m = m ?? S, m = typeof m != "function" && typeof m != "symbol" && !!m, s.checked = V ? s.checked : !!m, s.defaultChecked = !!m, B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" && (s.name = B);
        }
        function Xi(s, o, h) {
            o === "number" && Ti(s.ownerDocument) === s || s.defaultValue === "" + h || (s.defaultValue = "" + h);
        }
        function _i(s, o, h, m) {
            if (s = s.options, o) {
                o = {};
                for(var S = 0; S < h.length; S++)o["$" + h[S]] = !0;
                for(h = 0; h < s.length; h++)S = o.hasOwnProperty("$" + s[h].value), s[h].selected !== S && (s[h].selected = S), S && m && (s[h].defaultSelected = !0);
            } else {
                for(h = "" + Jt(h), o = null, S = 0; S < s.length; S++){
                    if (s[S].value === h) {
                        s[S].selected = !0, m && (s[S].defaultSelected = !0);
                        return;
                    }
                    o !== null || s[S].disabled || (o = s[S]);
                }
                o !== null && (o.selected = !0);
            }
        }
        function Oi(s, o, h) {
            if (o != null && (o = "" + Jt(o), o !== s.value && (s.value = o), h == null)) {
                s.defaultValue !== o && (s.defaultValue = o);
                return;
            }
            s.defaultValue = h != null ? "" + Jt(h) : "";
        }
        function zi(s, o, h, m) {
            if (o == null) {
                if (m != null) {
                    if (h != null) throw Error(n(92));
                    if (_e(m)) {
                        if (1 < m.length) throw Error(n(93));
                        m = m[0];
                    }
                    h = m;
                }
                h == null && (h = ""), o = h;
            }
            h = Jt(o), s.defaultValue = h, m = s.textContent, m === h && m !== "" && m !== null && (s.value = m);
        }
        function hs(s, o) {
            if (o) {
                var h = s.firstChild;
                if (h && h === s.lastChild && h.nodeType === 3) {
                    h.nodeValue = o;
                    return;
                }
            }
            s.textContent = o;
        }
        var Ka = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
        function iu(s, o, h) {
            var m = o.indexOf("--") === 0;
            h == null || typeof h == "boolean" || h === "" ? m ? s.setProperty(o, "") : o === "float" ? s.cssFloat = "" : s[o] = "" : m ? s.setProperty(o, h) : typeof h != "number" || h === 0 || Ka.has(o) ? o === "float" ? s.cssFloat = h : s[o] = ("" + h).trim() : s[o] = h + "px";
        }
        function su(s, o, h) {
            if (o != null && typeof o != "object") throw Error(n(62));
            if (s = s.style, h != null) {
                for(var m in h)!h.hasOwnProperty(m) || o != null && o.hasOwnProperty(m) || (m.indexOf("--") === 0 ? s.setProperty(m, "") : m === "float" ? s.cssFloat = "" : s[m] = "");
                for(var S in o)m = o[S], o.hasOwnProperty(S) && h[S] !== m && iu(s, S, m);
            } else for(var A in o)o.hasOwnProperty(A) && iu(s, A, o[A]);
        }
        function Of(s) {
            if (s.indexOf("-") === -1) return !1;
            switch(s){
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0;
            }
        }
        var zd = new Map([
            [
                "acceptCharset",
                "accept-charset"
            ],
            [
                "htmlFor",
                "for"
            ],
            [
                "httpEquiv",
                "http-equiv"
            ],
            [
                "crossOrigin",
                "crossorigin"
            ],
            [
                "accentHeight",
                "accent-height"
            ],
            [
                "alignmentBaseline",
                "alignment-baseline"
            ],
            [
                "arabicForm",
                "arabic-form"
            ],
            [
                "baselineShift",
                "baseline-shift"
            ],
            [
                "capHeight",
                "cap-height"
            ],
            [
                "clipPath",
                "clip-path"
            ],
            [
                "clipRule",
                "clip-rule"
            ],
            [
                "colorInterpolation",
                "color-interpolation"
            ],
            [
                "colorInterpolationFilters",
                "color-interpolation-filters"
            ],
            [
                "colorProfile",
                "color-profile"
            ],
            [
                "colorRendering",
                "color-rendering"
            ],
            [
                "dominantBaseline",
                "dominant-baseline"
            ],
            [
                "enableBackground",
                "enable-background"
            ],
            [
                "fillOpacity",
                "fill-opacity"
            ],
            [
                "fillRule",
                "fill-rule"
            ],
            [
                "floodColor",
                "flood-color"
            ],
            [
                "floodOpacity",
                "flood-opacity"
            ],
            [
                "fontFamily",
                "font-family"
            ],
            [
                "fontSize",
                "font-size"
            ],
            [
                "fontSizeAdjust",
                "font-size-adjust"
            ],
            [
                "fontStretch",
                "font-stretch"
            ],
            [
                "fontStyle",
                "font-style"
            ],
            [
                "fontVariant",
                "font-variant"
            ],
            [
                "fontWeight",
                "font-weight"
            ],
            [
                "glyphName",
                "glyph-name"
            ],
            [
                "glyphOrientationHorizontal",
                "glyph-orientation-horizontal"
            ],
            [
                "glyphOrientationVertical",
                "glyph-orientation-vertical"
            ],
            [
                "horizAdvX",
                "horiz-adv-x"
            ],
            [
                "horizOriginX",
                "horiz-origin-x"
            ],
            [
                "imageRendering",
                "image-rendering"
            ],
            [
                "letterSpacing",
                "letter-spacing"
            ],
            [
                "lightingColor",
                "lighting-color"
            ],
            [
                "markerEnd",
                "marker-end"
            ],
            [
                "markerMid",
                "marker-mid"
            ],
            [
                "markerStart",
                "marker-start"
            ],
            [
                "overlinePosition",
                "overline-position"
            ],
            [
                "overlineThickness",
                "overline-thickness"
            ],
            [
                "paintOrder",
                "paint-order"
            ],
            [
                "panose-1",
                "panose-1"
            ],
            [
                "pointerEvents",
                "pointer-events"
            ],
            [
                "renderingIntent",
                "rendering-intent"
            ],
            [
                "shapeRendering",
                "shape-rendering"
            ],
            [
                "stopColor",
                "stop-color"
            ],
            [
                "stopOpacity",
                "stop-opacity"
            ],
            [
                "strikethroughPosition",
                "strikethrough-position"
            ],
            [
                "strikethroughThickness",
                "strikethrough-thickness"
            ],
            [
                "strokeDasharray",
                "stroke-dasharray"
            ],
            [
                "strokeDashoffset",
                "stroke-dashoffset"
            ],
            [
                "strokeLinecap",
                "stroke-linecap"
            ],
            [
                "strokeLinejoin",
                "stroke-linejoin"
            ],
            [
                "strokeMiterlimit",
                "stroke-miterlimit"
            ],
            [
                "strokeOpacity",
                "stroke-opacity"
            ],
            [
                "strokeWidth",
                "stroke-width"
            ],
            [
                "textAnchor",
                "text-anchor"
            ],
            [
                "textDecoration",
                "text-decoration"
            ],
            [
                "textRendering",
                "text-rendering"
            ],
            [
                "transformOrigin",
                "transform-origin"
            ],
            [
                "underlinePosition",
                "underline-position"
            ],
            [
                "underlineThickness",
                "underline-thickness"
            ],
            [
                "unicodeBidi",
                "unicode-bidi"
            ],
            [
                "unicodeRange",
                "unicode-range"
            ],
            [
                "unitsPerEm",
                "units-per-em"
            ],
            [
                "vAlphabetic",
                "v-alphabetic"
            ],
            [
                "vHanging",
                "v-hanging"
            ],
            [
                "vIdeographic",
                "v-ideographic"
            ],
            [
                "vMathematical",
                "v-mathematical"
            ],
            [
                "vectorEffect",
                "vector-effect"
            ],
            [
                "vertAdvY",
                "vert-adv-y"
            ],
            [
                "vertOriginX",
                "vert-origin-x"
            ],
            [
                "vertOriginY",
                "vert-origin-y"
            ],
            [
                "wordSpacing",
                "word-spacing"
            ],
            [
                "writingMode",
                "writing-mode"
            ],
            [
                "xmlnsXlink",
                "xmlns:xlink"
            ],
            [
                "xHeight",
                "x-height"
            ]
        ]), Ym = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function au(s) {
            return Ym.test("" + s) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : s;
        }
        var zf = null;
        function Bf(s) {
            return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
        }
        var oo = null, Jo = null;
        function Bd(s) {
            var o = Aa(s);
            if (o && (s = o.stateNode)) {
                var h = s[Ei] || null;
                e: switch(s = o.stateNode, o.type){
                    case "input":
                        if (Za(s, h.value, h.defaultValue, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name), o = h.name, h.type === "radio" && o != null) {
                            for(h = s; h.parentNode;)h = h.parentNode;
                            for(h = h.querySelectorAll('input[name="' + zn("" + o) + '"][type="radio"]'), o = 0; o < h.length; o++){
                                var m = h[o];
                                if (m !== s && m.form === s.form) {
                                    var S = m[Ei] || null;
                                    if (!S) throw Error(n(90));
                                    Za(m, S.value, S.defaultValue, S.defaultValue, S.checked, S.defaultChecked, S.type, S.name);
                                }
                            }
                            for(o = 0; o < h.length; o++)m = h[o], m.form === s.form && ln(m);
                        }
                        break e;
                    case "textarea":
                        Oi(s, h.value, h.defaultValue);
                        break e;
                    case "select":
                        o = h.value, o != null && _i(s, !!h.multiple, o, !1);
                }
            }
        }
        var ru = !1;
        function Id(s, o, h) {
            if (ru) return s(o, h);
            ru = !0;
            try {
                var m = s(o);
                return m;
            } finally{
                if (ru = !1, (oo !== null || Jo !== null) && (hr(), oo && (o = oo, s = Jo, Jo = oo = null, Bd(o), s))) for(o = 0; o < s.length; o++)Bd(s[o]);
            }
        }
        function Fl(s, o) {
            var h = s.stateNode;
            if (h === null) return null;
            var m = h[Ei] || null;
            if (m === null) return null;
            h = m[o];
            e: switch(o){
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (m = !m.disabled) || (s = s.type, m = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !m;
                    break e;
                default:
                    s = !1;
            }
            if (s) return null;
            if (h && typeof h != "function") throw Error(n(231, o, typeof h));
            return h;
        }
        var Qa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ou = !1;
        if (Qa) try {
            var Gl = {};
            Object.defineProperty(Gl, "passive", {
                get: function() {
                    ou = !0;
                }
            }), window.addEventListener("test", Gl, Gl), window.removeEventListener("test", Gl, Gl);
        } catch  {
            ou = !1;
        }
        var wr = null, Pd = null, If = null;
        function Hd() {
            if (If) return If;
            var s, o = Pd, h = o.length, m, S = "value" in wr ? wr.value : wr.textContent, A = S.length;
            for(s = 0; s < h && o[s] === S[s]; s++);
            var B = h - s;
            for(m = 1; m <= B && o[h - m] === S[A - m]; m++);
            return If = S.slice(s, 1 < m ? 1 - m : void 0);
        }
        function lo(s) {
            var o = s.keyCode;
            return "charCode" in s ? (s = s.charCode, s === 0 && o === 13 && (s = 13)) : s = o, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
        }
        function Vl() {
            return !0;
        }
        function lu() {
            return !1;
        }
        function ds(s) {
            function o(h, m, S, A, B) {
                this._reactName = h, this._targetInst = S, this.type = m, this.nativeEvent = A, this.target = B, this.currentTarget = null;
                for(var V in s)s.hasOwnProperty(V) && (h = s[V], this[V] = h ? h(A) : A[V]);
                return this.isDefaultPrevented = (A.defaultPrevented != null ? A.defaultPrevented : A.returnValue === !1) ? Vl : lu, this.isPropagationStopped = lu, this;
            }
            return g(o.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                    var h = this.nativeEvent;
                    h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = Vl);
                },
                stopPropagation: function() {
                    var h = this.nativeEvent;
                    h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = Vl);
                },
                persist: function() {},
                isPersistent: Vl
            }), o;
        }
        var co = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(s) {
                return s.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        }, kl = ds(co), Xl = g({}, co, {
            view: 0,
            detail: 0
        }), Wm = ds(Xl), Rr, jl, ql, Yl = g({}, Xl, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: uu,
            button: 0,
            buttons: 0,
            relatedTarget: function(s) {
                return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
            },
            movementX: function(s) {
                return "movementX" in s ? s.movementX : (s !== ql && (ql && s.type === "mousemove" ? (Rr = s.screenX - ql.screenX, jl = s.screenY - ql.screenY) : jl = Rr = 0, ql = s), Rr);
            },
            movementY: function(s) {
                return "movementY" in s ? s.movementY : jl;
            }
        }), Fd = ds(Yl), Zm = g({}, Yl, {
            dataTransfer: 0
        }), Zy = ds(Zm), ji = g({}, Xl, {
            relatedTarget: 0
        }), Pf = ds(ji), Km = g({}, co, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), Qm = ds(Km), Jm = g({}, co, {
            clipboardData: function(s) {
                return "clipboardData" in s ? s.clipboardData : window.clipboardData;
            }
        }), $m = ds(Jm), cu = g({}, co, {
            data: 0
        }), Hf = ds(cu), eg = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, tg = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, ng = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function Gd(s) {
            var o = this.nativeEvent;
            return o.getModifierState ? o.getModifierState(s) : (s = ng[s]) ? !!o[s] : !1;
        }
        function uu() {
            return Gd;
        }
        var ig = g({}, Xl, {
            key: function(s) {
                if (s.key) {
                    var o = eg[s.key] || s.key;
                    if (o !== "Unidentified") return o;
                }
                return s.type === "keypress" ? (s = lo(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? tg[s.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: uu,
            charCode: function(s) {
                return s.type === "keypress" ? lo(s) : 0;
            },
            keyCode: function(s) {
                return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
            },
            which: function(s) {
                return s.type === "keypress" ? lo(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
            }
        }), Vd = ds(ig), kd = g({}, Yl, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), Ff = ds(kd), sg = g({}, Xl, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: uu
        }), Xd = ds(sg), ag = g({}, co, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), Cr = ds(ag), jd = g({}, Yl, {
            deltaX: function(s) {
                return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
            },
            deltaY: function(s) {
                return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        }), Ky = ds(jd), rg = g({}, co, {
            newState: 0,
            oldState: 0
        }), uo = ds(rg), Dr = [
            9,
            13,
            27,
            32
        ], fu = Qa && "CompositionEvent" in window, $o = null;
        Qa && "documentMode" in document && ($o = document.documentMode);
        var hu = Qa && "TextEvent" in window && !$o, du = Qa && (!fu || $o && 8 < $o && 11 >= $o), fo = " ", qi = !1;
        function pu(s, o) {
            switch(s){
                case "keyup":
                    return Dr.indexOf(o.keyCode) !== -1;
                case "keydown":
                    return o.keyCode !== 229;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1;
            }
        }
        function qd(s) {
            return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
        }
        var ho = !1;
        function mu(s, o) {
            switch(s){
                case "compositionend":
                    return qd(o);
                case "keypress":
                    return o.which !== 32 ? null : (qi = !0, fo);
                case "textInput":
                    return s = o.data, s === fo && qi ? null : s;
                default:
                    return null;
            }
        }
        function Yd(s, o) {
            if (ho) return s === "compositionend" || !fu && pu(s, o) ? (s = Hd(), If = Pd = wr = null, ho = !1, s) : null;
            switch(s){
                case "paste":
                    return null;
                case "keypress":
                    if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
                        if (o.char && 1 < o.char.length) return o.char;
                        if (o.which) return String.fromCharCode(o.which);
                    }
                    return null;
                case "compositionend":
                    return du && o.locale !== "ko" ? null : o.data;
                default:
                    return null;
            }
        }
        var Gf = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };
        function Wd(s) {
            var o = s && s.nodeName && s.nodeName.toLowerCase();
            return o === "input" ? !!Gf[s.type] : o === "textarea";
        }
        function Es(s, o, h, m) {
            oo ? Jo ? Jo.push(m) : Jo = [
                m
            ] : oo = m, o = a0(o, "onChange"), 0 < o.length && (h = new kl("onChange", "change", null, h, m), s.push({
                event: h,
                listeners: o
            }));
        }
        var Wl = null, el = null;
        function og(s) {
            _b(s, 0);
        }
        function gu(s) {
            var o = ro(s);
            if (ln(o)) return s;
        }
        function Vf(s, o) {
            if (s === "change") return o;
        }
        var kf = !1;
        if (Qa) {
            var Xf;
            if (Qa) {
                var Zl = "oninput" in document;
                if (!Zl) {
                    var Kl = document.createElement("div");
                    Kl.setAttribute("oninput", "return;"), Zl = typeof Kl.oninput == "function";
                }
                Xf = Zl;
            } else Xf = !1;
            kf = Xf && (!document.documentMode || 9 < document.documentMode);
        }
        function Kn() {
            Wl && (Wl.detachEvent("onpropertychange", lg), el = Wl = null);
        }
        function lg(s) {
            if (s.propertyName === "value" && gu(el)) {
                var o = [];
                Es(o, el, s, Bf(s)), Id(og, o);
            }
        }
        function Qy(s, o, h) {
            s === "focusin" ? (Kn(), Wl = o, el = h, Wl.attachEvent("onpropertychange", lg)) : s === "focusout" && Kn();
        }
        function cg(s) {
            if (s === "selectionchange" || s === "keyup" || s === "keydown") return gu(el);
        }
        function vu(s, o) {
            if (s === "click") return gu(o);
        }
        function po(s, o) {
            if (s === "input" || s === "change") return gu(o);
        }
        function ug(s, o) {
            return s === o && (s !== 0 || 1 / s === 1 / o) || s !== s && o !== o;
        }
        var Ts = typeof Object.is == "function" ? Object.is : ug;
        function Ra(s, o) {
            if (Ts(s, o)) return !0;
            if (typeof s != "object" || s === null || typeof o != "object" || o === null) return !1;
            var h = Object.keys(s), m = Object.keys(o);
            if (h.length !== m.length) return !1;
            for(m = 0; m < h.length; m++){
                var S = h[m];
                if (!Vt.call(o, S) || !Ts(s[S], o[S])) return !1;
            }
            return !0;
        }
        function As(s) {
            for(; s && s.firstChild;)s = s.firstChild;
            return s;
        }
        function Zd(s, o) {
            var h = As(s);
            s = 0;
            for(var m; h;){
                if (h.nodeType === 3) {
                    if (m = s + h.textContent.length, s <= o && m >= o) return {
                        node: h,
                        offset: o - s
                    };
                    s = m;
                }
                e: {
                    for(; h;){
                        if (h.nextSibling) {
                            h = h.nextSibling;
                            break e;
                        }
                        h = h.parentNode;
                    }
                    h = void 0;
                }
                h = As(h);
            }
        }
        function Kd(s, o) {
            return s && o ? s === o ? !0 : s && s.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Kd(s, o.parentNode) : "contains" in s ? s.contains(o) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(o) & 16) : !1 : !1;
        }
        function Qd(s) {
            s = s != null && s.ownerDocument != null && s.ownerDocument.defaultView != null ? s.ownerDocument.defaultView : window;
            for(var o = Ti(s.document); o instanceof s.HTMLIFrameElement;){
                try {
                    var h = typeof o.contentWindow.location.href == "string";
                } catch  {
                    h = !1;
                }
                if (h) s = o.contentWindow;
                else break;
                o = Ti(s.document);
            }
            return o;
        }
        function yu(s) {
            var o = s && s.nodeName && s.nodeName.toLowerCase();
            return o && (o === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || o === "textarea" || s.contentEditable === "true");
        }
        var Jd = Qa && "documentMode" in document && 11 >= document.documentMode, Nr = null, jf = null, _u = null, qf = !1;
        function $d(s, o, h) {
            var m = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
            qf || Nr == null || Nr !== Ti(m) || (m = Nr, "selectionStart" in m && yu(m) ? m = {
                start: m.selectionStart,
                end: m.selectionEnd
            } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
                anchorNode: m.anchorNode,
                anchorOffset: m.anchorOffset,
                focusNode: m.focusNode,
                focusOffset: m.focusOffset
            }), _u && Ra(_u, m) || (_u = m, m = a0(jf, "onSelect"), 0 < m.length && (o = new kl("onSelect", "select", null, o, h), s.push({
                event: o,
                listeners: m
            }), o.target = Nr)));
        }
        function Yi(s, o) {
            var h = {};
            return h[s.toLowerCase()] = o.toLowerCase(), h["Webkit" + s] = "webkit" + o, h["Moz" + s] = "moz" + o, h;
        }
        var mo = {
            animationend: Yi("Animation", "AnimationEnd"),
            animationiteration: Yi("Animation", "AnimationIteration"),
            animationstart: Yi("Animation", "AnimationStart"),
            transitionrun: Yi("Transition", "TransitionRun"),
            transitionstart: Yi("Transition", "TransitionStart"),
            transitioncancel: Yi("Transition", "TransitionCancel"),
            transitionend: Yi("Transition", "TransitionEnd")
        }, Yf = {}, fg = {};
        Qa && (fg = document.createElement("div").style, "AnimationEvent" in window || (delete mo.animationend.animation, delete mo.animationiteration.animation, delete mo.animationstart.animation), "TransitionEvent" in window || delete mo.transitionend.transition);
        function Ur(s) {
            if (Yf[s]) return Yf[s];
            if (!mo[s]) return s;
            var o = mo[s], h;
            for(h in o)if (o.hasOwnProperty(h) && h in fg) return Yf[s] = o[h];
            return s;
        }
        var ps = Ur("animationend"), ep = Ur("animationiteration"), ws = Ur("animationstart"), hg = Ur("transitionrun"), Lr = Ur("transitionstart"), Ql = Ur("transitioncancel"), Or = Ur("transitionend"), Wf = new Map, xu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        xu.push("scrollEnd");
        function Bi(s, o) {
            Wf.set(s, o), wa(o, [
                s
            ]);
        }
        var tp = new WeakMap;
        function Wi(s, o) {
            if (typeof s == "object" && s !== null) {
                var h = tp.get(s);
                return h !== void 0 ? h : (o = {
                    value: s,
                    source: o,
                    stack: Gn(o)
                }, tp.set(s, o), o);
            }
            return {
                value: s,
                source: o,
                stack: Gn(o)
            };
        }
        var is = [], aa = 0, Zf = 0;
        function Su() {
            for(var s = aa, o = Zf = aa = 0; o < s;){
                var h = is[o];
                is[o++] = null;
                var m = is[o];
                is[o++] = null;
                var S = is[o];
                is[o++] = null;
                var A = is[o];
                if (is[o++] = null, m !== null && S !== null) {
                    var B = m.pending;
                    B === null ? S.next = S : (S.next = B.next, B.next = S), m.pending = S;
                }
                A !== 0 && np(h, S, A);
            }
        }
        function go(s, o, h, m) {
            is[aa++] = s, is[aa++] = o, is[aa++] = h, is[aa++] = m, Zf |= m, s.lanes |= m, s = s.alternate, s !== null && (s.lanes |= m);
        }
        function Kf(s, o, h, m) {
            return go(s, o, h, m), Jl(s);
        }
        function zr(s, o) {
            return go(s, null, null, o), Jl(s);
        }
        function np(s, o, h) {
            s.lanes |= h;
            var m = s.alternate;
            m !== null && (m.lanes |= h);
            for(var S = !1, A = s.return; A !== null;)A.childLanes |= h, m = A.alternate, m !== null && (m.childLanes |= h), A.tag === 22 && (s = A.stateNode, s === null || s._visibility & 1 || (S = !0)), s = A, A = A.return;
            return s.tag === 3 ? (A = s.stateNode, S && o !== null && (S = 31 - lt(h), s = A.hiddenUpdates, m = s[S], m === null ? s[S] = [
                o
            ] : m.push(o), o.lane = h | 536870912), A) : null;
        }
        function Jl(s) {
            if (50 < fr) throw fr = 0, yl = null, Error(n(185));
            for(var o = s.return; o !== null;)s = o, o = s.return;
            return s.tag === 3 ? s.stateNode : null;
        }
        var vo = {};
        function ip(s, o, h, m) {
            this.tag = s, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
        }
        function Rs(s, o, h, m) {
            return new ip(s, o, h, m);
        }
        function bu(s) {
            return s = s.prototype, !(!s || !s.isReactComponent);
        }
        function ri(s, o) {
            var h = s.alternate;
            return h === null ? (h = Rs(s.tag, o, s.key, s.mode), h.elementType = s.elementType, h.type = s.type, h.stateNode = s.stateNode, h.alternate = s, s.alternate = h) : (h.pendingProps = o, h.type = s.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = s.flags & 65011712, h.childLanes = s.childLanes, h.lanes = s.lanes, h.child = s.child, h.memoizedProps = s.memoizedProps, h.memoizedState = s.memoizedState, h.updateQueue = s.updateQueue, o = s.dependencies, h.dependencies = o === null ? null : {
                lanes: o.lanes,
                firstContext: o.firstContext
            }, h.sibling = s.sibling, h.index = s.index, h.ref = s.ref, h.refCleanup = s.refCleanup, h;
        }
        function sp(s, o) {
            s.flags &= 65011714;
            var h = s.alternate;
            return h === null ? (s.childLanes = 0, s.lanes = o, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = h.childLanes, s.lanes = h.lanes, s.child = h.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = h.memoizedProps, s.memoizedState = h.memoizedState, s.updateQueue = h.updateQueue, s.type = h.type, o = h.dependencies, s.dependencies = o === null ? null : {
                lanes: o.lanes,
                firstContext: o.firstContext
            }), s;
        }
        function Ii(s, o, h, m, S, A) {
            var B = 0;
            if (m = s, typeof s == "function") bu(s) && (B = 1);
            else if (typeof s == "string") B = Aw(s, h, J.current) ? 26 : s === "html" || s === "head" || s === "body" ? 27 : 5;
            else e: switch(s){
                case z:
                    return s = Rs(31, h, o, S), s.elementType = z, s.lanes = A, s;
                case M:
                    return yo(h.children, S, A, o);
                case R:
                    B = 8, S |= 24;
                    break;
                case T:
                    return s = Rs(12, h, o, S | 2), s.elementType = T, s.lanes = A, s;
                case I:
                    return s = Rs(13, h, o, S), s.elementType = I, s.lanes = A, s;
                case O:
                    return s = Rs(19, h, o, S), s.elementType = O, s.lanes = A, s;
                default:
                    if (typeof s == "object" && s !== null) switch(s.$$typeof){
                        case E:
                        case N:
                            B = 10;
                            break e;
                        case C:
                            B = 9;
                            break e;
                        case D:
                            B = 11;
                            break e;
                        case P:
                            B = 14;
                            break e;
                        case F:
                            B = 16, m = null;
                            break e;
                    }
                    B = 29, h = Error(n(130, s === null ? "null" : typeof s, "")), m = null;
            }
            return o = Rs(B, h, o, S), o.elementType = s, o.type = m, o.lanes = A, o;
        }
        function yo(s, o, h, m) {
            return s = Rs(7, s, m, o), s.lanes = h, s;
        }
        function Mu(s, o, h) {
            return s = Rs(6, s, null, o), s.lanes = h, s;
        }
        function Qf(s, o, h) {
            return o = Rs(4, s.children !== null ? s.children : [], s.key, o), o.lanes = h, o.stateNode = {
                containerInfo: s.containerInfo,
                pendingChildren: null,
                implementation: s.implementation
            }, o;
        }
        var $l = [], Cs = 0, Eu = null, ec = 0, Zi = [], Ps = 0, _o = null, Ja = 1, $a = "";
        function Br(s, o) {
            $l[Cs++] = ec, $l[Cs++] = Eu, Eu = s, ec = o;
        }
        function Jf(s, o, h) {
            Zi[Ps++] = Ja, Zi[Ps++] = $a, Zi[Ps++] = _o, _o = s;
            var m = Ja;
            s = $a;
            var S = 32 - lt(m) - 1;
            m &= ~(1 << S), h += 1;
            var A = 32 - lt(o) + S;
            if (30 < A) {
                var B = S - S % 5;
                A = (m & (1 << B) - 1).toString(32), m >>= B, S -= B, Ja = 1 << 32 - lt(o) + S | h << S | m, $a = A + s;
            } else Ja = 1 << A | h << S | m, $a = s;
        }
        function ap(s) {
            s.return !== null && (Br(s, 1), Jf(s, 1, 0));
        }
        function rp(s) {
            for(; s === Eu;)Eu = $l[--Cs], $l[Cs] = null, ec = $l[--Cs], $l[Cs] = null;
            for(; s === _o;)_o = Zi[--Ps], Zi[Ps] = null, $a = Zi[--Ps], Zi[Ps] = null, Ja = Zi[--Ps], Zi[Ps] = null;
        }
        var ms = null, Jn = null, bn = !1, ra = null, Hs = !1, $f = Error(n(519));
        function xo(s) {
            var o = Error(n(418, ""));
            throw tl(Wi(o, s)), $f;
        }
        function dg(s) {
            var o = s.stateNode, h = s.type, m = s.memoizedProps;
            switch(o[vi] = s, o[Ei] = m, h){
                case "dialog":
                    dn("cancel", o), dn("close", o);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    dn("load", o);
                    break;
                case "video":
                case "audio":
                    for(h = 0; h < Ip.length; h++)dn(Ip[h], o);
                    break;
                case "source":
                    dn("error", o);
                    break;
                case "img":
                case "image":
                case "link":
                    dn("error", o), dn("load", o);
                    break;
                case "details":
                    dn("toggle", o);
                    break;
                case "input":
                    dn("invalid", o), Ln(o, m.value, m.defaultValue, m.checked, m.defaultChecked, m.type, m.name, !0), Dn(o);
                    break;
                case "select":
                    dn("invalid", o);
                    break;
                case "textarea":
                    dn("invalid", o), zi(o, m.value, m.defaultValue, m.children), Dn(o);
            }
            h = m.children, typeof h != "string" && typeof h != "number" && typeof h != "bigint" || o.textContent === "" + h || m.suppressHydrationWarning === !0 || Mb(o.textContent, h) ? (m.popover != null && (dn("beforetoggle", o), dn("toggle", o)), m.onScroll != null && dn("scroll", o), m.onScrollEnd != null && dn("scrollend", o), m.onClick != null && (o.onclick = r0), o = !0) : o = !1, o || xo(s);
        }
        function op(s) {
            for(ms = s.return; ms;)switch(ms.tag){
                case 5:
                case 13:
                    Hs = !1;
                    return;
                case 27:
                case 3:
                    Hs = !0;
                    return;
                default:
                    ms = ms.return;
            }
        }
        function Ca(s) {
            if (s !== ms) return !1;
            if (!bn) return op(s), bn = !0, !1;
            var o = s.tag, h;
            if ((h = o !== 3 && o !== 27) && ((h = o === 5) && (h = s.type, h = !(h !== "form" && h !== "button") || v_(s.type, s.memoizedProps)), h = !h), h && Jn && xo(s), op(s), o === 13) {
                if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(n(317));
                e: {
                    for(s = s.nextSibling, o = 0; s;){
                        if (s.nodeType === 8) if (h = s.data, h === "/$") {
                            if (o === 0) {
                                Jn = Kr(s.nextSibling);
                                break e;
                            }
                            o--;
                        } else h !== "$" && h !== "$!" && h !== "$?" || o++;
                        s = s.nextSibling;
                    }
                    Jn = null;
                }
            } else o === 27 ? (o = Jn, Tc(s.type) ? (s = S_, S_ = null, Jn = s) : Jn = o) : Jn = ms ? Kr(s.stateNode.nextSibling) : null;
            return !0;
        }
        function tc() {
            Jn = ms = null, bn = !1;
        }
        function An() {
            var s = ra;
            return s !== null && (Ot === null ? Ot = s : Ot.push.apply(Ot, s), ra = null), s;
        }
        function tl(s) {
            ra === null ? ra = [
                s
            ] : ra.push(s);
        }
        var lp = $(null), So = null, Ir = null;
        function bo(s, o, h) {
            ve(lp, o._currentValue), o._currentValue = h;
        }
        function Pr(s) {
            s._currentValue = lp.current, me(lp);
        }
        function cp(s, o, h) {
            for(; s !== null;){
                var m = s.alternate;
                if ((s.childLanes & o) !== o ? (s.childLanes |= o, m !== null && (m.childLanes |= o)) : m !== null && (m.childLanes & o) !== o && (m.childLanes |= o), s === h) break;
                s = s.return;
            }
        }
        function Tu(s, o, h, m) {
            var S = s.child;
            for(S !== null && (S.return = s); S !== null;){
                var A = S.dependencies;
                if (A !== null) {
                    var B = S.child;
                    A = A.firstContext;
                    e: for(; A !== null;){
                        var V = A;
                        A = S;
                        for(var ee = 0; ee < o.length; ee++)if (V.context === o[ee]) {
                            A.lanes |= h, V = A.alternate, V !== null && (V.lanes |= h), cp(A.return, h, s), m || (B = null);
                            break e;
                        }
                        A = V.next;
                    }
                } else if (S.tag === 18) {
                    if (B = S.return, B === null) throw Error(n(341));
                    B.lanes |= h, A = B.alternate, A !== null && (A.lanes |= h), cp(B, h, s), B = null;
                } else B = S.child;
                if (B !== null) B.return = S;
                else for(B = S; B !== null;){
                    if (B === s) {
                        B = null;
                        break;
                    }
                    if (S = B.sibling, S !== null) {
                        S.return = B.return, B = S;
                        break;
                    }
                    B = B.return;
                }
                S = B;
            }
        }
        function oa(s, o, h, m) {
            s = null;
            for(var S = o, A = !1; S !== null;){
                if (!A) {
                    if ((S.flags & 524288) !== 0) A = !0;
                    else if ((S.flags & 262144) !== 0) break;
                }
                if (S.tag === 10) {
                    var B = S.alternate;
                    if (B === null) throw Error(n(387));
                    if (B = B.memoizedProps, B !== null) {
                        var V = S.type;
                        Ts(S.pendingProps.value, B.value) || (s !== null ? s.push(V) : s = [
                            V
                        ]);
                    }
                } else if (S === De.current) {
                    if (B = S.alternate, B === null) throw Error(n(387));
                    B.memoizedState.memoizedState !== S.memoizedState.memoizedState && (s !== null ? s.push(kp) : s = [
                        kp
                    ]);
                }
                S = S.return;
            }
            s !== null && Tu(o, s, h, m), o.flags |= 262144;
        }
        function Au(s) {
            for(s = s.firstContext; s !== null;){
                if (!Ts(s.context._currentValue, s.memoizedValue)) return !0;
                s = s.next;
            }
            return !1;
        }
        function er(s) {
            So = s, Ir = null, s = s.dependencies, s !== null && (s.firstContext = null);
        }
        function ti(s) {
            return eh(So, s);
        }
        function wu(s, o) {
            return So === null && er(s), eh(s, o);
        }
        function eh(s, o) {
            var h = o._currentValue;
            if (o = {
                context: o,
                memoizedValue: h,
                next: null
            }, Ir === null) {
                if (s === null) throw Error(n(308));
                Ir = o, s.dependencies = {
                    lanes: 0,
                    firstContext: o
                }, s.flags |= 524288;
            } else Ir = Ir.next = o;
            return h;
        }
        var up = typeof AbortController < "u" ? AbortController : function() {
            var s = [], o = this.signal = {
                aborted: !1,
                addEventListener: function(h, m) {
                    s.push(m);
                }
            };
            this.abort = function() {
                o.aborted = !0, s.forEach(function(h) {
                    return h();
                });
            };
        }, Jy = r.unstable_scheduleCallback, pg = r.unstable_NormalPriority, xi = {
            $$typeof: N,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0
        };
        function th() {
            return {
                controller: new up,
                data: new Map,
                refCount: 0
            };
        }
        function nc(s) {
            s.refCount--, s.refCount === 0 && Jy(pg, function() {
                s.controller.abort();
            });
        }
        var ic = null, Ru = 0, jt = 0, sc = null;
        function Fs(s, o) {
            if (ic === null) {
                var h = ic = [];
                Ru = 0, jt = l_(), sc = {
                    status: "pending",
                    value: void 0,
                    then: function(m) {
                        h.push(m);
                    }
                };
            }
            return Ru++, o.then(nh, nh), o;
        }
        function nh() {
            if (--Ru === 0 && ic !== null) {
                sc !== null && (sc.status = "fulfilled");
                var s = ic;
                ic = null, jt = 0, sc = null;
                for(var o = 0; o < s.length; o++)(0, s[o])();
            }
        }
        function $y(s, o) {
            var h = [], m = {
                status: "pending",
                value: null,
                reason: null,
                then: function(S) {
                    h.push(S);
                }
            };
            return s.then(function() {
                m.status = "fulfilled", m.value = o;
                for(var S = 0; S < h.length; S++)(0, h[S])(o);
            }, function(S) {
                for(m.status = "rejected", m.reason = S, S = 0; S < h.length; S++)(0, h[S])(void 0);
            }), m;
        }
        var Cu = H.S;
        H.S = function(s, o) {
            typeof o == "object" && o !== null && typeof o.then == "function" && Fs(s, o), Cu !== null && Cu(s, o);
        };
        var la = $(null);
        function Mo() {
            var s = la.current;
            return s !== null ? s : kt.pooledCache;
        }
        function Du(s, o) {
            o === null ? ve(la, la.current) : ve(la, o.pool);
        }
        function ih() {
            var s = Mo();
            return s === null ? null : {
                parent: xi._currentValue,
                pool: s
            };
        }
        var Nu = Error(n(460)), fp = Error(n(474)), Da = Error(n(542)), Uu = {
            then: function() {}
        };
        function sh(s) {
            return s = s.status, s === "fulfilled" || s === "rejected";
        }
        function ac() {}
        function ah(s, o, h) {
            switch(h = s[h], h === void 0 ? s.push(o) : h !== o && (o.then(ac, ac), o = h), o.status){
                case "fulfilled":
                    return o.value;
                case "rejected":
                    throw s = o.reason, mg(s), s;
                default:
                    if (typeof o.status == "string") o.then(ac, ac);
                    else {
                        if (s = kt, s !== null && 100 < s.shellSuspendCounter) throw Error(n(482));
                        s = o, s.status = "pending", s.then(function(m) {
                            if (o.status === "pending") {
                                var S = o;
                                S.status = "fulfilled", S.value = m;
                            }
                        }, function(m) {
                            if (o.status === "pending") {
                                var S = o;
                                S.status = "rejected", S.reason = m;
                            }
                        });
                    }
                    switch(o.status){
                        case "fulfilled":
                            return o.value;
                        case "rejected":
                            throw s = o.reason, mg(s), s;
                    }
                    throw ca = o, Nu;
            }
        }
        var ca = null;
        function hp() {
            if (ca === null) throw Error(n(459));
            var s = ca;
            return ca = null, s;
        }
        function mg(s) {
            if (s === Nu || s === Da) throw Error(n(483));
        }
        var Hr = !1;
        function dp(s) {
            s.updateQueue = {
                baseState: s.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    lanes: 0,
                    hiddenCallbacks: null
                },
                callbacks: null
            };
        }
        function Ht(s, o) {
            s = s.updateQueue, o.updateQueue === s && (o.updateQueue = {
                baseState: s.baseState,
                firstBaseUpdate: s.firstBaseUpdate,
                lastBaseUpdate: s.lastBaseUpdate,
                shared: s.shared,
                callbacks: null
            });
        }
        function tr(s) {
            return {
                lane: s,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function Fr(s, o, h) {
            var m = s.updateQueue;
            if (m === null) return null;
            if (m = m.shared, (wn & 2) !== 0) {
                var S = m.pending;
                return S === null ? o.next = o : (o.next = S.next, S.next = o), m.pending = o, o = Jl(s), np(s, null, h), o;
            }
            return go(s, m, o, h), Jl(s);
        }
        function nl(s, o, h) {
            if (o = o.updateQueue, o !== null && (o = o.shared, (h & 4194048) !== 0)) {
                var m = o.lanes;
                m &= s.pendingLanes, h |= m, o.lanes = h, ct(s, h);
            }
        }
        function rc(s, o) {
            var h = s.updateQueue, m = s.alternate;
            if (m !== null && (m = m.updateQueue, h === m)) {
                var S = null, A = null;
                if (h = h.firstBaseUpdate, h !== null) {
                    do {
                        var B = {
                            lane: h.lane,
                            tag: h.tag,
                            payload: h.payload,
                            callback: null,
                            next: null
                        };
                        A === null ? S = A = B : A = A.next = B, h = h.next;
                    }while (h !== null);
                    A === null ? S = A = o : A = A.next = o;
                } else S = A = o;
                h = {
                    baseState: m.baseState,
                    firstBaseUpdate: S,
                    lastBaseUpdate: A,
                    shared: m.shared,
                    callbacks: m.callbacks
                }, s.updateQueue = h;
                return;
            }
            s = h.lastBaseUpdate, s === null ? h.firstBaseUpdate = o : s.next = o, h.lastBaseUpdate = o;
        }
        var pp = !1;
        function Lu() {
            if (pp) {
                var s = sc;
                if (s !== null) throw s;
            }
        }
        function oc(s, o, h, m) {
            pp = !1;
            var S = s.updateQueue;
            Hr = !1;
            var A = S.firstBaseUpdate, B = S.lastBaseUpdate, V = S.shared.pending;
            if (V !== null) {
                S.shared.pending = null;
                var ee = V, Me = ee.next;
                ee.next = null, B === null ? A = Me : B.next = Me, B = ee;
                var ze = s.alternate;
                ze !== null && (ze = ze.updateQueue, V = ze.lastBaseUpdate, V !== B && (V === null ? ze.firstBaseUpdate = Me : V.next = Me, ze.lastBaseUpdate = ee));
            }
            if (A !== null) {
                var ke = S.baseState;
                B = 0, ze = Me = ee = null, V = A;
                do {
                    var Te = V.lane & -536870913, Re = Te !== V.lane;
                    if (Re ? (Ct & Te) === Te : (m & Te) === Te) {
                        Te !== 0 && Te === jt && (pp = !0), ze !== null && (ze = ze.next = {
                            lane: 0,
                            tag: V.tag,
                            payload: V.payload,
                            callback: null,
                            next: null
                        });
                        e: {
                            var Gt = s, Bt = V;
                            Te = o;
                            var qn = h;
                            switch(Bt.tag){
                                case 1:
                                    if (Gt = Bt.payload, typeof Gt == "function") {
                                        ke = Gt.call(qn, ke, Te);
                                        break e;
                                    }
                                    ke = Gt;
                                    break e;
                                case 3:
                                    Gt.flags = Gt.flags & -65537 | 128;
                                case 0:
                                    if (Gt = Bt.payload, Te = typeof Gt == "function" ? Gt.call(qn, ke, Te) : Gt, Te == null) break e;
                                    ke = g({}, ke, Te);
                                    break e;
                                case 2:
                                    Hr = !0;
                            }
                        }
                        Te = V.callback, Te !== null && (s.flags |= 64, Re && (s.flags |= 8192), Re = S.callbacks, Re === null ? S.callbacks = [
                            Te
                        ] : Re.push(Te));
                    } else Re = {
                        lane: Te,
                        tag: V.tag,
                        payload: V.payload,
                        callback: V.callback,
                        next: null
                    }, ze === null ? (Me = ze = Re, ee = ke) : ze = ze.next = Re, B |= Te;
                    if (V = V.next, V === null) {
                        if (V = S.shared.pending, V === null) break;
                        Re = V, V = Re.next, Re.next = null, S.lastBaseUpdate = Re, S.shared.pending = null;
                    }
                }while (!0);
                ze === null && (ee = ke), S.baseState = ee, S.firstBaseUpdate = Me, S.lastBaseUpdate = ze, A === null && (S.shared.lanes = 0), Pa |= B, s.lanes = B, s.memoizedState = ke;
            }
        }
        function lc(s, o) {
            if (typeof s != "function") throw Error(n(191, s));
            s.call(o);
        }
        function gg(s, o) {
            var h = s.callbacks;
            if (h !== null) for(s.callbacks = null, s = 0; s < h.length; s++)lc(h[s], o);
        }
        var cc = $(null), rh = $(0);
        function vg(s, o) {
            s = ma, ve(rh, s), ve(cc, o), ma = s | o.baseLanes;
        }
        function mp() {
            ve(rh, ma), ve(cc, cc.current);
        }
        function Ou() {
            ma = rh.current, me(cc), me(rh);
        }
        var Gr = 0, qt = null, Nn = null, Si = null, oh = !1, Eo = !1, gs = !1, Ai = 0, ua = 0, Ki = null, yg = 0;
        function oi() {
            throw Error(n(321));
        }
        function ss(s, o) {
            if (o === null) return !1;
            for(var h = 0; h < o.length && h < s.length; h++)if (!Ts(s[h], o[h])) return !1;
            return !0;
        }
        function Vr(s, o, h, m, S, A) {
            return Gr = A, qt = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, H.H = s === null || s.memoizedState === null ? gh : Np, gs = !1, A = h(m, S), gs = !1, Eo && (A = xg(o, h, m, S)), _g(s), A;
        }
        function _g(s) {
            H.H = Iu;
            var o = Nn !== null && Nn.next !== null;
            if (Gr = 0, Si = Nn = qt = null, oh = !1, ua = 0, Ki = null, o) throw Error(n(300));
            s === null || Pi || (s = s.dependencies, s !== null && Au(s) && (Pi = !0));
        }
        function xg(s, o, h, m) {
            qt = s;
            var S = 0;
            do {
                if (Eo && (Ki = null), ua = 0, Eo = !1, 25 <= S) throw Error(n(301));
                if (S += 1, Si = Nn = null, s.updateQueue != null) {
                    var A = s.updateQueue;
                    A.lastEffect = null, A.events = null, A.stores = null, A.memoCache != null && (A.memoCache.index = 0);
                }
                H.H = qg, A = o(h, m);
            }while (Eo);
            return A;
        }
        function e_() {
            var s = H.H, o = s.useState()[0];
            return o = typeof o.then == "function" ? Na(o) : o, s = s.useState()[0], (Nn !== null ? Nn.memoizedState : null) !== s && (qt.flags |= 1024), o;
        }
        function gp() {
            var s = Ai !== 0;
            return Ai = 0, s;
        }
        function lh(s, o, h) {
            o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~h;
        }
        function vp(s) {
            if (oh) {
                for(s = s.memoizedState; s !== null;){
                    var o = s.queue;
                    o !== null && (o.pending = null), s = s.next;
                }
                oh = !1;
            }
            Gr = 0, Si = Nn = qt = null, Eo = !1, ua = Ai = 0, Ki = null;
        }
        function vs() {
            var s = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            return Si === null ? qt.memoizedState = Si = s : Si = Si.next = s, Si;
        }
        function bi() {
            if (Nn === null) {
                var s = qt.alternate;
                s = s !== null ? s.memoizedState : null;
            } else s = Nn.next;
            var o = Si === null ? qt.memoizedState : Si.next;
            if (o !== null) Si = o, Nn = s;
            else {
                if (s === null) throw qt.alternate === null ? Error(n(467)) : Error(n(310));
                Nn = s, s = {
                    memoizedState: Nn.memoizedState,
                    baseState: Nn.baseState,
                    baseQueue: Nn.baseQueue,
                    queue: Nn.queue,
                    next: null
                }, Si === null ? qt.memoizedState = Si = s : Si = Si.next = s;
            }
            return Si;
        }
        function To() {
            return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null
            };
        }
        function Na(s) {
            var o = ua;
            return ua += 1, Ki === null && (Ki = []), s = ah(Ki, s, o), o = qt, (Si === null ? o.memoizedState : Si.next) === null && (o = o.alternate, H.H = o === null || o.memoizedState === null ? gh : Np), s;
        }
        function ch(s) {
            if (s !== null && typeof s == "object") {
                if (typeof s.then == "function") return Na(s);
                if (s.$$typeof === N) return ti(s);
            }
            throw Error(n(438, String(s)));
        }
        function yp(s) {
            var o = null, h = qt.updateQueue;
            if (h !== null && (o = h.memoCache), o == null) {
                var m = qt.alternate;
                m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (o = {
                    data: m.data.map(function(S) {
                        return S.slice();
                    }),
                    index: 0
                })));
            }
            if (o == null && (o = {
                data: [],
                index: 0
            }), h === null && (h = To(), qt.updateQueue = h), h.memoCache = o, h = o.data[o.index], h === void 0) for(h = o.data[o.index] = Array(s), m = 0; m < s; m++)h[m] = L;
            return o.index++, h;
        }
        function kr(s, o) {
            return typeof o == "function" ? o(s) : o;
        }
        function Ao(s) {
            var o = bi();
            return _p(o, Nn, s);
        }
        function _p(s, o, h) {
            var m = s.queue;
            if (m === null) throw Error(n(311));
            m.lastRenderedReducer = h;
            var S = s.baseQueue, A = m.pending;
            if (A !== null) {
                if (S !== null) {
                    var B = S.next;
                    S.next = A.next, A.next = B;
                }
                o.baseQueue = S = A, m.pending = null;
            }
            if (A = s.baseState, S === null) s.memoizedState = A;
            else {
                o = S.next;
                var V = B = null, ee = null, Me = o, ze = !1;
                do {
                    var ke = Me.lane & -536870913;
                    if (ke !== Me.lane ? (Ct & ke) === ke : (Gr & ke) === ke) {
                        var Te = Me.revertLane;
                        if (Te === 0) ee !== null && (ee = ee.next = {
                            lane: 0,
                            revertLane: 0,
                            action: Me.action,
                            hasEagerState: Me.hasEagerState,
                            eagerState: Me.eagerState,
                            next: null
                        }), ke === jt && (ze = !0);
                        else if ((Gr & Te) === Te) {
                            Me = Me.next, Te === jt && (ze = !0);
                            continue;
                        } else ke = {
                            lane: 0,
                            revertLane: Me.revertLane,
                            action: Me.action,
                            hasEagerState: Me.hasEagerState,
                            eagerState: Me.eagerState,
                            next: null
                        }, ee === null ? (V = ee = ke, B = A) : ee = ee.next = ke, qt.lanes |= Te, Pa |= Te;
                        ke = Me.action, gs && h(A, ke), A = Me.hasEagerState ? Me.eagerState : h(A, ke);
                    } else Te = {
                        lane: ke,
                        revertLane: Me.revertLane,
                        action: Me.action,
                        hasEagerState: Me.hasEagerState,
                        eagerState: Me.eagerState,
                        next: null
                    }, ee === null ? (V = ee = Te, B = A) : ee = ee.next = Te, qt.lanes |= ke, Pa |= ke;
                    Me = Me.next;
                }while (Me !== null && Me !== o);
                if (ee === null ? B = A : ee.next = V, !Ts(A, s.memoizedState) && (Pi = !0, ze && (h = sc, h !== null))) throw h;
                s.memoizedState = A, s.baseState = B, s.baseQueue = ee, m.lastRenderedState = A;
            }
            return S === null && (m.lanes = 0), [
                s.memoizedState,
                m.dispatch
            ];
        }
        function xp(s) {
            var o = bi(), h = o.queue;
            if (h === null) throw Error(n(311));
            h.lastRenderedReducer = s;
            var m = h.dispatch, S = h.pending, A = o.memoizedState;
            if (S !== null) {
                h.pending = null;
                var B = S = S.next;
                do A = s(A, B.action), B = B.next;
                while (B !== S);
                Ts(A, o.memoizedState) || (Pi = !0), o.memoizedState = A, o.baseQueue === null && (o.baseState = A), h.lastRenderedState = A;
            }
            return [
                A,
                m
            ];
        }
        function Sg(s, o, h) {
            var m = qt, S = bi(), A = bn;
            if (A) {
                if (h === void 0) throw Error(n(407));
                h = h();
            } else h = o();
            var B = !Ts((Nn || S).memoizedState, h);
            B && (S.memoizedState = h, Pi = !0), S = S.queue;
            var V = Mg.bind(null, m, S, s);
            if (hc(2048, 8, V, [
                s
            ]), S.getSnapshot !== o || B || Si !== null && Si.memoizedState.tag & 1) {
                if (m.flags |= 2048, fc(9, zu(), bg.bind(null, m, S, h, o), null), kt === null) throw Error(n(349));
                A || (Gr & 124) !== 0 || uc(m, o, h);
            }
            return h;
        }
        function uc(s, o, h) {
            s.flags |= 16384, s = {
                getSnapshot: o,
                value: h
            }, o = qt.updateQueue, o === null ? (o = To(), qt.updateQueue = o, o.stores = [
                s
            ]) : (h = o.stores, h === null ? o.stores = [
                s
            ] : h.push(s));
        }
        function bg(s, o, h, m) {
            o.value = h, o.getSnapshot = m, Eg(o) && Tg(s);
        }
        function Mg(s, o, h) {
            return h(function() {
                Eg(o) && Tg(s);
            });
        }
        function Eg(s) {
            var o = s.getSnapshot;
            s = s.value;
            try {
                var h = o();
                return !Ts(s, h);
            } catch  {
                return !0;
            }
        }
        function Tg(s) {
            var o = zr(s, 2);
            o !== null && xs(o, s, 2);
        }
        function Sp(s) {
            var o = vs();
            if (typeof s == "function") {
                var h = s;
                if (s = h(), gs) {
                    Ne(!0);
                    try {
                        h();
                    } finally{
                        Ne(!1);
                    }
                }
            }
            return o.memoizedState = o.baseState = s, o.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: kr,
                lastRenderedState: s
            }, o;
        }
        function Ag(s, o, h, m) {
            return s.baseState = h, _p(s, Nn, typeof m == "function" ? m : kr);
        }
        function t_(s, o, h, m, S) {
            if (mh(s)) throw Error(n(485));
            if (s = o.action, s !== null) {
                var A = {
                    payload: S,
                    action: s,
                    next: null,
                    isTransition: !0,
                    status: "pending",
                    value: null,
                    reason: null,
                    listeners: [],
                    then: function(B) {
                        A.listeners.push(B);
                    }
                };
                H.T !== null ? h(!0) : A.isTransition = !1, m(A), h = o.pending, h === null ? (A.next = o.pending = A, wg(o, A)) : (A.next = h.next, o.pending = h.next = A);
            }
        }
        function wg(s, o) {
            var h = o.action, m = o.payload, S = s.state;
            if (o.isTransition) {
                var A = H.T, B = {};
                H.T = B;
                try {
                    var V = h(S, m), ee = H.S;
                    ee !== null && ee(B, V), Rg(s, o, V);
                } catch (Me) {
                    bp(s, o, Me);
                } finally{
                    H.T = A;
                }
            } else try {
                A = h(S, m), Rg(s, o, A);
            } catch (Me) {
                bp(s, o, Me);
            }
        }
        function Rg(s, o, h) {
            h !== null && typeof h == "object" && typeof h.then == "function" ? h.then(function(m) {
                Cg(s, o, m);
            }, function(m) {
                return bp(s, o, m);
            }) : Cg(s, o, h);
        }
        function Cg(s, o, h) {
            o.status = "fulfilled", o.value = h, Dg(o), s.state = h, o = s.pending, o !== null && (h = o.next, h === o ? s.pending = null : (h = h.next, o.next = h, wg(s, h)));
        }
        function bp(s, o, h) {
            var m = s.pending;
            if (s.pending = null, m !== null) {
                m = m.next;
                do o.status = "rejected", o.reason = h, Dg(o), o = o.next;
                while (o !== m);
            }
            s.action = null;
        }
        function Dg(s) {
            s = s.listeners;
            for(var o = 0; o < s.length; o++)(0, s[o])();
        }
        function Mp(s, o) {
            return o;
        }
        function Ng(s, o) {
            if (bn) {
                var h = kt.formState;
                if (h !== null) {
                    e: {
                        var m = qt;
                        if (bn) {
                            if (Jn) {
                                t: {
                                    for(var S = Jn, A = Hs; S.nodeType !== 8;){
                                        if (!A) {
                                            S = null;
                                            break t;
                                        }
                                        if (S = Kr(S.nextSibling), S === null) {
                                            S = null;
                                            break t;
                                        }
                                    }
                                    A = S.data, S = A === "F!" || A === "F" ? S : null;
                                }
                                if (S) {
                                    Jn = Kr(S.nextSibling), m = S.data === "F!";
                                    break e;
                                }
                            }
                            xo(m);
                        }
                        m = !1;
                    }
                    m && (o = h[0]);
                }
            }
            return h = vs(), h.memoizedState = h.baseState = o, m = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Mp,
                lastRenderedState: o
            }, h.queue = m, h = Xg.bind(null, qt, m), m.dispatch = h, m = Sp(!1), A = ph.bind(null, qt, !1, m.queue), m = vs(), S = {
                state: o,
                dispatch: null,
                action: s,
                pending: null
            }, m.queue = S, h = t_.bind(null, qt, S, A, h), S.dispatch = h, m.memoizedState = s, [
                o,
                h,
                !1
            ];
        }
        function Ug(s) {
            var o = bi();
            return Lg(o, Nn, s);
        }
        function Lg(s, o, h) {
            if (o = _p(s, o, Mp)[0], s = Ao(kr)[0], typeof o == "object" && o !== null && typeof o.then == "function") try {
                var m = Na(o);
            } catch (B) {
                throw B === Nu ? Da : B;
            }
            else m = o;
            o = bi();
            var S = o.queue, A = S.dispatch;
            return h !== o.memoizedState && (qt.flags |= 2048, fc(9, zu(), n_.bind(null, S, h), null)), [
                m,
                A,
                s
            ];
        }
        function n_(s, o) {
            s.action = o;
        }
        function Og(s) {
            var o = bi(), h = Nn;
            if (h !== null) return Lg(o, h, s);
            bi(), o = o.memoizedState, h = bi();
            var m = h.queue.dispatch;
            return h.memoizedState = s, [
                o,
                m,
                !1
            ];
        }
        function fc(s, o, h, m) {
            return s = {
                tag: s,
                create: h,
                deps: m,
                inst: o,
                next: null
            }, o = qt.updateQueue, o === null && (o = To(), qt.updateQueue = o), h = o.lastEffect, h === null ? o.lastEffect = s.next = s : (m = h.next, h.next = s, s.next = m, o.lastEffect = s), s;
        }
        function zu() {
            return {
                destroy: void 0,
                resource: void 0
            };
        }
        function Ep() {
            return bi().memoizedState;
        }
        function uh(s, o, h, m) {
            var S = vs();
            m = m === void 0 ? null : m, qt.flags |= s, S.memoizedState = fc(1 | o, zu(), h, m);
        }
        function hc(s, o, h, m) {
            var S = bi();
            m = m === void 0 ? null : m;
            var A = S.memoizedState.inst;
            Nn !== null && m !== null && ss(m, Nn.memoizedState.deps) ? S.memoizedState = fc(o, A, h, m) : (qt.flags |= s, S.memoizedState = fc(1 | o, A, h, m));
        }
        function Tp(s, o) {
            uh(8390656, 8, s, o);
        }
        function Ap(s, o) {
            hc(2048, 8, s, o);
        }
        function fh(s, o) {
            return hc(4, 2, s, o);
        }
        function hh(s, o) {
            return hc(4, 4, s, o);
        }
        function zg(s, o) {
            if (typeof o == "function") {
                s = s();
                var h = o(s);
                return function() {
                    typeof h == "function" ? h() : o(null);
                };
            }
            if (o != null) return s = s(), o.current = s, function() {
                o.current = null;
            };
        }
        function Bg(s, o, h) {
            h = h != null ? h.concat([
                s
            ]) : null, hc(4, 4, zg.bind(null, o, s), h);
        }
        function wp() {}
        function Ig(s, o) {
            var h = bi();
            o = o === void 0 ? null : o;
            var m = h.memoizedState;
            return o !== null && ss(o, m[1]) ? m[0] : (h.memoizedState = [
                s,
                o
            ], s);
        }
        function Rp(s, o) {
            var h = bi();
            o = o === void 0 ? null : o;
            var m = h.memoizedState;
            if (o !== null && ss(o, m[1])) return m[0];
            if (m = s(), gs) {
                Ne(!0);
                try {
                    s();
                } finally{
                    Ne(!1);
                }
            }
            return h.memoizedState = [
                m,
                o
            ], m;
        }
        function dh(s, o, h) {
            return h === void 0 || (Gr & 1073741824) !== 0 ? s.memoizedState = o : (s.memoizedState = h, s = wh(), qt.lanes |= s, Pa |= s, h);
        }
        function Pg(s, o, h, m) {
            return Ts(h, o) ? h : cc.current !== null ? (s = dh(s, h, m), Ts(s, o) || (Pi = !0), s) : (Gr & 42) === 0 ? (Pi = !0, s.memoizedState = h) : (s = wh(), qt.lanes |= s, Pa |= s, o);
        }
        function Hg(s, o, h, m, S) {
            var A = K.p;
            K.p = A !== 0 && 8 > A ? A : 8;
            var B = H.T, V = {};
            H.T = V, ph(s, !1, o, h);
            try {
                var ee = S(), Me = H.S;
                if (Me !== null && Me(V, ee), ee !== null && typeof ee == "object" && typeof ee.then == "function") {
                    var ze = $y(ee, m);
                    Bu(s, o, ze, si(s));
                } else Bu(s, o, m, si(s));
            } catch (ke) {
                Bu(s, o, {
                    then: function() {},
                    status: "rejected",
                    reason: ke
                }, si());
            } finally{
                K.p = A, H.T = B;
            }
        }
        function i_() {}
        function Cp(s, o, h, m) {
            if (s.tag !== 5) throw Error(n(476));
            var S = Fg(s).queue;
            Hg(s, S, o, Q, h === null ? i_ : function() {
                return Gg(s), h(m);
            });
        }
        function Fg(s) {
            var o = s.memoizedState;
            if (o !== null) return o;
            o = {
                memoizedState: Q,
                baseState: Q,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: kr,
                    lastRenderedState: Q
                },
                next: null
            };
            var h = {};
            return o.next = {
                memoizedState: h,
                baseState: h,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: kr,
                    lastRenderedState: h
                },
                next: null
            }, s.memoizedState = o, s = s.alternate, s !== null && (s.memoizedState = o), o;
        }
        function Gg(s) {
            var o = Fg(s).next.queue;
            Bu(s, o, {}, si());
        }
        function Dp() {
            return ti(kp);
        }
        function Vg() {
            return bi().memoizedState;
        }
        function kg() {
            return bi().memoizedState;
        }
        function s_(s) {
            for(var o = s.return; o !== null;){
                switch(o.tag){
                    case 24:
                    case 3:
                        var h = si();
                        s = tr(h);
                        var m = Fr(o, s, h);
                        m !== null && (xs(m, o, h), nl(m, o, h)), o = {
                            cache: th()
                        }, s.payload = o;
                        return;
                }
                o = o.return;
            }
        }
        function a_(s, o, h) {
            var m = si();
            h = {
                lane: m,
                revertLane: 0,
                action: h,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, mh(s) ? jg(o, h) : (h = Kf(s, o, h, m), h !== null && (xs(h, s, m), Gs(h, o, m)));
        }
        function Xg(s, o, h) {
            var m = si();
            Bu(s, o, h, m);
        }
        function Bu(s, o, h, m) {
            var S = {
                lane: m,
                revertLane: 0,
                action: h,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
            if (mh(s)) jg(o, S);
            else {
                var A = s.alternate;
                if (s.lanes === 0 && (A === null || A.lanes === 0) && (A = o.lastRenderedReducer, A !== null)) try {
                    var B = o.lastRenderedState, V = A(B, h);
                    if (S.hasEagerState = !0, S.eagerState = V, Ts(V, B)) return go(s, o, S, 0), kt === null && Su(), !1;
                } catch  {} finally{}
                if (h = Kf(s, o, S, m), h !== null) return xs(h, s, m), Gs(h, o, m), !0;
            }
            return !1;
        }
        function ph(s, o, h, m) {
            if (m = {
                lane: 2,
                revertLane: l_(),
                action: m,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, mh(s)) {
                if (o) throw Error(n(479));
            } else o = Kf(s, h, m, 2), o !== null && xs(o, s, 2);
        }
        function mh(s) {
            var o = s.alternate;
            return s === qt || o !== null && o === qt;
        }
        function jg(s, o) {
            Eo = oh = !0;
            var h = s.pending;
            h === null ? o.next = o : (o.next = h.next, h.next = o), s.pending = o;
        }
        function Gs(s, o, h) {
            if ((h & 4194048) !== 0) {
                var m = o.lanes;
                m &= s.pendingLanes, h |= m, o.lanes = h, ct(s, h);
            }
        }
        var Iu = {
            readContext: ti,
            use: ch,
            useCallback: oi,
            useContext: oi,
            useEffect: oi,
            useImperativeHandle: oi,
            useLayoutEffect: oi,
            useInsertionEffect: oi,
            useMemo: oi,
            useReducer: oi,
            useRef: oi,
            useState: oi,
            useDebugValue: oi,
            useDeferredValue: oi,
            useTransition: oi,
            useSyncExternalStore: oi,
            useId: oi,
            useHostTransitionStatus: oi,
            useFormState: oi,
            useActionState: oi,
            useOptimistic: oi,
            useMemoCache: oi,
            useCacheRefresh: oi
        }, gh = {
            readContext: ti,
            use: ch,
            useCallback: function(s, o) {
                return vs().memoizedState = [
                    s,
                    o === void 0 ? null : o
                ], s;
            },
            useContext: ti,
            useEffect: Tp,
            useImperativeHandle: function(s, o, h) {
                h = h != null ? h.concat([
                    s
                ]) : null, uh(4194308, 4, zg.bind(null, o, s), h);
            },
            useLayoutEffect: function(s, o) {
                return uh(4194308, 4, s, o);
            },
            useInsertionEffect: function(s, o) {
                uh(4, 2, s, o);
            },
            useMemo: function(s, o) {
                var h = vs();
                o = o === void 0 ? null : o;
                var m = s();
                if (gs) {
                    Ne(!0);
                    try {
                        s();
                    } finally{
                        Ne(!1);
                    }
                }
                return h.memoizedState = [
                    m,
                    o
                ], m;
            },
            useReducer: function(s, o, h) {
                var m = vs();
                if (h !== void 0) {
                    var S = h(o);
                    if (gs) {
                        Ne(!0);
                        try {
                            h(o);
                        } finally{
                            Ne(!1);
                        }
                    }
                } else S = o;
                return m.memoizedState = m.baseState = S, s = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: s,
                    lastRenderedState: S
                }, m.queue = s, s = s.dispatch = a_.bind(null, qt, s), [
                    m.memoizedState,
                    s
                ];
            },
            useRef: function(s) {
                var o = vs();
                return s = {
                    current: s
                }, o.memoizedState = s;
            },
            useState: function(s) {
                s = Sp(s);
                var o = s.queue, h = Xg.bind(null, qt, o);
                return o.dispatch = h, [
                    s.memoizedState,
                    h
                ];
            },
            useDebugValue: wp,
            useDeferredValue: function(s, o) {
                var h = vs();
                return dh(h, s, o);
            },
            useTransition: function() {
                var s = Sp(!1);
                return s = Hg.bind(null, qt, s.queue, !0, !1), vs().memoizedState = s, [
                    !1,
                    s
                ];
            },
            useSyncExternalStore: function(s, o, h) {
                var m = qt, S = vs();
                if (bn) {
                    if (h === void 0) throw Error(n(407));
                    h = h();
                } else {
                    if (h = o(), kt === null) throw Error(n(349));
                    (Ct & 124) !== 0 || uc(m, o, h);
                }
                S.memoizedState = h;
                var A = {
                    value: h,
                    getSnapshot: o
                };
                return S.queue = A, Tp(Mg.bind(null, m, A, s), [
                    s
                ]), m.flags |= 2048, fc(9, zu(), bg.bind(null, m, A, h, o), null), h;
            },
            useId: function() {
                var s = vs(), o = kt.identifierPrefix;
                if (bn) {
                    var h = $a, m = Ja;
                    h = (m & ~(1 << 32 - lt(m) - 1)).toString(32) + h, o = "" + o + "R" + h, h = Ai++, 0 < h && (o += "H" + h.toString(32)), o += "";
                } else h = yg++, o = "" + o + "r" + h.toString(32) + "";
                return s.memoizedState = o;
            },
            useHostTransitionStatus: Dp,
            useFormState: Ng,
            useActionState: Ng,
            useOptimistic: function(s) {
                var o = vs();
                o.memoizedState = o.baseState = s;
                var h = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: null,
                    lastRenderedState: null
                };
                return o.queue = h, o = ph.bind(null, qt, !0, h), h.dispatch = o, [
                    s,
                    o
                ];
            },
            useMemoCache: yp,
            useCacheRefresh: function() {
                return vs().memoizedState = s_.bind(null, qt);
            }
        }, Np = {
            readContext: ti,
            use: ch,
            useCallback: Ig,
            useContext: ti,
            useEffect: Ap,
            useImperativeHandle: Bg,
            useInsertionEffect: fh,
            useLayoutEffect: hh,
            useMemo: Rp,
            useReducer: Ao,
            useRef: Ep,
            useState: function() {
                return Ao(kr);
            },
            useDebugValue: wp,
            useDeferredValue: function(s, o) {
                var h = bi();
                return Pg(h, Nn.memoizedState, s, o);
            },
            useTransition: function() {
                var s = Ao(kr)[0], o = bi().memoizedState;
                return [
                    typeof s == "boolean" ? s : Na(s),
                    o
                ];
            },
            useSyncExternalStore: Sg,
            useId: Vg,
            useHostTransitionStatus: Dp,
            useFormState: Ug,
            useActionState: Ug,
            useOptimistic: function(s, o) {
                var h = bi();
                return Ag(h, Nn, s, o);
            },
            useMemoCache: yp,
            useCacheRefresh: kg
        }, qg = {
            readContext: ti,
            use: ch,
            useCallback: Ig,
            useContext: ti,
            useEffect: Ap,
            useImperativeHandle: Bg,
            useInsertionEffect: fh,
            useLayoutEffect: hh,
            useMemo: Rp,
            useReducer: xp,
            useRef: Ep,
            useState: function() {
                return xp(kr);
            },
            useDebugValue: wp,
            useDeferredValue: function(s, o) {
                var h = bi();
                return Nn === null ? dh(h, s, o) : Pg(h, Nn.memoizedState, s, o);
            },
            useTransition: function() {
                var s = xp(kr)[0], o = bi().memoizedState;
                return [
                    typeof s == "boolean" ? s : Na(s),
                    o
                ];
            },
            useSyncExternalStore: Sg,
            useId: Vg,
            useHostTransitionStatus: Dp,
            useFormState: Og,
            useActionState: Og,
            useOptimistic: function(s, o) {
                var h = bi();
                return Nn !== null ? Ag(h, Nn, s, o) : (h.baseState = s, [
                    s,
                    h.queue.dispatch
                ]);
            },
            useMemoCache: yp,
            useCacheRefresh: kg
        }, il = null, Pu = 0;
        function Hu(s) {
            var o = Pu;
            return Pu += 1, il === null && (il = []), ah(il, s, o);
        }
        function dc(s, o) {
            o = o.props.ref, s.ref = o !== void 0 ? o : null;
        }
        function vh(s, o) {
            throw o.$$typeof === y ? Error(n(525)) : (s = Object.prototype.toString.call(o), Error(n(31, s === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : s)));
        }
        function Yg(s) {
            var o = s._init;
            return o(s._payload);
        }
        function Wg(s) {
            function o(de, le) {
                if (s) {
                    var be = de.deletions;
                    be === null ? (de.deletions = [
                        le
                    ], de.flags |= 16) : be.push(le);
                }
            }
            function h(de, le) {
                if (!s) return null;
                for(; le !== null;)o(de, le), le = le.sibling;
                return null;
            }
            function m(de) {
                for(var le = new Map; de !== null;)de.key !== null ? le.set(de.key, de) : le.set(de.index, de), de = de.sibling;
                return le;
            }
            function S(de, le) {
                return de = ri(de, le), de.index = 0, de.sibling = null, de;
            }
            function A(de, le, be) {
                return de.index = be, s ? (be = de.alternate, be !== null ? (be = be.index, be < le ? (de.flags |= 67108866, le) : be) : (de.flags |= 67108866, le)) : (de.flags |= 1048576, le);
            }
            function B(de) {
                return s && de.alternate === null && (de.flags |= 67108866), de;
            }
            function V(de, le, be, Ge) {
                return le === null || le.tag !== 6 ? (le = Mu(be, de.mode, Ge), le.return = de, le) : (le = S(le, be), le.return = de, le);
            }
            function ee(de, le, be, Ge) {
                var bt = be.type;
                return bt === M ? ze(de, le, be.props.children, Ge, be.key) : le !== null && (le.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === F && Yg(bt) === le.type) ? (le = S(le, be.props), dc(le, be), le.return = de, le) : (le = Ii(be.type, be.key, be.props, null, de.mode, Ge), dc(le, be), le.return = de, le);
            }
            function Me(de, le, be, Ge) {
                return le === null || le.tag !== 4 || le.stateNode.containerInfo !== be.containerInfo || le.stateNode.implementation !== be.implementation ? (le = Qf(be, de.mode, Ge), le.return = de, le) : (le = S(le, be.children || []), le.return = de, le);
            }
            function ze(de, le, be, Ge, bt) {
                return le === null || le.tag !== 7 ? (le = yo(be, de.mode, Ge, bt), le.return = de, le) : (le = S(le, be), le.return = de, le);
            }
            function ke(de, le, be) {
                if (typeof le == "string" && le !== "" || typeof le == "number" || typeof le == "bigint") return le = Mu("" + le, de.mode, be), le.return = de, le;
                if (typeof le == "object" && le !== null) {
                    switch(le.$$typeof){
                        case _:
                            return be = Ii(le.type, le.key, le.props, null, de.mode, be), dc(be, le), be.return = de, be;
                        case x:
                            return le = Qf(le, de.mode, be), le.return = de, le;
                        case F:
                            var Ge = le._init;
                            return le = Ge(le._payload), ke(de, le, be);
                    }
                    if (_e(le) || oe(le)) return le = yo(le, de.mode, be, null), le.return = de, le;
                    if (typeof le.then == "function") return ke(de, Hu(le), be);
                    if (le.$$typeof === N) return ke(de, wu(de, le), be);
                    vh(de, le);
                }
                return null;
            }
            function Te(de, le, be, Ge) {
                var bt = le !== null ? le.key : null;
                if (typeof be == "string" && be !== "" || typeof be == "number" || typeof be == "bigint") return bt !== null ? null : V(de, le, "" + be, Ge);
                if (typeof be == "object" && be !== null) {
                    switch(be.$$typeof){
                        case _:
                            return be.key === bt ? ee(de, le, be, Ge) : null;
                        case x:
                            return be.key === bt ? Me(de, le, be, Ge) : null;
                        case F:
                            return bt = be._init, be = bt(be._payload), Te(de, le, be, Ge);
                    }
                    if (_e(be) || oe(be)) return bt !== null ? null : ze(de, le, be, Ge, null);
                    if (typeof be.then == "function") return Te(de, le, Hu(be), Ge);
                    if (be.$$typeof === N) return Te(de, le, wu(de, be), Ge);
                    vh(de, be);
                }
                return null;
            }
            function Re(de, le, be, Ge, bt) {
                if (typeof Ge == "string" && Ge !== "" || typeof Ge == "number" || typeof Ge == "bigint") return de = de.get(be) || null, V(le, de, "" + Ge, bt);
                if (typeof Ge == "object" && Ge !== null) {
                    switch(Ge.$$typeof){
                        case _:
                            return de = de.get(Ge.key === null ? be : Ge.key) || null, ee(le, de, Ge, bt);
                        case x:
                            return de = de.get(Ge.key === null ? be : Ge.key) || null, Me(le, de, Ge, bt);
                        case F:
                            var un = Ge._init;
                            return Ge = un(Ge._payload), Re(de, le, be, Ge, bt);
                    }
                    if (_e(Ge) || oe(Ge)) return de = de.get(be) || null, ze(le, de, Ge, bt, null);
                    if (typeof Ge.then == "function") return Re(de, le, be, Hu(Ge), bt);
                    if (Ge.$$typeof === N) return Re(de, le, be, wu(le, Ge), bt);
                    vh(le, Ge);
                }
                return null;
            }
            function Gt(de, le, be, Ge) {
                for(var bt = null, un = null, At = le, Pt = le = 0, os = null; At !== null && Pt < be.length; Pt++){
                    At.index > Pt ? (os = At, At = null) : os = At.sibling;
                    var Cn = Te(de, At, be[Pt], Ge);
                    if (Cn === null) {
                        At === null && (At = os);
                        break;
                    }
                    s && At && Cn.alternate === null && o(de, At), le = A(Cn, le, Pt), un === null ? bt = Cn : un.sibling = Cn, un = Cn, At = os;
                }
                if (Pt === be.length) return h(de, At), bn && Br(de, Pt), bt;
                if (At === null) {
                    for(; Pt < be.length; Pt++)At = ke(de, be[Pt], Ge), At !== null && (le = A(At, le, Pt), un === null ? bt = At : un.sibling = At, un = At);
                    return bn && Br(de, Pt), bt;
                }
                for(At = m(At); Pt < be.length; Pt++)os = Re(At, de, Pt, be[Pt], Ge), os !== null && (s && os.alternate !== null && At.delete(os.key === null ? Pt : os.key), le = A(os, le, Pt), un === null ? bt = os : un.sibling = os, un = os);
                return s && At.forEach(function(Dc) {
                    return o(de, Dc);
                }), bn && Br(de, Pt), bt;
            }
            function Bt(de, le, be, Ge) {
                if (be == null) throw Error(n(151));
                for(var bt = null, un = null, At = le, Pt = le = 0, os = null, Cn = be.next(); At !== null && !Cn.done; Pt++, Cn = be.next()){
                    At.index > Pt ? (os = At, At = null) : os = At.sibling;
                    var Dc = Te(de, At, Cn.value, Ge);
                    if (Dc === null) {
                        At === null && (At = os);
                        break;
                    }
                    s && At && Dc.alternate === null && o(de, At), le = A(Dc, le, Pt), un === null ? bt = Dc : un.sibling = Dc, un = Dc, At = os;
                }
                if (Cn.done) return h(de, At), bn && Br(de, Pt), bt;
                if (At === null) {
                    for(; !Cn.done; Pt++, Cn = be.next())Cn = ke(de, Cn.value, Ge), Cn !== null && (le = A(Cn, le, Pt), un === null ? bt = Cn : un.sibling = Cn, un = Cn);
                    return bn && Br(de, Pt), bt;
                }
                for(At = m(At); !Cn.done; Pt++, Cn = be.next())Cn = Re(At, de, Pt, Cn.value, Ge), Cn !== null && (s && Cn.alternate !== null && At.delete(Cn.key === null ? Pt : Cn.key), le = A(Cn, le, Pt), un === null ? bt = Cn : un.sibling = Cn, un = Cn);
                return s && At.forEach(function(Pw) {
                    return o(de, Pw);
                }), bn && Br(de, Pt), bt;
            }
            function qn(de, le, be, Ge) {
                if (typeof be == "object" && be !== null && be.type === M && be.key === null && (be = be.props.children), typeof be == "object" && be !== null) {
                    switch(be.$$typeof){
                        case _:
                            e: {
                                for(var bt = be.key; le !== null;){
                                    if (le.key === bt) {
                                        if (bt = be.type, bt === M) {
                                            if (le.tag === 7) {
                                                h(de, le.sibling), Ge = S(le, be.props.children), Ge.return = de, de = Ge;
                                                break e;
                                            }
                                        } else if (le.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === F && Yg(bt) === le.type) {
                                            h(de, le.sibling), Ge = S(le, be.props), dc(Ge, be), Ge.return = de, de = Ge;
                                            break e;
                                        }
                                        h(de, le);
                                        break;
                                    } else o(de, le);
                                    le = le.sibling;
                                }
                                be.type === M ? (Ge = yo(be.props.children, de.mode, Ge, be.key), Ge.return = de, de = Ge) : (Ge = Ii(be.type, be.key, be.props, null, de.mode, Ge), dc(Ge, be), Ge.return = de, de = Ge);
                            }
                            return B(de);
                        case x:
                            e: {
                                for(bt = be.key; le !== null;){
                                    if (le.key === bt) if (le.tag === 4 && le.stateNode.containerInfo === be.containerInfo && le.stateNode.implementation === be.implementation) {
                                        h(de, le.sibling), Ge = S(le, be.children || []), Ge.return = de, de = Ge;
                                        break e;
                                    } else {
                                        h(de, le);
                                        break;
                                    }
                                    else o(de, le);
                                    le = le.sibling;
                                }
                                Ge = Qf(be, de.mode, Ge), Ge.return = de, de = Ge;
                            }
                            return B(de);
                        case F:
                            return bt = be._init, be = bt(be._payload), qn(de, le, be, Ge);
                    }
                    if (_e(be)) return Gt(de, le, be, Ge);
                    if (oe(be)) {
                        if (bt = oe(be), typeof bt != "function") throw Error(n(150));
                        return be = bt.call(be), Bt(de, le, be, Ge);
                    }
                    if (typeof be.then == "function") return qn(de, le, Hu(be), Ge);
                    if (be.$$typeof === N) return qn(de, le, wu(de, be), Ge);
                    vh(de, be);
                }
                return typeof be == "string" && be !== "" || typeof be == "number" || typeof be == "bigint" ? (be = "" + be, le !== null && le.tag === 6 ? (h(de, le.sibling), Ge = S(le, be), Ge.return = de, de = Ge) : (h(de, le), Ge = Mu(be, de.mode, Ge), Ge.return = de, de = Ge), B(de)) : h(de, le);
            }
            return function(de, le, be, Ge) {
                try {
                    Pu = 0;
                    var bt = qn(de, le, be, Ge);
                    return il = null, bt;
                } catch (At) {
                    if (At === Nu || At === Da) throw At;
                    var un = Rs(29, At, null, de.mode);
                    return un.lanes = Ge, un.return = de, un;
                } finally{}
            };
        }
        var sl = Wg(!0), Zg = Wg(!1), Bn = $(null), Ua = null;
        function wo(s) {
            var o = s.alternate;
            ve(li, li.current & 1), ve(Bn, s), Ua === null && (o === null || cc.current !== null || o.memoizedState !== null) && (Ua = s);
        }
        function Kg(s) {
            if (s.tag === 22) {
                if (ve(li, li.current), ve(Bn, s), Ua === null) {
                    var o = s.alternate;
                    o !== null && o.memoizedState !== null && (Ua = s);
                }
            } else Ro();
        }
        function Ro() {
            ve(li, li.current), ve(Bn, Bn.current);
        }
        function nr(s) {
            me(Bn), Ua === s && (Ua = null), me(li);
        }
        var li = $(0);
        function Xr(s) {
            for(var o = s; o !== null;){
                if (o.tag === 13) {
                    var h = o.memoizedState;
                    if (h !== null && (h = h.dehydrated, h === null || h.data === "$?" || x_(h))) return o;
                } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
                    if ((o.flags & 128) !== 0) return o;
                } else if (o.child !== null) {
                    o.child.return = o, o = o.child;
                    continue;
                }
                if (o === s) break;
                for(; o.sibling === null;){
                    if (o.return === null || o.return === s) return null;
                    o = o.return;
                }
                o.sibling.return = o.return, o = o.sibling;
            }
            return null;
        }
        function Co(s, o, h, m) {
            o = s.memoizedState, h = h(m, o), h = h == null ? o : g({}, o, h), s.memoizedState = h, s.lanes === 0 && (s.updateQueue.baseState = h);
        }
        var ys = {
            enqueueSetState: function(s, o, h) {
                s = s._reactInternals;
                var m = si(), S = tr(m);
                S.payload = o, h != null && (S.callback = h), o = Fr(s, S, m), o !== null && (xs(o, s, m), nl(o, s, m));
            },
            enqueueReplaceState: function(s, o, h) {
                s = s._reactInternals;
                var m = si(), S = tr(m);
                S.tag = 1, S.payload = o, h != null && (S.callback = h), o = Fr(s, S, m), o !== null && (xs(o, s, m), nl(o, s, m));
            },
            enqueueForceUpdate: function(s, o) {
                s = s._reactInternals;
                var h = si(), m = tr(h);
                m.tag = 2, o != null && (m.callback = o), o = Fr(s, m, h), o !== null && (xs(o, s, h), nl(o, s, h));
            }
        };
        function Qg(s, o, h, m, S, A, B) {
            return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(m, A, B) : o.prototype && o.prototype.isPureReactComponent ? !Ra(h, m) || !Ra(S, A) : !0;
        }
        function Jg(s, o, h, m) {
            s = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(h, m), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(h, m), o.state !== s && ys.enqueueReplaceState(o, o.state, null);
        }
        function ir(s, o) {
            var h = o;
            if ("ref" in o) {
                h = {};
                for(var m in o)m !== "ref" && (h[m] = o[m]);
            }
            if (s = s.defaultProps) {
                h === o && (h = g({}, h));
                for(var S in s)h[S] === void 0 && (h[S] = s[S]);
            }
            return h;
        }
        var al = typeof reportError == "function" ? reportError : function(s) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var o = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
                    error: s
                });
                if (!window.dispatchEvent(o)) return;
            } else if (typeof process == "object" && typeof process.emit == "function") {
                process.emit("uncaughtException", s);
                return;
            }
            console.error(s);
        };
        function Fu(s) {
            al(s);
        }
        function yh(s) {
            console.error(s);
        }
        function $g(s) {
            al(s);
        }
        function _h(s, o) {
            try {
                var h = s.onUncaughtError;
                h(o.value, {
                    componentStack: o.stack
                });
            } catch (m) {
                setTimeout(function() {
                    throw m;
                });
            }
        }
        function fa(s, o, h) {
            try {
                var m = s.onCaughtError;
                m(h.value, {
                    componentStack: h.stack,
                    errorBoundary: o.tag === 1 ? o.stateNode : null
                });
            } catch (S) {
                setTimeout(function() {
                    throw S;
                });
            }
        }
        function xh(s, o, h) {
            return h = tr(h), h.tag = 3, h.payload = {
                element: null
            }, h.callback = function() {
                _h(s, o);
            }, h;
        }
        function e0(s) {
            return s = tr(s), s.tag = 3, s;
        }
        function Sh(s, o, h, m) {
            var S = h.type.getDerivedStateFromError;
            if (typeof S == "function") {
                var A = m.value;
                s.payload = function() {
                    return S(A);
                }, s.callback = function() {
                    fa(o, h, m);
                };
            }
            var B = h.stateNode;
            B !== null && typeof B.componentDidCatch == "function" && (s.callback = function() {
                fa(o, h, m), typeof S != "function" && (Zs === null ? Zs = new Set([
                    this
                ]) : Zs.add(this));
                var V = m.stack;
                this.componentDidCatch(m.value, {
                    componentStack: V !== null ? V : ""
                });
            });
        }
        function r_(s, o, h, m, S) {
            if (h.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
                if (o = h.alternate, o !== null && oa(o, h, S, !0), h = Bn.current, h !== null) {
                    switch(h.tag){
                        case 13:
                            return Ua === null ? c() : h.alternate === null && Yn === 0 && (Yn = 3), h.flags &= -257, h.flags |= 65536, h.lanes = S, m === Uu ? h.flags |= 16384 : (o = h.updateQueue, o === null ? h.updateQueue = new Set([
                                m
                            ]) : o.add(m), Ce(s, m, S)), !1;
                        case 22:
                            return h.flags |= 65536, m === Uu ? h.flags |= 16384 : (o = h.updateQueue, o === null ? (o = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([
                                    m
                                ])
                            }, h.updateQueue = o) : (h = o.retryQueue, h === null ? o.retryQueue = new Set([
                                m
                            ]) : h.add(m)), Ce(s, m, S)), !1;
                    }
                    throw Error(n(435, h.tag));
                }
                return Ce(s, m, S), c(), !1;
            }
            if (bn) return o = Bn.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = S, m !== $f && (s = Error(n(422), {
                cause: m
            }), tl(Wi(s, h)))) : (m !== $f && (o = Error(n(423), {
                cause: m
            }), tl(Wi(o, h))), s = s.current.alternate, s.flags |= 65536, S &= -S, s.lanes |= S, m = Wi(m, h), S = xh(s.stateNode, m, S), rc(s, S), Yn !== 4 && (Yn = 2)), !1;
            var A = Error(n(520), {
                cause: m
            });
            if (A = Wi(A, h), Rn === null ? Rn = [
                A
            ] : Rn.push(A), Yn !== 4 && (Yn = 2), o === null) return !0;
            m = Wi(m, h), h = o;
            do {
                switch(h.tag){
                    case 3:
                        return h.flags |= 65536, s = S & -S, h.lanes |= s, s = xh(h.stateNode, m, s), rc(h, s), !1;
                    case 1:
                        if (o = h.type, A = h.stateNode, (h.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || A !== null && typeof A.componentDidCatch == "function" && (Zs === null || !Zs.has(A)))) return h.flags |= 65536, S &= -S, h.lanes |= S, S = e0(S), Sh(S, s, h, m), rc(h, S), !1;
                }
                h = h.return;
            }while (h !== null);
            return !1;
        }
        var t0 = Error(n(461)), Pi = !1;
        function ci(s, o, h, m) {
            o.child = s === null ? Zg(o, null, h, m) : sl(o, s.child, h, m);
        }
        function Ds(s, o, h, m, S) {
            h = h.render;
            var A = o.ref;
            if ("ref" in m) {
                var B = {};
                for(var V in m)V !== "ref" && (B[V] = m[V]);
            } else B = m;
            return er(o), m = Vr(s, o, h, B, A, S), V = gp(), s !== null && !Pi ? (lh(s, o, S), Hi(s, o, S)) : (bn && V && ap(o), o.flags |= 1, ci(s, o, m, S), o.child);
        }
        function Ns(s, o, h, m, S) {
            if (s === null) {
                var A = h.type;
                return typeof A == "function" && !bu(A) && A.defaultProps === void 0 && h.compare === null ? (o.tag = 15, o.type = A, Up(s, o, A, m, S)) : (s = Ii(h.type, null, m, o, o.mode, S), s.ref = o.ref, s.return = o, o.child = s);
            }
            if (A = s.child, !Gu(s, S)) {
                var B = A.memoizedProps;
                if (h = h.compare, h = h !== null ? h : Ra, h(B, m) && s.ref === o.ref) return Hi(s, o, S);
            }
            return o.flags |= 1, s = ri(A, m), s.ref = o.ref, s.return = o, o.child = s;
        }
        function Up(s, o, h, m, S) {
            if (s !== null) {
                var A = s.memoizedProps;
                if (Ra(A, m) && s.ref === o.ref) if (Pi = !1, o.pendingProps = m = A, Gu(s, S)) (s.flags & 131072) !== 0 && (Pi = !0);
                else return o.lanes = s.lanes, Hi(s, o, S);
            }
            return pc(s, o, h, m, S);
        }
        function rl(s, o, h) {
            var m = o.pendingProps, S = m.children, A = s !== null ? s.memoizedState : null;
            if (m.mode === "hidden") {
                if ((o.flags & 128) !== 0) {
                    if (m = A !== null ? A.baseLanes | h : h, s !== null) {
                        for(S = o.child = s.child, A = 0; S !== null;)A = A | S.lanes | S.childLanes, S = S.sibling;
                        o.childLanes = A & ~m;
                    } else o.childLanes = 0, o.child = null;
                    return ol(s, o, m, h);
                }
                if ((h & 536870912) !== 0) o.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                }, s !== null && Du(o, A !== null ? A.cachePool : null), A !== null ? vg(o, A) : mp(), Kg(o);
                else return o.lanes = o.childLanes = 536870912, ol(s, o, A !== null ? A.baseLanes | h : h, h);
            } else A !== null ? (Du(o, A.cachePool), vg(o, A), Ro(), o.memoizedState = null) : (s !== null && Du(o, null), mp(), Ro());
            return ci(s, o, S, h), o.child;
        }
        function ol(s, o, h, m) {
            var S = Mo();
            return S = S === null ? null : {
                parent: xi._currentValue,
                pool: S
            }, o.memoizedState = {
                baseLanes: h,
                cachePool: S
            }, s !== null && Du(o, null), mp(), Kg(o), s !== null && oa(s, o, m, !0), null;
        }
        function ll(s, o) {
            var h = o.ref;
            if (h === null) s !== null && s.ref !== null && (o.flags |= 4194816);
            else {
                if (typeof h != "function" && typeof h != "object") throw Error(n(284));
                (s === null || s.ref !== h) && (o.flags |= 4194816);
            }
        }
        function pc(s, o, h, m, S) {
            return er(o), h = Vr(s, o, h, m, void 0, S), m = gp(), s !== null && !Pi ? (lh(s, o, S), Hi(s, o, S)) : (bn && m && ap(o), o.flags |= 1, ci(s, o, h, S), o.child);
        }
        function Vs(s, o, h, m, S, A) {
            return er(o), o.updateQueue = null, h = xg(o, m, h, S), _g(s), m = gp(), s !== null && !Pi ? (lh(s, o, A), Hi(s, o, A)) : (bn && m && ap(o), o.flags |= 1, ci(s, o, h, A), o.child);
        }
        function ks(s, o, h, m, S) {
            if (er(o), o.stateNode === null) {
                var A = vo, B = h.contextType;
                typeof B == "object" && B !== null && (A = ti(B)), A = new h(m, A), o.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, A.updater = ys, o.stateNode = A, A._reactInternals = o, A = o.stateNode, A.props = m, A.state = o.memoizedState, A.refs = {}, dp(o), B = h.contextType, A.context = typeof B == "object" && B !== null ? ti(B) : vo, A.state = o.memoizedState, B = h.getDerivedStateFromProps, typeof B == "function" && (Co(o, h, B, m), A.state = o.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function" || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (B = A.state, typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount(), B !== A.state && ys.enqueueReplaceState(A, A.state, null), oc(o, m, A, S), Lu(), A.state = o.memoizedState), typeof A.componentDidMount == "function" && (o.flags |= 4194308), m = !0;
            } else if (s === null) {
                A = o.stateNode;
                var V = o.memoizedProps, ee = ir(h, V);
                A.props = ee;
                var Me = A.context, ze = h.contextType;
                B = vo, typeof ze == "object" && ze !== null && (B = ti(ze));
                var ke = h.getDerivedStateFromProps;
                ze = typeof ke == "function" || typeof A.getSnapshotBeforeUpdate == "function", V = o.pendingProps !== V, ze || typeof A.UNSAFE_componentWillReceiveProps != "function" && typeof A.componentWillReceiveProps != "function" || (V || Me !== B) && Jg(o, A, m, B), Hr = !1;
                var Te = o.memoizedState;
                A.state = Te, oc(o, m, A, S), Lu(), Me = o.memoizedState, V || Te !== Me || Hr ? (typeof ke == "function" && (Co(o, h, ke, m), Me = o.memoizedState), (ee = Hr || Qg(o, h, ee, m, Te, Me, B)) ? (ze || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount()), typeof A.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof A.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = m, o.memoizedState = Me), A.props = m, A.state = Me, A.context = B, m = ee) : (typeof A.componentDidMount == "function" && (o.flags |= 4194308), m = !1);
            } else {
                A = o.stateNode, Ht(s, o), B = o.memoizedProps, ze = ir(h, B), A.props = ze, ke = o.pendingProps, Te = A.context, Me = h.contextType, ee = vo, typeof Me == "object" && Me !== null && (ee = ti(Me)), V = h.getDerivedStateFromProps, (Me = typeof V == "function" || typeof A.getSnapshotBeforeUpdate == "function") || typeof A.UNSAFE_componentWillReceiveProps != "function" && typeof A.componentWillReceiveProps != "function" || (B !== ke || Te !== ee) && Jg(o, A, m, ee), Hr = !1, Te = o.memoizedState, A.state = Te, oc(o, m, A, S), Lu();
                var Re = o.memoizedState;
                B !== ke || Te !== Re || Hr || s !== null && s.dependencies !== null && Au(s.dependencies) ? (typeof V == "function" && (Co(o, h, V, m), Re = o.memoizedState), (ze = Hr || Qg(o, h, ze, m, Te, Re, ee) || s !== null && s.dependencies !== null && Au(s.dependencies)) ? (Me || typeof A.UNSAFE_componentWillUpdate != "function" && typeof A.componentWillUpdate != "function" || (typeof A.componentWillUpdate == "function" && A.componentWillUpdate(m, Re, ee), typeof A.UNSAFE_componentWillUpdate == "function" && A.UNSAFE_componentWillUpdate(m, Re, ee)), typeof A.componentDidUpdate == "function" && (o.flags |= 4), typeof A.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof A.componentDidUpdate != "function" || B === s.memoizedProps && Te === s.memoizedState || (o.flags |= 4), typeof A.getSnapshotBeforeUpdate != "function" || B === s.memoizedProps && Te === s.memoizedState || (o.flags |= 1024), o.memoizedProps = m, o.memoizedState = Re), A.props = m, A.state = Re, A.context = ee, m = ze) : (typeof A.componentDidUpdate != "function" || B === s.memoizedProps && Te === s.memoizedState || (o.flags |= 4), typeof A.getSnapshotBeforeUpdate != "function" || B === s.memoizedProps && Te === s.memoizedState || (o.flags |= 1024), m = !1);
            }
            return A = m, ll(s, o), m = (o.flags & 128) !== 0, A || m ? (A = o.stateNode, h = m && typeof h.getDerivedStateFromError != "function" ? null : A.render(), o.flags |= 1, s !== null && m ? (o.child = sl(o, s.child, null, S), o.child = sl(o, null, h, S)) : ci(s, o, h, S), o.memoizedState = A.state, s = o.child) : s = Hi(s, o, S), s;
        }
        function Do(s, o, h, m) {
            return tc(), o.flags |= 256, ci(s, o, h, m), o.child;
        }
        var La = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0,
            hydrationErrors: null
        };
        function Oa(s) {
            return {
                baseLanes: s,
                cachePool: ih()
            };
        }
        function wi(s, o, h) {
            return s = s !== null ? s.childLanes & ~h : 0, o && (s |= ga), s;
        }
        function mc(s, o, h) {
            var m = o.pendingProps, S = !1, A = (o.flags & 128) !== 0, B;
            if ((B = A) || (B = s !== null && s.memoizedState === null ? !1 : (li.current & 2) !== 0), B && (S = !0, o.flags &= -129), B = (o.flags & 32) !== 0, o.flags &= -33, s === null) {
                if (bn) {
                    if (S ? wo(o) : Ro(), bn) {
                        var V = Jn, ee;
                        if (ee = V) {
                            e: {
                                for(ee = V, V = Hs; ee.nodeType !== 8;){
                                    if (!V) {
                                        V = null;
                                        break e;
                                    }
                                    if (ee = Kr(ee.nextSibling), ee === null) {
                                        V = null;
                                        break e;
                                    }
                                }
                                V = ee;
                            }
                            V !== null ? (o.memoizedState = {
                                dehydrated: V,
                                treeContext: _o !== null ? {
                                    id: Ja,
                                    overflow: $a
                                } : null,
                                retryLane: 536870912,
                                hydrationErrors: null
                            }, ee = Rs(18, null, null, 0), ee.stateNode = V, ee.return = o, o.child = ee, ms = o, Jn = null, ee = !0) : ee = !1;
                        }
                        ee || xo(o);
                    }
                    if (V = o.memoizedState, V !== null && (V = V.dehydrated, V !== null)) return x_(V) ? o.lanes = 32 : o.lanes = 536870912, null;
                    nr(o);
                }
                return V = m.children, m = m.fallback, S ? (Ro(), S = o.mode, V = cl({
                    mode: "hidden",
                    children: V
                }, S), m = yo(m, S, h, null), V.return = o, m.return = o, V.sibling = m, o.child = V, S = o.child, S.memoizedState = Oa(h), S.childLanes = wi(s, B, h), o.memoizedState = La, m) : (wo(o), sr(o, V));
            }
            if (ee = s.memoizedState, ee !== null && (V = ee.dehydrated, V !== null)) {
                if (A) o.flags & 256 ? (wo(o), o.flags &= -257, o = Qi(s, o, h)) : o.memoizedState !== null ? (Ro(), o.child = s.child, o.flags |= 128, o = null) : (Ro(), S = m.fallback, V = o.mode, m = cl({
                    mode: "visible",
                    children: m.children
                }, V), S = yo(S, V, h, null), S.flags |= 2, m.return = o, S.return = o, m.sibling = S, o.child = m, sl(o, s.child, null, h), m = o.child, m.memoizedState = Oa(h), m.childLanes = wi(s, B, h), o.memoizedState = La, o = S);
                else if (wo(o), x_(V)) {
                    if (B = V.nextSibling && V.nextSibling.dataset, B) var Me = B.dgst;
                    B = Me, m = Error(n(419)), m.stack = "", m.digest = B, tl({
                        value: m,
                        source: null,
                        stack: null
                    }), o = Qi(s, o, h);
                } else if (Pi || oa(s, o, h, !1), B = (h & s.childLanes) !== 0, Pi || B) {
                    if (B = kt, B !== null && (m = h & -h, m = (m & 42) !== 0 ? 1 : Mt(m), m = (m & (B.suspendedLanes | h)) !== 0 ? 0 : m, m !== 0 && m !== ee.retryLane)) throw ee.retryLane = m, zr(s, m), xs(B, s, m), t0;
                    V.data === "$?" || c(), o = Qi(s, o, h);
                } else V.data === "$?" ? (o.flags |= 192, o.child = s.child, o = null) : (s = ee.treeContext, Jn = Kr(V.nextSibling), ms = o, bn = !0, ra = null, Hs = !1, s !== null && (Zi[Ps++] = Ja, Zi[Ps++] = $a, Zi[Ps++] = _o, Ja = s.id, $a = s.overflow, _o = o), o = sr(o, m.children), o.flags |= 4096);
                return o;
            }
            return S ? (Ro(), S = m.fallback, V = o.mode, ee = s.child, Me = ee.sibling, m = ri(ee, {
                mode: "hidden",
                children: m.children
            }), m.subtreeFlags = ee.subtreeFlags & 65011712, Me !== null ? S = ri(Me, S) : (S = yo(S, V, h, null), S.flags |= 2), S.return = o, m.return = o, m.sibling = S, o.child = m, m = S, S = o.child, V = s.child.memoizedState, V === null ? V = Oa(h) : (ee = V.cachePool, ee !== null ? (Me = xi._currentValue, ee = ee.parent !== Me ? {
                parent: Me,
                pool: Me
            } : ee) : ee = ih(), V = {
                baseLanes: V.baseLanes | h,
                cachePool: ee
            }), S.memoizedState = V, S.childLanes = wi(s, B, h), o.memoizedState = La, m) : (wo(o), h = s.child, s = h.sibling, h = ri(h, {
                mode: "visible",
                children: m.children
            }), h.return = o, h.sibling = null, s !== null && (B = o.deletions, B === null ? (o.deletions = [
                s
            ], o.flags |= 16) : B.push(s)), o.child = h, o.memoizedState = null, h);
        }
        function sr(s, o) {
            return o = cl({
                mode: "visible",
                children: o
            }, s.mode), o.return = s, s.child = o;
        }
        function cl(s, o) {
            return s = Rs(22, s, null, o), s.lanes = 0, s.stateNode = {
                _visibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null
            }, s;
        }
        function Qi(s, o, h) {
            return sl(o, s.child, null, h), s = sr(o, o.pendingProps.children), s.flags |= 2, o.memoizedState = null, s;
        }
        function Ji(s, o, h) {
            s.lanes |= o;
            var m = s.alternate;
            m !== null && (m.lanes |= o), cp(s.return, o, h);
        }
        function yn(s, o, h, m, S) {
            var A = s.memoizedState;
            A === null ? s.memoizedState = {
                isBackwards: o,
                rendering: null,
                renderingStartTime: 0,
                last: m,
                tail: h,
                tailMode: S
            } : (A.isBackwards = o, A.rendering = null, A.renderingStartTime = 0, A.last = m, A.tail = h, A.tailMode = S);
        }
        function ha(s, o, h) {
            var m = o.pendingProps, S = m.revealOrder, A = m.tail;
            if (ci(s, o, m.children, h), m = li.current, (m & 2) !== 0) m = m & 1 | 2, o.flags |= 128;
            else {
                if (s !== null && (s.flags & 128) !== 0) e: for(s = o.child; s !== null;){
                    if (s.tag === 13) s.memoizedState !== null && Ji(s, h, o);
                    else if (s.tag === 19) Ji(s, h, o);
                    else if (s.child !== null) {
                        s.child.return = s, s = s.child;
                        continue;
                    }
                    if (s === o) break e;
                    for(; s.sibling === null;){
                        if (s.return === null || s.return === o) break e;
                        s = s.return;
                    }
                    s.sibling.return = s.return, s = s.sibling;
                }
                m &= 1;
            }
            switch(ve(li, m), S){
                case "forwards":
                    for(h = o.child, S = null; h !== null;)s = h.alternate, s !== null && Xr(s) === null && (S = h), h = h.sibling;
                    h = S, h === null ? (S = o.child, o.child = null) : (S = h.sibling, h.sibling = null), yn(o, !1, S, h, A);
                    break;
                case "backwards":
                    for(h = null, S = o.child, o.child = null; S !== null;){
                        if (s = S.alternate, s !== null && Xr(s) === null) {
                            o.child = S;
                            break;
                        }
                        s = S.sibling, S.sibling = h, h = S, S = s;
                    }
                    yn(o, !0, h, null, A);
                    break;
                case "together":
                    yn(o, !1, null, null, void 0);
                    break;
                default:
                    o.memoizedState = null;
            }
            return o.child;
        }
        function Hi(s, o, h) {
            if (s !== null && (o.dependencies = s.dependencies), Pa |= o.lanes, (h & o.childLanes) === 0) if (s !== null) {
                if (oa(s, o, h, !1), (h & o.childLanes) === 0) return null;
            } else return null;
            if (s !== null && o.child !== s.child) throw Error(n(153));
            if (o.child !== null) {
                for(s = o.child, h = ri(s, s.pendingProps), o.child = h, h.return = o; s.sibling !== null;)s = s.sibling, h = h.sibling = ri(s, s.pendingProps), h.return = o;
                h.sibling = null;
            }
            return o.child;
        }
        function Gu(s, o) {
            return (s.lanes & o) !== 0 ? !0 : (s = s.dependencies, !!(s !== null && Au(s)));
        }
        function da(s, o, h) {
            switch(o.tag){
                case 3:
                    Pe(o, o.stateNode.containerInfo), bo(o, xi, s.memoizedState.cache), tc();
                    break;
                case 27:
                case 5:
                    xt(o);
                    break;
                case 4:
                    Pe(o, o.stateNode.containerInfo);
                    break;
                case 10:
                    bo(o, o.type, o.memoizedProps.value);
                    break;
                case 13:
                    var m = o.memoizedState;
                    if (m !== null) return m.dehydrated !== null ? (wo(o), o.flags |= 128, null) : (h & o.child.childLanes) !== 0 ? mc(s, o, h) : (wo(o), s = Hi(s, o, h), s !== null ? s.sibling : null);
                    wo(o);
                    break;
                case 19:
                    var S = (s.flags & 128) !== 0;
                    if (m = (h & o.childLanes) !== 0, m || (oa(s, o, h, !1), m = (h & o.childLanes) !== 0), S) {
                        if (m) return ha(s, o, h);
                        o.flags |= 128;
                    }
                    if (S = o.memoizedState, S !== null && (S.rendering = null, S.tail = null, S.lastEffect = null), ve(li, li.current), m) break;
                    return null;
                case 22:
                case 23:
                    return o.lanes = 0, rl(s, o, h);
                case 24:
                    bo(o, xi, s.memoizedState.cache);
            }
            return Hi(s, o, h);
        }
        function ul(s, o, h) {
            if (s !== null) if (s.memoizedProps !== o.pendingProps) Pi = !0;
            else {
                if (!Gu(s, h) && (o.flags & 128) === 0) return Pi = !1, da(s, o, h);
                Pi = (s.flags & 131072) !== 0;
            }
            else Pi = !1, bn && (o.flags & 1048576) !== 0 && Jf(o, ec, o.index);
            switch(o.lanes = 0, o.tag){
                case 16:
                    e: {
                        s = o.pendingProps;
                        var m = o.elementType, S = m._init;
                        if (m = S(m._payload), o.type = m, typeof m == "function") bu(m) ? (s = ir(m, s), o.tag = 1, o = ks(null, o, m, s, h)) : (o.tag = 0, o = pc(null, o, m, s, h));
                        else {
                            if (m != null) {
                                if (S = m.$$typeof, S === D) {
                                    o.tag = 11, o = Ds(null, o, m, s, h);
                                    break e;
                                } else if (S === P) {
                                    o.tag = 14, o = Ns(null, o, m, s, h);
                                    break e;
                                }
                            }
                            throw o = ge(m) || m, Error(n(306, o, ""));
                        }
                    }
                    return o;
                case 0:
                    return pc(s, o, o.type, o.pendingProps, h);
                case 1:
                    return m = o.type, S = ir(m, o.pendingProps), ks(s, o, m, S, h);
                case 3:
                    e: {
                        if (Pe(o, o.stateNode.containerInfo), s === null) throw Error(n(387));
                        m = o.pendingProps;
                        var A = o.memoizedState;
                        S = A.element, Ht(s, o), oc(o, m, null, h);
                        var B = o.memoizedState;
                        if (m = B.cache, bo(o, xi, m), m !== A.cache && Tu(o, [
                            xi
                        ], h, !0), Lu(), m = B.element, A.isDehydrated) if (A = {
                            element: m,
                            isDehydrated: !1,
                            cache: B.cache
                        }, o.updateQueue.baseState = A, o.memoizedState = A, o.flags & 256) {
                            o = Do(s, o, m, h);
                            break e;
                        } else if (m !== S) {
                            S = Wi(Error(n(424)), o), tl(S), o = Do(s, o, m, h);
                            break e;
                        } else {
                            switch(s = o.stateNode.containerInfo, s.nodeType){
                                case 9:
                                    s = s.body;
                                    break;
                                default:
                                    s = s.nodeName === "HTML" ? s.ownerDocument.body : s;
                            }
                            for(Jn = Kr(s.firstChild), ms = o, bn = !0, ra = null, Hs = !0, h = Zg(o, null, m, h), o.child = h; h;)h.flags = h.flags & -3 | 4096, h = h.sibling;
                        }
                        else {
                            if (tc(), m === S) {
                                o = Hi(s, o, h);
                                break e;
                            }
                            ci(s, o, m, h);
                        }
                        o = o.child;
                    }
                    return o;
                case 26:
                    return ll(s, o), s === null ? (h = Lb(o.type, null, o.pendingProps, null)) ? o.memoizedState = h : bn || (h = o.type, s = o.pendingProps, m = o0(he.current).createElement(h), m[vi] = o, m[Ei] = s, Ss(m, h, s), yi(m), o.stateNode = m) : o.memoizedState = Lb(o.type, s.memoizedProps, o.pendingProps, s.memoizedState), null;
                case 27:
                    return xt(o), s === null && bn && (m = o.stateNode = Db(o.type, o.pendingProps, he.current), ms = o, Hs = !0, S = Jn, Tc(o.type) ? (S_ = S, Jn = Kr(m.firstChild)) : Jn = S), ci(s, o, o.pendingProps.children, h), ll(s, o), s === null && (o.flags |= 4194304), o.child;
                case 5:
                    return s === null && bn && ((S = m = Jn) && (m = dw(m, o.type, o.pendingProps, Hs), m !== null ? (o.stateNode = m, ms = o, Jn = Kr(m.firstChild), Hs = !1, S = !0) : S = !1), S || xo(o)), xt(o), S = o.type, A = o.pendingProps, B = s !== null ? s.memoizedProps : null, m = A.children, v_(S, A) ? m = null : B !== null && v_(S, B) && (o.flags |= 32), o.memoizedState !== null && (S = Vr(s, o, e_, null, null, h), kp._currentValue = S), ll(s, o), ci(s, o, m, h), o.child;
                case 6:
                    return s === null && bn && ((s = h = Jn) && (h = pw(h, o.pendingProps, Hs), h !== null ? (o.stateNode = h, ms = o, Jn = null, s = !0) : s = !1), s || xo(o)), null;
                case 13:
                    return mc(s, o, h);
                case 4:
                    return Pe(o, o.stateNode.containerInfo), m = o.pendingProps, s === null ? o.child = sl(o, null, m, h) : ci(s, o, m, h), o.child;
                case 11:
                    return Ds(s, o, o.type, o.pendingProps, h);
                case 7:
                    return ci(s, o, o.pendingProps, h), o.child;
                case 8:
                    return ci(s, o, o.pendingProps.children, h), o.child;
                case 12:
                    return ci(s, o, o.pendingProps.children, h), o.child;
                case 10:
                    return m = o.pendingProps, bo(o, o.type, m.value), ci(s, o, m.children, h), o.child;
                case 9:
                    return S = o.type._context, m = o.pendingProps.children, er(o), S = ti(S), m = m(S), o.flags |= 1, ci(s, o, m, h), o.child;
                case 14:
                    return Ns(s, o, o.type, o.pendingProps, h);
                case 15:
                    return Up(s, o, o.type, o.pendingProps, h);
                case 19:
                    return ha(s, o, h);
                case 31:
                    return m = o.pendingProps, h = o.mode, m = {
                        mode: m.mode,
                        children: m.children
                    }, s === null ? (h = cl(m, h), h.ref = o.ref, o.child = h, h.return = o, o = h) : (h = ri(s.child, m), h.ref = o.ref, o.child = h, h.return = o, o = h), o;
                case 22:
                    return rl(s, o, h);
                case 24:
                    return er(o), m = ti(xi), s === null ? (S = Mo(), S === null && (S = kt, A = th(), S.pooledCache = A, A.refCount++, A !== null && (S.pooledCacheLanes |= h), S = A), o.memoizedState = {
                        parent: m,
                        cache: S
                    }, dp(o), bo(o, xi, S)) : ((s.lanes & h) !== 0 && (Ht(s, o), oc(o, null, null, h), Lu()), S = s.memoizedState, A = o.memoizedState, S.parent !== m ? (S = {
                        parent: m,
                        cache: m
                    }, o.memoizedState = S, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = S), bo(o, xi, m)) : (m = A.cache, bo(o, xi, m), m !== S.cache && Tu(o, [
                        xi
                    ], h, !0))), ci(s, o, o.pendingProps.children, h), o.child;
                case 29:
                    throw o.pendingProps;
            }
            throw Error(n(156, o.tag));
        }
        function za(s) {
            s.flags |= 4;
        }
        function Vu(s, o) {
            if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0) s.flags &= -16777217;
            else if (s.flags |= 16777216, !Pb(o)) {
                if (o = Bn.current, o !== null && ((Ct & 4194048) === Ct ? Ua !== null : (Ct & 62914560) !== Ct && (Ct & 536870912) === 0 || o !== Ua)) throw ca = Uu, fp;
                s.flags |= 8192;
            }
        }
        function jr(s, o) {
            o !== null && (s.flags |= 4), s.flags & 16384 && (o = s.tag !== 22 ? Qe() : 536870912, s.lanes |= o, xn |= o);
        }
        function fl(s, o) {
            if (!bn) switch(s.tailMode){
                case "hidden":
                    o = s.tail;
                    for(var h = null; o !== null;)o.alternate !== null && (h = o), o = o.sibling;
                    h === null ? s.tail = null : h.sibling = null;
                    break;
                case "collapsed":
                    h = s.tail;
                    for(var m = null; h !== null;)h.alternate !== null && (m = h), h = h.sibling;
                    m === null ? o || s.tail === null ? s.tail = null : s.tail.sibling = null : m.sibling = null;
            }
        }
        function Vn(s) {
            var o = s.alternate !== null && s.alternate.child === s.child, h = 0, m = 0;
            if (o) for(var S = s.child; S !== null;)h |= S.lanes | S.childLanes, m |= S.subtreeFlags & 65011712, m |= S.flags & 65011712, S.return = s, S = S.sibling;
            else for(S = s.child; S !== null;)h |= S.lanes | S.childLanes, m |= S.subtreeFlags, m |= S.flags, S.return = s, S = S.sibling;
            return s.subtreeFlags |= m, s.childLanes = h, o;
        }
        function Lp(s, o, h) {
            var m = o.pendingProps;
            switch(rp(o), o.tag){
                case 31:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return Vn(o), null;
                case 1:
                    return Vn(o), null;
                case 3:
                    return h = o.stateNode, m = null, s !== null && (m = s.memoizedState.cache), o.memoizedState.cache !== m && (o.flags |= 2048), Pr(xi), _t(), h.pendingContext && (h.context = h.pendingContext, h.pendingContext = null), (s === null || s.child === null) && (Ca(o) ? za(o) : s === null || s.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, An())), Vn(o), null;
                case 26:
                    return h = o.memoizedState, s === null ? (za(o), h !== null ? (Vn(o), Vu(o, h)) : (Vn(o), o.flags &= -16777217)) : h ? h !== s.memoizedState ? (za(o), Vn(o), Vu(o, h)) : (Vn(o), o.flags &= -16777217) : (s.memoizedProps !== m && za(o), Vn(o), o.flags &= -16777217), null;
                case 27:
                    on(o), h = he.current;
                    var S = o.type;
                    if (s !== null && o.stateNode != null) s.memoizedProps !== m && za(o);
                    else {
                        if (!m) {
                            if (o.stateNode === null) throw Error(n(166));
                            return Vn(o), null;
                        }
                        s = J.current, Ca(o) ? dg(o) : (s = Db(S, m, h), o.stateNode = s, za(o));
                    }
                    return Vn(o), null;
                case 5:
                    if (on(o), h = o.type, s !== null && o.stateNode != null) s.memoizedProps !== m && za(o);
                    else {
                        if (!m) {
                            if (o.stateNode === null) throw Error(n(166));
                            return Vn(o), null;
                        }
                        if (s = J.current, Ca(o)) dg(o);
                        else {
                            switch(S = o0(he.current), s){
                                case 1:
                                    s = S.createElementNS("http://www.w3.org/2000/svg", h);
                                    break;
                                case 2:
                                    s = S.createElementNS("http://www.w3.org/1998/Math/MathML", h);
                                    break;
                                default:
                                    switch(h){
                                        case "svg":
                                            s = S.createElementNS("http://www.w3.org/2000/svg", h);
                                            break;
                                        case "math":
                                            s = S.createElementNS("http://www.w3.org/1998/Math/MathML", h);
                                            break;
                                        case "script":
                                            s = S.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
                                            break;
                                        case "select":
                                            s = typeof m.is == "string" ? S.createElement("select", {
                                                is: m.is
                                            }) : S.createElement("select"), m.multiple ? s.multiple = !0 : m.size && (s.size = m.size);
                                            break;
                                        default:
                                            s = typeof m.is == "string" ? S.createElement(h, {
                                                is: m.is
                                            }) : S.createElement(h);
                                    }
                            }
                            s[vi] = o, s[Ei] = m;
                            e: for(S = o.child; S !== null;){
                                if (S.tag === 5 || S.tag === 6) s.appendChild(S.stateNode);
                                else if (S.tag !== 4 && S.tag !== 27 && S.child !== null) {
                                    S.child.return = S, S = S.child;
                                    continue;
                                }
                                if (S === o) break e;
                                for(; S.sibling === null;){
                                    if (S.return === null || S.return === o) break e;
                                    S = S.return;
                                }
                                S.sibling.return = S.return, S = S.sibling;
                            }
                            o.stateNode = s;
                            e: switch(Ss(s, h, m), h){
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    s = !!m.autoFocus;
                                    break e;
                                case "img":
                                    s = !0;
                                    break e;
                                default:
                                    s = !1;
                            }
                            s && za(o);
                        }
                    }
                    return Vn(o), o.flags &= -16777217, null;
                case 6:
                    if (s && o.stateNode != null) s.memoizedProps !== m && za(o);
                    else {
                        if (typeof m != "string" && o.stateNode === null) throw Error(n(166));
                        if (s = he.current, Ca(o)) {
                            if (s = o.stateNode, h = o.memoizedProps, m = null, S = ms, S !== null) switch(S.tag){
                                case 27:
                                case 5:
                                    m = S.memoizedProps;
                            }
                            s[vi] = o, s = !!(s.nodeValue === h || m !== null && m.suppressHydrationWarning === !0 || Mb(s.nodeValue, h)), s || xo(o);
                        } else s = o0(s).createTextNode(m), s[vi] = o, o.stateNode = s;
                    }
                    return Vn(o), null;
                case 13:
                    if (m = o.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                        if (S = Ca(o), m !== null && m.dehydrated !== null) {
                            if (s === null) {
                                if (!S) throw Error(n(318));
                                if (S = o.memoizedState, S = S !== null ? S.dehydrated : null, !S) throw Error(n(317));
                                S[vi] = o;
                            } else tc(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
                            Vn(o), S = !1;
                        } else S = An(), s !== null && s.memoizedState !== null && (s.memoizedState.hydrationErrors = S), S = !0;
                        if (!S) return o.flags & 256 ? (nr(o), o) : (nr(o), null);
                    }
                    if (nr(o), (o.flags & 128) !== 0) return o.lanes = h, o;
                    if (h = m !== null, s = s !== null && s.memoizedState !== null, h) {
                        m = o.child, S = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (S = m.alternate.memoizedState.cachePool.pool);
                        var A = null;
                        m.memoizedState !== null && m.memoizedState.cachePool !== null && (A = m.memoizedState.cachePool.pool), A !== S && (m.flags |= 2048);
                    }
                    return h !== s && h && (o.child.flags |= 8192), jr(o, o.updateQueue), Vn(o), null;
                case 4:
                    return _t(), s === null && h_(o.stateNode.containerInfo), Vn(o), null;
                case 10:
                    return Pr(o.type), Vn(o), null;
                case 19:
                    if (me(li), S = o.memoizedState, S === null) return Vn(o), null;
                    if (m = (o.flags & 128) !== 0, A = S.rendering, A === null) if (m) fl(S, !1);
                    else {
                        if (Yn !== 0 || s !== null && (s.flags & 128) !== 0) for(s = o.child; s !== null;){
                            if (A = Xr(s), A !== null) {
                                for(o.flags |= 128, fl(S, !1), s = A.updateQueue, o.updateQueue = s, jr(o, s), o.subtreeFlags = 0, s = h, h = o.child; h !== null;)sp(h, s), h = h.sibling;
                                return ve(li, li.current & 1 | 2), o.child;
                            }
                            s = s.sibling;
                        }
                        S.tail !== null && We() > as && (o.flags |= 128, m = !0, fl(S, !1), o.lanes = 4194304);
                    }
                    else {
                        if (!m) if (s = Xr(A), s !== null) {
                            if (o.flags |= 128, m = !0, s = s.updateQueue, o.updateQueue = s, jr(o, s), fl(S, !0), S.tail === null && S.tailMode === "hidden" && !A.alternate && !bn) return Vn(o), null;
                        } else 2 * We() - S.renderingStartTime > as && h !== 536870912 && (o.flags |= 128, m = !0, fl(S, !1), o.lanes = 4194304);
                        S.isBackwards ? (A.sibling = o.child, o.child = A) : (s = S.last, s !== null ? s.sibling = A : o.child = A, S.last = A);
                    }
                    return S.tail !== null ? (o = S.tail, S.rendering = o, S.tail = o.sibling, S.renderingStartTime = We(), o.sibling = null, s = li.current, ve(li, m ? s & 1 | 2 : s & 1), o) : (Vn(o), null);
                case 22:
                case 23:
                    return nr(o), Ou(), m = o.memoizedState !== null, s !== null ? s.memoizedState !== null !== m && (o.flags |= 8192) : m && (o.flags |= 8192), m ? (h & 536870912) !== 0 && (o.flags & 128) === 0 && (Vn(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : Vn(o), h = o.updateQueue, h !== null && jr(o, h.retryQueue), h = null, s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool), m = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (m = o.memoizedState.cachePool.pool), m !== h && (o.flags |= 2048), s !== null && me(la), null;
                case 24:
                    return h = null, s !== null && (h = s.memoizedState.cache), o.memoizedState.cache !== h && (o.flags |= 2048), Pr(xi), Vn(o), null;
                case 25:
                    return null;
                case 30:
                    return null;
            }
            throw Error(n(156, o.tag));
        }
        function gc(s, o) {
            switch(rp(o), o.tag){
                case 1:
                    return s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 3:
                    return Pr(xi), _t(), s = o.flags, (s & 65536) !== 0 && (s & 128) === 0 ? (o.flags = s & -65537 | 128, o) : null;
                case 26:
                case 27:
                case 5:
                    return on(o), null;
                case 13:
                    if (nr(o), s = o.memoizedState, s !== null && s.dehydrated !== null) {
                        if (o.alternate === null) throw Error(n(340));
                        tc();
                    }
                    return s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 19:
                    return me(li), null;
                case 4:
                    return _t(), null;
                case 10:
                    return Pr(o.type), null;
                case 22:
                case 23:
                    return nr(o), Ou(), s !== null && me(la), s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 24:
                    return Pr(xi), null;
                case 25:
                    return null;
                default:
                    return null;
            }
        }
        function vc(s, o) {
            switch(rp(o), o.tag){
                case 3:
                    Pr(xi), _t();
                    break;
                case 26:
                case 27:
                case 5:
                    on(o);
                    break;
                case 4:
                    _t();
                    break;
                case 13:
                    nr(o);
                    break;
                case 19:
                    me(li);
                    break;
                case 10:
                    Pr(o.type);
                    break;
                case 22:
                case 23:
                    nr(o), Ou(), s !== null && me(la);
                    break;
                case 24:
                    Pr(xi);
            }
        }
        function hl(s, o) {
            try {
                var h = o.updateQueue, m = h !== null ? h.lastEffect : null;
                if (m !== null) {
                    var S = m.next;
                    h = S;
                    do {
                        if ((h.tag & s) === s) {
                            m = void 0;
                            var A = h.create, B = h.inst;
                            m = A(), B.destroy = m;
                        }
                        h = h.next;
                    }while (h !== S);
                }
            } catch (V) {
                re(o, o.return, V);
            }
        }
        function Xs(s, o, h) {
            try {
                var m = o.updateQueue, S = m !== null ? m.lastEffect : null;
                if (S !== null) {
                    var A = S.next;
                    m = A;
                    do {
                        if ((m.tag & s) === s) {
                            var B = m.inst, V = B.destroy;
                            if (V !== void 0) {
                                B.destroy = void 0, S = o;
                                var ee = h, Me = V;
                                try {
                                    Me();
                                } catch (ze) {
                                    re(S, ee, ze);
                                }
                            }
                        }
                        m = m.next;
                    }while (m !== A);
                }
            } catch (ze) {
                re(o, o.return, ze);
            }
        }
        function dl(s) {
            var o = s.updateQueue;
            if (o !== null) {
                var h = s.stateNode;
                try {
                    gg(o, h);
                } catch (m) {
                    re(s, s.return, m);
                }
            }
        }
        function qr(s, o, h) {
            h.props = ir(s.type, s.memoizedProps), h.state = s.memoizedState;
            try {
                h.componentWillUnmount();
            } catch (m) {
                re(s, o, m);
            }
        }
        function pl(s, o) {
            try {
                var h = s.ref;
                if (h !== null) {
                    switch(s.tag){
                        case 26:
                        case 27:
                        case 5:
                            var m = s.stateNode;
                            break;
                        case 30:
                            m = s.stateNode;
                            break;
                        default:
                            m = s.stateNode;
                    }
                    typeof h == "function" ? s.refCleanup = h(m) : h.current = m;
                }
            } catch (S) {
                re(s, o, S);
            }
        }
        function ar(s, o) {
            var h = s.ref, m = s.refCleanup;
            if (h !== null) if (typeof m == "function") try {
                m();
            } catch (S) {
                re(s, o, S);
            } finally{
                s.refCleanup = null, s = s.alternate, s != null && (s.refCleanup = null);
            }
            else if (typeof h == "function") try {
                h(null);
            } catch (S) {
                re(s, o, S);
            }
            else h.current = null;
        }
        function yc(s) {
            var o = s.type, h = s.memoizedProps, m = s.stateNode;
            try {
                e: switch(o){
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        h.autoFocus && m.focus();
                        break e;
                    case "img":
                        h.src ? m.src = h.src : h.srcSet && (m.srcset = h.srcSet);
                }
            } catch (S) {
                re(s, s.return, S);
            }
        }
        function ku(s, o, h) {
            try {
                var m = s.stateNode;
                lw(m, s.type, h, o), m[Ei] = o;
            } catch (S) {
                re(s, s.return, S);
            }
        }
        function Xu(s) {
            return s.tag === 5 || s.tag === 3 || s.tag === 26 || s.tag === 27 && Tc(s.type) || s.tag === 4;
        }
        function No(s) {
            e: for(;;){
                for(; s.sibling === null;){
                    if (s.return === null || Xu(s.return)) return null;
                    s = s.return;
                }
                for(s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18;){
                    if (s.tag === 27 && Tc(s.type) || s.flags & 2 || s.child === null || s.tag === 4) continue e;
                    s.child.return = s, s = s.child;
                }
                if (!(s.flags & 2)) return s.stateNode;
            }
        }
        function Uo(s, o, h) {
            var m = s.tag;
            if (m === 5 || m === 6) s = s.stateNode, o ? (h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h).insertBefore(s, o) : (o = h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h, o.appendChild(s), h = h._reactRootContainer, h != null || o.onclick !== null || (o.onclick = r0));
            else if (m !== 4 && (m === 27 && Tc(s.type) && (h = s.stateNode, o = null), s = s.child, s !== null)) for(Uo(s, o, h), s = s.sibling; s !== null;)Uo(s, o, h), s = s.sibling;
        }
        function Lo(s, o, h) {
            var m = s.tag;
            if (m === 5 || m === 6) s = s.stateNode, o ? h.insertBefore(s, o) : h.appendChild(s);
            else if (m !== 4 && (m === 27 && Tc(s.type) && (h = s.stateNode), s = s.child, s !== null)) for(Lo(s, o, h), s = s.sibling; s !== null;)Lo(s, o, h), s = s.sibling;
        }
        function Oo(s) {
            var o = s.stateNode, h = s.memoizedProps;
            try {
                for(var m = s.type, S = o.attributes; S.length;)o.removeAttributeNode(S[0]);
                Ss(o, m, h), o[vi] = s, o[Ei] = h;
            } catch (A) {
                re(s, s.return, A);
            }
        }
        var rr = !1, kn = !1, _c = !1, js = typeof WeakSet == "function" ? WeakSet : Set, In = null;
        function Ri(s, o) {
            if (s = s.containerInfo, m_ = d0, s = Qd(s), yu(s)) {
                if ("selectionStart" in s) var h = {
                    start: s.selectionStart,
                    end: s.selectionEnd
                };
                else e: {
                    h = (h = s.ownerDocument) && h.defaultView || window;
                    var m = h.getSelection && h.getSelection();
                    if (m && m.rangeCount !== 0) {
                        h = m.anchorNode;
                        var S = m.anchorOffset, A = m.focusNode;
                        m = m.focusOffset;
                        try {
                            h.nodeType, A.nodeType;
                        } catch  {
                            h = null;
                            break e;
                        }
                        var B = 0, V = -1, ee = -1, Me = 0, ze = 0, ke = s, Te = null;
                        t: for(;;){
                            for(var Re; ke !== h || S !== 0 && ke.nodeType !== 3 || (V = B + S), ke !== A || m !== 0 && ke.nodeType !== 3 || (ee = B + m), ke.nodeType === 3 && (B += ke.nodeValue.length), (Re = ke.firstChild) !== null;)Te = ke, ke = Re;
                            for(;;){
                                if (ke === s) break t;
                                if (Te === h && ++Me === S && (V = B), Te === A && ++ze === m && (ee = B), (Re = ke.nextSibling) !== null) break;
                                ke = Te, Te = ke.parentNode;
                            }
                            ke = Re;
                        }
                        h = V === -1 || ee === -1 ? null : {
                            start: V,
                            end: ee
                        };
                    } else h = null;
                }
                h = h || {
                    start: 0,
                    end: 0
                };
            } else h = null;
            for(g_ = {
                focusedElem: s,
                selectionRange: h
            }, d0 = !1, In = o; In !== null;)if (o = In, s = o.child, (o.subtreeFlags & 1024) !== 0 && s !== null) s.return = o, In = s;
            else for(; In !== null;){
                switch(o = In, A = o.alternate, s = o.flags, o.tag){
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((s & 1024) !== 0 && A !== null) {
                            s = void 0, h = o, S = A.memoizedProps, A = A.memoizedState, m = h.stateNode;
                            try {
                                var Gt = ir(h.type, S, h.elementType === h.type);
                                s = m.getSnapshotBeforeUpdate(Gt, A), m.__reactInternalSnapshotBeforeUpdate = s;
                            } catch (Bt) {
                                re(h, h.return, Bt);
                            }
                        }
                        break;
                    case 3:
                        if ((s & 1024) !== 0) {
                            if (s = o.stateNode.containerInfo, h = s.nodeType, h === 9) __(s);
                            else if (h === 1) switch(s.nodeName){
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    __(s);
                                    break;
                                default:
                                    s.textContent = "";
                            }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((s & 1024) !== 0) throw Error(n(163));
                }
                if (s = o.sibling, s !== null) {
                    s.return = o.return, In = s;
                    break;
                }
                In = o.return;
            }
        }
        function Yr(s, o, h) {
            var m = h.flags;
            switch(h.tag){
                case 0:
                case 11:
                case 15:
                    _s(s, h), m & 4 && hl(5, h);
                    break;
                case 1:
                    if (_s(s, h), m & 4) if (s = h.stateNode, o === null) try {
                        s.componentDidMount();
                    } catch (B) {
                        re(h, h.return, B);
                    }
                    else {
                        var S = ir(h.type, o.memoizedProps);
                        o = o.memoizedState;
                        try {
                            s.componentDidUpdate(S, o, s.__reactInternalSnapshotBeforeUpdate);
                        } catch (B) {
                            re(h, h.return, B);
                        }
                    }
                    m & 64 && dl(h), m & 512 && pl(h, h.return);
                    break;
                case 3:
                    if (_s(s, h), m & 64 && (s = h.updateQueue, s !== null)) {
                        if (o = null, h.child !== null) switch(h.child.tag){
                            case 27:
                            case 5:
                                o = h.child.stateNode;
                                break;
                            case 1:
                                o = h.child.stateNode;
                        }
                        try {
                            gg(s, o);
                        } catch (B) {
                            re(h, h.return, B);
                        }
                    }
                    break;
                case 27:
                    o === null && m & 4 && Oo(h);
                case 26:
                case 5:
                    _s(s, h), o === null && m & 4 && yc(h), m & 512 && pl(h, h.return);
                    break;
                case 12:
                    _s(s, h);
                    break;
                case 13:
                    _s(s, h), m & 4 && zo(s, h), m & 64 && (s = h.memoizedState, s !== null && (s = s.dehydrated, s !== null && (h = Wn.bind(null, h), mw(s, h))));
                    break;
                case 22:
                    if (m = h.memoizedState !== null || rr, !m) {
                        o = o !== null && o.memoizedState !== null || kn, S = rr;
                        var A = kn;
                        rr = m, (kn = o) && !A ? or(s, h, (h.subtreeFlags & 8772) !== 0) : _s(s, h), rr = S, kn = A;
                    }
                    break;
                case 30:
                    break;
                default:
                    _s(s, h);
            }
        }
        function $t(s) {
            var o = s.alternate;
            o !== null && (s.alternate = null, $t(o)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (o = s.stateNode, o !== null && Un(o)), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
        }
        var Ut = null, _n = !1;
        function pa(s, o, h) {
            for(h = h.child; h !== null;)ml(s, o, h), h = h.sibling;
        }
        function ml(s, o, h) {
            if (Le && typeof Le.onCommitFiberUnmount == "function") try {
                Le.onCommitFiberUnmount(Ue, h);
            } catch  {}
            switch(h.tag){
                case 26:
                    kn || ar(h, o), pa(s, o, h), h.memoizedState ? h.memoizedState.count-- : h.stateNode && (h = h.stateNode, h.parentNode.removeChild(h));
                    break;
                case 27:
                    kn || ar(h, o);
                    var m = Ut, S = _n;
                    Tc(h.type) && (Ut = h.stateNode, _n = !1), pa(s, o, h), Hp(h.stateNode), Ut = m, _n = S;
                    break;
                case 5:
                    kn || ar(h, o);
                case 6:
                    if (m = Ut, S = _n, Ut = null, pa(s, o, h), Ut = m, _n = S, Ut !== null) if (_n) try {
                        (Ut.nodeType === 9 ? Ut.body : Ut.nodeName === "HTML" ? Ut.ownerDocument.body : Ut).removeChild(h.stateNode);
                    } catch (A) {
                        re(h, o, A);
                    }
                    else try {
                        Ut.removeChild(h.stateNode);
                    } catch (A) {
                        re(h, o, A);
                    }
                    break;
                case 18:
                    Ut !== null && (_n ? (s = Ut, Rb(s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, h.stateNode), Yp(s)) : Rb(Ut, h.stateNode));
                    break;
                case 4:
                    m = Ut, S = _n, Ut = h.stateNode.containerInfo, _n = !0, pa(s, o, h), Ut = m, _n = S;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    kn || Xs(2, h, o), kn || Xs(4, h, o), pa(s, o, h);
                    break;
                case 1:
                    kn || (ar(h, o), m = h.stateNode, typeof m.componentWillUnmount == "function" && qr(h, o, m)), pa(s, o, h);
                    break;
                case 21:
                    pa(s, o, h);
                    break;
                case 22:
                    kn = (m = kn) || h.memoizedState !== null, pa(s, o, h), kn = m;
                    break;
                default:
                    pa(s, o, h);
            }
        }
        function zo(s, o) {
            if (o.memoizedState === null && (s = o.alternate, s !== null && (s = s.memoizedState, s !== null && (s = s.dehydrated, s !== null)))) try {
                Yp(s);
            } catch (h) {
                re(o, o.return, h);
            }
        }
        function bh(s) {
            switch(s.tag){
                case 13:
                case 19:
                    var o = s.stateNode;
                    return o === null && (o = s.stateNode = new js), o;
                case 22:
                    return s = s.stateNode, o = s._retryCache, o === null && (o = s._retryCache = new js), o;
                default:
                    throw Error(n(435, s.tag));
            }
        }
        function gl(s, o) {
            var h = bh(s);
            o.forEach(function(m) {
                var S = Ft.bind(null, s, m);
                h.has(m) || (h.add(m), m.then(S, S));
            });
        }
        function Fi(s, o) {
            var h = o.deletions;
            if (h !== null) for(var m = 0; m < h.length; m++){
                var S = h[m], A = s, B = o, V = B;
                e: for(; V !== null;){
                    switch(V.tag){
                        case 27:
                            if (Tc(V.type)) {
                                Ut = V.stateNode, _n = !1;
                                break e;
                            }
                            break;
                        case 5:
                            Ut = V.stateNode, _n = !1;
                            break e;
                        case 3:
                        case 4:
                            Ut = V.stateNode.containerInfo, _n = !0;
                            break e;
                    }
                    V = V.return;
                }
                if (Ut === null) throw Error(n(160));
                ml(A, B, S), Ut = null, _n = !1, A = S.alternate, A !== null && (A.return = null), S.return = null;
            }
            if (o.subtreeFlags & 13878) for(o = o.child; o !== null;)Mh(o, s), o = o.sibling;
        }
        var Ba = null;
        function Mh(s, o) {
            var h = s.alternate, m = s.flags;
            switch(s.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    Fi(o, s), ni(s), m & 4 && (Xs(3, s, s.return), hl(3, s), Xs(5, s, s.return));
                    break;
                case 1:
                    Fi(o, s), ni(s), m & 512 && (kn || h === null || ar(h, h.return)), m & 64 && rr && (s = s.updateQueue, s !== null && (m = s.callbacks, m !== null && (h = s.shared.hiddenCallbacks, s.shared.hiddenCallbacks = h === null ? m : h.concat(m))));
                    break;
                case 26:
                    var S = Ba;
                    if (Fi(o, s), ni(s), m & 512 && (kn || h === null || ar(h, h.return)), m & 4) {
                        var A = h !== null ? h.memoizedState : null;
                        if (m = s.memoizedState, h === null) if (m === null) if (s.stateNode === null) {
                            e: {
                                m = s.type, h = s.memoizedProps, S = S.ownerDocument || S;
                                t: switch(m){
                                    case "title":
                                        A = S.getElementsByTagName("title")[0], (!A || A[Ea] || A[vi] || A.namespaceURI === "http://www.w3.org/2000/svg" || A.hasAttribute("itemprop")) && (A = S.createElement(m), S.head.insertBefore(A, S.querySelector("head > title"))), Ss(A, m, h), A[vi] = s, yi(A), m = A;
                                        break e;
                                    case "link":
                                        var B = Bb("link", "href", S).get(m + (h.href || ""));
                                        if (B) {
                                            for(var V = 0; V < B.length; V++)if (A = B[V], A.getAttribute("href") === (h.href == null || h.href === "" ? null : h.href) && A.getAttribute("rel") === (h.rel == null ? null : h.rel) && A.getAttribute("title") === (h.title == null ? null : h.title) && A.getAttribute("crossorigin") === (h.crossOrigin == null ? null : h.crossOrigin)) {
                                                B.splice(V, 1);
                                                break t;
                                            }
                                        }
                                        A = S.createElement(m), Ss(A, m, h), S.head.appendChild(A);
                                        break;
                                    case "meta":
                                        if (B = Bb("meta", "content", S).get(m + (h.content || ""))) {
                                            for(V = 0; V < B.length; V++)if (A = B[V], A.getAttribute("content") === (h.content == null ? null : "" + h.content) && A.getAttribute("name") === (h.name == null ? null : h.name) && A.getAttribute("property") === (h.property == null ? null : h.property) && A.getAttribute("http-equiv") === (h.httpEquiv == null ? null : h.httpEquiv) && A.getAttribute("charset") === (h.charSet == null ? null : h.charSet)) {
                                                B.splice(V, 1);
                                                break t;
                                            }
                                        }
                                        A = S.createElement(m), Ss(A, m, h), S.head.appendChild(A);
                                        break;
                                    default:
                                        throw Error(n(468, m));
                                }
                                A[vi] = s, yi(A), m = A;
                            }
                            s.stateNode = m;
                        } else Ib(S, s.type, s.stateNode);
                        else s.stateNode = zb(S, m, s.memoizedProps);
                        else A !== m ? (A === null ? h.stateNode !== null && (h = h.stateNode, h.parentNode.removeChild(h)) : A.count--, m === null ? Ib(S, s.type, s.stateNode) : zb(S, m, s.memoizedProps)) : m === null && s.stateNode !== null && ku(s, s.memoizedProps, h.memoizedProps);
                    }
                    break;
                case 27:
                    Fi(o, s), ni(s), m & 512 && (kn || h === null || ar(h, h.return)), h !== null && m & 4 && ku(s, s.memoizedProps, h.memoizedProps);
                    break;
                case 5:
                    if (Fi(o, s), ni(s), m & 512 && (kn || h === null || ar(h, h.return)), s.flags & 32) {
                        S = s.stateNode;
                        try {
                            hs(S, "");
                        } catch (Re) {
                            re(s, s.return, Re);
                        }
                    }
                    m & 4 && s.stateNode != null && (S = s.memoizedProps, ku(s, S, h !== null ? h.memoizedProps : S)), m & 1024 && (_c = !0);
                    break;
                case 6:
                    if (Fi(o, s), ni(s), m & 4) {
                        if (s.stateNode === null) throw Error(n(162));
                        m = s.memoizedProps, h = s.stateNode;
                        try {
                            h.nodeValue = m;
                        } catch (Re) {
                            re(s, s.return, Re);
                        }
                    }
                    break;
                case 3:
                    if (u0 = null, S = Ba, Ba = l0(o.containerInfo), Fi(o, s), Ba = S, ni(s), m & 4 && h !== null && h.memoizedState.isDehydrated) try {
                        Yp(o.containerInfo);
                    } catch (Re) {
                        re(s, s.return, Re);
                    }
                    _c && (_c = !1, Bo(s));
                    break;
                case 4:
                    m = Ba, Ba = l0(s.stateNode.containerInfo), Fi(o, s), ni(s), Ba = m;
                    break;
                case 12:
                    Fi(o, s), ni(s);
                    break;
                case 13:
                    Fi(o, s), ni(s), s.child.flags & 8192 && s.memoizedState !== null != (h !== null && h.memoizedState !== null) && (On = We()), m & 4 && (m = s.updateQueue, m !== null && (s.updateQueue = null, gl(s, m)));
                    break;
                case 22:
                    S = s.memoizedState !== null;
                    var ee = h !== null && h.memoizedState !== null, Me = rr, ze = kn;
                    if (rr = Me || S, kn = ze || ee, Fi(o, s), kn = ze, rr = Me, ni(s), m & 8192) e: for(o = s.stateNode, o._visibility = S ? o._visibility & -2 : o._visibility | 1, S && (h === null || ee || rr || kn || qs(s)), h = null, o = s;;){
                        if (o.tag === 5 || o.tag === 26) {
                            if (h === null) {
                                ee = h = o;
                                try {
                                    if (A = ee.stateNode, S) B = A.style, typeof B.setProperty == "function" ? B.setProperty("display", "none", "important") : B.display = "none";
                                    else {
                                        V = ee.stateNode;
                                        var ke = ee.memoizedProps.style, Te = ke != null && ke.hasOwnProperty("display") ? ke.display : null;
                                        V.style.display = Te == null || typeof Te == "boolean" ? "" : ("" + Te).trim();
                                    }
                                } catch (Re) {
                                    re(ee, ee.return, Re);
                                }
                            }
                        } else if (o.tag === 6) {
                            if (h === null) {
                                ee = o;
                                try {
                                    ee.stateNode.nodeValue = S ? "" : ee.memoizedProps;
                                } catch (Re) {
                                    re(ee, ee.return, Re);
                                }
                            }
                        } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === s) && o.child !== null) {
                            o.child.return = o, o = o.child;
                            continue;
                        }
                        if (o === s) break e;
                        for(; o.sibling === null;){
                            if (o.return === null || o.return === s) break e;
                            h === o && (h = null), o = o.return;
                        }
                        h === o && (h = null), o.sibling.return = o.return, o = o.sibling;
                    }
                    m & 4 && (m = s.updateQueue, m !== null && (h = m.retryQueue, h !== null && (m.retryQueue = null, gl(s, h))));
                    break;
                case 19:
                    Fi(o, s), ni(s), m & 4 && (m = s.updateQueue, m !== null && (s.updateQueue = null, gl(s, m)));
                    break;
                case 30:
                    break;
                case 21:
                    break;
                default:
                    Fi(o, s), ni(s);
            }
        }
        function ni(s) {
            var o = s.flags;
            if (o & 2) {
                try {
                    for(var h, m = s.return; m !== null;){
                        if (Xu(m)) {
                            h = m;
                            break;
                        }
                        m = m.return;
                    }
                    if (h == null) throw Error(n(160));
                    switch(h.tag){
                        case 27:
                            var S = h.stateNode, A = No(s);
                            Lo(s, A, S);
                            break;
                        case 5:
                            var B = h.stateNode;
                            h.flags & 32 && (hs(B, ""), h.flags &= -33);
                            var V = No(s);
                            Lo(s, V, B);
                            break;
                        case 3:
                        case 4:
                            var ee = h.stateNode.containerInfo, Me = No(s);
                            Uo(s, Me, ee);
                            break;
                        default:
                            throw Error(n(161));
                    }
                } catch (ze) {
                    re(s, s.return, ze);
                }
                s.flags &= -3;
            }
            o & 4096 && (s.flags &= -4097);
        }
        function Bo(s) {
            if (s.subtreeFlags & 1024) for(s = s.child; s !== null;){
                var o = s;
                Bo(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), s = s.sibling;
            }
        }
        function _s(s, o) {
            if (o.subtreeFlags & 8772) for(o = o.child; o !== null;)Yr(s, o.alternate, o), o = o.sibling;
        }
        function qs(s) {
            for(s = s.child; s !== null;){
                var o = s;
                switch(o.tag){
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        Xs(4, o, o.return), qs(o);
                        break;
                    case 1:
                        ar(o, o.return);
                        var h = o.stateNode;
                        typeof h.componentWillUnmount == "function" && qr(o, o.return, h), qs(o);
                        break;
                    case 27:
                        Hp(o.stateNode);
                    case 26:
                    case 5:
                        ar(o, o.return), qs(o);
                        break;
                    case 22:
                        o.memoizedState === null && qs(o);
                        break;
                    case 30:
                        qs(o);
                        break;
                    default:
                        qs(o);
                }
                s = s.sibling;
            }
        }
        function or(s, o, h) {
            for(h = h && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null;){
                var m = o.alternate, S = s, A = o, B = A.flags;
                switch(A.tag){
                    case 0:
                    case 11:
                    case 15:
                        or(S, A, h), hl(4, A);
                        break;
                    case 1:
                        if (or(S, A, h), m = A, S = m.stateNode, typeof S.componentDidMount == "function") try {
                            S.componentDidMount();
                        } catch (Me) {
                            re(m, m.return, Me);
                        }
                        if (m = A, S = m.updateQueue, S !== null) {
                            var V = m.stateNode;
                            try {
                                var ee = S.shared.hiddenCallbacks;
                                if (ee !== null) for(S.shared.hiddenCallbacks = null, S = 0; S < ee.length; S++)lc(ee[S], V);
                            } catch (Me) {
                                re(m, m.return, Me);
                            }
                        }
                        h && B & 64 && dl(A), pl(A, A.return);
                        break;
                    case 27:
                        Oo(A);
                    case 26:
                    case 5:
                        or(S, A, h), h && m === null && B & 4 && yc(A), pl(A, A.return);
                        break;
                    case 12:
                        or(S, A, h);
                        break;
                    case 13:
                        or(S, A, h), h && B & 4 && zo(S, A);
                        break;
                    case 22:
                        A.memoizedState === null && or(S, A, h), pl(A, A.return);
                        break;
                    case 30:
                        break;
                    default:
                        or(S, A, h);
                }
                o = o.sibling;
            }
        }
        function Eh(s, o) {
            var h = null;
            s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool), s = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (s = o.memoizedState.cachePool.pool), s !== h && (s != null && s.refCount++, h != null && nc(h));
        }
        function Th(s, o) {
            s = null, o.alternate !== null && (s = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== s && (o.refCount++, s != null && nc(s));
        }
        function Pn(s, o, h, m) {
            if (o.subtreeFlags & 10256) for(o = o.child; o !== null;)Ah(s, o, h, m), o = o.sibling;
        }
        function Ah(s, o, h, m) {
            var S = o.flags;
            switch(o.tag){
                case 0:
                case 11:
                case 15:
                    Pn(s, o, h, m), S & 2048 && hl(9, o);
                    break;
                case 1:
                    Pn(s, o, h, m);
                    break;
                case 3:
                    Pn(s, o, h, m), S & 2048 && (s = null, o.alternate !== null && (s = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== s && (o.refCount++, s != null && nc(s)));
                    break;
                case 12:
                    if (S & 2048) {
                        Pn(s, o, h, m), s = o.stateNode;
                        try {
                            var A = o.memoizedProps, B = A.id, V = A.onPostCommit;
                            typeof V == "function" && V(B, o.alternate === null ? "mount" : "update", s.passiveEffectDuration, -0);
                        } catch (ee) {
                            re(o, o.return, ee);
                        }
                    } else Pn(s, o, h, m);
                    break;
                case 13:
                    Pn(s, o, h, m);
                    break;
                case 23:
                    break;
                case 22:
                    A = o.stateNode, B = o.alternate, o.memoizedState !== null ? A._visibility & 2 ? Pn(s, o, h, m) : Ia(s, o) : A._visibility & 2 ? Pn(s, o, h, m) : (A._visibility |= 2, Wr(s, o, h, m, (o.subtreeFlags & 10256) !== 0)), S & 2048 && Eh(B, o);
                    break;
                case 24:
                    Pn(s, o, h, m), S & 2048 && Th(o.alternate, o);
                    break;
                default:
                    Pn(s, o, h, m);
            }
        }
        function Wr(s, o, h, m, S) {
            for(S = S && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null;){
                var A = s, B = o, V = h, ee = m, Me = B.flags;
                switch(B.tag){
                    case 0:
                    case 11:
                    case 15:
                        Wr(A, B, V, ee, S), hl(8, B);
                        break;
                    case 23:
                        break;
                    case 22:
                        var ze = B.stateNode;
                        B.memoizedState !== null ? ze._visibility & 2 ? Wr(A, B, V, ee, S) : Ia(A, B) : (ze._visibility |= 2, Wr(A, B, V, ee, S)), S && Me & 2048 && Eh(B.alternate, B);
                        break;
                    case 24:
                        Wr(A, B, V, ee, S), S && Me & 2048 && Th(B.alternate, B);
                        break;
                    default:
                        Wr(A, B, V, ee, S);
                }
                o = o.sibling;
            }
        }
        function Ia(s, o) {
            if (o.subtreeFlags & 10256) for(o = o.child; o !== null;){
                var h = s, m = o, S = m.flags;
                switch(m.tag){
                    case 22:
                        Ia(h, m), S & 2048 && Eh(m.alternate, m);
                        break;
                    case 24:
                        Ia(h, m), S & 2048 && Th(m.alternate, m);
                        break;
                    default:
                        Ia(h, m);
                }
                o = o.sibling;
            }
        }
        var Ys = 8192;
        function xc(s) {
            if (s.subtreeFlags & Ys) for(s = s.child; s !== null;)n0(s), s = s.sibling;
        }
        function n0(s) {
            switch(s.tag){
                case 26:
                    xc(s), s.flags & Ys && s.memoizedState !== null && Rw(Ba, s.memoizedState, s.memoizedProps);
                    break;
                case 5:
                    xc(s);
                    break;
                case 3:
                case 4:
                    var o = Ba;
                    Ba = l0(s.stateNode.containerInfo), xc(s), Ba = o;
                    break;
                case 22:
                    s.memoizedState === null && (o = s.alternate, o !== null && o.memoizedState !== null ? (o = Ys, Ys = 16777216, xc(s), Ys = o) : xc(s));
                    break;
                default:
                    xc(s);
            }
        }
        function i0(s) {
            var o = s.alternate;
            if (o !== null && (s = o.child, s !== null)) {
                o.child = null;
                do o = s.sibling, s.sibling = null, s = o;
                while (s !== null);
            }
        }
        function Xn(s) {
            var o = s.deletions;
            if ((s.flags & 16) !== 0) {
                if (o !== null) for(var h = 0; h < o.length; h++){
                    var m = o[h];
                    In = m, cr(m, s);
                }
                i0(s);
            }
            if (s.subtreeFlags & 10256) for(s = s.child; s !== null;)Op(s), s = s.sibling;
        }
        function Op(s) {
            switch(s.tag){
                case 0:
                case 11:
                case 15:
                    Xn(s), s.flags & 2048 && Xs(9, s, s.return);
                    break;
                case 3:
                    Xn(s);
                    break;
                case 12:
                    Xn(s);
                    break;
                case 22:
                    var o = s.stateNode;
                    s.memoizedState !== null && o._visibility & 2 && (s.return === null || s.return.tag !== 13) ? (o._visibility &= -3, lr(s)) : Xn(s);
                    break;
                default:
                    Xn(s);
            }
        }
        function lr(s) {
            var o = s.deletions;
            if ((s.flags & 16) !== 0) {
                if (o !== null) for(var h = 0; h < o.length; h++){
                    var m = o[h];
                    In = m, cr(m, s);
                }
                i0(s);
            }
            for(s = s.child; s !== null;){
                switch(o = s, o.tag){
                    case 0:
                    case 11:
                    case 15:
                        Xs(8, o, o.return), lr(o);
                        break;
                    case 22:
                        h = o.stateNode, h._visibility & 2 && (h._visibility &= -3, lr(o));
                        break;
                    default:
                        lr(o);
                }
                s = s.sibling;
            }
        }
        function cr(s, o) {
            for(; In !== null;){
                var h = In;
                switch(h.tag){
                    case 0:
                    case 11:
                    case 15:
                        Xs(8, h, o);
                        break;
                    case 23:
                    case 22:
                        if (h.memoizedState !== null && h.memoizedState.cachePool !== null) {
                            var m = h.memoizedState.cachePool.pool;
                            m != null && m.refCount++;
                        }
                        break;
                    case 24:
                        nc(h.memoizedState.cache);
                }
                if (m = h.child, m !== null) m.return = h, In = m;
                else e: for(h = s; In !== null;){
                    m = In;
                    var S = m.sibling, A = m.return;
                    if ($t(m), m === h) {
                        In = null;
                        break e;
                    }
                    if (S !== null) {
                        S.return = A, In = S;
                        break e;
                    }
                    In = A;
                }
            }
        }
        var ii = {
            getCacheForType: function(s) {
                var o = ti(xi), h = o.data.get(s);
                return h === void 0 && (h = s(), o.data.set(s, h)), h;
            }
        }, zp = typeof WeakMap == "function" ? WeakMap : Map, wn = 0, kt = null, an = null, Ct = 0, Qt = 0, $n = null, Ws = !1, Sc = !1, bc = !1, ma = 0, Yn = 0, Pa = 0, ur = 0, vl = 0, ga = 0, xn = 0, Rn = null, Ot = null, cn = !1, On = 0, as = 1 / 0, va = null, Zs = null, Ci = 0, rs = null, Hn = null, Ks = 0, Zr = 0, ju = null, Qs = null, fr = 0, yl = null;
        function si() {
            if ((wn & 2) !== 0 && Ct !== 0) return Ct & -Ct;
            if (H.T !== null) {
                var s = jt;
                return s !== 0 ? s : l_();
            }
            return Zt();
        }
        function wh() {
            ga === 0 && (ga = (Ct & 536870912) === 0 || bn ? te() : 536870912);
            var s = Bn.current;
            return s !== null && (s.flags |= 32), ga;
        }
        function xs(s, o, h) {
            (s === kt && (Qt === 2 || Qt === 9) || s.cancelPendingCommit !== null) && (Po(s, 0), Ha(s, Ct, ga, !1)), rt(s, h), ((wn & 2) === 0 || s !== kt) && (s === kt && ((wn & 2) === 0 && (ur |= h), Yn === 4 && Ha(s, Ct, ga, !1)), Go(s));
        }
        function Mc(s, o, h) {
            if ((wn & 6) !== 0) throw Error(n(327));
            var m = !h && (o & 124) === 0 && (o & s.expiredLanes) === 0 || xe(s, o), S = m ? b(s, o) : u(s, o, !0), A = m;
            do {
                if (S === 0) {
                    Sc && !m && Ha(s, o, 0, !1);
                    break;
                } else {
                    if (h = s.current.alternate, A && !Io(h)) {
                        S = u(s, o, !1), A = !1;
                        continue;
                    }
                    if (S === 2) {
                        if (A = o, s.errorRecoveryDisabledLanes & A) var B = 0;
                        else B = s.pendingLanes & -536870913, B = B !== 0 ? B : B & 536870912 ? 536870912 : 0;
                        if (B !== 0) {
                            o = B;
                            e: {
                                var V = s;
                                S = Rn;
                                var ee = V.current.memoizedState.isDehydrated;
                                if (ee && (Po(V, B).flags |= 256), B = u(V, B, !1), B !== 2) {
                                    if (bc && !ee) {
                                        V.errorRecoveryDisabledLanes |= A, ur |= A, S = 4;
                                        break e;
                                    }
                                    A = Ot, Ot = S, A !== null && (Ot === null ? Ot = A : Ot.push.apply(Ot, A));
                                }
                                S = B;
                            }
                            if (A = !1, S !== 2) continue;
                        }
                    }
                    if (S === 1) {
                        Po(s, 0), Ha(s, o, 0, !0);
                        break;
                    }
                    e: {
                        switch(m = s, A = S, A){
                            case 0:
                            case 1:
                                throw Error(n(345));
                            case 4:
                                if ((o & 4194048) !== o) break;
                            case 6:
                                Ha(m, o, ga, !Ws);
                                break e;
                            case 2:
                                Ot = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(n(329));
                        }
                        if ((o & 62914560) === o && (S = On + 300 - We(), 10 < S)) {
                            if (Ha(m, o, ga, !Ws), ie(m, 0, !0) !== 0) break e;
                            m.timeoutHandle = Ab(qu.bind(null, m, h, Ot, va, cn, o, ga, ur, xn, Ws, A, 2, -0, 0), S);
                            break e;
                        }
                        qu(m, h, Ot, va, cn, o, ga, ur, xn, Ws, A, 0, -0, 0);
                    }
                }
                break;
            }while (!0);
            Go(s);
        }
        function qu(s, o, h, m, S, A, B, V, ee, Me, ze, ke, Te, Re) {
            if (s.timeoutHandle = -1, ke = o.subtreeFlags, (ke & 8192 || (ke & 16785408) === 16785408) && (Vp = {
                stylesheets: null,
                count: 0,
                unsuspend: ww
            }, n0(o), ke = Cw(), ke !== null)) {
                s.cancelPendingCommit = ke($e.bind(null, s, o, A, h, m, S, B, V, ee, ze, 1, Te, Re)), Ha(s, A, B, !Me);
                return;
            }
            $e(s, o, A, h, m, S, B, V, ee);
        }
        function Io(s) {
            for(var o = s;;){
                var h = o.tag;
                if ((h === 0 || h === 11 || h === 15) && o.flags & 16384 && (h = o.updateQueue, h !== null && (h = h.stores, h !== null))) for(var m = 0; m < h.length; m++){
                    var S = h[m], A = S.getSnapshot;
                    S = S.value;
                    try {
                        if (!Ts(A(), S)) return !1;
                    } catch  {
                        return !1;
                    }
                }
                if (h = o.child, o.subtreeFlags & 16384 && h !== null) h.return = o, o = h;
                else {
                    if (o === s) break;
                    for(; o.sibling === null;){
                        if (o.return === null || o.return === s) return !0;
                        o = o.return;
                    }
                    o.sibling.return = o.return, o = o.sibling;
                }
            }
            return !0;
        }
        function Ha(s, o, h, m) {
            o &= ~vl, o &= ~ur, s.suspendedLanes |= o, s.pingedLanes &= ~o, m && (s.warmLanes |= o), m = s.expirationTimes;
            for(var S = o; 0 < S;){
                var A = 31 - lt(S), B = 1 << A;
                m[A] = -1, S &= ~B;
            }
            h !== 0 && Fe(s, h, o);
        }
        function hr() {
            return (wn & 6) === 0 ? (Bp(0), !1) : !0;
        }
        function _l() {
            if (an !== null) {
                if (Qt === 0) var s = an.return;
                else s = an, Ir = So = null, vp(s), il = null, Pu = 0, s = an;
                for(; s !== null;)vc(s.alternate, s), s = s.return;
                an = null;
            }
        }
        function Po(s, o) {
            var h = s.timeoutHandle;
            h !== -1 && (s.timeoutHandle = -1, uw(h)), h = s.cancelPendingCommit, h !== null && (s.cancelPendingCommit = null, h()), _l(), kt = s, an = h = ri(s.current, null), Ct = o, Qt = 0, $n = null, Ws = !1, Sc = xe(s, o), bc = !1, xn = ga = vl = ur = Pa = Yn = 0, Ot = Rn = null, cn = !1, (o & 8) !== 0 && (o |= o & 32);
            var m = s.entangledLanes;
            if (m !== 0) for(s = s.entanglements, m &= o; 0 < m;){
                var S = 31 - lt(m), A = 1 << S;
                o |= s[S], m &= ~A;
            }
            return ma = o, Su(), h;
        }
        function Rh(s, o) {
            qt = null, H.H = Iu, o === Nu || o === Da ? (o = hp(), Qt = 3) : o === fp ? (o = hp(), Qt = 4) : Qt = o === t0 ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, $n = o, an === null && (Yn = 1, _h(s, Wi(o, s.current)));
        }
        function Ec() {
            var s = H.H;
            return H.H = Iu, s === null ? Iu : s;
        }
        function Ch() {
            var s = H.A;
            return H.A = ii, s;
        }
        function c() {
            Yn = 4, Ws || (Ct & 4194048) !== Ct && Bn.current !== null || (Sc = !0), (Pa & 134217727) === 0 && (ur & 134217727) === 0 || kt === null || Ha(kt, Ct, ga, !1);
        }
        function u(s, o, h) {
            var m = wn;
            wn |= 2;
            var S = Ec(), A = Ch();
            (kt !== s || Ct !== o) && (va = null, Po(s, o)), o = !1;
            var B = Yn;
            e: do try {
                if (Qt !== 0 && an !== null) {
                    var V = an, ee = $n;
                    switch(Qt){
                        case 8:
                            _l(), B = 6;
                            break e;
                        case 3:
                        case 2:
                        case 9:
                        case 6:
                            Bn.current === null && (o = !0);
                            var Me = Qt;
                            if (Qt = 0, $n = null, ne(s, V, ee, Me), h && Sc) {
                                B = 0;
                                break e;
                            }
                            break;
                        default:
                            Me = Qt, Qt = 0, $n = null, ne(s, V, ee, Me);
                    }
                }
                v(), B = Yn;
                break;
            } catch (ze) {
                Rh(s, ze);
            }
            while (!0);
            return o && s.shellSuspendCounter++, Ir = So = null, wn = m, H.H = S, H.A = A, an === null && (kt = null, Ct = 0, Su()), B;
        }
        function v() {
            for(; an !== null;)U(an);
        }
        function b(s, o) {
            var h = wn;
            wn |= 2;
            var m = Ec(), S = Ch();
            kt !== s || Ct !== o ? (va = null, as = We() + 500, Po(s, o)) : Sc = xe(s, o);
            e: do try {
                if (Qt !== 0 && an !== null) {
                    o = an;
                    var A = $n;
                    t: switch(Qt){
                        case 1:
                            Qt = 0, $n = null, ne(s, o, A, 1);
                            break;
                        case 2:
                        case 9:
                            if (sh(A)) {
                                Qt = 0, $n = null, j(o);
                                break;
                            }
                            o = function() {
                                Qt !== 2 && Qt !== 9 || kt !== s || (Qt = 7), Go(s);
                            }, A.then(o, o);
                            break e;
                        case 3:
                            Qt = 7;
                            break e;
                        case 4:
                            Qt = 5;
                            break e;
                        case 7:
                            sh(A) ? (Qt = 0, $n = null, j(o)) : (Qt = 0, $n = null, ne(s, o, A, 7));
                            break;
                        case 5:
                            var B = null;
                            switch(an.tag){
                                case 26:
                                    B = an.memoizedState;
                                case 5:
                                case 27:
                                    var V = an;
                                    if (!B || Pb(B)) {
                                        Qt = 0, $n = null;
                                        var ee = V.sibling;
                                        if (ee !== null) an = ee;
                                        else {
                                            var Me = V.return;
                                            Me !== null ? (an = Me, ye(Me)) : an = null;
                                        }
                                        break t;
                                    }
                            }
                            Qt = 0, $n = null, ne(s, o, A, 5);
                            break;
                        case 6:
                            Qt = 0, $n = null, ne(s, o, A, 6);
                            break;
                        case 8:
                            _l(), Yn = 6;
                            break e;
                        default:
                            throw Error(n(462));
                    }
                }
                w();
                break;
            } catch (ze) {
                Rh(s, ze);
            }
            while (!0);
            return Ir = So = null, H.H = m, H.A = S, wn = h, an !== null ? 0 : (kt = null, Ct = 0, Su(), Yn);
        }
        function w() {
            for(; an !== null && !et();)U(an);
        }
        function U(s) {
            var o = ul(s.alternate, s, ma);
            s.memoizedProps = s.pendingProps, o === null ? ye(s) : an = o;
        }
        function j(s) {
            var o = s, h = o.alternate;
            switch(o.tag){
                case 15:
                case 0:
                    o = Vs(h, o, o.pendingProps, o.type, void 0, Ct);
                    break;
                case 11:
                    o = Vs(h, o, o.pendingProps, o.type.render, o.ref, Ct);
                    break;
                case 5:
                    vp(o);
                default:
                    vc(h, o), o = an = sp(o, ma), o = ul(h, o, ma);
            }
            s.memoizedProps = s.pendingProps, o === null ? ye(s) : an = o;
        }
        function ne(s, o, h, m) {
            Ir = So = null, vp(o), il = null, Pu = 0;
            var S = o.return;
            try {
                if (r_(s, S, o, h, Ct)) {
                    Yn = 1, _h(s, Wi(h, s.current)), an = null;
                    return;
                }
            } catch (A) {
                if (S !== null) throw an = S, A;
                Yn = 1, _h(s, Wi(h, s.current)), an = null;
                return;
            }
            o.flags & 32768 ? (bn || m === 1 ? s = !0 : Sc || (Ct & 536870912) !== 0 ? s = !1 : (Ws = s = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = Bn.current, m !== null && m.tag === 13 && (m.flags |= 16384))), Oe(o, s)) : ye(o);
        }
        function ye(s) {
            var o = s;
            do {
                if ((o.flags & 32768) !== 0) {
                    Oe(o, Ws);
                    return;
                }
                s = o.return;
                var h = Lp(o.alternate, o, ma);
                if (h !== null) {
                    an = h;
                    return;
                }
                if (o = o.sibling, o !== null) {
                    an = o;
                    return;
                }
                an = o = s;
            }while (o !== null);
            Yn === 0 && (Yn = 5);
        }
        function Oe(s, o) {
            do {
                var h = gc(s.alternate, s);
                if (h !== null) {
                    h.flags &= 32767, an = h;
                    return;
                }
                if (h = s.return, h !== null && (h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null), !o && (s = s.sibling, s !== null)) {
                    an = s;
                    return;
                }
                an = s = h;
            }while (s !== null);
            Yn = 6, an = null;
        }
        function $e(s, o, h, m, S, A, B, V, ee) {
            s.cancelPendingCommit = null;
            do Ho();
            while (Ci !== 0);
            if ((wn & 6) !== 0) throw Error(n(327));
            if (o !== null) {
                if (o === s.current) throw Error(n(177));
                if (A = o.lanes | o.childLanes, A |= Zf, Ke(s, h, A, B, V, ee), s === kt && (an = kt = null, Ct = 0), Hn = o, rs = s, Ks = h, Zr = A, ju = S, Qs = m, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (s.callbackNode = null, s.callbackPriority = 0, Mn(ot, function() {
                    return Fo(), null;
                })) : (s.callbackNode = null, s.callbackPriority = 0), m = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || m) {
                    m = H.T, H.T = null, S = K.p, K.p = 2, B = wn, wn |= 4;
                    try {
                        Ri(s, o, h);
                    } finally{
                        wn = B, K.p = S, H.T = m;
                    }
                }
                Ci = 1, ft(), gt(), Xt();
            }
        }
        function ft() {
            if (Ci === 1) {
                Ci = 0;
                var s = rs, o = Hn, h = (o.flags & 13878) !== 0;
                if ((o.subtreeFlags & 13878) !== 0 || h) {
                    h = H.T, H.T = null;
                    var m = K.p;
                    K.p = 2;
                    var S = wn;
                    wn |= 4;
                    try {
                        Mh(o, s);
                        var A = g_, B = Qd(s.containerInfo), V = A.focusedElem, ee = A.selectionRange;
                        if (B !== V && V && V.ownerDocument && Kd(V.ownerDocument.documentElement, V)) {
                            if (ee !== null && yu(V)) {
                                var Me = ee.start, ze = ee.end;
                                if (ze === void 0 && (ze = Me), "selectionStart" in V) V.selectionStart = Me, V.selectionEnd = Math.min(ze, V.value.length);
                                else {
                                    var ke = V.ownerDocument || document, Te = ke && ke.defaultView || window;
                                    if (Te.getSelection) {
                                        var Re = Te.getSelection(), Gt = V.textContent.length, Bt = Math.min(ee.start, Gt), qn = ee.end === void 0 ? Bt : Math.min(ee.end, Gt);
                                        !Re.extend && Bt > qn && (B = qn, qn = Bt, Bt = B);
                                        var de = Zd(V, Bt), le = Zd(V, qn);
                                        if (de && le && (Re.rangeCount !== 1 || Re.anchorNode !== de.node || Re.anchorOffset !== de.offset || Re.focusNode !== le.node || Re.focusOffset !== le.offset)) {
                                            var be = ke.createRange();
                                            be.setStart(de.node, de.offset), Re.removeAllRanges(), Bt > qn ? (Re.addRange(be), Re.extend(le.node, le.offset)) : (be.setEnd(le.node, le.offset), Re.addRange(be));
                                        }
                                    }
                                }
                            }
                            for(ke = [], Re = V; Re = Re.parentNode;)Re.nodeType === 1 && ke.push({
                                element: Re,
                                left: Re.scrollLeft,
                                top: Re.scrollTop
                            });
                            for(typeof V.focus == "function" && V.focus(), V = 0; V < ke.length; V++){
                                var Ge = ke[V];
                                Ge.element.scrollLeft = Ge.left, Ge.element.scrollTop = Ge.top;
                            }
                        }
                        d0 = !!m_, g_ = m_ = null;
                    } finally{
                        wn = S, K.p = m, H.T = h;
                    }
                }
                s.current = o, Ci = 2;
            }
        }
        function gt() {
            if (Ci === 2) {
                Ci = 0;
                var s = rs, o = Hn, h = (o.flags & 8772) !== 0;
                if ((o.subtreeFlags & 8772) !== 0 || h) {
                    h = H.T, H.T = null;
                    var m = K.p;
                    K.p = 2;
                    var S = wn;
                    wn |= 4;
                    try {
                        Yr(s, o.alternate, o);
                    } finally{
                        wn = S, K.p = m, H.T = h;
                    }
                }
                Ci = 3;
            }
        }
        function Xt() {
            if (Ci === 4 || Ci === 3) {
                Ci = 0, Ye();
                var s = rs, o = Hn, h = Ks, m = Qs;
                (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? Ci = 5 : (Ci = 0, Hn = rs = null, Js(s, s.pendingLanes));
                var S = s.pendingLanes;
                if (S === 0 && (Zs = null), tn(h), o = o.stateNode, Le && typeof Le.onCommitFiberRoot == "function") try {
                    Le.onCommitFiberRoot(Ue, o, void 0, (o.current.flags & 128) === 128);
                } catch  {}
                if (m !== null) {
                    o = H.T, S = K.p, K.p = 2, H.T = null;
                    try {
                        for(var A = s.onRecoverableError, B = 0; B < m.length; B++){
                            var V = m[B];
                            A(V.value, {
                                componentStack: V.stack
                            });
                        }
                    } finally{
                        H.T = o, K.p = S;
                    }
                }
                (Ks & 3) !== 0 && Ho(), Go(s), S = s.pendingLanes, (h & 4194090) !== 0 && (S & 42) !== 0 ? s === yl ? fr++ : (fr = 0, yl = s) : fr = 0, Bp(0);
            }
        }
        function Js(s, o) {
            (s.pooledCacheLanes &= o) === 0 && (o = s.pooledCache, o != null && (s.pooledCache = null, nc(o)));
        }
        function Ho(s) {
            return ft(), gt(), Xt(), Fo();
        }
        function Fo() {
            if (Ci !== 5) return !1;
            var s = rs, o = Zr;
            Zr = 0;
            var h = tn(Ks), m = H.T, S = K.p;
            try {
                K.p = 32 > h ? 32 : h, H.T = null, h = ju, ju = null;
                var A = rs, B = Ks;
                if (Ci = 0, Hn = rs = null, Ks = 0, (wn & 6) !== 0) throw Error(n(331));
                var V = wn;
                if (wn |= 4, Op(A.current), Ah(A, A.current, B, h), wn = V, Bp(0, !1), Le && typeof Le.onPostCommitFiberRoot == "function") try {
                    Le.onPostCommitFiberRoot(Ue, A);
                } catch  {}
                return !0;
            } finally{
                K.p = S, H.T = m, Js(s, o);
            }
        }
        function Ee(s, o, h) {
            o = Wi(h, o), o = xh(s.stateNode, o, 2), s = Fr(s, o, 2), s !== null && (rt(s, 2), Go(s));
        }
        function re(s, o, h) {
            if (s.tag === 3) Ee(s, s, h);
            else for(; o !== null;){
                if (o.tag === 3) {
                    Ee(o, s, h);
                    break;
                } else if (o.tag === 1) {
                    var m = o.stateNode;
                    if (typeof o.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (Zs === null || !Zs.has(m))) {
                        s = Wi(h, s), h = e0(2), m = Fr(o, h, 2), m !== null && (Sh(h, m, o, s), rt(m, 2), Go(m));
                        break;
                    }
                }
                o = o.return;
            }
        }
        function Ce(s, o, h) {
            var m = s.pingCache;
            if (m === null) {
                m = s.pingCache = new zp;
                var S = new Set;
                m.set(o, S);
            } else S = m.get(o), S === void 0 && (S = new Set, m.set(o, S));
            S.has(h) || (bc = !0, S.add(h), s = Je.bind(null, s, o, h), o.then(s, s));
        }
        function Je(s, o, h) {
            var m = s.pingCache;
            m !== null && m.delete(o), s.pingedLanes |= s.suspendedLanes & h, s.warmLanes &= ~h, kt === s && (Ct & h) === h && (Yn === 4 || Yn === 3 && (Ct & 62914560) === Ct && 300 > We() - On ? (wn & 2) === 0 && Po(s, 0) : vl |= h, xn === Ct && (xn = 0)), Go(s);
        }
        function Tt(s, o) {
            o === 0 && (o = Qe()), s = zr(s, o), s !== null && (rt(s, o), Go(s));
        }
        function Wn(s) {
            var o = s.memoizedState, h = 0;
            o !== null && (h = o.retryLane), Tt(s, h);
        }
        function Ft(s, o) {
            var h = 0;
            switch(s.tag){
                case 13:
                    var m = s.stateNode, S = s.memoizedState;
                    S !== null && (h = S.retryLane);
                    break;
                case 19:
                    m = s.stateNode;
                    break;
                case 22:
                    m = s.stateNode._retryCache;
                    break;
                default:
                    throw Error(n(314));
            }
            m !== null && m.delete(o), Tt(s, h);
        }
        function Mn(s, o) {
            return Nt(s, o);
        }
        var ui = null, rn = null, dr = !1, Dh = !1, o_ = !1, Yu = 0;
        function Go(s) {
            s !== rn && s.next === null && (rn === null ? ui = rn = s : rn = rn.next = s), Dh = !0, dr || (dr = !0, tw());
        }
        function Bp(s, o) {
            if (!o_ && Dh) {
                o_ = !0;
                do for(var h = !1, m = ui; m !== null;){
                    if (s !== 0) {
                        var S = m.pendingLanes;
                        if (S === 0) var A = 0;
                        else {
                            var B = m.suspendedLanes, V = m.pingedLanes;
                            A = (1 << 31 - lt(42 | s) + 1) - 1, A &= S & ~(B & ~V), A = A & 201326741 ? A & 201326741 | 1 : A ? A | 2 : 0;
                        }
                        A !== 0 && (h = !0, gb(m, A));
                    } else A = Ct, A = ie(m, m === kt ? A : 0, m.cancelPendingCommit !== null || m.timeoutHandle !== -1), (A & 3) === 0 || xe(m, A) || (h = !0, gb(m, A));
                    m = m.next;
                }
                while (h);
                o_ = !1;
            }
        }
        function ew() {
            db();
        }
        function db() {
            Dh = dr = !1;
            var s = 0;
            Yu !== 0 && (cw() && (s = Yu), Yu = 0);
            for(var o = We(), h = null, m = ui; m !== null;){
                var S = m.next, A = pb(m, o);
                A === 0 ? (m.next = null, h === null ? ui = S : h.next = S, S === null && (rn = h)) : (h = m, (s !== 0 || (A & 3) !== 0) && (Dh = !0)), m = S;
            }
            Bp(s);
        }
        function pb(s, o) {
            for(var h = s.suspendedLanes, m = s.pingedLanes, S = s.expirationTimes, A = s.pendingLanes & -62914561; 0 < A;){
                var B = 31 - lt(A), V = 1 << B, ee = S[B];
                ee === -1 ? ((V & h) === 0 || (V & m) !== 0) && (S[B] = Ze(V, o)) : ee <= o && (s.expiredLanes |= V), A &= ~V;
            }
            if (o = kt, h = Ct, h = ie(s, s === o ? h : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1), m = s.callbackNode, h === 0 || s === o && (Qt === 2 || Qt === 9) || s.cancelPendingCommit !== null) return m !== null && m !== null && W(m), s.callbackNode = null, s.callbackPriority = 0;
            if ((h & 3) === 0 || xe(s, h)) {
                if (o = h & -h, o === s.callbackPriority) return o;
                switch(m !== null && W(m), tn(h)){
                    case 2:
                    case 8:
                        h = Xe;
                        break;
                    case 32:
                        h = ot;
                        break;
                    case 268435456:
                        h = Z;
                        break;
                    default:
                        h = ot;
                }
                return m = mb.bind(null, s), h = Nt(h, m), s.callbackPriority = o, s.callbackNode = h, o;
            }
            return m !== null && m !== null && W(m), s.callbackPriority = 2, s.callbackNode = null, 2;
        }
        function mb(s, o) {
            if (Ci !== 0 && Ci !== 5) return s.callbackNode = null, s.callbackPriority = 0, null;
            var h = s.callbackNode;
            if (Ho() && s.callbackNode !== h) return null;
            var m = Ct;
            return m = ie(s, s === kt ? m : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1), m === 0 ? null : (Mc(s, m, o), pb(s, We()), s.callbackNode != null && s.callbackNode === h ? mb.bind(null, s) : null);
        }
        function gb(s, o) {
            if (Ho()) return null;
            Mc(s, o, !0);
        }
        function tw() {
            fw(function() {
                (wn & 6) !== 0 ? Nt(ut, ew) : db();
            });
        }
        function l_() {
            return Yu === 0 && (Yu = te()), Yu;
        }
        function vb(s) {
            return s == null || typeof s == "symbol" || typeof s == "boolean" ? null : typeof s == "function" ? s : au("" + s);
        }
        function yb(s, o) {
            var h = o.ownerDocument.createElement("input");
            return h.name = o.name, h.value = o.value, s.id && h.setAttribute("form", s.id), o.parentNode.insertBefore(h, o), s = new FormData(s), h.parentNode.removeChild(h), s;
        }
        function nw(s, o, h, m, S) {
            if (o === "submit" && h && h.stateNode === S) {
                var A = vb((S[Ei] || null).action), B = m.submitter;
                B && (o = (o = B[Ei] || null) ? vb(o.formAction) : B.getAttribute("formAction"), o !== null && (A = o, B = null));
                var V = new kl("action", "action", null, m, S);
                s.push({
                    event: V,
                    listeners: [
                        {
                            instance: null,
                            listener: function() {
                                if (m.defaultPrevented) {
                                    if (Yu !== 0) {
                                        var ee = B ? yb(S, B) : new FormData(S);
                                        Cp(h, {
                                            pending: !0,
                                            data: ee,
                                            method: S.method,
                                            action: A
                                        }, null, ee);
                                    }
                                } else typeof A == "function" && (V.preventDefault(), ee = B ? yb(S, B) : new FormData(S), Cp(h, {
                                    pending: !0,
                                    data: ee,
                                    method: S.method,
                                    action: A
                                }, A, ee));
                            },
                            currentTarget: S
                        }
                    ]
                });
            }
        }
        for(var c_ = 0; c_ < xu.length; c_++){
            var u_ = xu[c_], iw = u_.toLowerCase(), sw = u_[0].toUpperCase() + u_.slice(1);
            Bi(iw, "on" + sw);
        }
        Bi(ps, "onAnimationEnd"), Bi(ep, "onAnimationIteration"), Bi(ws, "onAnimationStart"), Bi("dblclick", "onDoubleClick"), Bi("focusin", "onFocus"), Bi("focusout", "onBlur"), Bi(hg, "onTransitionRun"), Bi(Lr, "onTransitionStart"), Bi(Ql, "onTransitionCancel"), Bi(Or, "onTransitionEnd"), k("onMouseEnter", [
            "mouseout",
            "mouseover"
        ]), k("onMouseLeave", [
            "mouseout",
            "mouseover"
        ]), k("onPointerEnter", [
            "pointerout",
            "pointerover"
        ]), k("onPointerLeave", [
            "pointerout",
            "pointerover"
        ]), wa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), wa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), wa("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
        ]), wa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), wa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), wa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var Ip = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), aw = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ip));
        function _b(s, o) {
            o = (o & 4) !== 0;
            for(var h = 0; h < s.length; h++){
                var m = s[h], S = m.event;
                m = m.listeners;
                e: {
                    var A = void 0;
                    if (o) for(var B = m.length - 1; 0 <= B; B--){
                        var V = m[B], ee = V.instance, Me = V.currentTarget;
                        if (V = V.listener, ee !== A && S.isPropagationStopped()) break e;
                        A = V, S.currentTarget = Me;
                        try {
                            A(S);
                        } catch (ze) {
                            al(ze);
                        }
                        S.currentTarget = null, A = ee;
                    }
                    else for(B = 0; B < m.length; B++){
                        if (V = m[B], ee = V.instance, Me = V.currentTarget, V = V.listener, ee !== A && S.isPropagationStopped()) break e;
                        A = V, S.currentTarget = Me;
                        try {
                            A(S);
                        } catch (ze) {
                            al(ze);
                        }
                        S.currentTarget = null, A = ee;
                    }
                }
            }
        }
        function dn(s, o) {
            var h = o[Ms];
            h === void 0 && (h = o[Ms] = new Set);
            var m = s + "__bubble";
            h.has(m) || (xb(o, s, 2, !1), h.add(m));
        }
        function f_(s, o, h) {
            var m = 0;
            o && (m |= 4), xb(h, s, m, o);
        }
        var s0 = "_reactListening" + Math.random().toString(36).slice(2);
        function h_(s) {
            if (!s[s0]) {
                s[s0] = !0, Pl.forEach(function(h) {
                    h !== "selectionchange" && (aw.has(h) || f_(h, !1, s), f_(h, !0, s));
                });
                var o = s.nodeType === 9 ? s : s.ownerDocument;
                o === null || o[s0] || (o[s0] = !0, f_("selectionchange", !1, o));
            }
        }
        function xb(s, o, h, m) {
            switch(Xb(o)){
                case 2:
                    var S = Uw;
                    break;
                case 8:
                    S = Lw;
                    break;
                default:
                    S = A_;
            }
            h = S.bind(null, o, h, s), S = void 0, !ou || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (S = !0), m ? S !== void 0 ? s.addEventListener(o, h, {
                capture: !0,
                passive: S
            }) : s.addEventListener(o, h, !0) : S !== void 0 ? s.addEventListener(o, h, {
                passive: S
            }) : s.addEventListener(o, h, !1);
        }
        function d_(s, o, h, m, S) {
            var A = m;
            if ((o & 1) === 0 && (o & 2) === 0 && m !== null) e: for(;;){
                if (m === null) return;
                var B = m.tag;
                if (B === 3 || B === 4) {
                    var V = m.stateNode.containerInfo;
                    if (V === S) break;
                    if (B === 4) for(B = m.return; B !== null;){
                        var ee = B.tag;
                        if ((ee === 3 || ee === 4) && B.stateNode.containerInfo === S) return;
                        B = B.return;
                    }
                    for(; V !== null;){
                        if (B = Ta(V), B === null) return;
                        if (ee = B.tag, ee === 5 || ee === 6 || ee === 26 || ee === 27) {
                            m = A = B;
                            continue e;
                        }
                        V = V.parentNode;
                    }
                }
                m = m.return;
            }
            Id(function() {
                var Me = A, ze = Bf(h), ke = [];
                e: {
                    var Te = Wf.get(s);
                    if (Te !== void 0) {
                        var Re = kl, Gt = s;
                        switch(s){
                            case "keypress":
                                if (lo(h) === 0) break e;
                            case "keydown":
                            case "keyup":
                                Re = Vd;
                                break;
                            case "focusin":
                                Gt = "focus", Re = Pf;
                                break;
                            case "focusout":
                                Gt = "blur", Re = Pf;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                Re = Pf;
                                break;
                            case "click":
                                if (h.button === 2) break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                Re = Fd;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                Re = Zy;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                Re = Xd;
                                break;
                            case ps:
                            case ep:
                            case ws:
                                Re = Qm;
                                break;
                            case Or:
                                Re = Cr;
                                break;
                            case "scroll":
                            case "scrollend":
                                Re = Wm;
                                break;
                            case "wheel":
                                Re = Ky;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                Re = $m;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                Re = Ff;
                                break;
                            case "toggle":
                            case "beforetoggle":
                                Re = uo;
                        }
                        var Bt = (o & 4) !== 0, qn = !Bt && (s === "scroll" || s === "scrollend"), de = Bt ? Te !== null ? Te + "Capture" : null : Te;
                        Bt = [];
                        for(var le = Me, be; le !== null;){
                            var Ge = le;
                            if (be = Ge.stateNode, Ge = Ge.tag, Ge !== 5 && Ge !== 26 && Ge !== 27 || be === null || de === null || (Ge = Fl(le, de), Ge != null && Bt.push(Pp(le, Ge, be))), qn) break;
                            le = le.return;
                        }
                        0 < Bt.length && (Te = new Re(Te, Gt, null, h, ze), ke.push({
                            event: Te,
                            listeners: Bt
                        }));
                    }
                }
                if ((o & 7) === 0) {
                    e: {
                        if (Te = s === "mouseover" || s === "pointerover", Re = s === "mouseout" || s === "pointerout", Te && h !== zf && (Gt = h.relatedTarget || h.fromElement) && (Ta(Gt) || Gt[ns])) break e;
                        if ((Re || Te) && (Te = ze.window === ze ? ze : (Te = ze.ownerDocument) ? Te.defaultView || Te.parentWindow : window, Re ? (Gt = h.relatedTarget || h.toElement, Re = Me, Gt = Gt ? Ta(Gt) : null, Gt !== null && (qn = a(Gt), Bt = Gt.tag, Gt !== qn || Bt !== 5 && Bt !== 27 && Bt !== 6) && (Gt = null)) : (Re = null, Gt = Me), Re !== Gt)) {
                            if (Bt = Fd, Ge = "onMouseLeave", de = "onMouseEnter", le = "mouse", (s === "pointerout" || s === "pointerover") && (Bt = Ff, Ge = "onPointerLeave", de = "onPointerEnter", le = "pointer"), qn = Re == null ? Te : ro(Re), be = Gt == null ? Te : ro(Gt), Te = new Bt(Ge, le + "leave", Re, h, ze), Te.target = qn, Te.relatedTarget = be, Ge = null, Ta(ze) === Me && (Bt = new Bt(de, le + "enter", Gt, h, ze), Bt.target = be, Bt.relatedTarget = qn, Ge = Bt), qn = Ge, Re && Gt) t: {
                                for(Bt = Re, de = Gt, le = 0, be = Bt; be; be = Nh(be))le++;
                                for(be = 0, Ge = de; Ge; Ge = Nh(Ge))be++;
                                for(; 0 < le - be;)Bt = Nh(Bt), le--;
                                for(; 0 < be - le;)de = Nh(de), be--;
                                for(; le--;){
                                    if (Bt === de || de !== null && Bt === de.alternate) break t;
                                    Bt = Nh(Bt), de = Nh(de);
                                }
                                Bt = null;
                            }
                            else Bt = null;
                            Re !== null && Sb(ke, Te, Re, Bt, !1), Gt !== null && qn !== null && Sb(ke, qn, Gt, Bt, !0);
                        }
                    }
                    e: {
                        if (Te = Me ? ro(Me) : window, Re = Te.nodeName && Te.nodeName.toLowerCase(), Re === "select" || Re === "input" && Te.type === "file") var bt = Vf;
                        else if (Wd(Te)) if (kf) bt = po;
                        else {
                            bt = cg;
                            var un = Qy;
                        }
                        else Re = Te.nodeName, !Re || Re.toLowerCase() !== "input" || Te.type !== "checkbox" && Te.type !== "radio" ? Me && Of(Me.elementType) && (bt = Vf) : bt = vu;
                        if (bt && (bt = bt(s, Me))) {
                            Es(ke, bt, h, ze);
                            break e;
                        }
                        un && un(s, Te, Me), s === "focusout" && Me && Te.type === "number" && Me.memoizedProps.value != null && Xi(Te, "number", Te.value);
                    }
                    switch(un = Me ? ro(Me) : window, s){
                        case "focusin":
                            (Wd(un) || un.contentEditable === "true") && (Nr = un, jf = Me, _u = null);
                            break;
                        case "focusout":
                            _u = jf = Nr = null;
                            break;
                        case "mousedown":
                            qf = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            qf = !1, $d(ke, h, ze);
                            break;
                        case "selectionchange":
                            if (Jd) break;
                        case "keydown":
                        case "keyup":
                            $d(ke, h, ze);
                    }
                    var At;
                    if (fu) e: {
                        switch(s){
                            case "compositionstart":
                                var Pt = "onCompositionStart";
                                break e;
                            case "compositionend":
                                Pt = "onCompositionEnd";
                                break e;
                            case "compositionupdate":
                                Pt = "onCompositionUpdate";
                                break e;
                        }
                        Pt = void 0;
                    }
                    else ho ? pu(s, h) && (Pt = "onCompositionEnd") : s === "keydown" && h.keyCode === 229 && (Pt = "onCompositionStart");
                    Pt && (du && h.locale !== "ko" && (ho || Pt !== "onCompositionStart" ? Pt === "onCompositionEnd" && ho && (At = Hd()) : (wr = ze, Pd = "value" in wr ? wr.value : wr.textContent, ho = !0)), un = a0(Me, Pt), 0 < un.length && (Pt = new Hf(Pt, s, null, h, ze), ke.push({
                        event: Pt,
                        listeners: un
                    }), At ? Pt.data = At : (At = qd(h), At !== null && (Pt.data = At)))), (At = hu ? mu(s, h) : Yd(s, h)) && (Pt = a0(Me, "onBeforeInput"), 0 < Pt.length && (un = new Hf("onBeforeInput", "beforeinput", null, h, ze), ke.push({
                        event: un,
                        listeners: Pt
                    }), un.data = At)), nw(ke, s, Me, h, ze);
                }
                _b(ke, o);
            });
        }
        function Pp(s, o, h) {
            return {
                instance: s,
                listener: o,
                currentTarget: h
            };
        }
        function a0(s, o) {
            for(var h = o + "Capture", m = []; s !== null;){
                var S = s, A = S.stateNode;
                if (S = S.tag, S !== 5 && S !== 26 && S !== 27 || A === null || (S = Fl(s, h), S != null && m.unshift(Pp(s, S, A)), S = Fl(s, o), S != null && m.push(Pp(s, S, A))), s.tag === 3) return m;
                s = s.return;
            }
            return [];
        }
        function Nh(s) {
            if (s === null) return null;
            do s = s.return;
            while (s && s.tag !== 5 && s.tag !== 27);
            return s || null;
        }
        function Sb(s, o, h, m, S) {
            for(var A = o._reactName, B = []; h !== null && h !== m;){
                var V = h, ee = V.alternate, Me = V.stateNode;
                if (V = V.tag, ee !== null && ee === m) break;
                V !== 5 && V !== 26 && V !== 27 || Me === null || (ee = Me, S ? (Me = Fl(h, A), Me != null && B.unshift(Pp(h, Me, ee))) : S || (Me = Fl(h, A), Me != null && B.push(Pp(h, Me, ee)))), h = h.return;
            }
            B.length !== 0 && s.push({
                event: o,
                listeners: B
            });
        }
        var rw = /\r\n?/g, ow = /\u0000|\uFFFD/g;
        function bb(s) {
            return (typeof s == "string" ? s : "" + s).replace(rw, `
`).replace(ow, "");
        }
        function Mb(s, o) {
            return o = bb(o), bb(s) === o;
        }
        function r0() {}
        function jn(s, o, h, m, S, A) {
            switch(h){
                case "children":
                    typeof m == "string" ? o === "body" || o === "textarea" && m === "" || hs(s, m) : (typeof m == "number" || typeof m == "bigint") && o !== "body" && hs(s, "" + m);
                    break;
                case "className":
                    at(s, "class", m);
                    break;
                case "tabIndex":
                    at(s, "tabindex", m);
                    break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                    at(s, h, m);
                    break;
                case "style":
                    su(s, m, A);
                    break;
                case "data":
                    if (o !== "object") {
                        at(s, "data", m);
                        break;
                    }
                case "src":
                case "href":
                    if (m === "" && (o !== "a" || h !== "href")) {
                        s.removeAttribute(h);
                        break;
                    }
                    if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
                        s.removeAttribute(h);
                        break;
                    }
                    m = au("" + m), s.setAttribute(h, m);
                    break;
                case "action":
                case "formAction":
                    if (typeof m == "function") {
                        s.setAttribute(h, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                        break;
                    } else typeof A == "function" && (h === "formAction" ? (o !== "input" && jn(s, o, "name", S.name, S, null), jn(s, o, "formEncType", S.formEncType, S, null), jn(s, o, "formMethod", S.formMethod, S, null), jn(s, o, "formTarget", S.formTarget, S, null)) : (jn(s, o, "encType", S.encType, S, null), jn(s, o, "method", S.method, S, null), jn(s, o, "target", S.target, S, null)));
                    if (m == null || typeof m == "symbol" || typeof m == "boolean") {
                        s.removeAttribute(h);
                        break;
                    }
                    m = au("" + m), s.setAttribute(h, m);
                    break;
                case "onClick":
                    m != null && (s.onclick = r0);
                    break;
                case "onScroll":
                    m != null && dn("scroll", s);
                    break;
                case "onScrollEnd":
                    m != null && dn("scrollend", s);
                    break;
                case "dangerouslySetInnerHTML":
                    if (m != null) {
                        if (typeof m != "object" || !("__html" in m)) throw Error(n(61));
                        if (h = m.__html, h != null) {
                            if (S.children != null) throw Error(n(60));
                            s.innerHTML = h;
                        }
                    }
                    break;
                case "multiple":
                    s.multiple = m && typeof m != "function" && typeof m != "symbol";
                    break;
                case "muted":
                    s.muted = m && typeof m != "function" && typeof m != "symbol";
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                    break;
                case "autoFocus":
                    break;
                case "xlinkHref":
                    if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
                        s.removeAttribute("xlink:href");
                        break;
                    }
                    h = au("" + m), s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", h);
                    break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    m != null && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, "" + m) : s.removeAttribute(h);
                    break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    m && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, "") : s.removeAttribute(h);
                    break;
                case "capture":
                case "download":
                    m === !0 ? s.setAttribute(h, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, m) : s.removeAttribute(h);
                    break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? s.setAttribute(h, m) : s.removeAttribute(h);
                    break;
                case "rowSpan":
                case "start":
                    m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? s.removeAttribute(h) : s.setAttribute(h, m);
                    break;
                case "popover":
                    dn("beforetoggle", s), dn("toggle", s), je(s, "popover", m);
                    break;
                case "xlinkActuate":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:actuate", m);
                    break;
                case "xlinkArcrole":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:arcrole", m);
                    break;
                case "xlinkRole":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:role", m);
                    break;
                case "xlinkShow":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:show", m);
                    break;
                case "xlinkTitle":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:title", m);
                    break;
                case "xlinkType":
                    dt(s, "http://www.w3.org/1999/xlink", "xlink:type", m);
                    break;
                case "xmlBase":
                    dt(s, "http://www.w3.org/XML/1998/namespace", "xml:base", m);
                    break;
                case "xmlLang":
                    dt(s, "http://www.w3.org/XML/1998/namespace", "xml:lang", m);
                    break;
                case "xmlSpace":
                    dt(s, "http://www.w3.org/XML/1998/namespace", "xml:space", m);
                    break;
                case "is":
                    je(s, "is", m);
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    (!(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (h = zd.get(h) || h, je(s, h, m));
            }
        }
        function p_(s, o, h, m, S, A) {
            switch(h){
                case "style":
                    su(s, m, A);
                    break;
                case "dangerouslySetInnerHTML":
                    if (m != null) {
                        if (typeof m != "object" || !("__html" in m)) throw Error(n(61));
                        if (h = m.__html, h != null) {
                            if (S.children != null) throw Error(n(60));
                            s.innerHTML = h;
                        }
                    }
                    break;
                case "children":
                    typeof m == "string" ? hs(s, m) : (typeof m == "number" || typeof m == "bigint") && hs(s, "" + m);
                    break;
                case "onScroll":
                    m != null && dn("scroll", s);
                    break;
                case "onScrollEnd":
                    m != null && dn("scrollend", s);
                    break;
                case "onClick":
                    m != null && (s.onclick = r0);
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    if (!Hl.hasOwnProperty(h)) e: {
                        if (h[0] === "o" && h[1] === "n" && (S = h.endsWith("Capture"), o = h.slice(2, S ? h.length - 7 : void 0), A = s[Ei] || null, A = A != null ? A[h] : null, typeof A == "function" && s.removeEventListener(o, A, S), typeof m == "function")) {
                            typeof A != "function" && A !== null && (h in s ? s[h] = null : s.hasAttribute(h) && s.removeAttribute(h)), s.addEventListener(o, m, S);
                            break e;
                        }
                        h in s ? s[h] = m : m === !0 ? s.setAttribute(h, "") : je(s, h, m);
                    }
            }
        }
        function Ss(s, o, h) {
            switch(o){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "img":
                    dn("error", s), dn("load", s);
                    var m = !1, S = !1, A;
                    for(A in h)if (h.hasOwnProperty(A)) {
                        var B = h[A];
                        if (B != null) switch(A){
                            case "src":
                                m = !0;
                                break;
                            case "srcSet":
                                S = !0;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                throw Error(n(137, o));
                            default:
                                jn(s, o, A, B, h, null);
                        }
                    }
                    S && jn(s, o, "srcSet", h.srcSet, h, null), m && jn(s, o, "src", h.src, h, null);
                    return;
                case "input":
                    dn("invalid", s);
                    var V = A = B = S = null, ee = null, Me = null;
                    for(m in h)if (h.hasOwnProperty(m)) {
                        var ze = h[m];
                        if (ze != null) switch(m){
                            case "name":
                                S = ze;
                                break;
                            case "type":
                                B = ze;
                                break;
                            case "checked":
                                ee = ze;
                                break;
                            case "defaultChecked":
                                Me = ze;
                                break;
                            case "value":
                                A = ze;
                                break;
                            case "defaultValue":
                                V = ze;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (ze != null) throw Error(n(137, o));
                                break;
                            default:
                                jn(s, o, m, ze, h, null);
                        }
                    }
                    Ln(s, A, V, ee, Me, B, S, !1), Dn(s);
                    return;
                case "select":
                    dn("invalid", s), m = B = A = null;
                    for(S in h)if (h.hasOwnProperty(S) && (V = h[S], V != null)) switch(S){
                        case "value":
                            A = V;
                            break;
                        case "defaultValue":
                            B = V;
                            break;
                        case "multiple":
                            m = V;
                        default:
                            jn(s, o, S, V, h, null);
                    }
                    o = A, h = B, s.multiple = !!m, o != null ? _i(s, !!m, o, !1) : h != null && _i(s, !!m, h, !0);
                    return;
                case "textarea":
                    dn("invalid", s), A = S = m = null;
                    for(B in h)if (h.hasOwnProperty(B) && (V = h[B], V != null)) switch(B){
                        case "value":
                            m = V;
                            break;
                        case "defaultValue":
                            S = V;
                            break;
                        case "children":
                            A = V;
                            break;
                        case "dangerouslySetInnerHTML":
                            if (V != null) throw Error(n(91));
                            break;
                        default:
                            jn(s, o, B, V, h, null);
                    }
                    zi(s, m, S, A), Dn(s);
                    return;
                case "option":
                    for(ee in h)if (h.hasOwnProperty(ee) && (m = h[ee], m != null)) switch(ee){
                        case "selected":
                            s.selected = m && typeof m != "function" && typeof m != "symbol";
                            break;
                        default:
                            jn(s, o, ee, m, h, null);
                    }
                    return;
                case "dialog":
                    dn("beforetoggle", s), dn("toggle", s), dn("cancel", s), dn("close", s);
                    break;
                case "iframe":
                case "object":
                    dn("load", s);
                    break;
                case "video":
                case "audio":
                    for(m = 0; m < Ip.length; m++)dn(Ip[m], s);
                    break;
                case "image":
                    dn("error", s), dn("load", s);
                    break;
                case "details":
                    dn("toggle", s);
                    break;
                case "embed":
                case "source":
                case "link":
                    dn("error", s), dn("load", s);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                    for(Me in h)if (h.hasOwnProperty(Me) && (m = h[Me], m != null)) switch(Me){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(n(137, o));
                        default:
                            jn(s, o, Me, m, h, null);
                    }
                    return;
                default:
                    if (Of(o)) {
                        for(ze in h)h.hasOwnProperty(ze) && (m = h[ze], m !== void 0 && p_(s, o, ze, m, h, void 0));
                        return;
                    }
            }
            for(V in h)h.hasOwnProperty(V) && (m = h[V], m != null && jn(s, o, V, m, h, null));
        }
        function lw(s, o, h, m) {
            switch(o){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "input":
                    var S = null, A = null, B = null, V = null, ee = null, Me = null, ze = null;
                    for(Re in h){
                        var ke = h[Re];
                        if (h.hasOwnProperty(Re) && ke != null) switch(Re){
                            case "checked":
                                break;
                            case "value":
                                break;
                            case "defaultValue":
                                ee = ke;
                            default:
                                m.hasOwnProperty(Re) || jn(s, o, Re, null, m, ke);
                        }
                    }
                    for(var Te in m){
                        var Re = m[Te];
                        if (ke = h[Te], m.hasOwnProperty(Te) && (Re != null || ke != null)) switch(Te){
                            case "type":
                                A = Re;
                                break;
                            case "name":
                                S = Re;
                                break;
                            case "checked":
                                Me = Re;
                                break;
                            case "defaultChecked":
                                ze = Re;
                                break;
                            case "value":
                                B = Re;
                                break;
                            case "defaultValue":
                                V = Re;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (Re != null) throw Error(n(137, o));
                                break;
                            default:
                                Re !== ke && jn(s, o, Te, Re, m, ke);
                        }
                    }
                    Za(s, B, V, ee, Me, ze, A, S);
                    return;
                case "select":
                    Re = B = V = Te = null;
                    for(A in h)if (ee = h[A], h.hasOwnProperty(A) && ee != null) switch(A){
                        case "value":
                            break;
                        case "multiple":
                            Re = ee;
                        default:
                            m.hasOwnProperty(A) || jn(s, o, A, null, m, ee);
                    }
                    for(S in m)if (A = m[S], ee = h[S], m.hasOwnProperty(S) && (A != null || ee != null)) switch(S){
                        case "value":
                            Te = A;
                            break;
                        case "defaultValue":
                            V = A;
                            break;
                        case "multiple":
                            B = A;
                        default:
                            A !== ee && jn(s, o, S, A, m, ee);
                    }
                    o = V, h = B, m = Re, Te != null ? _i(s, !!h, Te, !1) : !!m != !!h && (o != null ? _i(s, !!h, o, !0) : _i(s, !!h, h ? [] : "", !1));
                    return;
                case "textarea":
                    Re = Te = null;
                    for(V in h)if (S = h[V], h.hasOwnProperty(V) && S != null && !m.hasOwnProperty(V)) switch(V){
                        case "value":
                            break;
                        case "children":
                            break;
                        default:
                            jn(s, o, V, null, m, S);
                    }
                    for(B in m)if (S = m[B], A = h[B], m.hasOwnProperty(B) && (S != null || A != null)) switch(B){
                        case "value":
                            Te = S;
                            break;
                        case "defaultValue":
                            Re = S;
                            break;
                        case "children":
                            break;
                        case "dangerouslySetInnerHTML":
                            if (S != null) throw Error(n(91));
                            break;
                        default:
                            S !== A && jn(s, o, B, S, m, A);
                    }
                    Oi(s, Te, Re);
                    return;
                case "option":
                    for(var Gt in h)if (Te = h[Gt], h.hasOwnProperty(Gt) && Te != null && !m.hasOwnProperty(Gt)) switch(Gt){
                        case "selected":
                            s.selected = !1;
                            break;
                        default:
                            jn(s, o, Gt, null, m, Te);
                    }
                    for(ee in m)if (Te = m[ee], Re = h[ee], m.hasOwnProperty(ee) && Te !== Re && (Te != null || Re != null)) switch(ee){
                        case "selected":
                            s.selected = Te && typeof Te != "function" && typeof Te != "symbol";
                            break;
                        default:
                            jn(s, o, ee, Te, m, Re);
                    }
                    return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                    for(var Bt in h)Te = h[Bt], h.hasOwnProperty(Bt) && Te != null && !m.hasOwnProperty(Bt) && jn(s, o, Bt, null, m, Te);
                    for(Me in m)if (Te = m[Me], Re = h[Me], m.hasOwnProperty(Me) && Te !== Re && (Te != null || Re != null)) switch(Me){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (Te != null) throw Error(n(137, o));
                            break;
                        default:
                            jn(s, o, Me, Te, m, Re);
                    }
                    return;
                default:
                    if (Of(o)) {
                        for(var qn in h)Te = h[qn], h.hasOwnProperty(qn) && Te !== void 0 && !m.hasOwnProperty(qn) && p_(s, o, qn, void 0, m, Te);
                        for(ze in m)Te = m[ze], Re = h[ze], !m.hasOwnProperty(ze) || Te === Re || Te === void 0 && Re === void 0 || p_(s, o, ze, Te, m, Re);
                        return;
                    }
            }
            for(var de in h)Te = h[de], h.hasOwnProperty(de) && Te != null && !m.hasOwnProperty(de) && jn(s, o, de, null, m, Te);
            for(ke in m)Te = m[ke], Re = h[ke], !m.hasOwnProperty(ke) || Te === Re || Te == null && Re == null || jn(s, o, ke, Te, m, Re);
        }
        var m_ = null, g_ = null;
        function o0(s) {
            return s.nodeType === 9 ? s : s.ownerDocument;
        }
        function Eb(s) {
            switch(s){
                case "http://www.w3.org/2000/svg":
                    return 1;
                case "http://www.w3.org/1998/Math/MathML":
                    return 2;
                default:
                    return 0;
            }
        }
        function Tb(s, o) {
            if (s === 0) switch(o){
                case "svg":
                    return 1;
                case "math":
                    return 2;
                default:
                    return 0;
            }
            return s === 1 && o === "foreignObject" ? 0 : s;
        }
        function v_(s, o) {
            return s === "textarea" || s === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
        }
        var y_ = null;
        function cw() {
            var s = window.event;
            return s && s.type === "popstate" ? s === y_ ? !1 : (y_ = s, !0) : (y_ = null, !1);
        }
        var Ab = typeof setTimeout == "function" ? setTimeout : void 0, uw = typeof clearTimeout == "function" ? clearTimeout : void 0, wb = typeof Promise == "function" ? Promise : void 0, fw = typeof queueMicrotask == "function" ? queueMicrotask : typeof wb < "u" ? function(s) {
            return wb.resolve(null).then(s).catch(hw);
        } : Ab;
        function hw(s) {
            setTimeout(function() {
                throw s;
            });
        }
        function Tc(s) {
            return s === "head";
        }
        function Rb(s, o) {
            var h = o, m = 0, S = 0;
            do {
                var A = h.nextSibling;
                if (s.removeChild(h), A && A.nodeType === 8) if (h = A.data, h === "/$") {
                    if (0 < m && 8 > m) {
                        h = m;
                        var B = s.ownerDocument;
                        if (h & 1 && Hp(B.documentElement), h & 2 && Hp(B.body), h & 4) for(h = B.head, Hp(h), B = h.firstChild; B;){
                            var V = B.nextSibling, ee = B.nodeName;
                            B[Ea] || ee === "SCRIPT" || ee === "STYLE" || ee === "LINK" && B.rel.toLowerCase() === "stylesheet" || h.removeChild(B), B = V;
                        }
                    }
                    if (S === 0) {
                        s.removeChild(A), Yp(o);
                        return;
                    }
                    S--;
                } else h === "$" || h === "$?" || h === "$!" ? S++ : m = h.charCodeAt(0) - 48;
                else m = 0;
                h = A;
            }while (h);
            Yp(o);
        }
        function __(s) {
            var o = s.firstChild;
            for(o && o.nodeType === 10 && (o = o.nextSibling); o;){
                var h = o;
                switch(o = o.nextSibling, h.nodeName){
                    case "HTML":
                    case "HEAD":
                    case "BODY":
                        __(h), Un(h);
                        continue;
                    case "SCRIPT":
                    case "STYLE":
                        continue;
                    case "LINK":
                        if (h.rel.toLowerCase() === "stylesheet") continue;
                }
                s.removeChild(h);
            }
        }
        function dw(s, o, h, m) {
            for(; s.nodeType === 1;){
                var S = h;
                if (s.nodeName.toLowerCase() !== o.toLowerCase()) {
                    if (!m && (s.nodeName !== "INPUT" || s.type !== "hidden")) break;
                } else if (m) {
                    if (!s[Ea]) switch(o){
                        case "meta":
                            if (!s.hasAttribute("itemprop")) break;
                            return s;
                        case "link":
                            if (A = s.getAttribute("rel"), A === "stylesheet" && s.hasAttribute("data-precedence")) break;
                            if (A !== S.rel || s.getAttribute("href") !== (S.href == null || S.href === "" ? null : S.href) || s.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin) || s.getAttribute("title") !== (S.title == null ? null : S.title)) break;
                            return s;
                        case "style":
                            if (s.hasAttribute("data-precedence")) break;
                            return s;
                        case "script":
                            if (A = s.getAttribute("src"), (A !== (S.src == null ? null : S.src) || s.getAttribute("type") !== (S.type == null ? null : S.type) || s.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin)) && A && s.hasAttribute("async") && !s.hasAttribute("itemprop")) break;
                            return s;
                        default:
                            return s;
                    }
                } else if (o === "input" && s.type === "hidden") {
                    var A = S.name == null ? null : "" + S.name;
                    if (S.type === "hidden" && s.getAttribute("name") === A) return s;
                } else return s;
                if (s = Kr(s.nextSibling), s === null) break;
            }
            return null;
        }
        function pw(s, o, h) {
            if (o === "") return null;
            for(; s.nodeType !== 3;)if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !h || (s = Kr(s.nextSibling), s === null)) return null;
            return s;
        }
        function x_(s) {
            return s.data === "$!" || s.data === "$?" && s.ownerDocument.readyState === "complete";
        }
        function mw(s, o) {
            var h = s.ownerDocument;
            if (s.data !== "$?" || h.readyState === "complete") o();
            else {
                var m = function() {
                    o(), h.removeEventListener("DOMContentLoaded", m);
                };
                h.addEventListener("DOMContentLoaded", m), s._reactRetry = m;
            }
        }
        function Kr(s) {
            for(; s != null; s = s.nextSibling){
                var o = s.nodeType;
                if (o === 1 || o === 3) break;
                if (o === 8) {
                    if (o = s.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F") break;
                    if (o === "/$") return null;
                }
            }
            return s;
        }
        var S_ = null;
        function Cb(s) {
            s = s.previousSibling;
            for(var o = 0; s;){
                if (s.nodeType === 8) {
                    var h = s.data;
                    if (h === "$" || h === "$!" || h === "$?") {
                        if (o === 0) return s;
                        o--;
                    } else h === "/$" && o++;
                }
                s = s.previousSibling;
            }
            return null;
        }
        function Db(s, o, h) {
            switch(o = o0(h), s){
                case "html":
                    if (s = o.documentElement, !s) throw Error(n(452));
                    return s;
                case "head":
                    if (s = o.head, !s) throw Error(n(453));
                    return s;
                case "body":
                    if (s = o.body, !s) throw Error(n(454));
                    return s;
                default:
                    throw Error(n(451));
            }
        }
        function Hp(s) {
            for(var o = s.attributes; o.length;)s.removeAttributeNode(o[0]);
            Un(s);
        }
        var pr = new Map, Nb = new Set;
        function l0(s) {
            return typeof s.getRootNode == "function" ? s.getRootNode() : s.nodeType === 9 ? s : s.ownerDocument;
        }
        var xl = K.d;
        K.d = {
            f: gw,
            r: vw,
            D: yw,
            C: _w,
            L: xw,
            m: Sw,
            X: Mw,
            S: bw,
            M: Ew
        };
        function gw() {
            var s = xl.f(), o = hr();
            return s || o;
        }
        function vw(s) {
            var o = Aa(s);
            o !== null && o.tag === 5 && o.type === "form" ? Gg(o) : xl.r(s);
        }
        var Uh = typeof document > "u" ? null : document;
        function Ub(s, o, h) {
            var m = Uh;
            if (m && typeof o == "string" && o) {
                var S = zn(o);
                S = 'link[rel="' + s + '"][href="' + S + '"]', typeof h == "string" && (S += '[crossorigin="' + h + '"]'), Nb.has(S) || (Nb.add(S), s = {
                    rel: s,
                    crossOrigin: h,
                    href: o
                }, m.querySelector(S) === null && (o = m.createElement("link"), Ss(o, "link", s), yi(o), m.head.appendChild(o)));
            }
        }
        function yw(s) {
            xl.D(s), Ub("dns-prefetch", s, null);
        }
        function _w(s, o) {
            xl.C(s, o), Ub("preconnect", s, o);
        }
        function xw(s, o, h) {
            xl.L(s, o, h);
            var m = Uh;
            if (m && s && o) {
                var S = 'link[rel="preload"][as="' + zn(o) + '"]';
                o === "image" && h && h.imageSrcSet ? (S += '[imagesrcset="' + zn(h.imageSrcSet) + '"]', typeof h.imageSizes == "string" && (S += '[imagesizes="' + zn(h.imageSizes) + '"]')) : S += '[href="' + zn(s) + '"]';
                var A = S;
                switch(o){
                    case "style":
                        A = Lh(s);
                        break;
                    case "script":
                        A = Oh(s);
                }
                pr.has(A) || (s = g({
                    rel: "preload",
                    href: o === "image" && h && h.imageSrcSet ? void 0 : s,
                    as: o
                }, h), pr.set(A, s), m.querySelector(S) !== null || o === "style" && m.querySelector(Fp(A)) || o === "script" && m.querySelector(Gp(A)) || (o = m.createElement("link"), Ss(o, "link", s), yi(o), m.head.appendChild(o)));
            }
        }
        function Sw(s, o) {
            xl.m(s, o);
            var h = Uh;
            if (h && s) {
                var m = o && typeof o.as == "string" ? o.as : "script", S = 'link[rel="modulepreload"][as="' + zn(m) + '"][href="' + zn(s) + '"]', A = S;
                switch(m){
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                        A = Oh(s);
                }
                if (!pr.has(A) && (s = g({
                    rel: "modulepreload",
                    href: s
                }, o), pr.set(A, s), h.querySelector(S) === null)) {
                    switch(m){
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            if (h.querySelector(Gp(A))) return;
                    }
                    m = h.createElement("link"), Ss(m, "link", s), yi(m), h.head.appendChild(m);
                }
            }
        }
        function bw(s, o, h) {
            xl.S(s, o, h);
            var m = Uh;
            if (m && s) {
                var S = Ar(m).hoistableStyles, A = Lh(s);
                o = o || "default";
                var B = S.get(A);
                if (!B) {
                    var V = {
                        loading: 0,
                        preload: null
                    };
                    if (B = m.querySelector(Fp(A))) V.loading = 5;
                    else {
                        s = g({
                            rel: "stylesheet",
                            href: s,
                            "data-precedence": o
                        }, h), (h = pr.get(A)) && b_(s, h);
                        var ee = B = m.createElement("link");
                        yi(ee), Ss(ee, "link", s), ee._p = new Promise(function(Me, ze) {
                            ee.onload = Me, ee.onerror = ze;
                        }), ee.addEventListener("load", function() {
                            V.loading |= 1;
                        }), ee.addEventListener("error", function() {
                            V.loading |= 2;
                        }), V.loading |= 4, c0(B, o, m);
                    }
                    B = {
                        type: "stylesheet",
                        instance: B,
                        count: 1,
                        state: V
                    }, S.set(A, B);
                }
            }
        }
        function Mw(s, o) {
            xl.X(s, o);
            var h = Uh;
            if (h && s) {
                var m = Ar(h).hoistableScripts, S = Oh(s), A = m.get(S);
                A || (A = h.querySelector(Gp(S)), A || (s = g({
                    src: s,
                    async: !0
                }, o), (o = pr.get(S)) && M_(s, o), A = h.createElement("script"), yi(A), Ss(A, "link", s), h.head.appendChild(A)), A = {
                    type: "script",
                    instance: A,
                    count: 1,
                    state: null
                }, m.set(S, A));
            }
        }
        function Ew(s, o) {
            xl.M(s, o);
            var h = Uh;
            if (h && s) {
                var m = Ar(h).hoistableScripts, S = Oh(s), A = m.get(S);
                A || (A = h.querySelector(Gp(S)), A || (s = g({
                    src: s,
                    async: !0,
                    type: "module"
                }, o), (o = pr.get(S)) && M_(s, o), A = h.createElement("script"), yi(A), Ss(A, "link", s), h.head.appendChild(A)), A = {
                    type: "script",
                    instance: A,
                    count: 1,
                    state: null
                }, m.set(S, A));
            }
        }
        function Lb(s, o, h, m) {
            var S = (S = he.current) ? l0(S) : null;
            if (!S) throw Error(n(446));
            switch(s){
                case "meta":
                case "title":
                    return null;
                case "style":
                    return typeof h.precedence == "string" && typeof h.href == "string" ? (o = Lh(h.href), h = Ar(S).hoistableStyles, m = h.get(o), m || (m = {
                        type: "style",
                        instance: null,
                        count: 0,
                        state: null
                    }, h.set(o, m)), m) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                case "link":
                    if (h.rel === "stylesheet" && typeof h.href == "string" && typeof h.precedence == "string") {
                        s = Lh(h.href);
                        var A = Ar(S).hoistableStyles, B = A.get(s);
                        if (B || (S = S.ownerDocument || S, B = {
                            type: "stylesheet",
                            instance: null,
                            count: 0,
                            state: {
                                loading: 0,
                                preload: null
                            }
                        }, A.set(s, B), (A = S.querySelector(Fp(s))) && !A._p && (B.instance = A, B.state.loading = 5), pr.has(s) || (h = {
                            rel: "preload",
                            as: "style",
                            href: h.href,
                            crossOrigin: h.crossOrigin,
                            integrity: h.integrity,
                            media: h.media,
                            hrefLang: h.hrefLang,
                            referrerPolicy: h.referrerPolicy
                        }, pr.set(s, h), A || Tw(S, s, h, B.state))), o && m === null) throw Error(n(528, ""));
                        return B;
                    }
                    if (o && m !== null) throw Error(n(529, ""));
                    return null;
                case "script":
                    return o = h.async, h = h.src, typeof h == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = Oh(h), h = Ar(S).hoistableScripts, m = h.get(o), m || (m = {
                        type: "script",
                        instance: null,
                        count: 0,
                        state: null
                    }, h.set(o, m)), m) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                default:
                    throw Error(n(444, s));
            }
        }
        function Lh(s) {
            return 'href="' + zn(s) + '"';
        }
        function Fp(s) {
            return 'link[rel="stylesheet"][' + s + "]";
        }
        function Ob(s) {
            return g({}, s, {
                "data-precedence": s.precedence,
                precedence: null
            });
        }
        function Tw(s, o, h, m) {
            s.querySelector('link[rel="preload"][as="style"][' + o + "]") ? m.loading = 1 : (o = s.createElement("link"), m.preload = o, o.addEventListener("load", function() {
                return m.loading |= 1;
            }), o.addEventListener("error", function() {
                return m.loading |= 2;
            }), Ss(o, "link", h), yi(o), s.head.appendChild(o));
        }
        function Oh(s) {
            return '[src="' + zn(s) + '"]';
        }
        function Gp(s) {
            return "script[async]" + s;
        }
        function zb(s, o, h) {
            if (o.count++, o.instance === null) switch(o.type){
                case "style":
                    var m = s.querySelector('style[data-href~="' + zn(h.href) + '"]');
                    if (m) return o.instance = m, yi(m), m;
                    var S = g({}, h, {
                        "data-href": h.href,
                        "data-precedence": h.precedence,
                        href: null,
                        precedence: null
                    });
                    return m = (s.ownerDocument || s).createElement("style"), yi(m), Ss(m, "style", S), c0(m, h.precedence, s), o.instance = m;
                case "stylesheet":
                    S = Lh(h.href);
                    var A = s.querySelector(Fp(S));
                    if (A) return o.state.loading |= 4, o.instance = A, yi(A), A;
                    m = Ob(h), (S = pr.get(S)) && b_(m, S), A = (s.ownerDocument || s).createElement("link"), yi(A);
                    var B = A;
                    return B._p = new Promise(function(V, ee) {
                        B.onload = V, B.onerror = ee;
                    }), Ss(A, "link", m), o.state.loading |= 4, c0(A, h.precedence, s), o.instance = A;
                case "script":
                    return A = Oh(h.src), (S = s.querySelector(Gp(A))) ? (o.instance = S, yi(S), S) : (m = h, (S = pr.get(A)) && (m = g({}, h), M_(m, S)), s = s.ownerDocument || s, S = s.createElement("script"), yi(S), Ss(S, "link", m), s.head.appendChild(S), o.instance = S);
                case "void":
                    return null;
                default:
                    throw Error(n(443, o.type));
            }
            else o.type === "stylesheet" && (o.state.loading & 4) === 0 && (m = o.instance, o.state.loading |= 4, c0(m, h.precedence, s));
            return o.instance;
        }
        function c0(s, o, h) {
            for(var m = h.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), S = m.length ? m[m.length - 1] : null, A = S, B = 0; B < m.length; B++){
                var V = m[B];
                if (V.dataset.precedence === o) A = V;
                else if (A !== S) break;
            }
            A ? A.parentNode.insertBefore(s, A.nextSibling) : (o = h.nodeType === 9 ? h.head : h, o.insertBefore(s, o.firstChild));
        }
        function b_(s, o) {
            s.crossOrigin == null && (s.crossOrigin = o.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy), s.title == null && (s.title = o.title);
        }
        function M_(s, o) {
            s.crossOrigin == null && (s.crossOrigin = o.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy), s.integrity == null && (s.integrity = o.integrity);
        }
        var u0 = null;
        function Bb(s, o, h) {
            if (u0 === null) {
                var m = new Map, S = u0 = new Map;
                S.set(h, m);
            } else S = u0, m = S.get(h), m || (m = new Map, S.set(h, m));
            if (m.has(s)) return m;
            for(m.set(s, null), h = h.getElementsByTagName(s), S = 0; S < h.length; S++){
                var A = h[S];
                if (!(A[Ea] || A[vi] || s === "link" && A.getAttribute("rel") === "stylesheet") && A.namespaceURI !== "http://www.w3.org/2000/svg") {
                    var B = A.getAttribute(o) || "";
                    B = s + B;
                    var V = m.get(B);
                    V ? V.push(A) : m.set(B, [
                        A
                    ]);
                }
            }
            return m;
        }
        function Ib(s, o, h) {
            s = s.ownerDocument || s, s.head.insertBefore(h, o === "title" ? s.querySelector("head > title") : null);
        }
        function Aw(s, o, h) {
            if (h === 1 || o.itemProp != null) return !1;
            switch(s){
                case "meta":
                case "title":
                    return !0;
                case "style":
                    if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "") break;
                    return !0;
                case "link":
                    if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError) break;
                    switch(o.rel){
                        case "stylesheet":
                            return s = o.disabled, typeof o.precedence == "string" && s == null;
                        default:
                            return !0;
                    }
                case "script":
                    if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string") return !0;
            }
            return !1;
        }
        function Pb(s) {
            return !(s.type === "stylesheet" && (s.state.loading & 3) === 0);
        }
        var Vp = null;
        function ww() {}
        function Rw(s, o, h) {
            if (Vp === null) throw Error(n(475));
            var m = Vp;
            if (o.type === "stylesheet" && (typeof h.media != "string" || matchMedia(h.media).matches !== !1) && (o.state.loading & 4) === 0) {
                if (o.instance === null) {
                    var S = Lh(h.href), A = s.querySelector(Fp(S));
                    if (A) {
                        s = A._p, s !== null && typeof s == "object" && typeof s.then == "function" && (m.count++, m = f0.bind(m), s.then(m, m)), o.state.loading |= 4, o.instance = A, yi(A);
                        return;
                    }
                    A = s.ownerDocument || s, h = Ob(h), (S = pr.get(S)) && b_(h, S), A = A.createElement("link"), yi(A);
                    var B = A;
                    B._p = new Promise(function(V, ee) {
                        B.onload = V, B.onerror = ee;
                    }), Ss(A, "link", h), o.instance = A;
                }
                m.stylesheets === null && (m.stylesheets = new Map), m.stylesheets.set(o, s), (s = o.state.preload) && (o.state.loading & 3) === 0 && (m.count++, o = f0.bind(m), s.addEventListener("load", o), s.addEventListener("error", o));
            }
        }
        function Cw() {
            if (Vp === null) throw Error(n(475));
            var s = Vp;
            return s.stylesheets && s.count === 0 && E_(s, s.stylesheets), 0 < s.count ? function(o) {
                var h = setTimeout(function() {
                    if (s.stylesheets && E_(s, s.stylesheets), s.unsuspend) {
                        var m = s.unsuspend;
                        s.unsuspend = null, m();
                    }
                }, 6e4);
                return s.unsuspend = o, function() {
                    s.unsuspend = null, clearTimeout(h);
                };
            } : null;
        }
        function f0() {
            if (this.count--, this.count === 0) {
                if (this.stylesheets) E_(this, this.stylesheets);
                else if (this.unsuspend) {
                    var s = this.unsuspend;
                    this.unsuspend = null, s();
                }
            }
        }
        var h0 = null;
        function E_(s, o) {
            s.stylesheets = null, s.unsuspend !== null && (s.count++, h0 = new Map, o.forEach(Dw, s), h0 = null, f0.call(s));
        }
        function Dw(s, o) {
            if (!(o.state.loading & 4)) {
                var h = h0.get(s);
                if (h) var m = h.get(null);
                else {
                    h = new Map, h0.set(s, h);
                    for(var S = s.querySelectorAll("link[data-precedence],style[data-precedence]"), A = 0; A < S.length; A++){
                        var B = S[A];
                        (B.nodeName === "LINK" || B.getAttribute("media") !== "not all") && (h.set(B.dataset.precedence, B), m = B);
                    }
                    m && h.set(null, m);
                }
                S = o.instance, B = S.getAttribute("data-precedence"), A = h.get(B) || m, A === m && h.set(null, S), h.set(B, S), this.count++, m = f0.bind(this), S.addEventListener("load", m), S.addEventListener("error", m), A ? A.parentNode.insertBefore(S, A.nextSibling) : (s = s.nodeType === 9 ? s.head : s, s.insertBefore(S, s.firstChild)), o.state.loading |= 4;
            }
        }
        var kp = {
            $$typeof: N,
            Provider: null,
            Consumer: null,
            _currentValue: Q,
            _currentValue2: Q,
            _threadCount: 0
        };
        function Nw(s, o, h, m, S, A, B, V) {
            this.tag = 1, this.containerInfo = s, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Ve(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ve(0), this.hiddenUpdates = Ve(null), this.identifierPrefix = m, this.onUncaughtError = S, this.onCaughtError = A, this.onRecoverableError = B, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = V, this.incompleteTransitions = new Map;
        }
        function Hb(s, o, h, m, S, A, B, V, ee, Me, ze, ke) {
            return s = new Nw(s, o, h, B, V, ee, Me, ke), o = 1, A === !0 && (o |= 24), A = Rs(3, null, null, o), s.current = A, A.stateNode = s, o = th(), o.refCount++, s.pooledCache = o, o.refCount++, A.memoizedState = {
                element: m,
                isDehydrated: h,
                cache: o
            }, dp(A), s;
        }
        function Fb(s) {
            return s ? (s = vo, s) : vo;
        }
        function Gb(s, o, h, m, S, A) {
            S = Fb(S), m.context === null ? m.context = S : m.pendingContext = S, m = tr(o), m.payload = {
                element: h
            }, A = A === void 0 ? null : A, A !== null && (m.callback = A), h = Fr(s, m, o), h !== null && (xs(h, s, o), nl(h, s, o));
        }
        function Vb(s, o) {
            if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
                var h = s.retryLane;
                s.retryLane = h !== 0 && h < o ? h : o;
            }
        }
        function T_(s, o) {
            Vb(s, o), (s = s.alternate) && Vb(s, o);
        }
        function kb(s) {
            if (s.tag === 13) {
                var o = zr(s, 67108864);
                o !== null && xs(o, s, 67108864), T_(s, 67108864);
            }
        }
        var d0 = !0;
        function Uw(s, o, h, m) {
            var S = H.T;
            H.T = null;
            var A = K.p;
            try {
                K.p = 2, A_(s, o, h, m);
            } finally{
                K.p = A, H.T = S;
            }
        }
        function Lw(s, o, h, m) {
            var S = H.T;
            H.T = null;
            var A = K.p;
            try {
                K.p = 8, A_(s, o, h, m);
            } finally{
                K.p = A, H.T = S;
            }
        }
        function A_(s, o, h, m) {
            if (d0) {
                var S = w_(m);
                if (S === null) d_(s, o, m, p0, h), jb(s, m);
                else if (zw(S, s, o, h, m)) m.stopPropagation();
                else if (jb(s, m), o & 4 && -1 < Ow.indexOf(s)) {
                    for(; S !== null;){
                        var A = Aa(S);
                        if (A !== null) switch(A.tag){
                            case 3:
                                if (A = A.stateNode, A.current.memoizedState.isDehydrated) {
                                    var B = St(A.pendingLanes);
                                    if (B !== 0) {
                                        var V = A;
                                        for(V.pendingLanes |= 2, V.entangledLanes |= 2; B;){
                                            var ee = 1 << 31 - lt(B);
                                            V.entanglements[1] |= ee, B &= ~ee;
                                        }
                                        Go(A), (wn & 6) === 0 && (as = We() + 500, Bp(0));
                                    }
                                }
                                break;
                            case 13:
                                V = zr(A, 2), V !== null && xs(V, A, 2), hr(), T_(A, 2);
                        }
                        if (A = w_(m), A === null && d_(s, o, m, p0, h), A === S) break;
                        S = A;
                    }
                    S !== null && m.stopPropagation();
                } else d_(s, o, m, null, h);
            }
        }
        function w_(s) {
            return s = Bf(s), R_(s);
        }
        var p0 = null;
        function R_(s) {
            if (p0 = null, s = Ta(s), s !== null) {
                var o = a(s);
                if (o === null) s = null;
                else {
                    var h = o.tag;
                    if (h === 13) {
                        if (s = l(o), s !== null) return s;
                        s = null;
                    } else if (h === 3) {
                        if (o.stateNode.current.memoizedState.isDehydrated) return o.tag === 3 ? o.stateNode.containerInfo : null;
                        s = null;
                    } else o !== s && (s = null);
                }
            }
            return p0 = s, null;
        }
        function Xb(s) {
            switch(s){
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 8;
                case "message":
                    switch(Be()){
                        case ut:
                            return 2;
                        case Xe:
                            return 8;
                        case ot:
                        case It:
                            return 32;
                        case Z:
                            return 268435456;
                        default:
                            return 32;
                    }
                default:
                    return 32;
            }
        }
        var C_ = !1, Ac = null, wc = null, Rc = null, Xp = new Map, jp = new Map, Cc = [], Ow = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
        function jb(s, o) {
            switch(s){
                case "focusin":
                case "focusout":
                    Ac = null;
                    break;
                case "dragenter":
                case "dragleave":
                    wc = null;
                    break;
                case "mouseover":
                case "mouseout":
                    Rc = null;
                    break;
                case "pointerover":
                case "pointerout":
                    Xp.delete(o.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    jp.delete(o.pointerId);
            }
        }
        function qp(s, o, h, m, S, A) {
            return s === null || s.nativeEvent !== A ? (s = {
                blockedOn: o,
                domEventName: h,
                eventSystemFlags: m,
                nativeEvent: A,
                targetContainers: [
                    S
                ]
            }, o !== null && (o = Aa(o), o !== null && kb(o)), s) : (s.eventSystemFlags |= m, o = s.targetContainers, S !== null && o.indexOf(S) === -1 && o.push(S), s);
        }
        function zw(s, o, h, m, S) {
            switch(o){
                case "focusin":
                    return Ac = qp(Ac, s, o, h, m, S), !0;
                case "dragenter":
                    return wc = qp(wc, s, o, h, m, S), !0;
                case "mouseover":
                    return Rc = qp(Rc, s, o, h, m, S), !0;
                case "pointerover":
                    var A = S.pointerId;
                    return Xp.set(A, qp(Xp.get(A) || null, s, o, h, m, S)), !0;
                case "gotpointercapture":
                    return A = S.pointerId, jp.set(A, qp(jp.get(A) || null, s, o, h, m, S)), !0;
            }
            return !1;
        }
        function qb(s) {
            var o = Ta(s.target);
            if (o !== null) {
                var h = a(o);
                if (h !== null) {
                    if (o = h.tag, o === 13) {
                        if (o = l(h), o !== null) {
                            s.blockedOn = o, gi(s.priority, function() {
                                if (h.tag === 13) {
                                    var m = si();
                                    m = Mt(m);
                                    var S = zr(h, m);
                                    S !== null && xs(S, h, m), T_(h, m);
                                }
                            });
                            return;
                        }
                    } else if (o === 3 && h.stateNode.current.memoizedState.isDehydrated) {
                        s.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
                        return;
                    }
                }
            }
            s.blockedOn = null;
        }
        function m0(s) {
            if (s.blockedOn !== null) return !1;
            for(var o = s.targetContainers; 0 < o.length;){
                var h = w_(s.nativeEvent);
                if (h === null) {
                    h = s.nativeEvent;
                    var m = new h.constructor(h.type, h);
                    zf = m, h.target.dispatchEvent(m), zf = null;
                } else return o = Aa(h), o !== null && kb(o), s.blockedOn = h, !1;
                o.shift();
            }
            return !0;
        }
        function Yb(s, o, h) {
            m0(s) && h.delete(o);
        }
        function Bw() {
            C_ = !1, Ac !== null && m0(Ac) && (Ac = null), wc !== null && m0(wc) && (wc = null), Rc !== null && m0(Rc) && (Rc = null), Xp.forEach(Yb), jp.forEach(Yb);
        }
        function g0(s, o) {
            s.blockedOn === o && (s.blockedOn = null, C_ || (C_ = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Bw)));
        }
        var v0 = null;
        function Wb(s) {
            v0 !== s && (v0 = s, r.unstable_scheduleCallback(r.unstable_NormalPriority, function() {
                v0 === s && (v0 = null);
                for(var o = 0; o < s.length; o += 3){
                    var h = s[o], m = s[o + 1], S = s[o + 2];
                    if (typeof m != "function") {
                        if (R_(m || h) === null) continue;
                        break;
                    }
                    var A = Aa(h);
                    A !== null && (s.splice(o, 3), o -= 3, Cp(A, {
                        pending: !0,
                        data: S,
                        method: h.method,
                        action: m
                    }, m, S));
                }
            }));
        }
        function Yp(s) {
            function o(ee) {
                return g0(ee, s);
            }
            Ac !== null && g0(Ac, s), wc !== null && g0(wc, s), Rc !== null && g0(Rc, s), Xp.forEach(o), jp.forEach(o);
            for(var h = 0; h < Cc.length; h++){
                var m = Cc[h];
                m.blockedOn === s && (m.blockedOn = null);
            }
            for(; 0 < Cc.length && (h = Cc[0], h.blockedOn === null);)qb(h), h.blockedOn === null && Cc.shift();
            if (h = (s.ownerDocument || s).$$reactFormReplay, h != null) for(m = 0; m < h.length; m += 3){
                var S = h[m], A = h[m + 1], B = S[Ei] || null;
                if (typeof A == "function") B || Wb(h);
                else if (B) {
                    var V = null;
                    if (A && A.hasAttribute("formAction")) {
                        if (S = A, B = A[Ei] || null) V = B.formAction;
                        else if (R_(S) !== null) continue;
                    } else V = B.action;
                    typeof V == "function" ? h[m + 1] = V : (h.splice(m, 3), m -= 3), Wb(h);
                }
            }
        }
        function D_(s) {
            this._internalRoot = s;
        }
        y0.prototype.render = D_.prototype.render = function(s) {
            var o = this._internalRoot;
            if (o === null) throw Error(n(409));
            var h = o.current, m = si();
            Gb(h, m, s, o, null, null);
        }, y0.prototype.unmount = D_.prototype.unmount = function() {
            var s = this._internalRoot;
            if (s !== null) {
                this._internalRoot = null;
                var o = s.containerInfo;
                Gb(s.current, 2, null, s, null, null), hr(), o[ns] = null;
            }
        };
        function y0(s) {
            this._internalRoot = s;
        }
        y0.prototype.unstable_scheduleHydration = function(s) {
            if (s) {
                var o = Zt();
                s = {
                    blockedOn: null,
                    target: s,
                    priority: o
                };
                for(var h = 0; h < Cc.length && o !== 0 && o < Cc[h].priority; h++);
                Cc.splice(h, 0, s), h === 0 && qb(s);
            }
        };
        var Zb = e.version;
        if (Zb !== "19.1.0") throw Error(n(527, Zb, "19.1.0"));
        K.findDOMNode = function(s) {
            var o = s._reactInternals;
            if (o === void 0) throw typeof s.render == "function" ? Error(n(188)) : (s = Object.keys(s).join(","), Error(n(268, s)));
            return s = d(o), s = s !== null ? p(s) : null, s = s === null ? null : s.stateNode, s;
        };
        var Iw = {
            bundleType: 0,
            version: "19.1.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: H,
            reconcilerVersion: "19.1.0"
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
            var _0 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!_0.isDisabled && _0.supportsFiber) try {
                Ue = _0.inject(Iw), Le = _0;
            } catch  {}
        }
        return Zp.createRoot = function(s, o) {
            if (!i(s)) throw Error(n(299));
            var h = !1, m = "", S = Fu, A = yh, B = $g, V = null;
            return o != null && (o.unstable_strictMode === !0 && (h = !0), o.identifierPrefix !== void 0 && (m = o.identifierPrefix), o.onUncaughtError !== void 0 && (S = o.onUncaughtError), o.onCaughtError !== void 0 && (A = o.onCaughtError), o.onRecoverableError !== void 0 && (B = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (V = o.unstable_transitionCallbacks)), o = Hb(s, 1, !1, null, null, h, m, S, A, B, V, null), s[ns] = o.current, h_(s), new D_(o);
        }, Zp.hydrateRoot = function(s, o, h) {
            if (!i(s)) throw Error(n(299));
            var m = !1, S = "", A = Fu, B = yh, V = $g, ee = null, Me = null;
            return h != null && (h.unstable_strictMode === !0 && (m = !0), h.identifierPrefix !== void 0 && (S = h.identifierPrefix), h.onUncaughtError !== void 0 && (A = h.onUncaughtError), h.onCaughtError !== void 0 && (B = h.onCaughtError), h.onRecoverableError !== void 0 && (V = h.onRecoverableError), h.unstable_transitionCallbacks !== void 0 && (ee = h.unstable_transitionCallbacks), h.formState !== void 0 && (Me = h.formState)), o = Hb(s, 1, !0, o, h ?? null, m, S, A, B, V, ee, Me), o.context = Fb(null), h = o.current, m = si(), m = Mt(m), S = tr(m), S.callback = null, Fr(h, S, m), h = m, o.current.lanes = h, rt(o, h), Go(o), s[ns] = o.current, h_(s), new y0(o);
        }, Zp.version = "19.1.0", Zp;
    }
    var aM;
    function Yw() {
        if (aM) return L_.exports;
        aM = 1;
        function r() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r);
            } catch (e) {
                console.error(e);
            }
        }
        return r(), L_.exports = qw(), L_.exports;
    }
    var Ww = Yw();
    const Zw = hy(Ww), Kw = "modulepreload", Qw = function(r) {
        return "/" + r;
    }, rM = {}, Jw = function(e, t, n) {
        let i = Promise.resolve();
        if (t && t.length > 0) {
            let l = function(p) {
                return Promise.all(p.map((g)=>Promise.resolve(g).then((y)=>({
                            status: "fulfilled",
                            value: y
                        }), (y)=>({
                            status: "rejected",
                            reason: y
                        }))));
            };
            document.getElementsByTagName("link");
            const f = document.querySelector("meta[property=csp-nonce]"), d = f?.nonce || f?.getAttribute("nonce");
            i = l(t.map((p)=>{
                if (p = Qw(p), p in rM) return;
                rM[p] = !0;
                const g = p.endsWith(".css"), y = g ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${p}"]${y}`)) return;
                const _ = document.createElement("link");
                if (_.rel = g ? "stylesheet" : Kw, g || (_.as = "script"), _.crossOrigin = "", _.href = p, d && _.setAttribute("nonce", d), document.head.appendChild(_), g) return new Promise((x, M)=>{
                    _.addEventListener("load", x), _.addEventListener("error", ()=>M(new Error(`Unable to preload CSS for ${p}`)));
                });
            }));
        }
        function a(l) {
            const f = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (f.payload = l, window.dispatchEvent(f), !f.defaultPrevented) throw l;
        }
        return i.then((l)=>{
            for (const f of l || [])f.status === "rejected" && a(f.reason);
            return e().catch(a);
        });
    };
    let mf = null, xv = !1;
    async function $w() {
        if (xv && mf) return mf;
        try {
            const r = await Jw(()=>import("./pixie_juice-DME47-3W.js").then(async (m)=>{
                    await m.__tla;
                    return m;
                }), []);
            return mf = {
                optimize_image: r.optimize_image,
                optimize_mesh: r.optimize_mesh,
                optimize_auto: r.optimize_auto,
                detect_format: r.detect_format,
                version: r.version,
                optimize_png: r.optimize_png,
                optimize_jpeg: r.optimize_jpeg,
                optimize_webp: r.optimize_webp,
                optimize_gif: r.optimize_gif,
                optimize_ico: r.optimize_ico,
                is_webp: r.is_webp,
                is_gif: r.is_gif,
                is_ico: r.is_ico,
                convert_to_webp: r.convert_to_webp,
                convert_to_png: r.convert_to_png,
                convert_to_jpeg: r.convert_to_jpeg,
                convert_to_bmp: r.convert_to_bmp,
                convert_to_gif: r.convert_to_gif,
                convert_to_ico: r.convert_to_ico,
                convert_to_tiff: r.convert_to_tiff,
                convert_to_svg: r.convert_to_svg,
                get_performance_metrics: r.get_performance_metrics,
                reset_performance_stats: r.reset_performance_stats,
                check_performance_compliance: r.check_performance_compliance,
                set_lossless_mode: r.set_lossless_mode,
                set_preserve_metadata: r.set_preserve_metadata,
                build_timestamp: r.build_timestamp,
                pixie_get_memory_target_mb: r.pixie_get_memory_target_mb
            }, xv = !0, mf;
        } catch (r) {
            throw console.error("Failed to initialize WASM module:", r), new Error(`WASM initialization failed: ${r instanceof Error ? r.message : String(r)}`);
        }
    }
    function eR() {
        if (!xv || !mf) throw new Error("WASM module not initialized. Call initWasm() first.");
        return mf;
    }
    function tR() {
        return xv && mf !== null;
    }
    const nR = ()=>{
        const [r, e] = qe.useState(null), [t, n] = qe.useState(!0), [i, a] = qe.useState(null);
        return qe.useEffect(()=>{
            let l = !0;
            return (async ()=>{
                try {
                    if (n(!0), a(null), tR()) {
                        const p = eR();
                        l && (e(p), n(!1));
                        return;
                    }
                    const d = await $w();
                    l && (e(d), n(!1), typeof window < "u" && (window.pixieJuice = d));
                } catch (d) {
                    console.error("WASM loading error:", d), l && (a(d instanceof Error ? d.message : String(d)), n(!1));
                }
            })(), ()=>{
                l = !1;
            };
        }, []), {
            optimize_image: r?.optimize_image,
            optimize_mesh: r?.optimize_mesh,
            optimize_auto: r?.optimize_auto,
            optimize_png: r?.optimize_png,
            optimize_jpeg: r?.optimize_jpeg,
            optimize_webp: r?.optimize_webp,
            optimize_gif: r?.optimize_gif,
            optimize_ico: r?.optimize_ico,
            optimize_obj: r?.optimize_obj,
            optimize_stl: r?.optimize_stl,
            optimize_fbx: r?.optimize_fbx,
            optimize_gltf: r?.optimize_gltf,
            optimize_ply: r?.optimize_ply,
            detect_format: r?.detect_format,
            is_webp: r?.is_webp,
            is_gif: r?.is_gif,
            is_ico: r?.is_ico,
            convert_to_webp: r?.convert_to_webp,
            convert_to_png: r?.convert_to_png,
            convert_to_jpeg: r?.convert_to_jpeg,
            convert_to_bmp: r?.convert_to_bmp,
            convert_to_gif: r?.convert_to_gif,
            convert_to_ico: r?.convert_to_ico,
            convert_to_tiff: r?.convert_to_tiff,
            convert_to_svg: r?.convert_to_svg,
            get_performance_metrics: r?.get_performance_metrics,
            reset_performance_stats: r?.reset_performance_stats,
            check_performance_compliance: r?.check_performance_compliance,
            set_lossless_mode: r?.set_lossless_mode,
            set_preserve_metadata: r?.set_preserve_metadata,
            version: r?.version,
            build_timestamp: r?.build_timestamp,
            pixie_get_memory_target_mb: r?.pixie_get_memory_target_mb,
            loading: t,
            error: i,
            available: !!r && !t && !i
        };
    }, oM = [
        ".png",
        ".jpg",
        ".jpeg",
        ".gif",
        ".webp",
        ".bmp",
        ".ico",
        ".tiff",
        ".tif",
        ".svg",
        ".tga"
    ], iR = [
        ".obj",
        ".ply",
        ".gltf",
        ".glb",
        ".fbx",
        ".stl"
    ];
    function lM({ selectedFiles: r, setSelectedFiles: e, onFileSelect: t }) {
        const [n, i] = qe.useState(!1), a = qe.useCallback((_)=>{
            const x = _.filter((R)=>{
                const T = R.name.toLowerCase(), E = R.type.toLowerCase();
                return !!(E.startsWith("image/") || E === "application/pdf" || T.endsWith(".pdf") || oM.some((C)=>T.endsWith(C)) || iR.some((C)=>T.endsWith(C)));
            });
            if (x.length === 0) {
                alert(`Please select valid files:
 Images: PNG, JPEG, WebP, GIF, BMP, ICO, TIFF, SVG, TGA
 3D Models: OBJ, PLY, STL, GLTF, GLB, FBX`);
                return;
            }
            const M = x.filter((R)=>!r.some((T)=>T.name === R.name));
            M.length > 0 && (e((R)=>[
                    ...R,
                    ...M
                ]), t && M.length > 0 && t(M[0]));
        }, [
            r,
            e,
            t
        ]), l = qe.useCallback((_)=>{
            _.preventDefault(), i(!1);
            const x = Array.from(_.dataTransfer.files);
            a(x);
        }, [
            a
        ]), f = qe.useCallback((_)=>{
            const x = Array.from(_.target.files || []);
            a(x);
        }, [
            a
        ]), d = qe.useCallback((_)=>{
            e((x)=>x.filter((M, R)=>R !== _));
        }, [
            e
        ]), p = qe.useCallback((_)=>{
            _.preventDefault(), i(!0);
        }, []), g = qe.useCallback((_)=>{
            _.preventDefault(), i(!1);
        }, []), y = (_)=>{
            const x = _.name.toLowerCase();
            return _.type.startsWith("image/") || oM.some((M)=>x.endsWith(M));
        };
        return ae.jsxs("div", {
            className: "rounded-sm overflow-hidden",
            children: [
                ae.jsx("div", {
                    className: "p-4 border-b border-neutral-800",
                    children: ae.jsx("h3", {
                        className: "text-sm font-normal text-white text-center",
                        children: "Files"
                    })
                }),
                ae.jsxs("div", {
                    className: `p-8 text-center transition-colors cursor-pointer ${r.length === 0 ? "border-b border-dashed border-neutral-800" : ""} ${n ? "bg-neutral-900/50" : "hover:bg-neutral-900/20"}`,
                    onDrop: l,
                    onDragOver: p,
                    onDragLeave: g,
                    onClick: ()=>document.getElementById("file-input")?.click(),
                    children: [
                        ae.jsxs("div", {
                            className: "flex flex-col items-center justify-center",
                            children: [
                                ae.jsx("div", {
                                    className: "text-2xl mb-2",
                                    children: ""
                                }),
                                ae.jsx("h3", {
                                    className: "text-sm font-normal text-white mb-2",
                                    children: "Drop files or click to upload"
                                }),
                                ae.jsx("p", {
                                    className: "text-[10px] mb-4 text-neutral-500",
                                    children: "OBJ, PLY, STL, GLTF, GLB, FBX, PNG, JPEG, WebP, GIF, BMP, TIFF, SVG, TGA, ICO"
                                }),
                                ae.jsx("button", {
                                    className: "px-4 py-2 border border-white text-white text-sm rounded hover:bg-white hover:text-black transition-colors",
                                    children: "Choose Files"
                                })
                            ]
                        }),
                        ae.jsx("input", {
                            id: "file-input",
                            type: "file",
                            multiple: !0,
                            accept: ".png,.jpg,.jpeg,.gif,.webp,.bmp,.ico,.tiff,.tif,.svg,.tga,.obj,.ply,.gltf,.glb,.fbx,.stl",
                            onChange: f,
                            className: "hidden"
                        })
                    ]
                }),
                r.length > 0 && ae.jsxs("div", {
                    className: "p-4",
                    children: [
                        ae.jsxs("div", {
                            className: "flex items-center justify-between mb-3",
                            children: [
                                ae.jsxs("h4", {
                                    className: "text-xs text-neutral-400",
                                    children: [
                                        r.length,
                                        " file",
                                        r.length !== 1 ? "s" : "",
                                        " selected"
                                    ]
                                }),
                                ae.jsx("button", {
                                    onClick: ()=>e([]),
                                    className: "text-xs text-neutral-500 hover:text-white",
                                    children: "Clear all"
                                })
                            ]
                        }),
                        ae.jsx("div", {
                            className: "space-y-2 max-h-56 overflow-y-auto pr-1",
                            children: r.map((_, x)=>ae.jsxs("div", {
                                    className: "flex items-center justify-between p-2.5 border border-neutral-800 rounded hover:border-neutral-700 transition-colors",
                                    onClick: ()=>t && t(_),
                                    children: [
                                        ae.jsxs("div", {
                                            className: "flex items-center space-x-2.5",
                                            children: [
                                                ae.jsx("div", {
                                                    className: "text-lg",
                                                    children: y(_) ? "" : ""
                                                }),
                                                ae.jsxs("div", {
                                                    className: "flex-1 min-w-0",
                                                    children: [
                                                        ae.jsx("p", {
                                                            className: "text-xs text-white truncate max-w-[240px]",
                                                            children: _.name
                                                        }),
                                                        ae.jsxs("p", {
                                                            className: "text-xs text-neutral-500",
                                                            children: [
                                                                (_.size / 1024 / 1024).toFixed(2),
                                                                " MB"
                                                            ]
                                                        })
                                                    ]
                                                })
                                            ]
                                        }),
                                        ae.jsx("button", {
                                            onClick: (M)=>{
                                                M.stopPropagation(), d(x);
                                            },
                                            className: "ml-2 text-neutral-500 hover:text-red-400 p-1.5 transition-colors",
                                            title: "Remove file",
                                            children: ""
                                        })
                                    ]
                                }, x))
                        })
                    ]
                })
            ]
        });
    }
    const sR = (r)=>new Promise((e, t)=>{
            if (!r) {
                t(new Error("File is null or undefined"));
                return;
            }
            const n = new FileReader;
            n.onload = ()=>{
                const i = n.result;
                if (!i || !(i instanceof ArrayBuffer)) {
                    t(new Error("FileReader returned invalid result"));
                    return;
                }
                const a = new Uint8Array(i);
                if (a.length === 0) {
                    t(new Error("File data is empty"));
                    return;
                }
                e(a);
            }, n.onerror = ()=>t(new Error("FileReader error")), n.readAsArrayBuffer(r);
        }), cM = (r)=>{
        const e = r.name.toLowerCase().split(".").pop() || "";
        return r.type.startsWith("image/") || [
            "svg",
            "png",
            "jpg",
            "jpeg",
            "gif",
            "webp",
            "bmp",
            "ico",
            "tiff",
            "tif",
            "tga",
            "targa"
        ].includes(e) ? "image" : [
            "obj",
            "stl",
            "fbx",
            "gltf",
            "glb",
            "ply"
        ].includes(e) ? "mesh" : "unknown";
    };
    function aR({ files: r, wasm: e, onProcess: t, setIsProcessing: n }) {
        const [i, a] = qe.useState(75), [l, f] = qe.useState("auto"), [d, p] = qe.useState(!1), [g, y] = qe.useState(!1), [_, x] = qe.useState(0), [M, R] = qe.useState(""), [T, E] = qe.useState(!1), C = qe.useCallback(async ()=>{
            if (!e.available || r.length === 0) return;
            E(!0), n(!0), x(0);
            try {
                e.set_preserve_metadata && e.set_preserve_metadata(d);
                const D = g || i >= 95;
                e.set_lossless_mode && e.set_lossless_mode(D);
            } catch (D) {
                console.warn("Configuration setting failed:", D);
            }
            const N = [];
            try {
                for(let D = 0; D < r.length; D++){
                    const I = r[D];
                    R(I.name), x((D + 1) / r.length * 100);
                    try {
                        const O = await sR(I);
                        if (!O || O.length === 0) throw new Error(`File data is empty for ${I.name}`);
                        let P, F;
                        const z = cM(I), L = I.name.toLowerCase().split(".").pop() || "";
                        if (z === "image") {
                            let q = "unknown";
                            if (e.detect_format) try {
                                q = e.detect_format(O);
                            } catch  {
                                q = "unknown";
                            }
                            let oe;
                            if (q && q !== "unknown" && !q.startsWith("image:") ? oe = q : q.startsWith("image:") ? oe = q.split(":")[1] : L === "svg" ? oe = "svg" : I.type.includes("/") ? oe = I.type.split("/")[1] : oe = L, F = l === "auto" ? oe : l, l === "auto") if (e.optimize_auto) P = e.optimize_auto(O, i);
                            else if (e.optimize_image) P = e.optimize_image(O, i);
                            else throw new Error("No optimization function available");
                            else if (l !== oe) {
                                const se = `convert_to_${l}`, ge = e[se];
                                if (typeof ge == "function") l === "png" ? P = ge(O) : P = ge(O, i);
                                else throw new Error(`Conversion to ${l} not supported`);
                            } else {
                                const se = `optimize_${l}`, ge = e[se];
                                if (typeof ge == "function") P = ge(O, i);
                                else if (e.optimize_image) P = e.optimize_image(O, i);
                                else throw new Error("No optimization function available");
                            }
                            N.push({
                                originalFile: I,
                                originalData: O,
                                optimizedData: P,
                                targetFormat: F,
                                originalSize: O.length,
                                optimizedSize: P.length,
                                savings: (O.length - P.length) / O.length * 100,
                                success: !0,
                                fileType: "image",
                                performanceMetrics: e.get_performance_metrics?.() || null
                            });
                        } else if (z === "mesh") {
                            F = L;
                            const q = Math.max((100 - i) / 100, .1), se = {
                                obj: e.optimize_obj,
                                stl: e.optimize_stl,
                                fbx: e.optimize_fbx,
                                gltf: e.optimize_gltf,
                                glb: e.optimize_gltf,
                                ply: e.optimize_ply
                            }[L] || e.optimize_mesh;
                            if (!se) throw new Error(`No optimizer available for ${L.toUpperCase()} format`);
                            P = se(O, q), N.push({
                                originalFile: I,
                                originalData: O,
                                optimizedData: P,
                                targetFormat: F,
                                originalSize: O.length,
                                optimizedSize: P.length,
                                savings: (O.length - P.length) / O.length * 100,
                                success: !0,
                                fileType: "mesh",
                                performanceMetrics: e.get_performance_metrics?.() || null
                            });
                        } else throw new Error(`Unsupported file format: ${L}`);
                    } catch (O) {
                        N.push({
                            originalFile: I,
                            error: String(O),
                            success: !1,
                            fileType: cM(I)
                        });
                    }
                }
                if (e.check_performance_compliance) try {
                    e.check_performance_compliance() || console.warn("Performance targets exceeded during processing");
                } catch (D) {
                    console.warn("Failed to check performance compliance:", D);
                }
                t(N);
            } catch (D) {
                console.error("Processing failed:", D), alert("Processing failed. Please try again.");
            } finally{
                E(!1), n(!1), x(0), R("");
            }
        }, [
            r,
            e,
            i,
            l,
            d,
            g,
            t,
            n
        ]);
        return T ? ae.jsxs("div", {
            className: "border border-neutral-800 rounded-lg overflow-hidden",
            children: [
                ae.jsx("div", {
                    className: "p-4 border-b border-neutral-800",
                    children: ae.jsx("h3", {
                        className: "text-sm font-normal text-white",
                        children: "Processing"
                    })
                }),
                ae.jsx("div", {
                    className: "p-6",
                    children: ae.jsxs("div", {
                        className: "space-y-4",
                        children: [
                            ae.jsx("div", {
                                className: "w-full bg-neutral-900 rounded-full h-2",
                                children: ae.jsx("div", {
                                    className: "bg-white h-2 rounded-full transition-all duration-300",
                                    style: {
                                        width: `${_}%`
                                    }
                                })
                            }),
                            ae.jsxs("div", {
                                className: "flex items-center justify-between text-xs text-neutral-400",
                                children: [
                                    ae.jsx("p", {
                                        className: "truncate max-w-xs",
                                        children: M
                                    }),
                                    ae.jsxs("p", {
                                        className: "text-right",
                                        children: [
                                            Math.round(_),
                                            "%"
                                        ]
                                    })
                                ]
                            })
                        ]
                    })
                })
            ]
        }) : ae.jsxs("div", {
            className: "rounded-lg overflow-hidden",
            children: [
                ae.jsx("div", {
                    className: "p-4 border-b border-neutral-800",
                    children: ae.jsx("h3", {
                        className: "text-sm font-normal text-white text-center",
                        children: "Settings"
                    })
                }),
                ae.jsxs("div", {
                    className: "p-6 space-y-5",
                    children: [
                        ae.jsxs("div", {
                            children: [
                                ae.jsxs("div", {
                                    className: "flex items-center justify-between mb-3",
                                    children: [
                                        ae.jsx("label", {
                                            htmlFor: "quality",
                                            className: "text-xs text-neutral-400",
                                            children: "Quality"
                                        }),
                                        ae.jsx("div", {
                                            className: "flex items-center space-x-2",
                                            children: ae.jsxs("span", {
                                                className: "text-xs font-mono text-white bg-neutral-800 px-2 py-1 rounded",
                                                children: [
                                                    i,
                                                    "%"
                                                ]
                                            })
                                        })
                                    ]
                                }),
                                ae.jsxs("div", {
                                    className: "relative",
                                    children: [
                                        ae.jsx("div", {
                                            className: "absolute top-0 left-0 right-0 h-1 bg-neutral-700 rounded-full pointer-events-none"
                                        }),
                                        ae.jsx("div", {
                                            className: "absolute top-0 left-0 h-1 bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 rounded-full pointer-events-none transition-all duration-200",
                                            style: {
                                                width: `${(i - 10) / 90 * 100}%`
                                            }
                                        }),
                                        ae.jsx("input", {
                                            id: "quality",
                                            type: "range",
                                            min: "10",
                                            max: "100",
                                            value: i,
                                            onChange: (N)=>a(parseInt(N.target.value)),
                                            className: "quality-slider w-full h-1 bg-transparent appearance-none cursor-pointer relative z-10"
                                        })
                                    ]
                                }),
                                ae.jsxs("div", {
                                    className: "flex justify-between text-xs text-neutral-600 mt-2 px-1",
                                    children: [
                                        ae.jsx("span", {
                                            children: "10%"
                                        }),
                                        ae.jsx("span", {
                                            children: "50%"
                                        }),
                                        ae.jsx("span", {
                                            children: "100%"
                                        })
                                    ]
                                }),
                                ae.jsx("style", {
                                    children: `
            .quality-slider::-webkit-slider-thumb {
              appearance: none;
              height: 14px;
              width: 14px;
              border-radius: 50%;
              background: #ffffff;
              border: 2px solid #525252;
              cursor: pointer;
              box-shadow: 0 1px 3px rgba(0,0,0,0.4);
              transition: all 0.15s ease;
              margin-top: -20px;
            }
            .quality-slider::-webkit-slider-thumb:hover {
              transform: scale(1.2);
              border-color: #737373;
              box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            }
            .quality-slider::-moz-range-thumb {
              width: 14px;
              height: 14px;
              border-radius: 50%;
              background: #ffffff;
              border: 2px solid #525252;
              cursor: pointer;
              box-shadow: 0 1px 3px rgba(0,0,0,0.4);
            }
            .quality-slider::-moz-range-track {
              background: transparent;
              height: 1px;
              border: none;
            }
          `
                                }),
                                ae.jsx("div", {
                                    className: "text-xs text-neutral-500 mt-2",
                                    children: i <= 30 ? "Maximum compression (may affect quality)" : i <= 60 ? "High compression" : "Balanced compression"
                                })
                            ]
                        }),
                        ae.jsxs("div", {
                            children: [
                                ae.jsx("label", {
                                    htmlFor: "format",
                                    className: "block text-xs text-neutral-400 mb-1.5",
                                    children: "Output Format"
                                }),
                                ae.jsxs("select", {
                                    id: "format",
                                    value: l,
                                    onChange: (N)=>f(N.target.value),
                                    className: "w-full p-2.5 text-sm bg-black border border-neutral-800 rounded-md text-white focus:border-neutral-600 focus:outline-none",
                                    children: [
                                        ae.jsx("option", {
                                            value: "auto",
                                            children: "Auto (Smart Optimization)"
                                        }),
                                        ae.jsxs("optgroup", {
                                            label: "Image Formats",
                                            children: [
                                                ae.jsx("option", {
                                                    value: "png",
                                                    children: "PNG (Lossless)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "jpeg",
                                                    children: "JPEG (Lossy)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "webp",
                                                    children: "WebP (Modern)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "bmp",
                                                    children: "BMP (Basic)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "gif",
                                                    children: "GIF (Animation)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "ico",
                                                    children: "ICO (Icons)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "tiff",
                                                    children: "TIFF (Professional)"
                                                }),
                                                ae.jsx("option", {
                                                    value: "svg",
                                                    children: "SVG (Vector)"
                                                })
                                            ]
                                        })
                                    ]
                                }),
                                ae.jsx("div", {
                                    className: "text-xs text-neutral-500 mt-1",
                                    children: l === "auto" ? "Intelligent format selection based on content" : l === "webp" ? "Modern format with excellent compression" : l === "svg" ? "Vector format, scalable graphics" : l === "ico" ? "Icon format for favicons and applications" : l === "png" ? "Lossless format, preserves quality" : l === "jpeg" ? "Widely supported, good for photos" : l === "gif" ? "Animation support, good for simple graphics" : l === "bmp" ? "Basic format, widely compatible" : l === "tiff" ? "Professional format, high quality" : "Select a format for conversion and optimization"
                                })
                            ]
                        }),
                        ae.jsx("div", {
                            children: ae.jsxs("label", {
                                className: "flex items-center space-x-3 cursor-pointer",
                                children: [
                                    ae.jsx("input", {
                                        type: "checkbox",
                                        checked: d,
                                        onChange: (N)=>p(N.target.checked),
                                        className: "w-4 h-4 bg-black border border-neutral-800 rounded focus:ring-1 focus:ring-neutral-600 text-white"
                                    }),
                                    ae.jsxs("div", {
                                        className: "text-xs",
                                        children: [
                                            ae.jsx("div", {
                                                className: "text-neutral-400",
                                                children: "Preserve Metadata"
                                            }),
                                            ae.jsx("div", {
                                                className: "text-neutral-500 text-xs",
                                                children: "Keep EXIF, XMP, and other metadata (larger file size)"
                                            })
                                        ]
                                    })
                                ]
                            })
                        }),
                        ae.jsx("div", {
                            children: ae.jsxs("label", {
                                className: "flex items-center space-x-3 cursor-pointer",
                                children: [
                                    ae.jsx("input", {
                                        type: "checkbox",
                                        checked: g,
                                        onChange: (N)=>y(N.target.checked),
                                        className: "w-4 h-4 bg-black border border-neutral-800 rounded focus:ring-1 focus:ring-neutral-600 text-white"
                                    }),
                                    ae.jsxs("div", {
                                        className: "text-xs",
                                        children: [
                                            ae.jsx("div", {
                                                className: "text-neutral-400",
                                                children: "Lossless Mode"
                                            }),
                                            ae.jsx("div", {
                                                className: "text-neutral-500 text-xs",
                                                children: "Force lossless compression (overrides quality setting)"
                                            })
                                        ]
                                    })
                                ]
                            })
                        }),
                        ae.jsxs("button", {
                            onClick: C,
                            disabled: !e.available || r.length === 0,
                            className: "w-full py-3 px-4 bg-black hover:bg-neutral-900 border border-neutral-800 disabled:bg-neutral-800 text-white text-sm font-medium rounded-md transition-colors disabled:text-neutral-500",
                            children: [
                                "Optimize ",
                                r.length,
                                " File",
                                r.length !== 1 ? "s" : ""
                            ]
                        })
                    ]
                })
            ]
        });
    }
    function rR({ results: r, onReset: e }) {
        const t = qe.useCallback((p)=>{
            if (!p.success || !p.optimizedData) return;
            const g = p.fileType === "image" ? `image/${p.targetFormat}` : "application/octet-stream", y = new Blob([
                new Uint8Array(p.optimizedData)
            ], {
                type: g
            }), _ = URL.createObjectURL(y), x = document.createElement("a");
            x.href = _;
            const M = p.targetFormat || "bin", R = p.originalFile.name.replace(/\.[^/.]+$/, "");
            x.download = `${R}_juice.${M}`, document.body.appendChild(x), x.click(), document.body.removeChild(x), URL.revokeObjectURL(_);
        }, []), n = qe.useCallback(()=>{
            r.filter((g)=>g.success).forEach((g, y)=>{
                setTimeout(()=>{
                    t(g);
                }, y * 100);
            });
        }, [
            r,
            t
        ]), i = qe.useCallback((p)=>{
            if (p === 0) return "0 B";
            const g = 1024, y = [
                "B",
                "KB",
                "MB",
                "GB"
            ], _ = Math.floor(Math.log(p) / Math.log(g));
            return parseFloat((p / Math.pow(g, _)).toFixed(1)) + " " + y[_];
        }, []), a = r.reduce((p, g)=>g.success && g.originalSize ? p + g.originalSize : p, 0), l = r.reduce((p, g)=>g.success && g.optimizedSize ? p + g.optimizedSize : p, 0), f = a > 0 ? (a - l) / a * 100 : 0, d = r.filter((p)=>p.success).length;
        return ae.jsxs("div", {
            className: "rounded-lg overflow-hidden",
            children: [
                ae.jsxs("div", {
                    className: "p-[11px] border-b border-neutral-800 flex items-center justify-between",
                    children: [
                        ae.jsx("h3", {
                            className: "text-sm font-normal text-white flex-1 text-center",
                            children: "Results"
                        }),
                        ae.jsxs("div", {
                            className: "flex space-x-2",
                            children: [
                                ae.jsx("button", {
                                    onClick: n,
                                    disabled: d === 0,
                                    className: "px-3 py-1.5 bg-black hover:bg-neutral-900 border border-neutral-800 text-white text-xs rounded transition-colors disabled:text-neutral-500",
                                    children: "Download All"
                                }),
                                ae.jsx("button", {
                                    onClick: e,
                                    className: "px-3 py-1.5 border border-neutral-700 text-neutral-400 text-xs rounded hover:border-neutral-500 hover:text-white transition-colors",
                                    children: "Reset"
                                })
                            ]
                        })
                    ]
                }),
                d > 0 && ae.jsxs("div", {
                    className: "p-4 border-b border-neutral-800 bg-neutral-900/40",
                    children: [
                        ae.jsxs("div", {
                            className: "flex items-center space-x-2 mb-1",
                            children: [
                                ae.jsx("span", {
                                    className: "text-green-500",
                                    children: ""
                                }),
                                ae.jsxs("span", {
                                    className: "text-sm text-white",
                                    children: [
                                        d,
                                        " file",
                                        d !== 1 ? "s" : "",
                                        " optimized"
                                    ]
                                })
                            ]
                        }),
                        ae.jsxs("div", {
                            className: "flex items-center space-x-2 text-sm text-neutral-400",
                            children: [
                                ae.jsxs("span", {
                                    children: [
                                        i(a),
                                        "  ",
                                        i(l)
                                    ]
                                }),
                                ae.jsxs("span", {
                                    className: `font-medium ${f > 0 ? "text-green-500" : "text-red-500"}`,
                                    children: [
                                        "(",
                                        f > 0 ? "-" : "+",
                                        Math.abs(f).toFixed(1),
                                        "%)"
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                ae.jsx("div", {
                    className: "max-h-80 overflow-y-auto p-2",
                    children: ae.jsx("div", {
                        className: "space-y-2",
                        children: r.map((p, g)=>ae.jsx("div", {
                                className: `border rounded p-3 ${p.success ? "border-neutral-800 hover:border-neutral-700" : "border-red-900/30"} transition-colors`,
                                children: ae.jsxs("div", {
                                    className: "flex items-center justify-between",
                                    children: [
                                        ae.jsxs("div", {
                                            className: "flex-1",
                                            children: [
                                                ae.jsxs("div", {
                                                    className: "flex items-center space-x-2 mb-1",
                                                    children: [
                                                        ae.jsx("span", {
                                                            className: "text-sm",
                                                            children: p.fileType === "image" ? "" : ""
                                                        }),
                                                        ae.jsx("span", {
                                                            className: "text-xs text-white truncate max-w-[240px]",
                                                            children: p.originalFile.name
                                                        })
                                                    ]
                                                }),
                                                p.success ? ae.jsxs("div", {
                                                    className: "space-y-1",
                                                    children: [
                                                        ae.jsxs("div", {
                                                            className: "flex items-center space-x-2 text-xs text-neutral-500",
                                                            children: [
                                                                ae.jsxs("span", {
                                                                    children: [
                                                                        i(p.originalSize || 0),
                                                                        "  ",
                                                                        i(p.optimizedSize || 0)
                                                                    ]
                                                                }),
                                                                ae.jsxs("span", {
                                                                    className: `${(p.savings || 0) > 0 ? "text-green-500" : "text-red-500"}`,
                                                                    children: [
                                                                        "(",
                                                                        (p.savings || 0) > 0 ? "-" : "+",
                                                                        Math.abs(p.savings || 0).toFixed(1),
                                                                        "%)"
                                                                    ]
                                                                }),
                                                                p.targetFormat && ae.jsxs("span", {
                                                                    className: "text-neutral-400",
                                                                    children: [
                                                                        " ",
                                                                        p.targetFormat.toUpperCase()
                                                                    ]
                                                                })
                                                            ]
                                                        }),
                                                        p.performanceMetrics && ae.jsxs("div", {
                                                            className: "text-xs text-neutral-600",
                                                            children: [
                                                                "Performance: ",
                                                                p.performanceMetrics.last_operation_time_ms?.toFixed(1) || "N/A",
                                                                "ms",
                                                                p.performanceMetrics.memory_peak_mb && ` | Memory: ${p.performanceMetrics.memory_peak_mb.toFixed(1)}MB`
                                                            ]
                                                        })
                                                    ]
                                                }) : ae.jsxs("div", {
                                                    className: "text-xs text-red-500 truncate max-w-[240px]",
                                                    children: [
                                                        "Failed: ",
                                                        p.error
                                                    ]
                                                })
                                            ]
                                        }),
                                        p.success && ae.jsx("button", {
                                            onClick: ()=>t(p),
                                            className: "ml-3 px-2 py-1 border border-white bg-black text-white hover:bg-white hover:text-black text-xs rounded transition-colors",
                                            children: ""
                                        })
                                    ]
                                })
                            }, g))
                    })
                })
            ]
        });
    }
    const zm = "178", uf = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    }, ff = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    }, TE = 0, Qx = 1, AE = 2, oR = 3, wE = 0, dy = 1, hm = 2, to = 3, Wo = 0, sa = 1, ka = 2, Ul = 0, Sf = 1, Jx = 2, $x = 3, eS = 4, RE = 5, Fc = 100, CE = 101, DE = 102, NE = 103, UE = 104, LE = 200, OE = 201, zE = 202, BE = 203, Sv = 204, bv = 205, IE = 206, PE = 207, HE = 208, FE = 209, GE = 210, VE = 211, kE = 212, XE = 213, jE = 214, Mv = 0, Ev = 1, Tv = 2, Ef = 3, Av = 4, wv = 5, Rv = 6, Cv = 7, Bm = 0, qE = 1, YE = 2, jo = 0, WE = 1, ZE = 2, KE = 3, MS = 4, QE = 5, JE = 6, $E = 7, tS = "attached", eT = "detached", py = 300, Bl = 301, jc = 302, hd = 303, Mm = 304, wd = 306, Zo = 1e3, na = 1001, dd = 1002, cs = 1003, my = 1004, lR = 1004, gf = 1005, cR = 1005, pi = 1006, rd = 1007, uR = 1007, Xa = 1008, fR = 1008, br = 1009, ES = 1010, TS = 1011, pd = 1012, gy = 1013, Il = 1014, ia = 1015, Cf = 1016, vy = 1017, yy = 1018, md = 1020, AS = 35902, wS = 1021, RS = 1022, Is = 1023, gd = 1026, vd = 1027, _y = 1028, Im = 1029, CS = 1030, xy = 1031, hR = 1032, Sy = 1033, dm = 33776, pm = 33777, mm = 33778, gm = 33779, Dv = 35840, Nv = 35841, Uv = 35842, Lv = 35843, Ov = 36196, zv = 37492, Bv = 37496, Iv = 37808, Pv = 37809, Hv = 37810, Fv = 37811, Gv = 37812, Vv = 37813, kv = 37814, Xv = 37815, jv = 37816, qv = 37817, Yv = 37818, Wv = 37819, Zv = 37820, Kv = 37821, vm = 36492, Qv = 36494, Jv = 36495, DS = 36283, $v = 36284, ey = 36285, ty = 36286, tT = 2200, nT = 2201, iT = 2202, yd = 2300, _d = 2301, mv = 2302, vf = 2400, yf = 2401, Em = 2402, by = 2500, NS = 2501, sT = 0, US = 1, ny = 2, aT = 3200, rT = 3201, dR = 3202, pR = 3203, Jc = 0, oT = 1, Dl = "", Bs = "srgb", qc = "srgb-linear", Tm = "linear", Fn = "srgb", mR = 0, hf = 7680, gR = 7681, vR = 7682, yR = 7683, _R = 34055, xR = 34056, SR = 5386, bR = 512, MR = 513, ER = 514, TR = 515, AR = 516, wR = 517, RR = 518, nS = 519, lT = 512, cT = 513, uT = 514, LS = 515, fT = 516, hT = 517, dT = 518, pT = 519, Am = 35044, CR = 35048, DR = 35040, NR = 35045, UR = 35049, LR = 35041, OR = 35046, zR = 35050, BR = 35042, IR = "100", iS = "300 es", xr = 2e3, wm = 2001, PR = {
        COMPUTE: "compute",
        RENDER: "render"
    }, HR = {
        PERSPECTIVE: "perspective",
        LINEAR: "linear",
        FLAT: "flat"
    }, FR = {
        NORMAL: "normal",
        CENTROID: "centroid",
        SAMPLE: "sample",
        FIRST: "first",
        EITHER: "either"
    };
    let Qo = class {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
            const n = this._listeners;
            return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
            const n = this._listeners;
            if (n === void 0) return;
            const i = n[e];
            if (i !== void 0) {
                const a = i.indexOf(t);
                a !== -1 && i.splice(a, 1);
            }
        }
        dispatchEvent(e) {
            const t = this._listeners;
            if (t === void 0) return;
            const n = t[e.type];
            if (n !== void 0) {
                e.target = this;
                const i = n.slice(0);
                for(let a = 0, l = i.length; a < l; a++)i[a].call(this, e);
                e.target = null;
            }
        }
    };
    const Ls = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
    ];
    let uM = 1234567;
    const bf = Math.PI / 180, xd = 180 / Math.PI;
    function qa() {
        const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
        return (Ls[r & 255] + Ls[r >> 8 & 255] + Ls[r >> 16 & 255] + Ls[r >> 24 & 255] + "-" + Ls[e & 255] + Ls[e >> 8 & 255] + "-" + Ls[e >> 16 & 15 | 64] + Ls[e >> 24 & 255] + "-" + Ls[t & 63 | 128] + Ls[t >> 8 & 255] + "-" + Ls[t >> 16 & 255] + Ls[t >> 24 & 255] + Ls[n & 255] + Ls[n >> 8 & 255] + Ls[n >> 16 & 255] + Ls[n >> 24 & 255]).toLowerCase();
    }
    function Wt(r, e, t) {
        return Math.max(e, Math.min(t, r));
    }
    function OS(r, e) {
        return (r % e + e) % e;
    }
    function GR(r, e, t, n, i) {
        return n + (r - e) * (i - n) / (t - e);
    }
    function VR(r, e, t) {
        return r !== e ? (t - r) / (e - r) : 0;
    }
    function ym(r, e, t) {
        return (1 - t) * r + t * e;
    }
    function kR(r, e, t, n) {
        return ym(r, e, 1 - Math.exp(-t * n));
    }
    function XR(r, e = 1) {
        return e - Math.abs(OS(r, e * 2) - e);
    }
    function jR(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r));
    }
    function qR(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10));
    }
    function YR(r, e) {
        return r + Math.floor(Math.random() * (e - r + 1));
    }
    function WR(r, e) {
        return r + Math.random() * (e - r);
    }
    function ZR(r) {
        return r * (.5 - Math.random());
    }
    function KR(r) {
        r !== void 0 && (uM = r);
        let e = uM += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
    }
    function QR(r) {
        return r * bf;
    }
    function JR(r) {
        return r * xd;
    }
    function $R(r) {
        return (r & r - 1) === 0 && r !== 0;
    }
    function e2(r) {
        return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
    }
    function t2(r) {
        return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
    }
    function n2(r, e, t, n, i) {
        const a = Math.cos, l = Math.sin, f = a(t / 2), d = l(t / 2), p = a((e + n) / 2), g = l((e + n) / 2), y = a((e - n) / 2), _ = l((e - n) / 2), x = a((n - e) / 2), M = l((n - e) / 2);
        switch(i){
            case "XYX":
                r.set(f * g, d * y, d * _, f * p);
                break;
            case "YZY":
                r.set(d * _, f * g, d * y, f * p);
                break;
            case "ZXZ":
                r.set(d * y, d * _, f * g, f * p);
                break;
            case "XZX":
                r.set(f * g, d * M, d * x, f * p);
                break;
            case "YXY":
                r.set(d * x, f * g, d * M, f * p);
                break;
            case "ZYZ":
                r.set(d * M, d * x, f * g, f * p);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
        }
    }
    function ta(r, e) {
        switch(e.constructor){
            case Float32Array:
                return r;
            case Uint32Array:
                return r / 4294967295;
            case Uint16Array:
                return r / 65535;
            case Uint8Array:
                return r / 255;
            case Int32Array:
                return Math.max(r / 2147483647, -1);
            case Int16Array:
                return Math.max(r / 32767, -1);
            case Int8Array:
                return Math.max(r / 127, -1);
            default:
                throw new Error("Invalid component type.");
        }
    }
    function en(r, e) {
        switch(e.constructor){
            case Float32Array:
                return r;
            case Uint32Array:
                return Math.round(r * 4294967295);
            case Uint16Array:
                return Math.round(r * 65535);
            case Uint8Array:
                return Math.round(r * 255);
            case Int32Array:
                return Math.round(r * 2147483647);
            case Int16Array:
                return Math.round(r * 32767);
            case Int8Array:
                return Math.round(r * 127);
            default:
                throw new Error("Invalid component type.");
        }
    }
    const yr = {
        DEG2RAD: bf,
        RAD2DEG: xd,
        generateUUID: qa,
        clamp: Wt,
        euclideanModulo: OS,
        mapLinear: GR,
        inverseLerp: VR,
        lerp: ym,
        damp: kR,
        pingpong: XR,
        smoothstep: jR,
        smootherstep: qR,
        randInt: YR,
        randFloat: WR,
        randFloatSpread: ZR,
        seededRandom: KR,
        degToRad: QR,
        radToDeg: JR,
        isPowerOfTwo: $R,
        ceilPowerOfTwo: e2,
        floorPowerOfTwo: t2,
        setQuaternionFromProperEuler: n2,
        normalize: en,
        denormalize: ta
    };
    class Ie {
        constructor(e = 0, t = 0){
            Ie.prototype.isVector2 = !0, this.x = e, this.y = t;
        }
        get width() {
            return this.x;
        }
        set width(e) {
            this.x = e;
        }
        get height() {
            return this.y;
        }
        set height(e) {
            this.y = e;
        }
        set(e, t) {
            return this.x = e, this.y = t, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
            return this.x = Wt(this.x, e.x, t.x), this.y = Wt(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
            return this.x = Wt(this.x, e, t), this.y = Wt(this.y, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Wt(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y;
        }
        cross(e) {
            return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Wt(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y;
            return t * t + n * n;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
            const n = Math.cos(t), i = Math.sin(t), a = this.x - e.x, l = this.y - e.y;
            return this.x = a * n - l * i + e.x, this.y = a * i + l * n + e.y, this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y;
        }
    }
    class mi {
        constructor(e = 0, t = 0, n = 0, i = 1){
            this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
        }
        static slerpFlat(e, t, n, i, a, l, f) {
            let d = n[i + 0], p = n[i + 1], g = n[i + 2], y = n[i + 3];
            const _ = a[l + 0], x = a[l + 1], M = a[l + 2], R = a[l + 3];
            if (f === 0) {
                e[t + 0] = d, e[t + 1] = p, e[t + 2] = g, e[t + 3] = y;
                return;
            }
            if (f === 1) {
                e[t + 0] = _, e[t + 1] = x, e[t + 2] = M, e[t + 3] = R;
                return;
            }
            if (y !== R || d !== _ || p !== x || g !== M) {
                let T = 1 - f;
                const E = d * _ + p * x + g * M + y * R, C = E >= 0 ? 1 : -1, N = 1 - E * E;
                if (N > Number.EPSILON) {
                    const I = Math.sqrt(N), O = Math.atan2(I, E * C);
                    T = Math.sin(T * O) / I, f = Math.sin(f * O) / I;
                }
                const D = f * C;
                if (d = d * T + _ * D, p = p * T + x * D, g = g * T + M * D, y = y * T + R * D, T === 1 - f) {
                    const I = 1 / Math.sqrt(d * d + p * p + g * g + y * y);
                    d *= I, p *= I, g *= I, y *= I;
                }
            }
            e[t] = d, e[t + 1] = p, e[t + 2] = g, e[t + 3] = y;
        }
        static multiplyQuaternionsFlat(e, t, n, i, a, l) {
            const f = n[i], d = n[i + 1], p = n[i + 2], g = n[i + 3], y = a[l], _ = a[l + 1], x = a[l + 2], M = a[l + 3];
            return e[t] = f * M + g * y + d * x - p * _, e[t + 1] = d * M + g * _ + p * y - f * x, e[t + 2] = p * M + g * x + f * _ - d * y, e[t + 3] = g * M - f * y - d * _ - p * x, e;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get w() {
            return this._w;
        }
        set w(e) {
            this._w = e, this._onChangeCallback();
        }
        set(e, t, n, i) {
            return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = !0) {
            const n = e._x, i = e._y, a = e._z, l = e._order, f = Math.cos, d = Math.sin, p = f(n / 2), g = f(i / 2), y = f(a / 2), _ = d(n / 2), x = d(i / 2), M = d(a / 2);
            switch(l){
                case "XYZ":
                    this._x = _ * g * y + p * x * M, this._y = p * x * y - _ * g * M, this._z = p * g * M + _ * x * y, this._w = p * g * y - _ * x * M;
                    break;
                case "YXZ":
                    this._x = _ * g * y + p * x * M, this._y = p * x * y - _ * g * M, this._z = p * g * M - _ * x * y, this._w = p * g * y + _ * x * M;
                    break;
                case "ZXY":
                    this._x = _ * g * y - p * x * M, this._y = p * x * y + _ * g * M, this._z = p * g * M + _ * x * y, this._w = p * g * y - _ * x * M;
                    break;
                case "ZYX":
                    this._x = _ * g * y - p * x * M, this._y = p * x * y + _ * g * M, this._z = p * g * M - _ * x * y, this._w = p * g * y + _ * x * M;
                    break;
                case "YZX":
                    this._x = _ * g * y + p * x * M, this._y = p * x * y + _ * g * M, this._z = p * g * M - _ * x * y, this._w = p * g * y - _ * x * M;
                    break;
                case "XZY":
                    this._x = _ * g * y - p * x * M, this._y = p * x * y - _ * g * M, this._z = p * g * M + _ * x * y, this._w = p * g * y + _ * x * M;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
            }
            return t === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
            const n = t / 2, i = Math.sin(n);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
            const t = e.elements, n = t[0], i = t[4], a = t[8], l = t[1], f = t[5], d = t[9], p = t[2], g = t[6], y = t[10], _ = n + f + y;
            if (_ > 0) {
                const x = .5 / Math.sqrt(_ + 1);
                this._w = .25 / x, this._x = (g - d) * x, this._y = (a - p) * x, this._z = (l - i) * x;
            } else if (n > f && n > y) {
                const x = 2 * Math.sqrt(1 + n - f - y);
                this._w = (g - d) / x, this._x = .25 * x, this._y = (i + l) / x, this._z = (a + p) / x;
            } else if (f > y) {
                const x = 2 * Math.sqrt(1 + f - n - y);
                this._w = (a - p) / x, this._x = (i + l) / x, this._y = .25 * x, this._z = (d + g) / x;
            } else {
                const x = 2 * Math.sqrt(1 + y - n - f);
                this._w = (l - i) / x, this._x = (a + p) / x, this._y = (d + g) / x, this._z = .25 * x;
            }
            return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < 1e-8 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(Wt(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (n === 0) return this;
            const i = Math.min(1, t / n);
            return this.slerp(e, i), this;
        }
        identity() {
            return this.set(0, 0, 0, 1);
        }
        invert() {
            return this.conjugate();
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
            const n = e._x, i = e._y, a = e._z, l = e._w, f = t._x, d = t._y, p = t._z, g = t._w;
            return this._x = n * g + l * f + i * p - a * d, this._y = i * g + l * d + a * f - n * p, this._z = a * g + l * p + n * d - i * f, this._w = l * g - n * f - i * d - a * p, this._onChangeCallback(), this;
        }
        slerp(e, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(e);
            const n = this._x, i = this._y, a = this._z, l = this._w;
            let f = l * e._w + n * e._x + i * e._y + a * e._z;
            if (f < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, f = -f) : this.copy(e), f >= 1) return this._w = l, this._x = n, this._y = i, this._z = a, this;
            const d = 1 - f * f;
            if (d <= Number.EPSILON) {
                const x = 1 - t;
                return this._w = x * l + t * this._w, this._x = x * n + t * this._x, this._y = x * i + t * this._y, this._z = x * a + t * this._z, this.normalize(), this;
            }
            const p = Math.sqrt(d), g = Math.atan2(p, f), y = Math.sin((1 - t) * g) / p, _ = Math.sin(t * g) / p;
            return this._w = l * y + this._w * _, this._x = n * y + this._x * _, this._y = i * y + this._y * _, this._z = a * y + this._z * _, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n);
        }
        random() {
            const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), a = Math.sqrt(n);
            return this.set(i * Math.sin(e), i * Math.cos(e), a * Math.sin(t), a * Math.cos(t));
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
            return this.toArray();
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
        }
    }
    class Y {
        constructor(e = 0, t = 0, n = 0){
            Y.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
            return this.applyQuaternion(fM.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(fM.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
            const t = this.x, n = this.y, i = this.z, a = e.elements;
            return this.x = a[0] * t + a[3] * n + a[6] * i, this.y = a[1] * t + a[4] * n + a[7] * i, this.z = a[2] * t + a[5] * n + a[8] * i, this;
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, i = this.z, a = e.elements, l = 1 / (a[3] * t + a[7] * n + a[11] * i + a[15]);
            return this.x = (a[0] * t + a[4] * n + a[8] * i + a[12]) * l, this.y = (a[1] * t + a[5] * n + a[9] * i + a[13]) * l, this.z = (a[2] * t + a[6] * n + a[10] * i + a[14]) * l, this;
        }
        applyQuaternion(e) {
            const t = this.x, n = this.y, i = this.z, a = e.x, l = e.y, f = e.z, d = e.w, p = 2 * (l * i - f * n), g = 2 * (f * t - a * i), y = 2 * (a * n - l * t);
            return this.x = t + d * p + l * y - f * g, this.y = n + d * g + f * p - a * y, this.z = i + d * y + a * g - l * p, this;
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
            const t = this.x, n = this.y, i = this.z, a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i, this.y = a[1] * t + a[5] * n + a[9] * i, this.z = a[2] * t + a[6] * n + a[10] * i, this.normalize();
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
            return this.x = Wt(this.x, e.x, t.x), this.y = Wt(this.y, e.y, t.y), this.z = Wt(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
            return this.x = Wt(this.x, e, t), this.y = Wt(this.y, e, t), this.z = Wt(this.z, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Wt(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
        }
        cross(e) {
            return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
            const n = e.x, i = e.y, a = e.z, l = t.x, f = t.y, d = t.z;
            return this.x = i * d - a * f, this.y = a * l - n * d, this.z = n * f - i * l, this;
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (t === 0) return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
            return I_.copy(this).projectOnVector(e), this.sub(I_);
        }
        reflect(e) {
            return this.sub(I_.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0) return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(Wt(n, -1, 1));
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
            return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
            const i = Math.sin(t) * e;
            return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = i, this;
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
            return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
            return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
            const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
            return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
        }
    }
    const I_ = new Y, fM = new mi;
    class Yt {
        constructor(e, t, n, i, a, l, f, d, p){
            Yt.prototype.isMatrix3 = !0, this.elements = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, i, a, l, f, d, p);
        }
        set(e, t, n, i, a, l, f, d, p) {
            const g = this.elements;
            return g[0] = e, g[1] = i, g[2] = f, g[3] = t, g[4] = a, g[5] = d, g[6] = n, g[7] = l, g[8] = p, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, i = t.elements, a = this.elements, l = n[0], f = n[3], d = n[6], p = n[1], g = n[4], y = n[7], _ = n[2], x = n[5], M = n[8], R = i[0], T = i[3], E = i[6], C = i[1], N = i[4], D = i[7], I = i[2], O = i[5], P = i[8];
            return a[0] = l * R + f * C + d * I, a[3] = l * T + f * N + d * O, a[6] = l * E + f * D + d * P, a[1] = p * R + g * C + y * I, a[4] = p * T + g * N + y * O, a[7] = p * E + g * D + y * P, a[2] = _ * R + x * C + M * I, a[5] = _ * T + x * N + M * O, a[8] = _ * E + x * D + M * P, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], a = e[3], l = e[4], f = e[5], d = e[6], p = e[7], g = e[8];
            return t * l * g - t * f * p - n * a * g + n * f * d + i * a * p - i * l * d;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], a = e[3], l = e[4], f = e[5], d = e[6], p = e[7], g = e[8], y = g * l - f * p, _ = f * d - g * a, x = p * a - l * d, M = t * y + n * _ + i * x;
            if (M === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const R = 1 / M;
            return e[0] = y * R, e[1] = (i * p - g * n) * R, e[2] = (f * n - i * l) * R, e[3] = _ * R, e[4] = (g * t - i * d) * R, e[5] = (i * a - f * t) * R, e[6] = x * R, e[7] = (n * d - p * t) * R, e[8] = (l * t - n * a) * R, this;
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, n, i, a, l, f) {
            const d = Math.cos(a), p = Math.sin(a);
            return this.set(n * d, n * p, -n * (d * l + p * f) + l + e, -i * p, i * d, -i * (-p * l + d * f) + f + t, 0, 0, 1), this;
        }
        scale(e, t) {
            return this.premultiply(P_.makeScale(e, t)), this;
        }
        rotate(e) {
            return this.premultiply(P_.makeRotation(-e)), this;
        }
        translate(e, t) {
            return this.premultiply(P_.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let i = 0; i < 9; i++)if (t[i] !== n[i]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 9; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
        }
        clone() {
            return new this.constructor().fromArray(this.elements);
        }
    }
    const P_ = new Yt;
    function mT(r) {
        for(let e = r.length - 1; e >= 0; --e)if (r[e] >= 65535) return !0;
        return !1;
    }
    const i2 = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
    };
    function sd(r, e) {
        return new i2[r](e);
    }
    function Rm(r) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", r);
    }
    function gT() {
        const r = Rm("canvas");
        return r.style.display = "block", r;
    }
    const hM = {};
    function od(r) {
        r in hM || (hM[r] = !0, console.warn(r));
    }
    function s2(r, e, t) {
        return new Promise(function(n, i) {
            function a() {
                switch(r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)){
                    case r.WAIT_FAILED:
                        i();
                        break;
                    case r.TIMEOUT_EXPIRED:
                        setTimeout(a, t);
                        break;
                    default:
                        n();
                }
            }
            setTimeout(a, t);
        });
    }
    function a2(r) {
        const e = r.elements;
        e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15];
    }
    function r2(r) {
        const e = r.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
    }
    const dM = new Yt().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), pM = new Yt().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
    function o2() {
        const r = {
            enabled: !0,
            workingColorSpace: qc,
            spaces: {},
            convert: function(i, a, l) {
                return this.enabled === !1 || a === l || !a || !l || (this.spaces[a].transfer === Fn && (i.r = Ll(i.r), i.g = Ll(i.g), i.b = Ll(i.b)), this.spaces[a].primaries !== this.spaces[l].primaries && (i.applyMatrix3(this.spaces[a].toXYZ), i.applyMatrix3(this.spaces[l].fromXYZ)), this.spaces[l].transfer === Fn && (i.r = ld(i.r), i.g = ld(i.g), i.b = ld(i.b))), i;
            },
            workingToColorSpace: function(i, a) {
                return this.convert(i, this.workingColorSpace, a);
            },
            colorSpaceToWorking: function(i, a) {
                return this.convert(i, a, this.workingColorSpace);
            },
            getPrimaries: function(i) {
                return this.spaces[i].primaries;
            },
            getTransfer: function(i) {
                return i === Dl ? Tm : this.spaces[i].transfer;
            },
            getLuminanceCoefficients: function(i, a = this.workingColorSpace) {
                return i.fromArray(this.spaces[a].luminanceCoefficients);
            },
            define: function(i) {
                Object.assign(this.spaces, i);
            },
            _getMatrix: function(i, a, l) {
                return i.copy(this.spaces[a].toXYZ).multiply(this.spaces[l].fromXYZ);
            },
            _getDrawingBufferColorSpace: function(i) {
                return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function(i = this.workingColorSpace) {
                return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
            },
            fromWorkingColorSpace: function(i, a) {
                return od("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), r.workingToColorSpace(i, a);
            },
            toWorkingColorSpace: function(i, a) {
                return od("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), r.colorSpaceToWorking(i, a);
            }
        }, e = [
            .64,
            .33,
            .3,
            .6,
            .15,
            .06
        ], t = [
            .2126,
            .7152,
            .0722
        ], n = [
            .3127,
            .329
        ];
        return r.define({
            [qc]: {
                primaries: e,
                whitePoint: n,
                transfer: Tm,
                toXYZ: dM,
                fromXYZ: pM,
                luminanceCoefficients: t,
                workingColorSpaceConfig: {
                    unpackColorSpace: Bs
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Bs
                }
            },
            [Bs]: {
                primaries: e,
                whitePoint: n,
                transfer: Fn,
                toXYZ: dM,
                fromXYZ: pM,
                luminanceCoefficients: t,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: Bs
                }
            }
        }), r;
    }
    const Sn = o2();
    function Ll(r) {
        return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4);
    }
    function ld(r) {
        return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055;
    }
    let zh;
    class vT {
        static getDataURL(e, t = "image/png") {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
            let n;
            if (e instanceof HTMLCanvasElement) n = e;
            else {
                zh === void 0 && (zh = Rm("canvas")), zh.width = e.width, zh.height = e.height;
                const i = zh.getContext("2d");
                e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = zh;
            }
            return n.toDataURL(t);
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                const t = Rm("canvas");
                t.width = e.width, t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const i = n.getImageData(0, 0, e.width, e.height), a = i.data;
                for(let l = 0; l < a.length; l++)a[l] = Ll(a[l] / 255) * 255;
                return n.putImageData(i, 0, 0), t;
            } else if (e.data) {
                const t = e.data.slice(0);
                for(let n = 0; n < t.length; n++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Ll(t[n] / 255) * 255) : t[n] = Ll(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                };
            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
    }
    let l2 = 0;
    class Vc {
        constructor(e = null){
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: l2++
            }), this.uuid = qa(), this.data = e, this.dataReady = !0, this.version = 0;
        }
        getSize(e) {
            const t = this.data;
            return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e;
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: ""
            }, i = this.data;
            if (i !== null) {
                let a;
                if (Array.isArray(i)) {
                    a = [];
                    for(let l = 0, f = i.length; l < f; l++)i[l].isDataTexture ? a.push(H_(i[l].image)) : a.push(H_(i[l]));
                } else a = H_(i);
                n.url = a;
            }
            return t || (e.images[this.uuid] = n), n;
        }
    }
    function H_(r) {
        return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? vT.getDataURL(r) : r.data ? {
            data: Array.from(r.data),
            width: r.width,
            height: r.height,
            type: r.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let c2 = 0;
    const F_ = new Y;
    class Qn extends Qo {
        constructor(e = Qn.DEFAULT_IMAGE, t = Qn.DEFAULT_MAPPING, n = na, i = na, a = pi, l = Xa, f = Is, d = br, p = Qn.DEFAULT_ANISOTROPY, g = Dl){
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: c2++
            }), this.uuid = qa(), this.name = "", this.source = new Vc(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = a, this.minFilter = l, this.anisotropy = p, this.format = f, this.internalFormat = null, this.type = d, this.offset = new Ie(0, 0), this.repeat = new Ie(1, 1), this.center = new Ie(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Yt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = g, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0;
        }
        get width() {
            return this.source.getSize(F_).x;
        }
        get height() {
            return this.source.getSize(F_).y;
        }
        get depth() {
            return this.source.getSize(F_).z;
        }
        get image() {
            return this.source.data;
        }
        set image(e = null) {
            this.source.data = e;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
        }
        setValues(e) {
            for(const t in e){
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
                    continue;
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
                    continue;
                }
                i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n;
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [
                    this.repeat.x,
                    this.repeat.y
                ],
                offset: [
                    this.offset.x,
                    this.offset.y
                ],
                center: [
                    this.center.x,
                    this.center.y
                ],
                rotation: this.rotation,
                wrap: [
                    this.wrapS,
                    this.wrapT
                ],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        transformUv(e) {
            if (this.mapping !== py) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch(this.wrapS){
                case Zo:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case na:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case dd:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break;
            }
            if (e.y < 0 || e.y > 1) switch(this.wrapT){
                case Zo:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case na:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case dd:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break;
            }
            return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
            e === !0 && (this.version++, this.source.needsUpdate = !0);
        }
        set needsPMREMUpdate(e) {
            e === !0 && this.pmremVersion++;
        }
    }
    Qn.DEFAULT_IMAGE = null;
    Qn.DEFAULT_MAPPING = py;
    Qn.DEFAULT_ANISOTROPY = 1;
    class gn {
        constructor(e = 0, t = 0, n = 0, i = 1){
            gn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
        }
        get width() {
            return this.z;
        }
        set width(e) {
            this.z = e;
        }
        get height() {
            return this.w;
        }
        set height(e) {
            this.w = e;
        }
        set(e, t, n, i) {
            return this.x = e, this.y = t, this.z = n, this.w = i, this;
        }
        setScalar(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
            return this.x = e, this;
        }
        setY(e) {
            return this.y = e, this;
        }
        setZ(e) {
            return this.z = e, this;
        }
        setW(e) {
            return this.w = e, this;
        }
        setComponent(e, t) {
            switch(e){
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch(e){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
            const t = this.x, n = this.y, i = this.z, a = this.w, l = e.elements;
            return this.x = l[0] * t + l[4] * n + l[8] * i + l[12] * a, this.y = l[1] * t + l[5] * n + l[9] * i + l[13] * a, this.z = l[2] * t + l[6] * n + l[10] * i + l[14] * a, this.w = l[3] * t + l[7] * n + l[11] * i + l[15] * a, this;
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, a;
            const d = e.elements, p = d[0], g = d[4], y = d[8], _ = d[1], x = d[5], M = d[9], R = d[2], T = d[6], E = d[10];
            if (Math.abs(g - _) < .01 && Math.abs(y - R) < .01 && Math.abs(M - T) < .01) {
                if (Math.abs(g + _) < .1 && Math.abs(y + R) < .1 && Math.abs(M + T) < .1 && Math.abs(p + x + E - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                const N = (p + 1) / 2, D = (x + 1) / 2, I = (E + 1) / 2, O = (g + _) / 4, P = (y + R) / 4, F = (M + T) / 4;
                return N > D && N > I ? N < .01 ? (n = 0, i = .707106781, a = .707106781) : (n = Math.sqrt(N), i = O / n, a = P / n) : D > I ? D < .01 ? (n = .707106781, i = 0, a = .707106781) : (i = Math.sqrt(D), n = O / i, a = F / i) : I < .01 ? (n = .707106781, i = .707106781, a = 0) : (a = Math.sqrt(I), n = P / a, i = F / a), this.set(n, i, a, t), this;
            }
            let C = Math.sqrt((T - M) * (T - M) + (y - R) * (y - R) + (_ - g) * (_ - g));
            return Math.abs(C) < .001 && (C = 1), this.x = (T - M) / C, this.y = (y - R) / C, this.z = (_ - g) / C, this.w = Math.acos((p + x + E - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
            return this.x = Wt(this.x, e.x, t.x), this.y = Wt(this.y, e.y, t.y), this.z = Wt(this.z, e.z, t.z), this.w = Wt(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
            return this.x = Wt(this.x, e, t), this.y = Wt(this.y, e, t), this.z = Wt(this.z, e, t), this.w = Wt(this.w, e, t), this;
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Wt(n, e, t));
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
        }
    }
    class zS extends Qo {
        constructor(e = 1, t = 1, n = {}){
            super(), n = Object.assign({
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: pi,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
                depth: 1,
                multiview: !1
            }, n), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = n.depth, this.scissor = new gn(0, 0, e, t), this.scissorTest = !1, this.viewport = new gn(0, 0, e, t);
            const i = {
                width: e,
                height: t,
                depth: n.depth
            }, a = new Qn(i);
            this.textures = [];
            const l = n.count;
            for(let f = 0; f < l; f++)this.textures[f] = a.clone(), this.textures[f].isRenderTargetTexture = !0, this.textures[f].renderTarget = this;
            this._setTextureOptions(n), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples, this.multiview = n.multiview;
        }
        _setTextureOptions(e = {}) {
            const t = {
                minFilter: pi,
                generateMipmaps: !1,
                flipY: !1,
                internalFormat: null
            };
            e.mapping !== void 0 && (t.mapping = e.mapping), e.wrapS !== void 0 && (t.wrapS = e.wrapS), e.wrapT !== void 0 && (t.wrapT = e.wrapT), e.wrapR !== void 0 && (t.wrapR = e.wrapR), e.magFilter !== void 0 && (t.magFilter = e.magFilter), e.minFilter !== void 0 && (t.minFilter = e.minFilter), e.format !== void 0 && (t.format = e.format), e.type !== void 0 && (t.type = e.type), e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace), e.flipY !== void 0 && (t.flipY = e.flipY), e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
            for(let n = 0; n < this.textures.length; n++)this.textures[n].setValues(t);
        }
        get texture() {
            return this.textures[0];
        }
        set texture(e) {
            this.textures[0] = e;
        }
        set depthTexture(e) {
            this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
            return this._depthTexture;
        }
        setSize(e, t, n = 1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e, this.height = t, this.depth = n;
                for(let i = 0, a = this.textures.length; i < a; i++)this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                this.dispose();
            }
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
            for(let t = 0, n = e.textures.length; t < n; t++){
                this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                const i = Object.assign({}, e.textures[t].image);
                this.textures[t].source = new Vc(i);
            }
            return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    class so extends zS {
        constructor(e = 1, t = 1, n = {}){
            super(e, t, n), this.isWebGLRenderTarget = !0;
        }
    }
    class My extends Qn {
        constructor(e = null, t = 1, n = 1, i = 1){
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = cs, this.minFilter = cs, this.wrapR = na, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set;
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class u2 extends so {
        constructor(e = 1, t = 1, n = 1, i = {}){
            super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new My(null, e, t, n), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0;
        }
    }
    class Ey extends Qn {
        constructor(e = null, t = 1, n = 1, i = 1){
            super(null), this.isData3DTexture = !0, this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            }, this.magFilter = cs, this.minFilter = cs, this.wrapR = na, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    class f2 extends so {
        constructor(e = 1, t = 1, n = 1, i = {}){
            super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Ey(null, e, t, n), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0;
        }
    }
    class Ui {
        constructor(e = new Y(1 / 0, 1 / 0, 1 / 0), t = new Y(-1 / 0, -1 / 0, -1 / 0)){
            this.isBox3 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(Qr.fromArray(e, t));
            return this;
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for(let t = 0, n = e.count; t < n; t++)this.expandByPoint(Qr.fromBufferAttribute(e, t));
            return this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            const n = Qr.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
            return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
            e.updateWorldMatrix(!1, !1);
            const n = e.geometry;
            if (n !== void 0) {
                const a = n.getAttribute("position");
                if (t === !0 && a !== void 0 && e.isInstancedMesh !== !0) for(let l = 0, f = a.count; l < f; l++)e.isMesh === !0 ? e.getVertexPosition(l, Qr) : Qr.fromBufferAttribute(a, l), Qr.applyMatrix4(e.matrixWorld), this.expandByPoint(Qr);
                else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), x0.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), x0.copy(n.boundingBox)), x0.applyMatrix4(e.matrixWorld), this.union(x0);
            }
            const i = e.children;
            for(let a = 0, l = i.length; a < l; a++)this.expandByObject(i[a], t);
            return this;
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, Qr), Qr.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Kp), S0.subVectors(this.max, Kp), Bh.subVectors(e.a, Kp), Ih.subVectors(e.b, Kp), Ph.subVectors(e.c, Kp), Nc.subVectors(Ih, Bh), Uc.subVectors(Ph, Ih), Wu.subVectors(Bh, Ph);
            let t = [
                0,
                -Nc.z,
                Nc.y,
                0,
                -Uc.z,
                Uc.y,
                0,
                -Wu.z,
                Wu.y,
                Nc.z,
                0,
                -Nc.x,
                Uc.z,
                0,
                -Uc.x,
                Wu.z,
                0,
                -Wu.x,
                -Nc.y,
                Nc.x,
                0,
                -Uc.y,
                Uc.x,
                0,
                -Wu.y,
                Wu.x,
                0
            ];
            return !G_(t, Bh, Ih, Ph, S0) || (t = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ], !G_(t, Bh, Ih, Ph, S0)) ? !1 : (b0.crossVectors(Nc, Uc), t = [
                b0.x,
                b0.y,
                b0.z
            ], G_(t, Bh, Ih, Ph, S0));
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return this.clampPoint(e, Qr).distanceTo(e);
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Qr).length() * .5), e;
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (Sl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Sl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Sl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Sl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Sl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Sl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Sl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Sl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Sl), this);
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
        toJSON() {
            return {
                min: this.min.toArray(),
                max: this.max.toArray()
            };
        }
        fromJSON(e) {
            return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
        }
    }
    const Sl = [
        new Y,
        new Y,
        new Y,
        new Y,
        new Y,
        new Y,
        new Y,
        new Y
    ], Qr = new Y, x0 = new Ui, Bh = new Y, Ih = new Y, Ph = new Y, Nc = new Y, Uc = new Y, Wu = new Y, Kp = new Y, S0 = new Y, b0 = new Y, Zu = new Y;
    function G_(r, e, t, n, i) {
        for(let a = 0, l = r.length - 3; a <= l; a += 3){
            Zu.fromArray(r, a);
            const f = i.x * Math.abs(Zu.x) + i.y * Math.abs(Zu.y) + i.z * Math.abs(Zu.z), d = e.dot(Zu), p = t.dot(Zu), g = n.dot(Zu);
            if (Math.max(-Math.max(d, p, g), Math.min(d, p, g)) > f) return !1;
        }
        return !0;
    }
    const h2 = new Ui, Qp = new Y, V_ = new Y;
    class us {
        constructor(e = new Y, t = -1){
            this.isSphere = !0, this.center = e, this.radius = t;
        }
        set(e, t) {
            return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
            const n = this.center;
            t !== void 0 ? n.copy(t) : h2.setFromPoints(e).getCenter(n);
            let i = 0;
            for(let a = 0, l = e.length; a < l; a++)i = Math.max(i, n.distanceToSquared(e[a]));
            return this.radius = Math.sqrt(i), this;
        }
        copy(e) {
            return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
            return this.radius < 0;
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
            return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
            return this.center.add(e), this;
        }
        expandByPoint(e) {
            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
            Qp.subVectors(e, this.center);
            const t = Qp.lengthSq();
            if (t > this.radius * this.radius) {
                const n = Math.sqrt(t), i = (n - this.radius) * .5;
                this.center.addScaledVector(Qp, i / n), this.radius += i;
            }
            return this;
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (V_.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Qp.copy(e.center).add(V_)), this.expandByPoint(Qp.copy(e.center).sub(V_))), this);
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            return {
                radius: this.radius,
                center: this.center.toArray()
            };
        }
        fromJSON(e) {
            return this.radius = e.radius, this.center.fromArray(e.center), this;
        }
    }
    const bl = new Y, k_ = new Y, M0 = new Y, Lc = new Y, X_ = new Y, E0 = new Y, j_ = new Y;
    class Df {
        constructor(e = new Y, t = new Y(0, 0, -1)){
            this.origin = e, this.direction = t;
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
            return this.origin.copy(this.at(e, bl)), this;
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
            const t = bl.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (bl.copy(this.origin).addScaledVector(this.direction, t), bl.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
            k_.copy(e).add(t).multiplyScalar(.5), M0.copy(t).sub(e).normalize(), Lc.copy(this.origin).sub(k_);
            const a = e.distanceTo(t) * .5, l = -this.direction.dot(M0), f = Lc.dot(this.direction), d = -Lc.dot(M0), p = Lc.lengthSq(), g = Math.abs(1 - l * l);
            let y, _, x, M;
            if (g > 0) if (y = l * d - f, _ = l * f - d, M = a * g, y >= 0) if (_ >= -M) if (_ <= M) {
                const R = 1 / g;
                y *= R, _ *= R, x = y * (y + l * _ + 2 * f) + _ * (l * y + _ + 2 * d) + p;
            } else _ = a, y = Math.max(0, -(l * _ + f)), x = -y * y + _ * (_ + 2 * d) + p;
            else _ = -a, y = Math.max(0, -(l * _ + f)), x = -y * y + _ * (_ + 2 * d) + p;
            else _ <= -M ? (y = Math.max(0, -(-l * a + f)), _ = y > 0 ? -a : Math.min(Math.max(-a, -d), a), x = -y * y + _ * (_ + 2 * d) + p) : _ <= M ? (y = 0, _ = Math.min(Math.max(-a, -d), a), x = _ * (_ + 2 * d) + p) : (y = Math.max(0, -(l * a + f)), _ = y > 0 ? a : Math.min(Math.max(-a, -d), a), x = -y * y + _ * (_ + 2 * d) + p);
            else _ = l > 0 ? -a : a, y = Math.max(0, -(l * _ + f)), x = -y * y + _ * (_ + 2 * d) + p;
            return n && n.copy(this.origin).addScaledVector(this.direction, y), i && i.copy(k_).addScaledVector(M0, _), x;
        }
        intersectSphere(e, t) {
            bl.subVectors(e.center, this.origin);
            const n = bl.dot(this.direction), i = bl.dot(bl) - n * n, a = e.radius * e.radius;
            if (i > a) return null;
            const l = Math.sqrt(a - i), f = n - l, d = n + l;
            return d < 0 ? null : f < 0 ? this.at(d, t) : this.at(f, t);
        }
        intersectsSphere(e) {
            return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
            let n, i, a, l, f, d;
            const p = 1 / this.direction.x, g = 1 / this.direction.y, y = 1 / this.direction.z, _ = this.origin;
            return p >= 0 ? (n = (e.min.x - _.x) * p, i = (e.max.x - _.x) * p) : (n = (e.max.x - _.x) * p, i = (e.min.x - _.x) * p), g >= 0 ? (a = (e.min.y - _.y) * g, l = (e.max.y - _.y) * g) : (a = (e.max.y - _.y) * g, l = (e.min.y - _.y) * g), n > l || a > i || ((a > n || isNaN(n)) && (n = a), (l < i || isNaN(i)) && (i = l), y >= 0 ? (f = (e.min.z - _.z) * y, d = (e.max.z - _.z) * y) : (f = (e.max.z - _.z) * y, d = (e.min.z - _.z) * y), n > d || f > i) || ((f > n || n !== n) && (n = f), (d < i || i !== i) && (i = d), i < 0) ? null : this.at(n >= 0 ? n : i, t);
        }
        intersectsBox(e) {
            return this.intersectBox(e, bl) !== null;
        }
        intersectTriangle(e, t, n, i, a) {
            X_.subVectors(t, e), E0.subVectors(n, e), j_.crossVectors(X_, E0);
            let l = this.direction.dot(j_), f;
            if (l > 0) {
                if (i) return null;
                f = 1;
            } else if (l < 0) f = -1, l = -l;
            else return null;
            Lc.subVectors(this.origin, e);
            const d = f * this.direction.dot(E0.crossVectors(Lc, E0));
            if (d < 0) return null;
            const p = f * this.direction.dot(X_.cross(Lc));
            if (p < 0 || d + p > l) return null;
            const g = -f * Lc.dot(j_);
            return g < 0 ? null : this.at(g / l, a);
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class pt {
        constructor(e, t, n, i, a, l, f, d, p, g, y, _, x, M, R, T){
            pt.prototype.isMatrix4 = !0, this.elements = [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, i, a, l, f, d, p, g, y, _, x, M, R, T);
        }
        set(e, t, n, i, a, l, f, d, p, g, y, _, x, M, R, T) {
            const E = this.elements;
            return E[0] = e, E[4] = t, E[8] = n, E[12] = i, E[1] = a, E[5] = l, E[9] = f, E[13] = d, E[2] = p, E[6] = g, E[10] = y, E[14] = _, E[3] = x, E[7] = M, E[11] = R, E[15] = T, this;
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
            return new pt().fromArray(this.elements);
        }
        copy(e) {
            const t = this.elements, n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
        }
        copyPosition(e) {
            const t = this.elements, n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
            const t = this.elements, n = e.elements, i = 1 / Hh.setFromMatrixColumn(e, 0).length(), a = 1 / Hh.setFromMatrixColumn(e, 1).length(), l = 1 / Hh.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * a, t[5] = n[5] * a, t[6] = n[6] * a, t[7] = 0, t[8] = n[8] * l, t[9] = n[9] * l, t[10] = n[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
            const t = this.elements, n = e.x, i = e.y, a = e.z, l = Math.cos(n), f = Math.sin(n), d = Math.cos(i), p = Math.sin(i), g = Math.cos(a), y = Math.sin(a);
            if (e.order === "XYZ") {
                const _ = l * g, x = l * y, M = f * g, R = f * y;
                t[0] = d * g, t[4] = -d * y, t[8] = p, t[1] = x + M * p, t[5] = _ - R * p, t[9] = -f * d, t[2] = R - _ * p, t[6] = M + x * p, t[10] = l * d;
            } else if (e.order === "YXZ") {
                const _ = d * g, x = d * y, M = p * g, R = p * y;
                t[0] = _ + R * f, t[4] = M * f - x, t[8] = l * p, t[1] = l * y, t[5] = l * g, t[9] = -f, t[2] = x * f - M, t[6] = R + _ * f, t[10] = l * d;
            } else if (e.order === "ZXY") {
                const _ = d * g, x = d * y, M = p * g, R = p * y;
                t[0] = _ - R * f, t[4] = -l * y, t[8] = M + x * f, t[1] = x + M * f, t[5] = l * g, t[9] = R - _ * f, t[2] = -l * p, t[6] = f, t[10] = l * d;
            } else if (e.order === "ZYX") {
                const _ = l * g, x = l * y, M = f * g, R = f * y;
                t[0] = d * g, t[4] = M * p - x, t[8] = _ * p + R, t[1] = d * y, t[5] = R * p + _, t[9] = x * p - M, t[2] = -p, t[6] = f * d, t[10] = l * d;
            } else if (e.order === "YZX") {
                const _ = l * d, x = l * p, M = f * d, R = f * p;
                t[0] = d * g, t[4] = R - _ * y, t[8] = M * y + x, t[1] = y, t[5] = l * g, t[9] = -f * g, t[2] = -p * g, t[6] = x * y + M, t[10] = _ - R * y;
            } else if (e.order === "XZY") {
                const _ = l * d, x = l * p, M = f * d, R = f * p;
                t[0] = d * g, t[4] = -y, t[8] = p * g, t[1] = _ * y + R, t[5] = l * g, t[9] = x * y - M, t[2] = M * y - x, t[6] = f * g, t[10] = R * y + _;
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
            return this.compose(d2, e, p2);
        }
        lookAt(e, t, n) {
            const i = this.elements;
            return Fa.subVectors(e, t), Fa.lengthSq() === 0 && (Fa.z = 1), Fa.normalize(), Oc.crossVectors(n, Fa), Oc.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Fa.x += 1e-4 : Fa.z += 1e-4, Fa.normalize(), Oc.crossVectors(n, Fa)), Oc.normalize(), T0.crossVectors(Fa, Oc), i[0] = Oc.x, i[4] = T0.x, i[8] = Fa.x, i[1] = Oc.y, i[5] = T0.y, i[9] = Fa.y, i[2] = Oc.z, i[6] = T0.z, i[10] = Fa.z, this;
        }
        multiply(e) {
            return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            const n = e.elements, i = t.elements, a = this.elements, l = n[0], f = n[4], d = n[8], p = n[12], g = n[1], y = n[5], _ = n[9], x = n[13], M = n[2], R = n[6], T = n[10], E = n[14], C = n[3], N = n[7], D = n[11], I = n[15], O = i[0], P = i[4], F = i[8], z = i[12], L = i[1], q = i[5], oe = i[9], se = i[13], ge = i[2], _e = i[6], H = i[10], K = i[14], Q = i[3], fe = i[7], X = i[11], $ = i[15];
            return a[0] = l * O + f * L + d * ge + p * Q, a[4] = l * P + f * q + d * _e + p * fe, a[8] = l * F + f * oe + d * H + p * X, a[12] = l * z + f * se + d * K + p * $, a[1] = g * O + y * L + _ * ge + x * Q, a[5] = g * P + y * q + _ * _e + x * fe, a[9] = g * F + y * oe + _ * H + x * X, a[13] = g * z + y * se + _ * K + x * $, a[2] = M * O + R * L + T * ge + E * Q, a[6] = M * P + R * q + T * _e + E * fe, a[10] = M * F + R * oe + T * H + E * X, a[14] = M * z + R * se + T * K + E * $, a[3] = C * O + N * L + D * ge + I * Q, a[7] = C * P + N * q + D * _e + I * fe, a[11] = C * F + N * oe + D * H + I * X, a[15] = C * z + N * se + D * K + I * $, this;
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
            const e = this.elements, t = e[0], n = e[4], i = e[8], a = e[12], l = e[1], f = e[5], d = e[9], p = e[13], g = e[2], y = e[6], _ = e[10], x = e[14], M = e[3], R = e[7], T = e[11], E = e[15];
            return M * (+a * d * y - i * p * y - a * f * _ + n * p * _ + i * f * x - n * d * x) + R * (+t * d * x - t * p * _ + a * l * _ - i * l * x + i * p * g - a * d * g) + T * (+t * p * y - t * f * x - a * l * y + n * l * x + a * f * g - n * p * g) + E * (-i * f * g - t * d * y + t * f * _ + i * l * y - n * l * _ + n * d * g);
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, n) {
            const i = this.elements;
            return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
        }
        invert() {
            const e = this.elements, t = e[0], n = e[1], i = e[2], a = e[3], l = e[4], f = e[5], d = e[6], p = e[7], g = e[8], y = e[9], _ = e[10], x = e[11], M = e[12], R = e[13], T = e[14], E = e[15], C = y * T * p - R * _ * p + R * d * x - f * T * x - y * d * E + f * _ * E, N = M * _ * p - g * T * p - M * d * x + l * T * x + g * d * E - l * _ * E, D = g * R * p - M * y * p + M * f * x - l * R * x - g * f * E + l * y * E, I = M * y * d - g * R * d - M * f * _ + l * R * _ + g * f * T - l * y * T, O = t * C + n * N + i * D + a * I;
            if (O === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const P = 1 / O;
            return e[0] = C * P, e[1] = (R * _ * a - y * T * a - R * i * x + n * T * x + y * i * E - n * _ * E) * P, e[2] = (f * T * a - R * d * a + R * i * p - n * T * p - f * i * E + n * d * E) * P, e[3] = (y * d * a - f * _ * a - y * i * p + n * _ * p + f * i * x - n * d * x) * P, e[4] = N * P, e[5] = (g * T * a - M * _ * a + M * i * x - t * T * x - g * i * E + t * _ * E) * P, e[6] = (M * d * a - l * T * a - M * i * p + t * T * p + l * i * E - t * d * E) * P, e[7] = (l * _ * a - g * d * a + g * i * p - t * _ * p - l * i * x + t * d * x) * P, e[8] = D * P, e[9] = (M * y * a - g * R * a - M * n * x + t * R * x + g * n * E - t * y * E) * P, e[10] = (l * R * a - M * f * a + M * n * p - t * R * p - l * n * E + t * f * E) * P, e[11] = (g * f * a - l * y * a - g * n * p + t * y * p + l * n * x - t * f * x) * P, e[12] = I * P, e[13] = (g * R * i - M * y * i + M * n * _ - t * R * _ - g * n * T + t * y * T) * P, e[14] = (M * f * i - l * R * i - M * n * d + t * R * d + l * n * T - t * f * T) * P, e[15] = (l * y * i - g * f * i + g * n * d - t * y * d - l * n * _ + t * f * _) * P, this;
        }
        scale(e) {
            const t = this.elements, n = e.x, i = e.y, a = e.z;
            return t[0] *= n, t[4] *= i, t[8] *= a, t[1] *= n, t[5] *= i, t[9] *= a, t[2] *= n, t[6] *= i, t[10] *= a, t[3] *= n, t[7] *= i, t[11] *= a, this;
        }
        getMaxScaleOnAxis() {
            const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
            const t = Math.cos(e), n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t), i = Math.sin(t), a = 1 - n, l = e.x, f = e.y, d = e.z, p = a * l, g = a * f;
            return this.set(p * l + n, p * f - i * d, p * d + i * f, 0, p * f + i * d, g * f + n, g * d - i * l, 0, p * d - i * f, g * d + i * l, a * d * d + n, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, a, l) {
            return this.set(1, n, a, 0, e, 1, l, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
            const i = this.elements, a = t._x, l = t._y, f = t._z, d = t._w, p = a + a, g = l + l, y = f + f, _ = a * p, x = a * g, M = a * y, R = l * g, T = l * y, E = f * y, C = d * p, N = d * g, D = d * y, I = n.x, O = n.y, P = n.z;
            return i[0] = (1 - (R + E)) * I, i[1] = (x + D) * I, i[2] = (M - N) * I, i[3] = 0, i[4] = (x - D) * O, i[5] = (1 - (_ + E)) * O, i[6] = (T + C) * O, i[7] = 0, i[8] = (M + N) * P, i[9] = (T - C) * P, i[10] = (1 - (_ + R)) * P, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
        }
        decompose(e, t, n) {
            const i = this.elements;
            let a = Hh.set(i[0], i[1], i[2]).length();
            const l = Hh.set(i[4], i[5], i[6]).length(), f = Hh.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (a = -a), e.x = i[12], e.y = i[13], e.z = i[14], Jr.copy(this);
            const p = 1 / a, g = 1 / l, y = 1 / f;
            return Jr.elements[0] *= p, Jr.elements[1] *= p, Jr.elements[2] *= p, Jr.elements[4] *= g, Jr.elements[5] *= g, Jr.elements[6] *= g, Jr.elements[8] *= y, Jr.elements[9] *= y, Jr.elements[10] *= y, t.setFromRotationMatrix(Jr), n.x = a, n.y = l, n.z = f, this;
        }
        makePerspective(e, t, n, i, a, l, f = xr) {
            const d = this.elements, p = 2 * a / (t - e), g = 2 * a / (n - i), y = (t + e) / (t - e), _ = (n + i) / (n - i);
            let x, M;
            if (f === xr) x = -(l + a) / (l - a), M = -2 * l * a / (l - a);
            else if (f === wm) x = -l / (l - a), M = -l * a / (l - a);
            else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + f);
            return d[0] = p, d[4] = 0, d[8] = y, d[12] = 0, d[1] = 0, d[5] = g, d[9] = _, d[13] = 0, d[2] = 0, d[6] = 0, d[10] = x, d[14] = M, d[3] = 0, d[7] = 0, d[11] = -1, d[15] = 0, this;
        }
        makeOrthographic(e, t, n, i, a, l, f = xr) {
            const d = this.elements, p = 1 / (t - e), g = 1 / (n - i), y = 1 / (l - a), _ = (t + e) * p, x = (n + i) * g;
            let M, R;
            if (f === xr) M = (l + a) * y, R = -2 * y;
            else if (f === wm) M = a * y, R = -1 * y;
            else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + f);
            return d[0] = 2 * p, d[4] = 0, d[8] = 0, d[12] = -_, d[1] = 0, d[5] = 2 * g, d[9] = 0, d[13] = -x, d[2] = 0, d[6] = 0, d[10] = R, d[14] = -M, d[3] = 0, d[7] = 0, d[11] = 0, d[15] = 1, this;
        }
        equals(e) {
            const t = this.elements, n = e.elements;
            for(let i = 0; i < 16; i++)if (t[i] !== n[i]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 16; n++)this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
        }
    }
    const Hh = new Y, Jr = new pt, d2 = new Y(0, 0, 0), p2 = new Y(1, 1, 1), Oc = new Y, T0 = new Y, Fa = new Y, mM = new pt, gM = new mi;
    class $i {
        constructor(e = 0, t = 0, n = 0, i = $i.DEFAULT_ORDER){
            this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
        }
        get x() {
            return this._x;
        }
        set x(e) {
            this._x = e, this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            this._y = e, this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            this._z = e, this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(e) {
            this._order = e, this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
            return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            const i = e.elements, a = i[0], l = i[4], f = i[8], d = i[1], p = i[5], g = i[9], y = i[2], _ = i[6], x = i[10];
            switch(t){
                case "XYZ":
                    this._y = Math.asin(Wt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(-g, x), this._z = Math.atan2(-l, a)) : (this._x = Math.atan2(_, p), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Wt(g, -1, 1)), Math.abs(g) < .9999999 ? (this._y = Math.atan2(f, x), this._z = Math.atan2(d, p)) : (this._y = Math.atan2(-y, a), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Wt(_, -1, 1)), Math.abs(_) < .9999999 ? (this._y = Math.atan2(-y, x), this._z = Math.atan2(-l, p)) : (this._y = 0, this._z = Math.atan2(d, a));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Wt(y, -1, 1)), Math.abs(y) < .9999999 ? (this._x = Math.atan2(_, x), this._z = Math.atan2(d, a)) : (this._x = 0, this._z = Math.atan2(-l, p));
                    break;
                case "YZX":
                    this._z = Math.asin(Wt(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(-g, p), this._y = Math.atan2(-y, a)) : (this._x = 0, this._y = Math.atan2(f, x));
                    break;
                case "XZY":
                    this._z = Math.asin(-Wt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(_, p), this._y = Math.atan2(f, a)) : (this._x = Math.atan2(-g, x), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
            }
            return this._order = t, n === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
            return mM.makeRotationFromQuaternion(e), this.setFromRotationMatrix(mM, t, n);
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
            return gM.setFromEuler(this), this.setFromQuaternion(gM, e);
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
            return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
        }
    }
    $i.DEFAULT_ORDER = "XYZ";
    class Sd {
        constructor(){
            this.mask = 1;
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
            this.mask |= 1 << e | 0;
        }
        enableAll() {
            this.mask = -1;
        }
        toggle(e) {
            this.mask ^= 1 << e | 0;
        }
        disable(e) {
            this.mask &= ~(1 << e | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(e) {
            return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0;
        }
    }
    let m2 = 0;
    const vM = new Y, Fh = new mi, Ml = new pt, A0 = new Y, Jp = new Y, g2 = new Y, v2 = new mi, yM = new Y(1, 0, 0), _M = new Y(0, 1, 0), xM = new Y(0, 0, 1), SM = {
        type: "added"
    }, y2 = {
        type: "removed"
    }, Gh = {
        type: "childadded",
        child: null
    }, q_ = {
        type: "childremoved",
        child: null
    };
    class hn extends Qo {
        constructor(){
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: m2++
            }), this.uuid = qa(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = hn.DEFAULT_UP.clone();
            const e = new Y, t = new $i, n = new mi, i = new Y(1, 1, 1);
            function a() {
                n.setFromEuler(t, !1);
            }
            function l() {
                t.setFromQuaternion(n, void 0, !1);
            }
            t._onChange(a), n._onChange(l), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new pt
                },
                normalMatrix: {
                    value: new Yt
                }
            }), this.matrix = new pt, this.matrixWorld = new pt, this.matrixAutoUpdate = hn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Sd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
            return Fh.setFromAxisAngle(e, t), this.quaternion.multiply(Fh), this;
        }
        rotateOnWorldAxis(e, t) {
            return Fh.setFromAxisAngle(e, t), this.quaternion.premultiply(Fh), this;
        }
        rotateX(e) {
            return this.rotateOnAxis(yM, e);
        }
        rotateY(e) {
            return this.rotateOnAxis(_M, e);
        }
        rotateZ(e) {
            return this.rotateOnAxis(xM, e);
        }
        translateOnAxis(e, t) {
            return vM.copy(e).applyQuaternion(this.quaternion), this.position.add(vM.multiplyScalar(t)), this;
        }
        translateX(e) {
            return this.translateOnAxis(yM, e);
        }
        translateY(e) {
            return this.translateOnAxis(_M, e);
        }
        translateZ(e) {
            return this.translateOnAxis(xM, e);
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ml.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
            e.isVector3 ? A0.copy(e) : A0.set(e, t, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), Jp.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ml.lookAt(Jp, A0, this.up) : Ml.lookAt(A0, Jp, this.up), this.quaternion.setFromRotationMatrix(Ml), i && (Ml.extractRotation(i.matrixWorld), Fh.setFromRotationMatrix(Ml), this.quaternion.premultiply(Fh.invert()));
        }
        add(e) {
            if (arguments.length > 1) {
                for(let t = 0; t < arguments.length; t++)this.add(arguments[t]);
                return this;
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(SM), Gh.child = e, this.dispatchEvent(Gh), Gh.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
            if (arguments.length > 1) {
                for(let n = 0; n < arguments.length; n++)this.remove(arguments[n]);
                return this;
            }
            const t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(y2), q_.child = e, this.dispatchEvent(q_), q_.child = null), this;
        }
        removeFromParent() {
            const e = this.parent;
            return e !== null && e.remove(this), this;
        }
        clear() {
            return this.remove(...this.children);
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1), Ml.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ml.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ml), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(SM), Gh.child = e, this.dispatchEvent(Gh), Gh.child = null, this;
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for(let n = 0, i = this.children.length; n < i; n++){
                const l = this.children[n].getObjectByProperty(e, t);
                if (l !== void 0) return l;
            }
        }
        getObjectsByProperty(e, t, n = []) {
            this[e] === t && n.push(this);
            const i = this.children;
            for(let a = 0, l = i.length; a < l; a++)i[a].getObjectsByProperty(e, t, n);
            return n;
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jp, e, g2), e;
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jp, v2, e), e;
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
            e(this);
            const t = this.children;
            for(let n = 0, i = t.length; n < i; n++)t[n].traverse(e);
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            const t = this.children;
            for(let n = 0, i = t.length; n < i; n++)t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
            const t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
            const t = this.children;
            for(let n = 0, i = t.length; n < i; n++)t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
            const n = this.parent;
            if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
                const i = this.children;
                for(let a = 0, l = i.length; a < l; a++)i[a].updateWorldMatrix(!1, !0);
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string", n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.7,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};
            i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map((f)=>({
                    ...f,
                    boundingBox: f.boundingBox ? f.boundingBox.toJSON() : void 0,
                    boundingSphere: f.boundingSphere ? f.boundingSphere.toJSON() : void 0
                })), i.instanceInfo = this._instanceInfo.map((f)=>({
                    ...f
                })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(e), i.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));
            function a(f, d) {
                return f[d.uuid] === void 0 && (f[d.uuid] = d.toJSON(e)), d.uuid;
            }
            if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = a(e.geometries, this.geometry);
                const f = this.geometry.parameters;
                if (f !== void 0 && f.shapes !== void 0) {
                    const d = f.shapes;
                    if (Array.isArray(d)) for(let p = 0, g = d.length; p < g; p++){
                        const y = d[p];
                        a(e.shapes, y);
                    }
                    else a(e.shapes, d);
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
                const f = [];
                for(let d = 0, p = this.material.length; d < p; d++)f.push(a(e.materials, this.material[d]));
                i.material = f;
            } else i.material = a(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for(let f = 0; f < this.children.length; f++)i.children.push(this.children[f].toJSON(e).object);
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for(let f = 0; f < this.animations.length; f++){
                    const d = this.animations[f];
                    i.animations.push(a(e.animations, d));
                }
            }
            if (t) {
                const f = l(e.geometries), d = l(e.materials), p = l(e.textures), g = l(e.images), y = l(e.shapes), _ = l(e.skeletons), x = l(e.animations), M = l(e.nodes);
                f.length > 0 && (n.geometries = f), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), g.length > 0 && (n.images = g), y.length > 0 && (n.shapes = y), _.length > 0 && (n.skeletons = _), x.length > 0 && (n.animations = x), M.length > 0 && (n.nodes = M);
            }
            return n.object = i, n;
            function l(f) {
                const d = [];
                for(const p in f){
                    const g = f[p];
                    delete g.metadata, d.push(g);
                }
                return d;
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for(let n = 0; n < e.children.length; n++){
                const i = e.children[n];
                this.add(i.clone());
            }
            return this;
        }
    }
    hn.DEFAULT_UP = new Y(0, 1, 0);
    hn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
    hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const $r = new Y, El = new Y, Y_ = new Y, Tl = new Y, Vh = new Y, kh = new Y, bM = new Y, W_ = new Y, Z_ = new Y, K_ = new Y, Q_ = new gn, J_ = new gn, $_ = new gn;
    class ba {
        constructor(e = new Y, t = new Y, n = new Y){
            this.a = e, this.b = t, this.c = n;
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), $r.subVectors(e, t), i.cross($r);
            const a = i.lengthSq();
            return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, a) {
            $r.subVectors(i, t), El.subVectors(n, t), Y_.subVectors(e, t);
            const l = $r.dot($r), f = $r.dot(El), d = $r.dot(Y_), p = El.dot(El), g = El.dot(Y_), y = l * p - f * f;
            if (y === 0) return a.set(0, 0, 0), null;
            const _ = 1 / y, x = (p * d - f * g) * _, M = (l * g - f * d) * _;
            return a.set(1 - x - M, M, x);
        }
        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, Tl) === null ? !1 : Tl.x >= 0 && Tl.y >= 0 && Tl.x + Tl.y <= 1;
        }
        static getInterpolation(e, t, n, i, a, l, f, d) {
            return this.getBarycoord(e, t, n, i, Tl) === null ? (d.x = 0, d.y = 0, "z" in d && (d.z = 0), "w" in d && (d.w = 0), null) : (d.setScalar(0), d.addScaledVector(a, Tl.x), d.addScaledVector(l, Tl.y), d.addScaledVector(f, Tl.z), d);
        }
        static getInterpolatedAttribute(e, t, n, i, a, l) {
            return Q_.setScalar(0), J_.setScalar(0), $_.setScalar(0), Q_.fromBufferAttribute(e, t), J_.fromBufferAttribute(e, n), $_.fromBufferAttribute(e, i), l.setScalar(0), l.addScaledVector(Q_, a.x), l.addScaledVector(J_, a.y), l.addScaledVector($_, a.z), l;
        }
        static isFrontFacing(e, t, n, i) {
            return $r.subVectors(n, t), El.subVectors(e, t), $r.cross(El).dot(i) < 0;
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
            return $r.subVectors(this.c, this.b), El.subVectors(this.a, this.b), $r.cross(El).length() * .5;
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
            return ba.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
            return ba.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, n, i, a) {
            return ba.getInterpolation(e, this.a, this.b, this.c, t, n, i, a);
        }
        containsPoint(e) {
            return ba.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
            return ba.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
            const n = this.a, i = this.b, a = this.c;
            let l, f;
            Vh.subVectors(i, n), kh.subVectors(a, n), W_.subVectors(e, n);
            const d = Vh.dot(W_), p = kh.dot(W_);
            if (d <= 0 && p <= 0) return t.copy(n);
            Z_.subVectors(e, i);
            const g = Vh.dot(Z_), y = kh.dot(Z_);
            if (g >= 0 && y <= g) return t.copy(i);
            const _ = d * y - g * p;
            if (_ <= 0 && d >= 0 && g <= 0) return l = d / (d - g), t.copy(n).addScaledVector(Vh, l);
            K_.subVectors(e, a);
            const x = Vh.dot(K_), M = kh.dot(K_);
            if (M >= 0 && x <= M) return t.copy(a);
            const R = x * p - d * M;
            if (R <= 0 && p >= 0 && M <= 0) return f = p / (p - M), t.copy(n).addScaledVector(kh, f);
            const T = g * M - x * y;
            if (T <= 0 && y - g >= 0 && x - M >= 0) return bM.subVectors(a, i), f = (y - g) / (y - g + (x - M)), t.copy(i).addScaledVector(bM, f);
            const E = 1 / (T + R + _);
            return l = R * E, f = _ * E, t.copy(n).addScaledVector(Vh, l).addScaledVector(kh, f);
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
    }
    const yT = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, zc = {
        h: 0,
        s: 0,
        l: 0
    }, w0 = {
        h: 0,
        s: 0,
        l: 0
    };
    function ex(r, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r;
    }
    class tt {
        constructor(e, t, n){
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
        }
        set(e, t, n) {
            if (t === void 0 && n === void 0) {
                const i = e;
                i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
            } else this.setRGB(e, t, n);
            return this;
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = Bs) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Sn.colorSpaceToWorking(this, t), this;
        }
        setRGB(e, t, n, i = Sn.workingColorSpace) {
            return this.r = e, this.g = t, this.b = n, Sn.colorSpaceToWorking(this, i), this;
        }
        setHSL(e, t, n, i = Sn.workingColorSpace) {
            if (e = OS(e, 1), t = Wt(t, 0, 1), n = Wt(n, 0, 1), t === 0) this.r = this.g = this.b = n;
            else {
                const a = n <= .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
                this.r = ex(l, a, e + 1 / 3), this.g = ex(l, a, e), this.b = ex(l, a, e - 1 / 3);
            }
            return Sn.colorSpaceToWorking(this, i), this;
        }
        setStyle(e, t = Bs) {
            function n(a) {
                a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let a;
                const l = i[1], f = i[2];
                switch(l){
                    case "rgb":
                    case "rgba":
                        if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f)) return n(a[4]), this.setRGB(Math.min(255, parseInt(a[1], 10)) / 255, Math.min(255, parseInt(a[2], 10)) / 255, Math.min(255, parseInt(a[3], 10)) / 255, t);
                        if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f)) return n(a[4]), this.setRGB(Math.min(100, parseInt(a[1], 10)) / 100, Math.min(100, parseInt(a[2], 10)) / 100, Math.min(100, parseInt(a[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f)) return n(a[4]), this.setHSL(parseFloat(a[1]) / 360, parseFloat(a[2]) / 100, parseFloat(a[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e);
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const a = i[1], l = a.length;
                if (l === 3) return this.setRGB(parseInt(a.charAt(0), 16) / 15, parseInt(a.charAt(1), 16) / 15, parseInt(a.charAt(2), 16) / 15, t);
                if (l === 6) return this.setHex(parseInt(a, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e);
            } else if (e && e.length > 0) return this.setColorName(e, t);
            return this;
        }
        setColorName(e, t = Bs) {
            const n = yT[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
            return this.r = Ll(e.r), this.g = Ll(e.g), this.b = Ll(e.b), this;
        }
        copyLinearToSRGB(e) {
            return this.r = ld(e.r), this.g = ld(e.g), this.b = ld(e.b), this;
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Bs) {
            return Sn.workingToColorSpace(Os.copy(this), e), Math.round(Wt(Os.r * 255, 0, 255)) * 65536 + Math.round(Wt(Os.g * 255, 0, 255)) * 256 + Math.round(Wt(Os.b * 255, 0, 255));
        }
        getHexString(e = Bs) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Sn.workingColorSpace) {
            Sn.workingToColorSpace(Os.copy(this), t);
            const n = Os.r, i = Os.g, a = Os.b, l = Math.max(n, i, a), f = Math.min(n, i, a);
            let d, p;
            const g = (f + l) / 2;
            if (f === l) d = 0, p = 0;
            else {
                const y = l - f;
                switch(p = g <= .5 ? y / (l + f) : y / (2 - l - f), l){
                    case n:
                        d = (i - a) / y + (i < a ? 6 : 0);
                        break;
                    case i:
                        d = (a - n) / y + 2;
                        break;
                    case a:
                        d = (n - i) / y + 4;
                        break;
                }
                d /= 6;
            }
            return e.h = d, e.s = p, e.l = g, e;
        }
        getRGB(e, t = Sn.workingColorSpace) {
            return Sn.workingToColorSpace(Os.copy(this), t), e.r = Os.r, e.g = Os.g, e.b = Os.b, e;
        }
        getStyle(e = Bs) {
            Sn.workingToColorSpace(Os.copy(this), e);
            const t = Os.r, n = Os.g, i = Os.b;
            return e !== Bs ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
        }
        offsetHSL(e, t, n) {
            return this.getHSL(zc), this.setHSL(zc.h + e, zc.s + t, zc.l + n);
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
        }
        lerpHSL(e, t) {
            this.getHSL(zc), e.getHSL(w0);
            const n = ym(zc.h, w0.h, t), i = ym(zc.s, w0.s, t), a = ym(zc.l, w0.l, t);
            return this.setHSL(n, i, a), this;
        }
        setFromVector3(e) {
            return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
            const t = this.r, n = this.g, i = this.b, a = e.elements;
            return this.r = a[0] * t + a[3] * n + a[6] * i, this.g = a[1] * t + a[4] * n + a[7] * i, this.b = a[2] * t + a[5] * n + a[8] * i, this;
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
            return this.getHex();
        }
        *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
        }
    }
    const Os = new tt;
    tt.NAMES = yT;
    let _2 = 0;
    class Li extends Qo {
        constructor(){
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: _2++
            }), this.uuid = qa(), this.name = "", this.type = "Material", this.blending = Sf, this.side = Wo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Sv, this.blendDst = bv, this.blendEquation = Fc, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new tt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Ef, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = nS, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = hf, this.stencilZFail = hf, this.stencilZPass = hf, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(e) {
            if (e !== void 0) for(const t in e){
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue;
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
            }
        }
        toJSON(e) {
            const t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Sf && (n.blending = this.blending), this.side !== Wo && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Sv && (n.blendSrc = this.blendSrc), this.blendDst !== bv && (n.blendDst = this.blendDst), this.blendEquation !== Fc && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Ef && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== nS && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== hf && (n.stencilFail = this.stencilFail), this.stencilZFail !== hf && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== hf && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
            function i(a) {
                const l = [];
                for(const f in a){
                    const d = a[f];
                    delete d.metadata, l.push(d);
                }
                return l;
            }
            if (t) {
                const a = i(e.textures), l = i(e.images);
                a.length > 0 && (n.textures = a), l.length > 0 && (n.images = l);
            }
            return n;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (t !== null) {
                const i = t.length;
                n = new Array(i);
                for(let a = 0; a !== i; ++a)n[a] = t[a].clone();
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
    }
    class ja extends Li {
        constructor(e){
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i, this.combine = Bm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
    }
    const Nl = x2();
    function x2() {
        const r = new ArrayBuffer(4), e = new Float32Array(r), t = new Uint32Array(r), n = new Uint32Array(512), i = new Uint32Array(512);
        for(let d = 0; d < 256; ++d){
            const p = d - 127;
            p < -27 ? (n[d] = 0, n[d | 256] = 32768, i[d] = 24, i[d | 256] = 24) : p < -14 ? (n[d] = 1024 >> -p - 14, n[d | 256] = 1024 >> -p - 14 | 32768, i[d] = -p - 1, i[d | 256] = -p - 1) : p <= 15 ? (n[d] = p + 15 << 10, n[d | 256] = p + 15 << 10 | 32768, i[d] = 13, i[d | 256] = 13) : p < 128 ? (n[d] = 31744, n[d | 256] = 64512, i[d] = 24, i[d | 256] = 24) : (n[d] = 31744, n[d | 256] = 64512, i[d] = 13, i[d | 256] = 13);
        }
        const a = new Uint32Array(2048), l = new Uint32Array(64), f = new Uint32Array(64);
        for(let d = 1; d < 1024; ++d){
            let p = d << 13, g = 0;
            for(; (p & 8388608) === 0;)p <<= 1, g -= 8388608;
            p &= -8388609, g += 947912704, a[d] = p | g;
        }
        for(let d = 1024; d < 2048; ++d)a[d] = 939524096 + (d - 1024 << 13);
        for(let d = 1; d < 31; ++d)l[d] = d << 23;
        l[31] = 1199570944, l[32] = 2147483648;
        for(let d = 33; d < 63; ++d)l[d] = 2147483648 + (d - 32 << 23);
        l[63] = 3347054592;
        for(let d = 1; d < 64; ++d)d !== 32 && (f[d] = 1024);
        return {
            floatView: e,
            uint32View: t,
            baseTable: n,
            shiftTable: i,
            mantissaTable: a,
            exponentTable: l,
            offsetTable: f
        };
    }
    function _a(r) {
        Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = Wt(r, -65504, 65504), Nl.floatView[0] = r;
        const e = Nl.uint32View[0], t = e >> 23 & 511;
        return Nl.baseTable[t] + ((e & 8388607) >> Nl.shiftTable[t]);
    }
    function cm(r) {
        const e = r >> 10;
        return Nl.uint32View[0] = Nl.mantissaTable[Nl.offsetTable[e] + (r & 1023)] + Nl.exponentTable[e], Nl.floatView[0];
    }
    class S2 {
        static toHalfFloat(e) {
            return _a(e);
        }
        static fromHalfFloat(e) {
            return cm(e);
        }
    }
    const Gi = new Y, R0 = new Ie;
    let b2 = 0;
    class vn {
        constructor(e, t, n = !1){
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                value: b2++
            }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Am, this.updateRanges = [], this.gpuType = ia, this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for(let i = 0, a = this.itemSize; i < a; i++)this.array[e + i] = t.array[n + i];
            return this;
        }
        copyArray(e) {
            return this.array.set(e), this;
        }
        applyMatrix3(e) {
            if (this.itemSize === 2) for(let t = 0, n = this.count; t < n; t++)R0.fromBufferAttribute(this, t), R0.applyMatrix3(e), this.setXY(t, R0.x, R0.y);
            else if (this.itemSize === 3) for(let t = 0, n = this.count; t < n; t++)Gi.fromBufferAttribute(this, t), Gi.applyMatrix3(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
            return this;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.count; t < n; t++)Gi.fromBufferAttribute(this, t), Gi.applyMatrix4(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)Gi.fromBufferAttribute(this, t), Gi.applyNormalMatrix(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)Gi.fromBufferAttribute(this, t), Gi.transformDirection(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.itemSize + t];
            return this.normalized && (n = ta(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = en(n, this.array)), this.array[e * this.itemSize + t] = n, this;
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setX(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setY(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setZ(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setW(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
        }
        setXYZW(e, t, n, i, a) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array), a = en(a, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = a, this;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name), this.usage !== Am && (e.usage = this.usage), e;
        }
    }
    class M2 extends vn {
        constructor(e, t, n){
            super(new Int8Array(e), t, n);
        }
    }
    class E2 extends vn {
        constructor(e, t, n){
            super(new Uint8Array(e), t, n);
        }
    }
    class T2 extends vn {
        constructor(e, t, n){
            super(new Uint8ClampedArray(e), t, n);
        }
    }
    class A2 extends vn {
        constructor(e, t, n){
            super(new Int16Array(e), t, n);
        }
    }
    class Ty extends vn {
        constructor(e, t, n){
            super(new Uint16Array(e), t, n);
        }
    }
    class w2 extends vn {
        constructor(e, t, n){
            super(new Int32Array(e), t, n);
        }
    }
    class BS extends vn {
        constructor(e, t, n){
            super(new Uint32Array(e), t, n);
        }
    }
    class R2 extends vn {
        constructor(e, t, n){
            super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
        }
        getX(e) {
            let t = cm(this.array[e * this.itemSize]);
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setX(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize] = _a(t), this;
        }
        getY(e) {
            let t = cm(this.array[e * this.itemSize + 1]);
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setY(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 1] = _a(t), this;
        }
        getZ(e) {
            let t = cm(this.array[e * this.itemSize + 2]);
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setZ(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 2] = _a(t), this;
        }
        getW(e) {
            let t = cm(this.array[e * this.itemSize + 3]);
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setW(e, t) {
            return this.normalized && (t = en(t, this.array)), this.array[e * this.itemSize + 3] = _a(t), this;
        }
        setXY(e, t, n) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array)), this.array[e + 0] = _a(t), this.array[e + 1] = _a(n), this;
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array)), this.array[e + 0] = _a(t), this.array[e + 1] = _a(n), this.array[e + 2] = _a(i), this;
        }
        setXYZW(e, t, n, i, a) {
            return e *= this.itemSize, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array), a = en(a, this.array)), this.array[e + 0] = _a(t), this.array[e + 1] = _a(n), this.array[e + 2] = _a(i), this.array[e + 3] = _a(a), this;
        }
    }
    class nt extends vn {
        constructor(e, t, n){
            super(new Float32Array(e), t, n);
        }
    }
    let C2 = 0;
    const mr = new pt, tx = new hn, Xh = new Y, Ga = new Ui, $p = new Ui, ls = new Y;
    class Dt extends Qo {
        constructor(){
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: C2++
            }), this.uuid = qa(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {};
        }
        getIndex() {
            return this.index;
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new (mT(e) ? BS : Ty)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
            return this.indirect = e, this;
        }
        getIndirect() {
            return this.indirect;
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        setAttribute(e, t) {
            return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this;
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(e, t) {
            this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
            const t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (n !== void 0) {
                const a = new Yt().getNormalMatrix(e);
                n.applyNormalMatrix(a), n.needsUpdate = !0;
            }
            const i = this.attributes.tangent;
            return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
            return mr.makeRotationFromQuaternion(e), this.applyMatrix4(mr), this;
        }
        rotateX(e) {
            return mr.makeRotationX(e), this.applyMatrix4(mr), this;
        }
        rotateY(e) {
            return mr.makeRotationY(e), this.applyMatrix4(mr), this;
        }
        rotateZ(e) {
            return mr.makeRotationZ(e), this.applyMatrix4(mr), this;
        }
        translate(e, t, n) {
            return mr.makeTranslation(e, t, n), this.applyMatrix4(mr), this;
        }
        scale(e, t, n) {
            return mr.makeScale(e, t, n), this.applyMatrix4(mr), this;
        }
        lookAt(e) {
            return tx.lookAt(e), tx.updateMatrix(), this.applyMatrix4(tx.matrix), this;
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Xh).negate(), this.translate(Xh.x, Xh.y, Xh.z), this;
        }
        setFromPoints(e) {
            const t = this.getAttribute("position");
            if (t === void 0) {
                const n = [];
                for(let i = 0, a = e.length; i < a; i++){
                    const l = e[i];
                    n.push(l.x, l.y, l.z || 0);
                }
                this.setAttribute("position", new nt(n, 3));
            } else {
                const n = Math.min(e.length, t.count);
                for(let i = 0; i < n; i++){
                    const a = e[i];
                    t.setXYZ(i, a.x, a.y, a.z || 0);
                }
                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
            }
            return this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Ui);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Y(-1 / 0, -1 / 0, -1 / 0), new Y(1 / 0, 1 / 0, 1 / 0));
                return;
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e), t) for(let n = 0, i = t.length; n < i; n++){
                    const a = t[n];
                    Ga.setFromBufferAttribute(a), this.morphTargetsRelative ? (ls.addVectors(this.boundingBox.min, Ga.min), this.boundingBox.expandByPoint(ls), ls.addVectors(this.boundingBox.max, Ga.max), this.boundingBox.expandByPoint(ls)) : (this.boundingBox.expandByPoint(Ga.min), this.boundingBox.expandByPoint(Ga.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new us);
            const e = this.attributes.position, t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Y, 1 / 0);
                return;
            }
            if (e) {
                const n = this.boundingSphere.center;
                if (Ga.setFromBufferAttribute(e), t) for(let a = 0, l = t.length; a < l; a++){
                    const f = t[a];
                    $p.setFromBufferAttribute(f), this.morphTargetsRelative ? (ls.addVectors(Ga.min, $p.min), Ga.expandByPoint(ls), ls.addVectors(Ga.max, $p.max), Ga.expandByPoint(ls)) : (Ga.expandByPoint($p.min), Ga.expandByPoint($p.max));
                }
                Ga.getCenter(n);
                let i = 0;
                for(let a = 0, l = e.count; a < l; a++)ls.fromBufferAttribute(e, a), i = Math.max(i, n.distanceToSquared(ls));
                if (t) for(let a = 0, l = t.length; a < l; a++){
                    const f = t[a], d = this.morphTargetsRelative;
                    for(let p = 0, g = f.count; p < g; p++)ls.fromBufferAttribute(f, p), d && (Xh.fromBufferAttribute(e, p), ls.add(Xh)), i = Math.max(i, n.distanceToSquared(ls));
                }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
        computeTangents() {
            const e = this.index, t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return;
            }
            const n = t.position, i = t.normal, a = t.uv;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new vn(new Float32Array(4 * n.count), 4));
            const l = this.getAttribute("tangent"), f = [], d = [];
            for(let F = 0; F < n.count; F++)f[F] = new Y, d[F] = new Y;
            const p = new Y, g = new Y, y = new Y, _ = new Ie, x = new Ie, M = new Ie, R = new Y, T = new Y;
            function E(F, z, L) {
                p.fromBufferAttribute(n, F), g.fromBufferAttribute(n, z), y.fromBufferAttribute(n, L), _.fromBufferAttribute(a, F), x.fromBufferAttribute(a, z), M.fromBufferAttribute(a, L), g.sub(p), y.sub(p), x.sub(_), M.sub(_);
                const q = 1 / (x.x * M.y - M.x * x.y);
                isFinite(q) && (R.copy(g).multiplyScalar(M.y).addScaledVector(y, -x.y).multiplyScalar(q), T.copy(y).multiplyScalar(x.x).addScaledVector(g, -M.x).multiplyScalar(q), f[F].add(R), f[z].add(R), f[L].add(R), d[F].add(T), d[z].add(T), d[L].add(T));
            }
            let C = this.groups;
            C.length === 0 && (C = [
                {
                    start: 0,
                    count: e.count
                }
            ]);
            for(let F = 0, z = C.length; F < z; ++F){
                const L = C[F], q = L.start, oe = L.count;
                for(let se = q, ge = q + oe; se < ge; se += 3)E(e.getX(se + 0), e.getX(se + 1), e.getX(se + 2));
            }
            const N = new Y, D = new Y, I = new Y, O = new Y;
            function P(F) {
                I.fromBufferAttribute(i, F), O.copy(I);
                const z = f[F];
                N.copy(z), N.sub(I.multiplyScalar(I.dot(z))).normalize(), D.crossVectors(O, z);
                const q = D.dot(d[F]) < 0 ? -1 : 1;
                l.setXYZW(F, N.x, N.y, N.z, q);
            }
            for(let F = 0, z = C.length; F < z; ++F){
                const L = C[F], q = L.start, oe = L.count;
                for(let se = q, ge = q + oe; se < ge; se += 3)P(e.getX(se + 0)), P(e.getX(se + 1)), P(e.getX(se + 2));
            }
        }
        computeVertexNormals() {
            const e = this.index, t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0) n = new vn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                else for(let _ = 0, x = n.count; _ < x; _++)n.setXYZ(_, 0, 0, 0);
                const i = new Y, a = new Y, l = new Y, f = new Y, d = new Y, p = new Y, g = new Y, y = new Y;
                if (e) for(let _ = 0, x = e.count; _ < x; _ += 3){
                    const M = e.getX(_ + 0), R = e.getX(_ + 1), T = e.getX(_ + 2);
                    i.fromBufferAttribute(t, M), a.fromBufferAttribute(t, R), l.fromBufferAttribute(t, T), g.subVectors(l, a), y.subVectors(i, a), g.cross(y), f.fromBufferAttribute(n, M), d.fromBufferAttribute(n, R), p.fromBufferAttribute(n, T), f.add(g), d.add(g), p.add(g), n.setXYZ(M, f.x, f.y, f.z), n.setXYZ(R, d.x, d.y, d.z), n.setXYZ(T, p.x, p.y, p.z);
                }
                else for(let _ = 0, x = t.count; _ < x; _ += 3)i.fromBufferAttribute(t, _ + 0), a.fromBufferAttribute(t, _ + 1), l.fromBufferAttribute(t, _ + 2), g.subVectors(l, a), y.subVectors(i, a), g.cross(y), n.setXYZ(_ + 0, g.x, g.y, g.z), n.setXYZ(_ + 1, g.x, g.y, g.z), n.setXYZ(_ + 2, g.x, g.y, g.z);
                this.normalizeNormals(), n.needsUpdate = !0;
            }
        }
        normalizeNormals() {
            const e = this.attributes.normal;
            for(let t = 0, n = e.count; t < n; t++)ls.fromBufferAttribute(e, t), ls.normalize(), e.setXYZ(t, ls.x, ls.y, ls.z);
        }
        toNonIndexed() {
            function e(f, d) {
                const p = f.array, g = f.itemSize, y = f.normalized, _ = new p.constructor(d.length * g);
                let x = 0, M = 0;
                for(let R = 0, T = d.length; R < T; R++){
                    f.isInterleavedBufferAttribute ? x = d[R] * f.data.stride + f.offset : x = d[R] * g;
                    for(let E = 0; E < g; E++)_[M++] = p[x++];
                }
                return new vn(_, g, y);
            }
            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const t = new Dt, n = this.index.array, i = this.attributes;
            for(const f in i){
                const d = i[f], p = e(d, n);
                t.setAttribute(f, p);
            }
            const a = this.morphAttributes;
            for(const f in a){
                const d = [], p = a[f];
                for(let g = 0, y = p.length; g < y; g++){
                    const _ = p[g], x = e(_, n);
                    d.push(x);
                }
                t.morphAttributes[f] = d;
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const l = this.groups;
            for(let f = 0, d = l.length; f < d; f++){
                const p = l[f];
                t.addGroup(p.start, p.count, p.materialIndex);
            }
            return t;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                const d = this.parameters;
                for(const p in d)d[p] !== void 0 && (e[p] = d[p]);
                return e;
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for(const d in n){
                const p = n[d];
                e.data.attributes[d] = p.toJSON(e.data);
            }
            const i = {};
            let a = !1;
            for(const d in this.morphAttributes){
                const p = this.morphAttributes[d], g = [];
                for(let y = 0, _ = p.length; y < _; y++){
                    const x = p[y];
                    g.push(x.toJSON(e.data));
                }
                g.length > 0 && (i[d] = g, a = !0);
            }
            a && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
            const l = this.groups;
            l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
            const f = this.boundingSphere;
            return f !== null && (e.data.boundingSphere = f.toJSON()), e;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            n !== null && this.setIndex(n.clone());
            const i = e.attributes;
            for(const p in i){
                const g = i[p];
                this.setAttribute(p, g.clone(t));
            }
            const a = e.morphAttributes;
            for(const p in a){
                const g = [], y = a[p];
                for(let _ = 0, x = y.length; _ < x; _++)g.push(y[_].clone(t));
                this.morphAttributes[p] = g;
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const l = e.groups;
            for(let p = 0, g = l.length; p < g; p++){
                const y = l[p];
                this.addGroup(y.start, y.count, y.materialIndex);
            }
            const f = e.boundingBox;
            f !== null && (this.boundingBox = f.clone());
            const d = e.boundingSphere;
            return d !== null && (this.boundingSphere = d.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    const MM = new pt, Ku = new Df, C0 = new us, EM = new Y, D0 = new Y, N0 = new Y, U0 = new Y, nx = new Y, L0 = new Y, TM = new Y, O0 = new Y;
    class ai extends hn {
        constructor(e = new Dt, t = new ja){
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let a = 0, l = i.length; a < l; a++){
                        const f = i[a].name || String(a);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = a;
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            const n = this.geometry, i = n.attributes.position, a = n.morphAttributes.position, l = n.morphTargetsRelative;
            t.fromBufferAttribute(i, e);
            const f = this.morphTargetInfluences;
            if (a && f) {
                L0.set(0, 0, 0);
                for(let d = 0, p = a.length; d < p; d++){
                    const g = f[d], y = a[d];
                    g !== 0 && (nx.fromBufferAttribute(y, e), l ? L0.addScaledVector(nx, g) : L0.addScaledVector(nx.sub(t), g));
                }
                t.add(L0);
            }
            return t;
        }
        raycast(e, t) {
            const n = this.geometry, i = this.material, a = this.matrixWorld;
            i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), C0.copy(n.boundingSphere), C0.applyMatrix4(a), Ku.copy(e.ray).recast(e.near), !(C0.containsPoint(Ku.origin) === !1 && (Ku.intersectSphere(C0, EM) === null || Ku.origin.distanceToSquared(EM) > (e.far - e.near) ** 2)) && (MM.copy(a).invert(), Ku.copy(e.ray).applyMatrix4(MM), !(n.boundingBox !== null && Ku.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Ku)));
        }
        _computeIntersections(e, t, n) {
            let i;
            const a = this.geometry, l = this.material, f = a.index, d = a.attributes.position, p = a.attributes.uv, g = a.attributes.uv1, y = a.attributes.normal, _ = a.groups, x = a.drawRange;
            if (f !== null) if (Array.isArray(l)) for(let M = 0, R = _.length; M < R; M++){
                const T = _[M], E = l[T.materialIndex], C = Math.max(T.start, x.start), N = Math.min(f.count, Math.min(T.start + T.count, x.start + x.count));
                for(let D = C, I = N; D < I; D += 3){
                    const O = f.getX(D), P = f.getX(D + 1), F = f.getX(D + 2);
                    i = z0(this, E, e, n, p, g, y, O, P, F), i && (i.faceIndex = Math.floor(D / 3), i.face.materialIndex = T.materialIndex, t.push(i));
                }
            }
            else {
                const M = Math.max(0, x.start), R = Math.min(f.count, x.start + x.count);
                for(let T = M, E = R; T < E; T += 3){
                    const C = f.getX(T), N = f.getX(T + 1), D = f.getX(T + 2);
                    i = z0(this, l, e, n, p, g, y, C, N, D), i && (i.faceIndex = Math.floor(T / 3), t.push(i));
                }
            }
            else if (d !== void 0) if (Array.isArray(l)) for(let M = 0, R = _.length; M < R; M++){
                const T = _[M], E = l[T.materialIndex], C = Math.max(T.start, x.start), N = Math.min(d.count, Math.min(T.start + T.count, x.start + x.count));
                for(let D = C, I = N; D < I; D += 3){
                    const O = D, P = D + 1, F = D + 2;
                    i = z0(this, E, e, n, p, g, y, O, P, F), i && (i.faceIndex = Math.floor(D / 3), i.face.materialIndex = T.materialIndex, t.push(i));
                }
            }
            else {
                const M = Math.max(0, x.start), R = Math.min(d.count, x.start + x.count);
                for(let T = M, E = R; T < E; T += 3){
                    const C = T, N = T + 1, D = T + 2;
                    i = z0(this, l, e, n, p, g, y, C, N, D), i && (i.faceIndex = Math.floor(T / 3), t.push(i));
                }
            }
        }
    }
    function D2(r, e, t, n, i, a, l, f) {
        let d;
        if (e.side === sa ? d = n.intersectTriangle(l, a, i, !0, f) : d = n.intersectTriangle(i, a, l, e.side === Wo, f), d === null) return null;
        O0.copy(f), O0.applyMatrix4(r.matrixWorld);
        const p = t.ray.origin.distanceTo(O0);
        return p < t.near || p > t.far ? null : {
            distance: p,
            point: O0.clone(),
            object: r
        };
    }
    function z0(r, e, t, n, i, a, l, f, d, p) {
        r.getVertexPosition(f, D0), r.getVertexPosition(d, N0), r.getVertexPosition(p, U0);
        const g = D2(r, e, t, n, D0, N0, U0, TM);
        if (g) {
            const y = new Y;
            ba.getBarycoord(TM, D0, N0, U0, y), i && (g.uv = ba.getInterpolatedAttribute(i, f, d, p, y, new Ie)), a && (g.uv1 = ba.getInterpolatedAttribute(a, f, d, p, y, new Ie)), l && (g.normal = ba.getInterpolatedAttribute(l, f, d, p, y, new Y), g.normal.dot(n.direction) > 0 && g.normal.multiplyScalar(-1));
            const _ = {
                a: f,
                b: d,
                c: p,
                normal: new Y,
                materialIndex: 0
            };
            ba.getNormal(D0, N0, U0, _.normal), g.face = _, g.barycoord = y;
        }
        return g;
    }
    class $c extends Dt {
        constructor(e = 1, t = 1, n = 1, i = 1, a = 1, l = 1){
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: a,
                depthSegments: l
            };
            const f = this;
            i = Math.floor(i), a = Math.floor(a), l = Math.floor(l);
            const d = [], p = [], g = [], y = [];
            let _ = 0, x = 0;
            M("z", "y", "x", -1, -1, n, t, e, l, a, 0), M("z", "y", "x", 1, -1, n, t, -e, l, a, 1), M("x", "z", "y", 1, 1, e, n, t, i, l, 2), M("x", "z", "y", 1, -1, e, n, -t, i, l, 3), M("x", "y", "z", 1, -1, e, t, n, i, a, 4), M("x", "y", "z", -1, -1, e, t, -n, i, a, 5), this.setIndex(d), this.setAttribute("position", new nt(p, 3)), this.setAttribute("normal", new nt(g, 3)), this.setAttribute("uv", new nt(y, 2));
            function M(R, T, E, C, N, D, I, O, P, F, z) {
                const L = D / P, q = I / F, oe = D / 2, se = I / 2, ge = O / 2, _e = P + 1, H = F + 1;
                let K = 0, Q = 0;
                const fe = new Y;
                for(let X = 0; X < H; X++){
                    const $ = X * q - se;
                    for(let me = 0; me < _e; me++){
                        const ve = me * L - oe;
                        fe[R] = ve * C, fe[T] = $ * N, fe[E] = ge, p.push(fe.x, fe.y, fe.z), fe[R] = 0, fe[T] = 0, fe[E] = O > 0 ? 1 : -1, g.push(fe.x, fe.y, fe.z), y.push(me / P), y.push(1 - X / F), K += 1;
                    }
                }
                for(let X = 0; X < F; X++)for(let $ = 0; $ < P; $++){
                    const me = _ + $ + _e * X, ve = _ + $ + _e * (X + 1), J = _ + ($ + 1) + _e * (X + 1), ue = _ + ($ + 1) + _e * X;
                    d.push(me, ve, ue), d.push(ve, J, ue), Q += 6;
                }
                f.addGroup(x, Q, z), x += Q, _ += K;
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new $c(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
    }
    function bd(r) {
        const e = {};
        for(const t in r){
            e[t] = {};
            for(const n in r[t]){
                const i = r[t][n];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
            }
        }
        return e;
    }
    function ea(r) {
        const e = {};
        for(let t = 0; t < r.length; t++){
            const n = bd(r[t]);
            for(const i in n)e[i] = n[i];
        }
        return e;
    }
    function N2(r) {
        const e = [];
        for(let t = 0; t < r.length; t++)e.push(r[t].clone());
        return e;
    }
    function _T(r) {
        const e = r.getRenderTarget();
        return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Sn.workingColorSpace;
    }
    const xT = {
        clone: bd,
        merge: ea
    };
    var U2 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, L2 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class ao extends Li {
        constructor(e){
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = U2, this.fragmentShader = L2, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
            }, this.defaultAttributeValues = {
                color: [
                    1,
                    1,
                    1
                ],
                uv: [
                    0,
                    0
                ],
                uv1: [
                    0,
                    0
                ]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = bd(e.uniforms), this.uniformsGroups = N2(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion, t.uniforms = {};
            for(const i in this.uniforms){
                const l = this.uniforms[i].value;
                l && l.isTexture ? t.uniforms[i] = {
                    type: "t",
                    value: l.toJSON(e).uuid
                } : l && l.isColor ? t.uniforms[i] = {
                    type: "c",
                    value: l.getHex()
                } : l && l.isVector2 ? t.uniforms[i] = {
                    type: "v2",
                    value: l.toArray()
                } : l && l.isVector3 ? t.uniforms[i] = {
                    type: "v3",
                    value: l.toArray()
                } : l && l.isVector4 ? t.uniforms[i] = {
                    type: "v4",
                    value: l.toArray()
                } : l && l.isMatrix3 ? t.uniforms[i] = {
                    type: "m3",
                    value: l.toArray()
                } : l && l.isMatrix4 ? t.uniforms[i] = {
                    type: "m4",
                    value: l.toArray()
                } : t.uniforms[i] = {
                    value: l
                };
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
            const n = {};
            for(const i in this.extensions)this.extensions[i] === !0 && (n[i] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
    }
    class Ay extends hn {
        constructor(){
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new pt, this.projectionMatrix = new pt, this.projectionMatrixInverse = new pt, this.coordinateSystem = xr;
        }
        copy(e, t) {
            return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
            return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Bc = new Y, AM = new Ie, wM = new Ie;
    let hi = class extends Ay {
        constructor(e = 50, t = 1, n = .1, i = 2e3){
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = xd * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
            const e = Math.tan(bf * .5 * this.fov);
            return .5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
            return xd * 2 * Math.atan(Math.tan(bf * .5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, n) {
            Bc.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Bc.x, Bc.y).multiplyScalar(-e / Bc.z), Bc.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Bc.x, Bc.y).multiplyScalar(-e / Bc.z);
        }
        getViewSize(e, t) {
            return this.getViewBounds(e, AM, wM), t.subVectors(wM, AM);
        }
        setViewOffset(e, t, n, i, a, l) {
            this.aspect = e / t, this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = l, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(bf * .5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, a = -.5 * i;
            const l = this.view;
            if (this.view !== null && this.view.enabled) {
                const d = l.fullWidth, p = l.fullHeight;
                a += l.offsetX * i / d, t -= l.offsetY * n / p, i *= l.width / d, n *= l.height / p;
            }
            const f = this.filmOffset;
            f !== 0 && (a += e * f / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
    };
    const jh = -90, qh = 1;
    class ST extends hn {
        constructor(e, t, n){
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
            const i = new hi(jh, qh, e, t);
            i.layers = this.layers, this.add(i);
            const a = new hi(jh, qh, e, t);
            a.layers = this.layers, this.add(a);
            const l = new hi(jh, qh, e, t);
            l.layers = this.layers, this.add(l);
            const f = new hi(jh, qh, e, t);
            f.layers = this.layers, this.add(f);
            const d = new hi(jh, qh, e, t);
            d.layers = this.layers, this.add(d);
            const p = new hi(jh, qh, e, t);
            p.layers = this.layers, this.add(p);
        }
        updateCoordinateSystem() {
            const e = this.coordinateSystem, t = this.children.concat(), [n, i, a, l, f, d] = t;
            for (const p of t)this.remove(p);
            if (e === xr) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), f.up.set(0, 1, 0), f.lookAt(0, 0, 1), d.up.set(0, 1, 0), d.lookAt(0, 0, -1);
            else if (e === wm) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), f.up.set(0, -1, 0), f.lookAt(0, 0, 1), d.up.set(0, -1, 0), d.lookAt(0, 0, -1);
            else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            for (const p of t)this.add(p), p.updateMatrixWorld();
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            const { renderTarget: n, activeMipmapLevel: i } = this;
            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
            const [a, l, f, d, p, g] = this.children, y = e.getRenderTarget(), _ = e.getActiveCubeFace(), x = e.getActiveMipmapLevel(), M = e.xr.enabled;
            e.xr.enabled = !1;
            const R = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, a), e.setRenderTarget(n, 1, i), e.render(t, l), e.setRenderTarget(n, 2, i), e.render(t, f), e.setRenderTarget(n, 3, i), e.render(t, d), e.setRenderTarget(n, 4, i), e.render(t, p), n.texture.generateMipmaps = R, e.setRenderTarget(n, 5, i), e.render(t, g), e.setRenderTarget(y, _, x), e.xr.enabled = M, n.texture.needsPMREMUpdate = !0;
        }
    }
    class Pm extends Qn {
        constructor(e = [], t = Bl, n, i, a, l, f, d, p, g){
            super(e, t, n, i, a, l, f, d, p, g), this.isCubeTexture = !0, this.flipY = !1;
        }
        get images() {
            return this.image;
        }
        set images(e) {
            this.image = e;
        }
    }
    class bT extends so {
        constructor(e = 1, t = {}){
            super(e, e, t), this.isWebGLCubeRenderTarget = !0;
            const n = {
                width: e,
                height: e,
                depth: 1
            }, i = [
                n,
                n,
                n,
                n,
                n,
                n
            ];
            this.texture = new Pm(i), this._setTextureOptions(t), this.texture.isRenderTargetTexture = !0;
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            }, i = new $c(5, 5, 5), a = new ao({
                name: "CubemapFromEquirect",
                uniforms: bd(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: sa,
                blending: Ul
            });
            a.uniforms.tEquirect.value = t;
            const l = new ai(i, a), f = t.minFilter;
            return t.minFilter === Xa && (t.minFilter = pi), new ST(1, 10, this).update(e, l), t.minFilter = f, l.geometry.dispose(), l.material.dispose(), this;
        }
        clear(e, t = !0, n = !0, i = !0) {
            const a = e.getRenderTarget();
            for(let l = 0; l < 6; l++)e.setRenderTarget(this, l), e.clear(t, n, i);
            e.setRenderTarget(a);
        }
    }
    class Sr extends hn {
        constructor(){
            super(), this.isGroup = !0, this.type = "Group";
        }
    }
    const O2 = {
        type: "move"
    };
    class gv {
        constructor(){
            this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new Sr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand;
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new Sr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Y, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Y), this._targetRay;
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new Sr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Y, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Y), this._grip;
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
        }
        connect(e) {
            if (e && e.hand) {
                const t = this._hand;
                if (t) for (const n of e.hand.values())this._getHandJoint(t, n);
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }), this;
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
        }
        update(e, t, n) {
            let i = null, a = null, l = null;
            const f = this._targetRay, d = this._grip, p = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (p && e.hand) {
                    l = !0;
                    for (const R of e.hand.values()){
                        const T = t.getJointPose(R, n), E = this._getHandJoint(p, R);
                        T !== null && (E.matrix.fromArray(T.transform.matrix), E.matrix.decompose(E.position, E.rotation, E.scale), E.matrixWorldNeedsUpdate = !0, E.jointRadius = T.radius), E.visible = T !== null;
                    }
                    const g = p.joints["index-finger-tip"], y = p.joints["thumb-tip"], _ = g.position.distanceTo(y.position), x = .02, M = .005;
                    p.inputState.pinching && _ > x + M ? (p.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !p.inputState.pinching && _ <= x - M && (p.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }));
                } else d !== null && e.gripSpace && (a = t.getPose(e.gripSpace, n), a !== null && (d.matrix.fromArray(a.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (d.hasLinearVelocity = !0, d.linearVelocity.copy(a.linearVelocity)) : d.hasLinearVelocity = !1, a.angularVelocity ? (d.hasAngularVelocity = !0, d.angularVelocity.copy(a.angularVelocity)) : d.hasAngularVelocity = !1));
                f !== null && (i = t.getPose(e.targetRaySpace, n), i === null && a !== null && (i = a), i !== null && (f.matrix.fromArray(i.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), f.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (f.hasLinearVelocity = !0, f.linearVelocity.copy(i.linearVelocity)) : f.hasLinearVelocity = !1, i.angularVelocity ? (f.hasAngularVelocity = !0, f.angularVelocity.copy(i.angularVelocity)) : f.hasAngularVelocity = !1, this.dispatchEvent(O2)));
            }
            return f !== null && (f.visible = i !== null), d !== null && (d.visible = a !== null), p !== null && (p.visible = l !== null), this;
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                const n = new Sr;
                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
            }
            return e.joints[t.jointName];
        }
    }
    class wy {
        constructor(e, t = 25e-5){
            this.isFogExp2 = !0, this.name = "", this.color = new tt(e), this.density = t;
        }
        clone() {
            return new wy(this.color, this.density);
        }
        toJSON() {
            return {
                type: "FogExp2",
                name: this.name,
                color: this.color.getHex(),
                density: this.density
            };
        }
    }
    class Ry {
        constructor(e, t = 1, n = 1e3){
            this.isFog = !0, this.name = "", this.color = new tt(e), this.near = t, this.far = n;
        }
        clone() {
            return new Ry(this.color, this.near, this.far);
        }
        toJSON() {
            return {
                type: "Fog",
                name: this.name,
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };
        }
    }
    class IS extends hn {
        constructor(){
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $i, this.environmentIntensity = 1, this.environmentRotation = new $i, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        copy(e, t) {
            return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
    }
    class Hm {
        constructor(e, t){
            this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Am, this.updateRanges = [], this.version = 0, this.uuid = qa();
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        addUpdateRange(e, t) {
            this.updateRanges.push({
                start: e,
                count: t
            });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, n) {
            e *= this.stride, n *= t.stride;
            for(let i = 0, a = this.stride; i < a; i++)this.array[e + i] = t.array[n + i];
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        clone(e) {
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
            return n.setUsage(this.usage), n;
        }
        onUpload(e) {
            return this.onUploadCallback = e, this;
        }
        toJSON(e) {
            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    }
    const $s = new Y;
    class Yc {
        constructor(e, t, n, i = !1){
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
            for(let t = 0, n = this.data.count; t < n; t++)$s.fromBufferAttribute(this, t), $s.applyMatrix4(e), this.setXYZ(t, $s.x, $s.y, $s.z);
            return this;
        }
        applyNormalMatrix(e) {
            for(let t = 0, n = this.count; t < n; t++)$s.fromBufferAttribute(this, t), $s.applyNormalMatrix(e), this.setXYZ(t, $s.x, $s.y, $s.z);
            return this;
        }
        transformDirection(e) {
            for(let t = 0, n = this.count; t < n; t++)$s.fromBufferAttribute(this, t), $s.transformDirection(e), this.setXYZ(t, $s.x, $s.y, $s.z);
            return this;
        }
        getComponent(e, t) {
            let n = this.array[e * this.data.stride + this.offset + t];
            return this.normalized && (n = ta(n, this.array)), n;
        }
        setComponent(e, t, n) {
            return this.normalized && (n = en(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
        }
        setX(e, t) {
            return this.normalized && (t = en(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
            return this.normalized && (t = en(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
            return this.normalized && (t = en(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
            return this.normalized && (t = en(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
            let t = this.data.array[e * this.data.stride + this.offset];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        getY(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 1];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        getZ(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 2];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        getW(e) {
            let t = this.data.array[e * this.data.stride + this.offset + 3];
            return this.normalized && (t = ta(t, this.array)), t;
        }
        setXY(e, t, n) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = en(t, this.array), n = en(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
        }
        setXYZ(e, t, n, i) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
        }
        setXYZW(e, t, n, i, a) {
            return e = e * this.data.stride + this.offset, this.normalized && (t = en(t, this.array), n = en(n, this.array), i = en(i, this.array), a = en(a, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = a, this;
        }
        clone(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const i = n * this.data.stride + this.offset;
                    for(let a = 0; a < this.itemSize; a++)t.push(this.data.array[i + a]);
                }
                return new vn(new this.array.constructor(t), this.itemSize, this.normalized);
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Yc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
            if (e === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for(let n = 0; n < this.count; n++){
                    const i = n * this.data.stride + this.offset;
                    for(let a = 0; a < this.itemSize; a++)t.push(this.data.array[i + a]);
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                };
            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
    class PS extends Li {
        constructor(e){
            super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new tt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
    }
    let Yh;
    const em = new Y, Wh = new Y, Zh = new Y, Kh = new Ie, tm = new Ie, MT = new pt, B0 = new Y, nm = new Y, I0 = new Y, RM = new Ie, ix = new Ie, CM = new Ie;
    class ET extends hn {
        constructor(e = new PS){
            if (super(), this.isSprite = !0, this.type = "Sprite", Yh === void 0) {
                Yh = new Dt;
                const t = new Float32Array([
                    -.5,
                    -.5,
                    0,
                    0,
                    0,
                    .5,
                    -.5,
                    0,
                    1,
                    0,
                    .5,
                    .5,
                    0,
                    1,
                    1,
                    -.5,
                    .5,
                    0,
                    0,
                    1
                ]), n = new Hm(t, 5);
                Yh.setIndex([
                    0,
                    1,
                    2,
                    0,
                    2,
                    3
                ]), Yh.setAttribute("position", new Yc(n, 3, 0, !1)), Yh.setAttribute("uv", new Yc(n, 2, 3, !1));
            }
            this.geometry = Yh, this.material = e, this.center = new Ie(.5, .5), this.count = 1;
        }
        raycast(e, t) {
            e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Wh.setFromMatrixScale(this.matrixWorld), MT.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Zh.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Wh.multiplyScalar(-Zh.z);
            const n = this.material.rotation;
            let i, a;
            n !== 0 && (a = Math.cos(n), i = Math.sin(n));
            const l = this.center;
            P0(B0.set(-.5, -.5, 0), Zh, l, Wh, i, a), P0(nm.set(.5, -.5, 0), Zh, l, Wh, i, a), P0(I0.set(.5, .5, 0), Zh, l, Wh, i, a), RM.set(0, 0), ix.set(1, 0), CM.set(1, 1);
            let f = e.ray.intersectTriangle(B0, nm, I0, !1, em);
            if (f === null && (P0(nm.set(-.5, .5, 0), Zh, l, Wh, i, a), ix.set(0, 1), f = e.ray.intersectTriangle(B0, I0, nm, !1, em), f === null)) return;
            const d = e.ray.origin.distanceTo(em);
            d < e.near || d > e.far || t.push({
                distance: d,
                point: em.clone(),
                uv: ba.getInterpolation(em, B0, nm, I0, RM, ix, CM, new Ie),
                face: null,
                object: this
            });
        }
        copy(e, t) {
            return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
        }
    }
    function P0(r, e, t, n, i, a) {
        Kh.subVectors(r, t).addScalar(.5).multiply(n), i !== void 0 ? (tm.x = a * Kh.x - i * Kh.y, tm.y = i * Kh.x + a * Kh.y) : tm.copy(Kh), r.copy(e), r.x += tm.x, r.y += tm.y, r.applyMatrix4(MT);
    }
    const H0 = new Y, DM = new Y;
    class TT extends hn {
        constructor(){
            super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0;
        }
        copy(e) {
            super.copy(e, !1);
            const t = e.levels;
            for(let n = 0, i = t.length; n < i; n++){
                const a = t[n];
                this.addLevel(a.object.clone(), a.distance, a.hysteresis);
            }
            return this.autoUpdate = e.autoUpdate, this;
        }
        addLevel(e, t = 0, n = 0) {
            t = Math.abs(t);
            const i = this.levels;
            let a;
            for(a = 0; a < i.length && !(t < i[a].distance); a++);
            return i.splice(a, 0, {
                distance: t,
                hysteresis: n,
                object: e
            }), this.add(e), this;
        }
        removeLevel(e) {
            const t = this.levels;
            for(let n = 0; n < t.length; n++)if (t[n].distance === e) {
                const i = t.splice(n, 1);
                return this.remove(i[0].object), !0;
            }
            return !1;
        }
        getCurrentLevel() {
            return this._currentLevel;
        }
        getObjectForDistance(e) {
            const t = this.levels;
            if (t.length > 0) {
                let n, i;
                for(n = 1, i = t.length; n < i; n++){
                    let a = t[n].distance;
                    if (t[n].object.visible && (a -= a * t[n].hysteresis), e < a) break;
                }
                return t[n - 1].object;
            }
            return null;
        }
        raycast(e, t) {
            if (this.levels.length > 0) {
                H0.setFromMatrixPosition(this.matrixWorld);
                const i = e.ray.origin.distanceTo(H0);
                this.getObjectForDistance(i).raycast(e, t);
            }
        }
        update(e) {
            const t = this.levels;
            if (t.length > 1) {
                H0.setFromMatrixPosition(e.matrixWorld), DM.setFromMatrixPosition(this.matrixWorld);
                const n = H0.distanceTo(DM) / e.zoom;
                t[0].object.visible = !0;
                let i, a;
                for(i = 1, a = t.length; i < a; i++){
                    let l = t[i].distance;
                    if (t[i].object.visible && (l -= l * t[i].hysteresis), n >= l) t[i - 1].object.visible = !1, t[i].object.visible = !0;
                    else break;
                }
                for(this._currentLevel = i - 1; i < a; i++)t[i].object.visible = !1;
            }
        }
        toJSON(e) {
            const t = super.toJSON(e);
            this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
            const n = this.levels;
            for(let i = 0, a = n.length; i < a; i++){
                const l = n[i];
                t.object.levels.push({
                    object: l.object.uuid,
                    distance: l.distance,
                    hysteresis: l.hysteresis
                });
            }
            return t;
        }
    }
    const NM = new Y, UM = new gn, LM = new gn, z2 = new Y, OM = new pt, F0 = new Y, sx = new us, zM = new pt, ax = new Df;
    class Cy extends ai {
        constructor(e, t){
            super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = tS, this.bindMatrix = new pt, this.bindMatrixInverse = new pt, this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
            const e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new Ui), this.boundingBox.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, F0), this.boundingBox.expandByPoint(F0);
        }
        computeBoundingSphere() {
            const e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new us), this.boundingSphere.makeEmpty();
            const t = e.getAttribute("position");
            for(let n = 0; n < t.count; n++)this.getVertexPosition(n, F0), this.boundingSphere.expandByPoint(F0);
        }
        copy(e, t) {
            return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        raycast(e, t) {
            const n = this.material, i = this.matrixWorld;
            n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), sx.copy(this.boundingSphere), sx.applyMatrix4(i), e.ray.intersectsSphere(sx) !== !1 && (zM.copy(i).invert(), ax.copy(e.ray).applyMatrix4(zM), !(this.boundingBox !== null && ax.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, ax)));
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
            this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            const e = new gn, t = this.geometry.attributes.skinWeight;
            for(let n = 0, i = t.count; n < i; n++){
                e.fromBufferAttribute(t, n);
                const a = 1 / e.manhattanLength();
                a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e), this.bindMode === tS ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === eT ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
            const n = this.skeleton, i = this.geometry;
            UM.fromBufferAttribute(i.attributes.skinIndex, e), LM.fromBufferAttribute(i.attributes.skinWeight, e), NM.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for(let a = 0; a < 4; a++){
                const l = LM.getComponent(a);
                if (l !== 0) {
                    const f = UM.getComponent(a);
                    OM.multiplyMatrices(n.bones[f].matrixWorld, n.boneInverses[f]), t.addScaledVector(z2.copy(NM).applyMatrix4(OM), l);
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse);
        }
    }
    class Md extends hn {
        constructor(){
            super(), this.isBone = !0, this.type = "Bone";
        }
    }
    class qo extends Qn {
        constructor(e = null, t = 1, n = 1, i, a, l, f, d, p = cs, g = cs, y, _){
            super(null, l, f, d, p, g, i, a, y, _), this.isDataTexture = !0, this.image = {
                data: e,
                width: t,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
        }
    }
    const BM = new pt, B2 = new pt;
    class Rd {
        constructor(e = [], t = []){
            this.uuid = qa(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
            const e = this.bones, t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for(let n = 0, i = this.bones.length; n < i; n++)this.boneInverses.push(new pt);
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = new pt;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
            }
        }
        pose() {
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert();
            }
            for(let e = 0, t = this.bones.length; e < t; e++){
                const n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
            }
        }
        update() {
            const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
            for(let a = 0, l = e.length; a < l; a++){
                const f = e[a] ? e[a].matrixWorld : B2;
                BM.multiplyMatrices(f, t[a]), BM.toArray(n, a * 16);
            }
            i !== null && (i.needsUpdate = !0);
        }
        clone() {
            return new Rd(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const n = new qo(t, e, e, Is, ia);
            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
        }
        getBoneByName(e) {
            for(let t = 0, n = this.bones.length; t < n; t++){
                const i = this.bones[t];
                if (i.name === e) return i;
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for(let n = 0, i = e.bones.length; n < i; n++){
                const a = e.bones[n];
                let l = t[a];
                l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", a), l = new Md), this.bones.push(l), this.boneInverses.push(new pt().fromArray(e.boneInverses[n]));
            }
            return this.init(), this;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones, n = this.boneInverses;
            for(let i = 0, a = t.length; i < a; i++){
                const l = t[i];
                e.bones.push(l.uuid);
                const f = n[i];
                e.boneInverses.push(f.toArray());
            }
            return e;
        }
    }
    class Tf extends vn {
        constructor(e, t, n, i = 1){
            super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
        }
    }
    const Qh = new pt, IM = new pt, G0 = [], PM = new Ui, I2 = new pt, im = new ai, sm = new us;
    class HS extends ai {
        constructor(e, t, n){
            super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Tf(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
            for(let i = 0; i < n; i++)this.setMatrixAt(i, I2);
        }
        computeBoundingBox() {
            const e = this.geometry, t = this.count;
            this.boundingBox === null && (this.boundingBox = new Ui), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, Qh), PM.copy(e.boundingBox).applyMatrix4(Qh), this.boundingBox.union(PM);
        }
        computeBoundingSphere() {
            const e = this.geometry, t = this.count;
            this.boundingSphere === null && (this.boundingSphere = new us), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
            for(let n = 0; n < t; n++)this.getMatrixAt(n, Qh), sm.copy(e.boundingSphere).applyMatrix4(Qh), this.boundingSphere.union(sm);
        }
        copy(e, t) {
            return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
            const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, a = n.length + 1, l = e * a + 1;
            for(let f = 0; f < n.length; f++)n[f] = i[l + f];
        }
        raycast(e, t) {
            const n = this.matrixWorld, i = this.count;
            if (im.geometry = this.geometry, im.material = this.material, im.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), sm.copy(this.boundingSphere), sm.applyMatrix4(n), e.ray.intersectsSphere(sm) !== !1)) for(let a = 0; a < i; a++){
                this.getMatrixAt(a, Qh), IM.multiplyMatrices(n, Qh), im.matrixWorld = IM, im.raycast(e, G0);
                for(let l = 0, f = G0.length; l < f; l++){
                    const d = G0[l];
                    d.instanceId = a, d.object = this, t.push(d);
                }
                G0.length = 0;
            }
        }
        setColorAt(e, t) {
            this.instanceColor === null && (this.instanceColor = new Tf(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
            const n = t.morphTargetInfluences, i = n.length + 1;
            this.morphTexture === null && (this.morphTexture = new qo(new Float32Array(i * this.count), i, this.count, _y, ia));
            const a = this.morphTexture.source.data.data;
            let l = 0;
            for(let p = 0; p < n.length; p++)l += n[p];
            const f = this.geometry.morphTargetsRelative ? 1 : 1 - l, d = i * e;
            a[d] = f, a.set(n, d + 1);
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
    }
    const rx = new Y, P2 = new Y, H2 = new Yt;
    class Cl {
        constructor(e = new Y(1, 0, 0), t = 0){
            this.isPlane = !0, this.normal = e, this.constant = t;
        }
        set(e, t) {
            return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), this.constant = i, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, n) {
            const i = rx.subVectors(n, t).cross(P2.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
            const n = e.delta(rx), i = this.normal.dot(n);
            if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            const a = -(e.start.dot(this.normal) + this.constant) / i;
            return a < 0 || a > 1 ? null : t.copy(e.start).addScaledVector(n, a);
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0;
        }
        intersectsBox(e) {
            return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
            const n = t || H2.getNormalMatrix(e), i = this.coplanarPoint(rx).applyMatrix4(e), a = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(a), this;
        }
        translate(e) {
            return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Qu = new us, F2 = new Ie(.5, .5), V0 = new Y;
    class Cd {
        constructor(e = new Cl, t = new Cl, n = new Cl, i = new Cl, a = new Cl, l = new Cl){
            this.planes = [
                e,
                t,
                n,
                i,
                a,
                l
            ];
        }
        set(e, t, n, i, a, l) {
            const f = this.planes;
            return f[0].copy(e), f[1].copy(t), f[2].copy(n), f[3].copy(i), f[4].copy(a), f[5].copy(l), this;
        }
        copy(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)t[n].copy(e.planes[n]);
            return this;
        }
        setFromProjectionMatrix(e, t = xr) {
            const n = this.planes, i = e.elements, a = i[0], l = i[1], f = i[2], d = i[3], p = i[4], g = i[5], y = i[6], _ = i[7], x = i[8], M = i[9], R = i[10], T = i[11], E = i[12], C = i[13], N = i[14], D = i[15];
            if (n[0].setComponents(d - a, _ - p, T - x, D - E).normalize(), n[1].setComponents(d + a, _ + p, T + x, D + E).normalize(), n[2].setComponents(d + l, _ + g, T + M, D + C).normalize(), n[3].setComponents(d - l, _ - g, T - M, D - C).normalize(), n[4].setComponents(d - f, _ - y, T - R, D - N).normalize(), t === xr) n[5].setComponents(d + f, _ + y, T + R, D + N).normalize();
            else if (t === wm) n[5].setComponents(f, y, R, N).normalize();
            else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            return this;
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Qu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                const t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(), Qu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
            }
            return this.intersectsSphere(Qu);
        }
        intersectsSprite(e) {
            Qu.center.set(0, 0, 0);
            const t = F2.distanceTo(e.center);
            return Qu.radius = .7071067811865476 + t, Qu.applyMatrix4(e.matrixWorld), this.intersectsSphere(Qu);
        }
        intersectsSphere(e) {
            const t = this.planes, n = e.center, i = -e.radius;
            for(let a = 0; a < 6; a++)if (t[a].distanceToPoint(n) < i) return !1;
            return !0;
        }
        intersectsBox(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++){
                const i = t[n];
                if (V0.x = i.normal.x > 0 ? e.max.x : e.min.x, V0.y = i.normal.y > 0 ? e.max.y : e.min.y, V0.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(V0) < 0) return !1;
            }
            return !0;
        }
        containsPoint(e) {
            const t = this.planes;
            for(let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1;
            return !0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const Vo = new pt, ko = new Cd;
    class Dy {
        constructor(){
            this.coordinateSystem = xr;
        }
        intersectsObject(e, t) {
            if (!t.isArrayCamera || t.cameras.length === 0) return !1;
            for(let n = 0; n < t.cameras.length; n++){
                const i = t.cameras[n];
                if (Vo.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), ko.setFromProjectionMatrix(Vo, this.coordinateSystem), ko.intersectsObject(e)) return !0;
            }
            return !1;
        }
        intersectsSprite(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for(let n = 0; n < t.cameras.length; n++){
                const i = t.cameras[n];
                if (Vo.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), ko.setFromProjectionMatrix(Vo, this.coordinateSystem), ko.intersectsSprite(e)) return !0;
            }
            return !1;
        }
        intersectsSphere(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for(let n = 0; n < t.cameras.length; n++){
                const i = t.cameras[n];
                if (Vo.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), ko.setFromProjectionMatrix(Vo, this.coordinateSystem), ko.intersectsSphere(e)) return !0;
            }
            return !1;
        }
        intersectsBox(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for(let n = 0; n < t.cameras.length; n++){
                const i = t.cameras[n];
                if (Vo.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), ko.setFromProjectionMatrix(Vo, this.coordinateSystem), ko.intersectsBox(e)) return !0;
            }
            return !1;
        }
        containsPoint(e, t) {
            if (!t || !t.cameras || t.cameras.length === 0) return !1;
            for(let n = 0; n < t.cameras.length; n++){
                const i = t.cameras[n];
                if (Vo.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), ko.setFromProjectionMatrix(Vo, this.coordinateSystem), ko.containsPoint(e)) return !0;
            }
            return !1;
        }
        clone() {
            return new Dy;
        }
    }
    function ox(r, e) {
        return r - e;
    }
    function G2(r, e) {
        return r.z - e.z;
    }
    function V2(r, e) {
        return e.z - r.z;
    }
    class k2 {
        constructor(){
            this.index = 0, this.pool = [], this.list = [];
        }
        push(e, t, n, i) {
            const a = this.pool, l = this.list;
            this.index >= a.length && a.push({
                start: -1,
                count: -1,
                z: -1,
                index: -1
            });
            const f = a[this.index];
            l.push(f), this.index++, f.start = e, f.count = t, f.z = n, f.index = i;
        }
        reset() {
            this.list.length = 0, this.index = 0;
        }
    }
    const ya = new pt, X2 = new tt(1, 1, 1), HM = new Cd, j2 = new Dy, k0 = new Ui, Ju = new us, am = new Y, FM = new Y, q2 = new Y, lx = new k2, zs = new ai, X0 = [];
    function Y2(r, e, t = 0) {
        const n = e.itemSize;
        if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
            const i = r.count;
            for(let a = 0; a < i; a++)for(let l = 0; l < n; l++)e.setComponent(a + t, l, r.getComponent(a, l));
        } else e.array.set(r.array, t * n);
        e.needsUpdate = !0;
    }
    function $u(r, e) {
        if (r.constructor !== e.constructor) {
            const t = Math.min(r.length, e.length);
            for(let n = 0; n < t; n++)e[n] = r[n];
        } else {
            const t = Math.min(r.length, e.length);
            e.set(new r.constructor(r.buffer, 0, t));
        }
    }
    class AT extends ai {
        constructor(e, t, n = t * 2, i){
            super(new Dt, i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
        }
        get maxInstanceCount() {
            return this._maxInstanceCount;
        }
        get instanceCount() {
            return this._instanceInfo.length - this._availableInstanceIds.length;
        }
        get unusedVertexCount() {
            return this._maxVertexCount - this._nextVertexStart;
        }
        get unusedIndexCount() {
            return this._maxIndexCount - this._nextIndexStart;
        }
        _initMatricesTexture() {
            let e = Math.sqrt(this._maxInstanceCount * 4);
            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4), n = new qo(t, e, e, Is, ia);
            this._matricesTexture = n;
        }
        _initIndirectTexture() {
            let e = Math.sqrt(this._maxInstanceCount);
            e = Math.ceil(e);
            const t = new Uint32Array(e * e), n = new qo(t, e, e, Im, Il);
            this._indirectTexture = n;
        }
        _initColorsTexture() {
            let e = Math.sqrt(this._maxInstanceCount);
            e = Math.ceil(e);
            const t = new Float32Array(e * e * 4).fill(1), n = new qo(t, e, e, Is, ia);
            n.colorSpace = Sn.workingColorSpace, this._colorsTexture = n;
        }
        _initializeGeometry(e) {
            const t = this.geometry, n = this._maxVertexCount, i = this._maxIndexCount;
            if (this._geometryInitialized === !1) {
                for(const a in e.attributes){
                    const l = e.getAttribute(a), { array: f, itemSize: d, normalized: p } = l, g = new f.constructor(n * d), y = new vn(g, d, p);
                    t.setAttribute(a, y);
                }
                if (e.getIndex() !== null) {
                    const a = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                    t.setIndex(new vn(a, 1));
                }
                this._geometryInitialized = !0;
            }
        }
        _validateGeometry(e) {
            const t = this.geometry;
            if (!!e.getIndex() != !!t.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
            for(const n in t.attributes){
                if (!e.hasAttribute(n)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                const i = e.getAttribute(n), a = t.getAttribute(n);
                if (i.itemSize !== a.itemSize || i.normalized !== a.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
            }
        }
        validateInstanceId(e) {
            const t = this._instanceInfo;
            if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`);
        }
        validateGeometryId(e) {
            const t = this._geometryInfo;
            if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`);
        }
        setCustomSort(e) {
            return this.customSort = e, this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Ui);
            const e = this.boundingBox, t = this._instanceInfo;
            e.makeEmpty();
            for(let n = 0, i = t.length; n < i; n++){
                if (t[n].active === !1) continue;
                const a = t[n].geometryIndex;
                this.getMatrixAt(n, ya), this.getBoundingBoxAt(a, k0).applyMatrix4(ya), e.union(k0);
            }
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new us);
            const e = this.boundingSphere, t = this._instanceInfo;
            e.makeEmpty();
            for(let n = 0, i = t.length; n < i; n++){
                if (t[n].active === !1) continue;
                const a = t[n].geometryIndex;
                this.getMatrixAt(n, ya), this.getBoundingSphereAt(a, Ju).applyMatrix4(ya), e.union(Ju);
            }
        }
        addInstance(e) {
            if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached.");
            const n = {
                visible: !0,
                active: !0,
                geometryIndex: e
            };
            let i = null;
            this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(ox), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = n) : (i = this._instanceInfo.length, this._instanceInfo.push(n));
            const a = this._matricesTexture;
            ya.identity().toArray(a.image.data, i * 16), a.needsUpdate = !0;
            const l = this._colorsTexture;
            return l && (X2.toArray(l.image.data, i * 4), l.needsUpdate = !0), this._visibilityChanged = !0, i;
        }
        addGeometry(e, t = -1, n = -1) {
            this._initializeGeometry(e), this._validateGeometry(e);
            const i = {
                vertexStart: -1,
                vertexCount: -1,
                reservedVertexCount: -1,
                indexStart: -1,
                indexCount: -1,
                reservedIndexCount: -1,
                start: -1,
                count: -1,
                boundingBox: null,
                boundingSphere: null,
                active: !0
            }, a = this._geometryInfo;
            i.vertexStart = this._nextVertexStart, i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
            const l = e.getIndex();
            if (l !== null && (i.indexStart = this._nextIndexStart, i.reservedIndexCount = n === -1 ? l.count : n), i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
            let d;
            return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(ox), d = this._availableGeometryIds.shift(), a[d] = i) : (d = this._geometryCount, this._geometryCount++, a.push(i)), this.setGeometryAt(d, e), this._nextIndexStart = i.indexStart + i.reservedIndexCount, this._nextVertexStart = i.vertexStart + i.reservedVertexCount, d;
        }
        setGeometryAt(e, t) {
            if (e >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
            this._validateGeometry(t);
            const n = this.geometry, i = n.getIndex() !== null, a = n.getIndex(), l = t.getIndex(), f = this._geometryInfo[e];
            if (i && l.count > f.reservedIndexCount || t.attributes.position.count > f.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
            const d = f.vertexStart, p = f.reservedVertexCount;
            f.vertexCount = t.getAttribute("position").count;
            for(const g in n.attributes){
                const y = t.getAttribute(g), _ = n.getAttribute(g);
                Y2(y, _, d);
                const x = y.itemSize;
                for(let M = y.count, R = p; M < R; M++){
                    const T = d + M;
                    for(let E = 0; E < x; E++)_.setComponent(T, E, 0);
                }
                _.needsUpdate = !0, _.addUpdateRange(d * x, p * x);
            }
            if (i) {
                const g = f.indexStart, y = f.reservedIndexCount;
                f.indexCount = t.getIndex().count;
                for(let _ = 0; _ < l.count; _++)a.setX(g + _, d + l.getX(_));
                for(let _ = l.count, x = y; _ < x; _++)a.setX(g + _, d);
                a.needsUpdate = !0, a.addUpdateRange(g, f.reservedIndexCount);
            }
            return f.start = i ? f.indexStart : f.vertexStart, f.count = i ? f.indexCount : f.vertexCount, f.boundingBox = null, t.boundingBox !== null && (f.boundingBox = t.boundingBox.clone()), f.boundingSphere = null, t.boundingSphere !== null && (f.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e;
        }
        deleteGeometry(e) {
            const t = this._geometryInfo;
            if (e >= t.length || t[e].active === !1) return this;
            const n = this._instanceInfo;
            for(let i = 0, a = n.length; i < a; i++)n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
            return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this;
        }
        deleteInstance(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this;
        }
        optimize() {
            let e = 0, t = 0;
            const n = this._geometryInfo, i = n.map((l, f)=>f).sort((l, f)=>n[l].vertexStart - n[f].vertexStart), a = this.geometry;
            for(let l = 0, f = n.length; l < f; l++){
                const d = i[l], p = n[d];
                if (p.active !== !1) {
                    if (a.index !== null) {
                        if (p.indexStart !== t) {
                            const { indexStart: g, vertexStart: y, reservedIndexCount: _ } = p, x = a.index, M = x.array, R = e - y;
                            for(let T = g; T < g + _; T++)M[T] = M[T] + R;
                            x.array.copyWithin(t, g, g + _), x.addUpdateRange(t, _), p.indexStart = t;
                        }
                        t += p.reservedIndexCount;
                    }
                    if (p.vertexStart !== e) {
                        const { vertexStart: g, reservedVertexCount: y } = p, _ = a.attributes;
                        for(const x in _){
                            const M = _[x], { array: R, itemSize: T } = M;
                            R.copyWithin(e * T, g * T, (g + y) * T), M.addUpdateRange(e * T, y * T);
                        }
                        p.vertexStart = e;
                    }
                    e += p.reservedVertexCount, p.start = a.index ? p.indexStart : p.vertexStart, this._nextIndexStart = a.index ? p.indexStart + p.reservedIndexCount : 0, this._nextVertexStart = p.vertexStart + p.reservedVertexCount;
                }
            }
            return this;
        }
        getBoundingBoxAt(e, t) {
            if (e >= this._geometryCount) return null;
            const n = this.geometry, i = this._geometryInfo[e];
            if (i.boundingBox === null) {
                const a = new Ui, l = n.index, f = n.attributes.position;
                for(let d = i.start, p = i.start + i.count; d < p; d++){
                    let g = d;
                    l && (g = l.getX(g)), a.expandByPoint(am.fromBufferAttribute(f, g));
                }
                i.boundingBox = a;
            }
            return t.copy(i.boundingBox), t;
        }
        getBoundingSphereAt(e, t) {
            if (e >= this._geometryCount) return null;
            const n = this.geometry, i = this._geometryInfo[e];
            if (i.boundingSphere === null) {
                const a = new us;
                this.getBoundingBoxAt(e, k0), k0.getCenter(a.center);
                const l = n.index, f = n.attributes.position;
                let d = 0;
                for(let p = i.start, g = i.start + i.count; p < g; p++){
                    let y = p;
                    l && (y = l.getX(y)), am.fromBufferAttribute(f, y), d = Math.max(d, a.center.distanceToSquared(am));
                }
                a.radius = Math.sqrt(d), i.boundingSphere = a;
            }
            return t.copy(i.boundingSphere), t;
        }
        setMatrixAt(e, t) {
            this.validateInstanceId(e);
            const n = this._matricesTexture, i = this._matricesTexture.image.data;
            return t.toArray(i, e * 16), n.needsUpdate = !0, this;
        }
        getMatrixAt(e, t) {
            return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16);
        }
        setColorAt(e, t) {
            return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this;
        }
        getColorAt(e, t) {
            return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4);
        }
        setVisibleAt(e, t) {
            return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this);
        }
        getVisibleAt(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].visible;
        }
        setGeometryIdAt(e, t) {
            return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this;
        }
        getGeometryIdAt(e) {
            return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
        }
        getGeometryRangeAt(e, t = {}) {
            this.validateGeometryId(e);
            const n = this._geometryInfo[e];
            return t.vertexStart = n.vertexStart, t.vertexCount = n.vertexCount, t.reservedVertexCount = n.reservedVertexCount, t.indexStart = n.indexStart, t.indexCount = n.indexCount, t.reservedIndexCount = n.reservedIndexCount, t.start = n.start, t.count = n.count, t;
        }
        setInstanceCount(e) {
            const t = this._availableInstanceIds, n = this._instanceInfo;
            for(t.sort(ox); t[t.length - 1] === n.length;)n.pop(), t.pop();
            if (e < n.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
            const i = new Int32Array(e), a = new Int32Array(e);
            $u(this._multiDrawCounts, i), $u(this._multiDrawStarts, a), this._multiDrawCounts = i, this._multiDrawStarts = a, this._maxInstanceCount = e;
            const l = this._indirectTexture, f = this._matricesTexture, d = this._colorsTexture;
            l.dispose(), this._initIndirectTexture(), $u(l.image.data, this._indirectTexture.image.data), f.dispose(), this._initMatricesTexture(), $u(f.image.data, this._matricesTexture.image.data), d && (d.dispose(), this._initColorsTexture(), $u(d.image.data, this._colorsTexture.image.data));
        }
        setGeometrySize(e, t) {
            const n = [
                ...this._geometryInfo
            ].filter((f)=>f.active);
            if (Math.max(...n.map((f)=>f.vertexStart + f.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
            if (this.geometry.index && Math.max(...n.map((d)=>d.indexStart + d.reservedIndexCount)) > t) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
            const a = this.geometry;
            a.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Dt, this._initializeGeometry(a));
            const l = this.geometry;
            a.index && $u(a.index.array, l.index.array);
            for(const f in a.attributes)$u(a.attributes[f].array, l.attributes[f].array);
        }
        raycast(e, t) {
            const n = this._instanceInfo, i = this._geometryInfo, a = this.matrixWorld, l = this.geometry;
            zs.material = this.material, zs.geometry.index = l.index, zs.geometry.attributes = l.attributes, zs.geometry.boundingBox === null && (zs.geometry.boundingBox = new Ui), zs.geometry.boundingSphere === null && (zs.geometry.boundingSphere = new us);
            for(let f = 0, d = n.length; f < d; f++){
                if (!n[f].visible || !n[f].active) continue;
                const p = n[f].geometryIndex, g = i[p];
                zs.geometry.setDrawRange(g.start, g.count), this.getMatrixAt(f, zs.matrixWorld).premultiply(a), this.getBoundingBoxAt(p, zs.geometry.boundingBox), this.getBoundingSphereAt(p, zs.geometry.boundingSphere), zs.raycast(e, X0);
                for(let y = 0, _ = X0.length; y < _; y++){
                    const x = X0[y];
                    x.object = this, x.batchId = f, t.push(x);
                }
                X0.length = 0;
            }
            zs.material = null, zs.geometry.index = null, zs.geometry.attributes = {}, zs.geometry.setDrawRange(0, 1 / 0);
        }
        copy(e) {
            return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map((t)=>({
                    ...t,
                    boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
                    boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
                })), this._instanceInfo = e._instanceInfo.map((t)=>({
                    ...t
                })), this._availableInstanceIds = e._availableInstanceIds.slice(), this._availableGeometryIds = e._availableGeometryIds.slice(), this._nextIndexStart = e._nextIndexStart, this._nextVertexStart = e._nextVertexStart, this._geometryCount = e._geometryCount, this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._indirectTexture = e._indirectTexture.clone(), this._indirectTexture.image.data = this._indirectTexture.image.data.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
        }
        dispose() {
            this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null);
        }
        onBeforeRender(e, t, n, i, a) {
            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
            const l = i.getIndex(), f = l === null ? 1 : l.array.BYTES_PER_ELEMENT, d = this._instanceInfo, p = this._multiDrawStarts, g = this._multiDrawCounts, y = this._geometryInfo, _ = this.perObjectFrustumCulled, x = this._indirectTexture, M = x.image.data, R = n.isArrayCamera ? j2 : HM;
            _ && !n.isArrayCamera && (ya.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), HM.setFromProjectionMatrix(ya, e.coordinateSystem));
            let T = 0;
            if (this.sortObjects) {
                ya.copy(this.matrixWorld).invert(), am.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ya), FM.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(ya);
                for(let N = 0, D = d.length; N < D; N++)if (d[N].visible && d[N].active) {
                    const I = d[N].geometryIndex;
                    this.getMatrixAt(N, ya), this.getBoundingSphereAt(I, Ju).applyMatrix4(ya);
                    let O = !1;
                    if (_ && (O = !R.intersectsSphere(Ju, n)), !O) {
                        const P = y[I], F = q2.subVectors(Ju.center, am).dot(FM);
                        lx.push(P.start, P.count, F, N);
                    }
                }
                const E = lx.list, C = this.customSort;
                C === null ? E.sort(a.transparent ? V2 : G2) : C.call(this, E, n);
                for(let N = 0, D = E.length; N < D; N++){
                    const I = E[N];
                    p[T] = I.start * f, g[T] = I.count, M[T] = I.index, T++;
                }
                lx.reset();
            } else for(let E = 0, C = d.length; E < C; E++)if (d[E].visible && d[E].active) {
                const N = d[E].geometryIndex;
                let D = !1;
                if (_ && (this.getMatrixAt(E, ya), this.getBoundingSphereAt(N, Ju).applyMatrix4(ya), D = !R.intersectsSphere(Ju, n)), !D) {
                    const I = y[N];
                    p[T] = I.start * f, g[T] = I.count, M[T] = E, T++;
                }
            }
            x.needsUpdate = !0, this._multiDrawCount = T, this._visibilityChanged = !1;
        }
        onBeforeShadow(e, t, n, i, a, l) {
            this.onBeforeRender(e, null, i, a, l);
        }
    }
    class Vi extends Li {
        constructor(e){
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new tt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
    }
    const iy = new Y, sy = new Y, GM = new pt, rm = new Df, j0 = new us, cx = new Y, VM = new Y;
    class Ko extends hn {
        constructor(e = new Dt, t = new Vi){
            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [
                    0
                ];
                for(let i = 1, a = t.count; i < a; i++)iy.fromBufferAttribute(t, i - 1), sy.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += iy.distanceTo(sy);
                e.setAttribute("lineDistance", new nt(n, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
        raycast(e, t) {
            const n = this.geometry, i = this.matrixWorld, a = e.params.Line.threshold, l = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), j0.copy(n.boundingSphere), j0.applyMatrix4(i), j0.radius += a, e.ray.intersectsSphere(j0) === !1) return;
            GM.copy(i).invert(), rm.copy(e.ray).applyMatrix4(GM);
            const f = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), d = f * f, p = this.isLineSegments ? 2 : 1, g = n.index, _ = n.attributes.position;
            if (g !== null) {
                const x = Math.max(0, l.start), M = Math.min(g.count, l.start + l.count);
                for(let R = x, T = M - 1; R < T; R += p){
                    const E = g.getX(R), C = g.getX(R + 1), N = q0(this, e, rm, d, E, C, R);
                    N && t.push(N);
                }
                if (this.isLineLoop) {
                    const R = g.getX(M - 1), T = g.getX(x), E = q0(this, e, rm, d, R, T, M - 1);
                    E && t.push(E);
                }
            } else {
                const x = Math.max(0, l.start), M = Math.min(_.count, l.start + l.count);
                for(let R = x, T = M - 1; R < T; R += p){
                    const E = q0(this, e, rm, d, R, R + 1, R);
                    E && t.push(E);
                }
                if (this.isLineLoop) {
                    const R = q0(this, e, rm, d, M - 1, x, M - 1);
                    R && t.push(R);
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let a = 0, l = i.length; a < l; a++){
                        const f = i[a].name || String(a);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = a;
                    }
                }
            }
        }
    }
    function q0(r, e, t, n, i, a, l) {
        const f = r.geometry.attributes.position;
        if (iy.fromBufferAttribute(f, i), sy.fromBufferAttribute(f, a), t.distanceSqToSegment(iy, sy, cx, VM) > n) return;
        cx.applyMatrix4(r.matrixWorld);
        const p = e.ray.origin.distanceTo(cx);
        if (!(p < e.near || p > e.far)) return {
            distance: p,
            point: VM.clone().applyMatrix4(r.matrixWorld),
            index: l,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: r
        };
    }
    const kM = new Y, XM = new Y;
    class Ya extends Ko {
        constructor(e, t){
            super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
        }
        computeLineDistances() {
            const e = this.geometry;
            if (e.index === null) {
                const t = e.attributes.position, n = [];
                for(let i = 0, a = t.count; i < a; i += 2)kM.fromBufferAttribute(t, i), XM.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + kM.distanceTo(XM);
                e.setAttribute("lineDistance", new nt(n, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this;
        }
    }
    class FS extends Ko {
        constructor(e, t){
            super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
        }
    }
    class kc extends Li {
        constructor(e){
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new tt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
    }
    const jM = new pt, sS = new Df, Y0 = new us, W0 = new Y;
    class cd extends hn {
        constructor(e = new Dt, t = new kc){
            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
            return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
            const n = this.geometry, i = this.matrixWorld, a = e.params.Points.threshold, l = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(), Y0.copy(n.boundingSphere), Y0.applyMatrix4(i), Y0.radius += a, e.ray.intersectsSphere(Y0) === !1) return;
            jM.copy(i).invert(), sS.copy(e.ray).applyMatrix4(jM);
            const f = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), d = f * f, p = n.index, y = n.attributes.position;
            if (p !== null) {
                const _ = Math.max(0, l.start), x = Math.min(p.count, l.start + l.count);
                for(let M = _, R = x; M < R; M++){
                    const T = p.getX(M);
                    W0.fromBufferAttribute(y, T), qM(W0, T, d, i, e, t, this);
                }
            } else {
                const _ = Math.max(0, l.start), x = Math.min(y.count, l.start + l.count);
                for(let M = _, R = x; M < R; M++)W0.fromBufferAttribute(y, M), qM(W0, M, d, i, e, t, this);
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes, n = Object.keys(t);
            if (n.length > 0) {
                const i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let a = 0, l = i.length; a < l; a++){
                        const f = i[a].name || String(a);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = a;
                    }
                }
            }
        }
    }
    function qM(r, e, t, n, i, a, l) {
        const f = sS.distanceSqToPoint(r);
        if (f < t) {
            const d = new Y;
            sS.closestPointToPoint(r, d), d.applyMatrix4(n);
            const p = i.ray.origin.distanceTo(d);
            if (p < i.near || p > i.far) return;
            a.push({
                distance: p,
                distanceToRay: Math.sqrt(f),
                point: d,
                index: e,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: l
            });
        }
    }
    class wT extends Qn {
        constructor(e, t, n, i, a = pi, l = pi, f, d, p){
            super(e, t, n, i, a, l, f, d, p), this.isVideoTexture = !0, this.generateMipmaps = !1;
            const g = this;
            function y() {
                g.needsUpdate = !0, e.requestVideoFrameCallback(y);
            }
            "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(y);
        }
        clone() {
            return new this.constructor(this.image).copy(this);
        }
        update() {
            const e = this.image;
            "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        }
    }
    class W2 extends wT {
        constructor(e, t, n, i, a, l, f, d){
            super({}, e, t, n, i, a, l, f, d), this.isVideoFrameTexture = !0;
        }
        update() {}
        clone() {
            return new this.constructor().copy(this);
        }
        setFrame(e) {
            this.image = e, this.needsUpdate = !0;
        }
    }
    class Z2 extends Qn {
        constructor(e, t){
            super({
                width: e,
                height: t
            }), this.isFramebufferTexture = !0, this.magFilter = cs, this.minFilter = cs, this.generateMipmaps = !1, this.needsUpdate = !0;
        }
    }
    class Ny extends Qn {
        constructor(e, t, n, i, a, l, f, d, p, g, y, _){
            super(null, l, f, d, p, g, i, a, y, _), this.isCompressedTexture = !0, this.image = {
                width: t,
                height: n
            }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
        }
    }
    class K2 extends Ny {
        constructor(e, t, n, i, a, l){
            super(e, t, n, a, l), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = na, this.layerUpdates = new Set;
        }
        addLayerUpdate(e) {
            this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class Q2 extends Ny {
        constructor(e, t, n){
            super(void 0, e[0].width, e[0].height, t, n, Bl), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
        }
    }
    class J2 extends Qn {
        constructor(e, t, n, i, a, l, f, d, p){
            super(e, t, n, i, a, l, f, d, p), this.isCanvasTexture = !0, this.needsUpdate = !0;
        }
    }
    class Uy extends Qn {
        constructor(e, t, n = Il, i, a, l, f = cs, d = cs, p, g = gd, y = 1){
            if (g !== gd && g !== vd) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            const _ = {
                width: e,
                height: t,
                depth: y
            };
            super(_, i, a, l, f, d, g, n, p), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
        }
        copy(e) {
            return super.copy(e), this.source = new Vc(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
    }
    class Ly extends Dt {
        constructor(e = 1, t = 1, n = 4, i = 8, a = 1){
            super(), this.type = "CapsuleGeometry", this.parameters = {
                radius: e,
                height: t,
                capSegments: n,
                radialSegments: i,
                heightSegments: a
            }, t = Math.max(0, t), n = Math.max(1, Math.floor(n)), i = Math.max(3, Math.floor(i)), a = Math.max(1, Math.floor(a));
            const l = [], f = [], d = [], p = [], g = t / 2, y = Math.PI / 2 * e, _ = t, x = 2 * y + _, M = n * 2 + a, R = i + 1, T = new Y, E = new Y;
            for(let C = 0; C <= M; C++){
                let N = 0, D = 0, I = 0, O = 0;
                if (C <= n) {
                    const z = C / n, L = z * Math.PI / 2;
                    D = -g - e * Math.cos(L), I = e * Math.sin(L), O = -e * Math.cos(L), N = z * y;
                } else if (C <= n + a) {
                    const z = (C - n) / a;
                    D = -g + z * t, I = e, O = 0, N = y + z * _;
                } else {
                    const z = (C - n - a) / n, L = z * Math.PI / 2;
                    D = g + e * Math.sin(L), I = e * Math.cos(L), O = e * Math.sin(L), N = y + _ + z * y;
                }
                const P = Math.max(0, Math.min(1, N / x));
                let F = 0;
                C === 0 ? F = .5 / i : C === M && (F = -.5 / i);
                for(let z = 0; z <= i; z++){
                    const L = z / i, q = L * Math.PI * 2, oe = Math.sin(q), se = Math.cos(q);
                    E.x = -I * se, E.y = D, E.z = I * oe, f.push(E.x, E.y, E.z), T.set(-I * se, O, I * oe), T.normalize(), d.push(T.x, T.y, T.z), p.push(L + F, P);
                }
                if (C > 0) {
                    const z = (C - 1) * R;
                    for(let L = 0; L < i; L++){
                        const q = z + L, oe = z + L + 1, se = C * R + L, ge = C * R + L + 1;
                        l.push(q, oe, se), l.push(oe, ge, se);
                    }
                }
            }
            this.setIndex(l), this.setAttribute("position", new nt(f, 3)), this.setAttribute("normal", new nt(d, 3)), this.setAttribute("uv", new nt(p, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Ly(e.radius, e.height, e.capSegments, e.radialSegments, e.heightSegments);
        }
    }
    class Oy extends Dt {
        constructor(e = 1, t = 32, n = 0, i = Math.PI * 2){
            super(), this.type = "CircleGeometry", this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: i
            }, t = Math.max(3, t);
            const a = [], l = [], f = [], d = [], p = new Y, g = new Ie;
            l.push(0, 0, 0), f.push(0, 0, 1), d.push(.5, .5);
            for(let y = 0, _ = 3; y <= t; y++, _ += 3){
                const x = n + y / t * i;
                p.x = e * Math.cos(x), p.y = e * Math.sin(x), l.push(p.x, p.y, p.z), f.push(0, 0, 1), g.x = (l[_] / e + 1) / 2, g.y = (l[_ + 1] / e + 1) / 2, d.push(g.x, g.y);
            }
            for(let y = 1; y <= t; y++)a.push(y, y + 1, 0);
            this.setIndex(a), this.setAttribute("position", new nt(l, 3)), this.setAttribute("normal", new nt(f, 3)), this.setAttribute("uv", new nt(d, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Oy(e.radius, e.segments, e.thetaStart, e.thetaLength);
        }
    }
    class Dd extends Dt {
        constructor(e = 1, t = 1, n = 1, i = 32, a = 1, l = !1, f = 0, d = Math.PI * 2){
            super(), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: a,
                openEnded: l,
                thetaStart: f,
                thetaLength: d
            };
            const p = this;
            i = Math.floor(i), a = Math.floor(a);
            const g = [], y = [], _ = [], x = [];
            let M = 0;
            const R = [], T = n / 2;
            let E = 0;
            C(), l === !1 && (e > 0 && N(!0), t > 0 && N(!1)), this.setIndex(g), this.setAttribute("position", new nt(y, 3)), this.setAttribute("normal", new nt(_, 3)), this.setAttribute("uv", new nt(x, 2));
            function C() {
                const D = new Y, I = new Y;
                let O = 0;
                const P = (t - e) / n;
                for(let F = 0; F <= a; F++){
                    const z = [], L = F / a, q = L * (t - e) + e;
                    for(let oe = 0; oe <= i; oe++){
                        const se = oe / i, ge = se * d + f, _e = Math.sin(ge), H = Math.cos(ge);
                        I.x = q * _e, I.y = -L * n + T, I.z = q * H, y.push(I.x, I.y, I.z), D.set(_e, P, H).normalize(), _.push(D.x, D.y, D.z), x.push(se, 1 - L), z.push(M++);
                    }
                    R.push(z);
                }
                for(let F = 0; F < i; F++)for(let z = 0; z < a; z++){
                    const L = R[z][F], q = R[z + 1][F], oe = R[z + 1][F + 1], se = R[z][F + 1];
                    (e > 0 || z !== 0) && (g.push(L, q, se), O += 3), (t > 0 || z !== a - 1) && (g.push(q, oe, se), O += 3);
                }
                p.addGroup(E, O, 0), E += O;
            }
            function N(D) {
                const I = M, O = new Ie, P = new Y;
                let F = 0;
                const z = D === !0 ? e : t, L = D === !0 ? 1 : -1;
                for(let oe = 1; oe <= i; oe++)y.push(0, T * L, 0), _.push(0, L, 0), x.push(.5, .5), M++;
                const q = M;
                for(let oe = 0; oe <= i; oe++){
                    const ge = oe / i * d + f, _e = Math.cos(ge), H = Math.sin(ge);
                    P.x = z * H, P.y = T * L, P.z = z * _e, y.push(P.x, P.y, P.z), _.push(0, L, 0), O.x = _e * .5 + .5, O.y = H * .5 * L + .5, x.push(O.x, O.y), M++;
                }
                for(let oe = 0; oe < i; oe++){
                    const se = I + oe, ge = q + oe;
                    D === !0 ? g.push(ge, ge + 1, se) : g.push(ge + 1, ge, se), F += 3;
                }
                p.addGroup(E, F, D === !0 ? 1 : 2), E += F;
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Dd(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
        }
    }
    class Fm extends Dd {
        constructor(e = 1, t = 1, n = 32, i = 1, a = !1, l = 0, f = Math.PI * 2){
            super(0, e, t, n, i, a, l, f), this.type = "ConeGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: i,
                openEnded: a,
                thetaStart: l,
                thetaLength: f
            };
        }
        static fromJSON(e) {
            return new Fm(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
        }
    }
    class eu extends Dt {
        constructor(e = [], t = [], n = 1, i = 0){
            super(), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: i
            };
            const a = [], l = [];
            f(i), p(n), g(), this.setAttribute("position", new nt(a, 3)), this.setAttribute("normal", new nt(a.slice(), 3)), this.setAttribute("uv", new nt(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
            function f(C) {
                const N = new Y, D = new Y, I = new Y;
                for(let O = 0; O < t.length; O += 3)x(t[O + 0], N), x(t[O + 1], D), x(t[O + 2], I), d(N, D, I, C);
            }
            function d(C, N, D, I) {
                const O = I + 1, P = [];
                for(let F = 0; F <= O; F++){
                    P[F] = [];
                    const z = C.clone().lerp(D, F / O), L = N.clone().lerp(D, F / O), q = O - F;
                    for(let oe = 0; oe <= q; oe++)oe === 0 && F === O ? P[F][oe] = z : P[F][oe] = z.clone().lerp(L, oe / q);
                }
                for(let F = 0; F < O; F++)for(let z = 0; z < 2 * (O - F) - 1; z++){
                    const L = Math.floor(z / 2);
                    z % 2 === 0 ? (_(P[F][L + 1]), _(P[F + 1][L]), _(P[F][L])) : (_(P[F][L + 1]), _(P[F + 1][L + 1]), _(P[F + 1][L]));
                }
            }
            function p(C) {
                const N = new Y;
                for(let D = 0; D < a.length; D += 3)N.x = a[D + 0], N.y = a[D + 1], N.z = a[D + 2], N.normalize().multiplyScalar(C), a[D + 0] = N.x, a[D + 1] = N.y, a[D + 2] = N.z;
            }
            function g() {
                const C = new Y;
                for(let N = 0; N < a.length; N += 3){
                    C.x = a[N + 0], C.y = a[N + 1], C.z = a[N + 2];
                    const D = T(C) / 2 / Math.PI + .5, I = E(C) / Math.PI + .5;
                    l.push(D, 1 - I);
                }
                M(), y();
            }
            function y() {
                for(let C = 0; C < l.length; C += 6){
                    const N = l[C + 0], D = l[C + 2], I = l[C + 4], O = Math.max(N, D, I), P = Math.min(N, D, I);
                    O > .9 && P < .1 && (N < .2 && (l[C + 0] += 1), D < .2 && (l[C + 2] += 1), I < .2 && (l[C + 4] += 1));
                }
            }
            function _(C) {
                a.push(C.x, C.y, C.z);
            }
            function x(C, N) {
                const D = C * 3;
                N.x = e[D + 0], N.y = e[D + 1], N.z = e[D + 2];
            }
            function M() {
                const C = new Y, N = new Y, D = new Y, I = new Y, O = new Ie, P = new Ie, F = new Ie;
                for(let z = 0, L = 0; z < a.length; z += 9, L += 6){
                    C.set(a[z + 0], a[z + 1], a[z + 2]), N.set(a[z + 3], a[z + 4], a[z + 5]), D.set(a[z + 6], a[z + 7], a[z + 8]), O.set(l[L + 0], l[L + 1]), P.set(l[L + 2], l[L + 3]), F.set(l[L + 4], l[L + 5]), I.copy(C).add(N).add(D).divideScalar(3);
                    const q = T(I);
                    R(O, L + 0, C, q), R(P, L + 2, N, q), R(F, L + 4, D, q);
                }
            }
            function R(C, N, D, I) {
                I < 0 && C.x === 1 && (l[N] = C.x - 1), D.x === 0 && D.z === 0 && (l[N] = I / 2 / Math.PI + .5);
            }
            function T(C) {
                return Math.atan2(C.z, -C.x);
            }
            function E(C) {
                return Math.atan2(-C.y, Math.sqrt(C.x * C.x + C.z * C.z));
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new eu(e.vertices, e.indices, e.radius, e.details);
        }
    }
    class zy extends eu {
        constructor(e = 1, t = 0){
            const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, a = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                0,
                -n,
                0,
                -i,
                n,
                0,
                -i,
                -n,
                0,
                i,
                n,
                0,
                i
            ], l = [
                3,
                11,
                7,
                3,
                7,
                15,
                3,
                15,
                13,
                7,
                19,
                17,
                7,
                17,
                6,
                7,
                6,
                15,
                17,
                4,
                8,
                17,
                8,
                10,
                17,
                10,
                6,
                8,
                0,
                16,
                8,
                16,
                2,
                8,
                2,
                10,
                0,
                12,
                1,
                0,
                1,
                18,
                0,
                18,
                16,
                6,
                10,
                2,
                6,
                2,
                13,
                6,
                13,
                15,
                2,
                16,
                18,
                2,
                18,
                3,
                2,
                3,
                13,
                18,
                1,
                9,
                18,
                9,
                11,
                18,
                11,
                3,
                4,
                14,
                12,
                4,
                12,
                0,
                4,
                0,
                8,
                11,
                9,
                5,
                11,
                5,
                19,
                11,
                19,
                7,
                19,
                5,
                14,
                19,
                14,
                4,
                19,
                4,
                17,
                1,
                12,
                14,
                1,
                14,
                5,
                1,
                5,
                9
            ];
            super(a, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            };
        }
        static fromJSON(e) {
            return new zy(e.radius, e.detail);
        }
    }
    const Z0 = new Y, K0 = new Y, ux = new Y, Q0 = new ba;
    class RT extends Dt {
        constructor(e = null, t = 1){
            if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: e,
                thresholdAngle: t
            }, e !== null) {
                const i = Math.pow(10, 4), a = Math.cos(bf * t), l = e.getIndex(), f = e.getAttribute("position"), d = l ? l.count : f.count, p = [
                    0,
                    0,
                    0
                ], g = [
                    "a",
                    "b",
                    "c"
                ], y = new Array(3), _ = {}, x = [];
                for(let M = 0; M < d; M += 3){
                    l ? (p[0] = l.getX(M), p[1] = l.getX(M + 1), p[2] = l.getX(M + 2)) : (p[0] = M, p[1] = M + 1, p[2] = M + 2);
                    const { a: R, b: T, c: E } = Q0;
                    if (R.fromBufferAttribute(f, p[0]), T.fromBufferAttribute(f, p[1]), E.fromBufferAttribute(f, p[2]), Q0.getNormal(ux), y[0] = `${Math.round(R.x * i)},${Math.round(R.y * i)},${Math.round(R.z * i)}`, y[1] = `${Math.round(T.x * i)},${Math.round(T.y * i)},${Math.round(T.z * i)}`, y[2] = `${Math.round(E.x * i)},${Math.round(E.y * i)},${Math.round(E.z * i)}`, !(y[0] === y[1] || y[1] === y[2] || y[2] === y[0])) for(let C = 0; C < 3; C++){
                        const N = (C + 1) % 3, D = y[C], I = y[N], O = Q0[g[C]], P = Q0[g[N]], F = `${D}_${I}`, z = `${I}_${D}`;
                        z in _ && _[z] ? (ux.dot(_[z].normal) <= a && (x.push(O.x, O.y, O.z), x.push(P.x, P.y, P.z)), _[z] = null) : F in _ || (_[F] = {
                            index0: p[C],
                            index1: p[N],
                            normal: ux.clone()
                        });
                    }
                }
                for(const M in _)if (_[M]) {
                    const { index0: R, index1: T } = _[M];
                    Z0.fromBufferAttribute(f, R), K0.fromBufferAttribute(f, T), x.push(Z0.x, Z0.y, Z0.z), x.push(K0.x, K0.y, K0.z);
                }
                this.setAttribute("position", new nt(x, 3));
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
    }
    class Mr {
        constructor(){
            this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
        }
        getPoint() {
            console.warn("THREE.Curve: .getPoint() not implemented.");
        }
        getPointAt(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getPoint(n, t);
        }
        getPoints(e = 5) {
            const t = [];
            for(let n = 0; n <= e; n++)t.push(this.getPoint(n / e));
            return t;
        }
        getSpacedPoints(e = 5) {
            const t = [];
            for(let n = 0; n <= e; n++)t.push(this.getPointAt(n / e));
            return t;
        }
        getLength() {
            const e = this.getLengths();
            return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            const t = [];
            let n, i = this.getPoint(0), a = 0;
            t.push(0);
            for(let l = 1; l <= e; l++)n = this.getPoint(l / e), a += n.distanceTo(i), t.push(a), i = n;
            return this.cacheArcLengths = t, t;
        }
        updateArcLengths() {
            this.needsUpdate = !0, this.getLengths();
        }
        getUtoTmapping(e, t = null) {
            const n = this.getLengths();
            let i = 0;
            const a = n.length;
            let l;
            t ? l = t : l = e * n[a - 1];
            let f = 0, d = a - 1, p;
            for(; f <= d;)if (i = Math.floor(f + (d - f) / 2), p = n[i] - l, p < 0) f = i + 1;
            else if (p > 0) d = i - 1;
            else {
                d = i;
                break;
            }
            if (i = d, n[i] === l) return i / (a - 1);
            const g = n[i], _ = n[i + 1] - g, x = (l - g) / _;
            return (i + x) / (a - 1);
        }
        getTangent(e, t) {
            let i = e - 1e-4, a = e + 1e-4;
            i < 0 && (i = 0), a > 1 && (a = 1);
            const l = this.getPoint(i), f = this.getPoint(a), d = t || (l.isVector2 ? new Ie : new Y);
            return d.copy(f).sub(l).normalize(), d;
        }
        getTangentAt(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t = !1) {
            const n = new Y, i = [], a = [], l = [], f = new Y, d = new pt;
            for(let x = 0; x <= e; x++){
                const M = x / e;
                i[x] = this.getTangentAt(M, new Y);
            }
            a[0] = new Y, l[0] = new Y;
            let p = Number.MAX_VALUE;
            const g = Math.abs(i[0].x), y = Math.abs(i[0].y), _ = Math.abs(i[0].z);
            g <= p && (p = g, n.set(1, 0, 0)), y <= p && (p = y, n.set(0, 1, 0)), _ <= p && n.set(0, 0, 1), f.crossVectors(i[0], n).normalize(), a[0].crossVectors(i[0], f), l[0].crossVectors(i[0], a[0]);
            for(let x = 1; x <= e; x++){
                if (a[x] = a[x - 1].clone(), l[x] = l[x - 1].clone(), f.crossVectors(i[x - 1], i[x]), f.length() > Number.EPSILON) {
                    f.normalize();
                    const M = Math.acos(Wt(i[x - 1].dot(i[x]), -1, 1));
                    a[x].applyMatrix4(d.makeRotationAxis(f, M));
                }
                l[x].crossVectors(i[x], a[x]);
            }
            if (t === !0) {
                let x = Math.acos(Wt(a[0].dot(a[e]), -1, 1));
                x /= e, i[0].dot(f.crossVectors(a[0], a[e])) > 0 && (x = -x);
                for(let M = 1; M <= e; M++)a[M].applyMatrix4(d.makeRotationAxis(i[M], x * M)), l[M].crossVectors(i[M], a[M]);
            }
            return {
                tangents: i,
                normals: a,
                binormals: l
            };
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
        toJSON() {
            const e = {
                metadata: {
                    version: 4.7,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
        }
        fromJSON(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
    }
    class By extends Mr {
        constructor(e = 0, t = 0, n = 1, i = 1, a = 0, l = Math.PI * 2, f = !1, d = 0){
            super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = a, this.aEndAngle = l, this.aClockwise = f, this.aRotation = d;
        }
        getPoint(e, t = new Ie) {
            const n = t, i = Math.PI * 2;
            let a = this.aEndAngle - this.aStartAngle;
            const l = Math.abs(a) < Number.EPSILON;
            for(; a < 0;)a += i;
            for(; a > i;)a -= i;
            a < Number.EPSILON && (l ? a = 0 : a = i), this.aClockwise === !0 && !l && (a === i ? a = -i : a = a - i);
            const f = this.aStartAngle + e * a;
            let d = this.aX + this.xRadius * Math.cos(f), p = this.aY + this.yRadius * Math.sin(f);
            if (this.aRotation !== 0) {
                const g = Math.cos(this.aRotation), y = Math.sin(this.aRotation), _ = d - this.aX, x = p - this.aY;
                d = _ * g - x * y + this.aX, p = _ * y + x * g + this.aY;
            }
            return n.set(d, p);
        }
        copy(e) {
            return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
    }
    class CT extends By {
        constructor(e, t, n, i, a, l){
            super(e, t, n, n, i, a, l), this.isArcCurve = !0, this.type = "ArcCurve";
        }
    }
    function GS() {
        let r = 0, e = 0, t = 0, n = 0;
        function i(a, l, f, d) {
            r = a, e = f, t = -3 * a + 3 * l - 2 * f - d, n = 2 * a - 2 * l + f + d;
        }
        return {
            initCatmullRom: function(a, l, f, d, p) {
                i(l, f, p * (f - a), p * (d - l));
            },
            initNonuniformCatmullRom: function(a, l, f, d, p, g, y) {
                let _ = (l - a) / p - (f - a) / (p + g) + (f - l) / g, x = (f - l) / g - (d - l) / (g + y) + (d - f) / y;
                _ *= g, x *= g, i(l, f, _, x);
            },
            calc: function(a) {
                const l = a * a, f = l * a;
                return r + e * a + t * l + n * f;
            }
        };
    }
    const J0 = new Y, fx = new GS, hx = new GS, dx = new GS;
    class DT extends Mr {
        constructor(e = [], t = !1, n = "centripetal", i = .5){
            super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
        }
        getPoint(e, t = new Y) {
            const n = t, i = this.points, a = i.length, l = (a - (this.closed ? 0 : 1)) * e;
            let f = Math.floor(l), d = l - f;
            this.closed ? f += f > 0 ? 0 : (Math.floor(Math.abs(f) / a) + 1) * a : d === 0 && f === a - 1 && (f = a - 2, d = 1);
            let p, g;
            this.closed || f > 0 ? p = i[(f - 1) % a] : (J0.subVectors(i[0], i[1]).add(i[0]), p = J0);
            const y = i[f % a], _ = i[(f + 1) % a];
            if (this.closed || f + 2 < a ? g = i[(f + 2) % a] : (J0.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), g = J0), this.curveType === "centripetal" || this.curveType === "chordal") {
                const x = this.curveType === "chordal" ? .5 : .25;
                let M = Math.pow(p.distanceToSquared(y), x), R = Math.pow(y.distanceToSquared(_), x), T = Math.pow(_.distanceToSquared(g), x);
                R < 1e-4 && (R = 1), M < 1e-4 && (M = R), T < 1e-4 && (T = R), fx.initNonuniformCatmullRom(p.x, y.x, _.x, g.x, M, R, T), hx.initNonuniformCatmullRom(p.y, y.y, _.y, g.y, M, R, T), dx.initNonuniformCatmullRom(p.z, y.z, _.z, g.z, M, R, T);
            } else this.curveType === "catmullrom" && (fx.initCatmullRom(p.x, y.x, _.x, g.x, this.tension), hx.initCatmullRom(p.y, y.y, _.y, g.y, this.tension), dx.initCatmullRom(p.z, y.z, _.z, g.z, this.tension));
            return n.set(fx.calc(d), hx.calc(d), dx.calc(d)), n;
        }
        copy(e) {
            super.copy(e), this.points = [];
            for(let t = 0, n = e.points.length; t < n; t++){
                const i = e.points[t];
                this.points.push(i.clone());
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
        toJSON() {
            const e = super.toJSON();
            e.points = [];
            for(let t = 0, n = this.points.length; t < n; t++){
                const i = this.points[t];
                e.points.push(i.toArray());
            }
            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
        }
        fromJSON(e) {
            super.fromJSON(e), this.points = [];
            for(let t = 0, n = e.points.length; t < n; t++){
                const i = e.points[t];
                this.points.push(new Y().fromArray(i));
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
    }
    function YM(r, e, t, n, i) {
        const a = (n - e) * .5, l = (i - t) * .5, f = r * r, d = r * f;
        return (2 * t - 2 * n + a + l) * d + (-3 * t + 3 * n - 2 * a - l) * f + a * r + t;
    }
    function $2(r, e) {
        const t = 1 - r;
        return t * t * e;
    }
    function eC(r, e) {
        return 2 * (1 - r) * r * e;
    }
    function tC(r, e) {
        return r * r * e;
    }
    function _m(r, e, t, n) {
        return $2(r, e) + eC(r, t) + tC(r, n);
    }
    function nC(r, e) {
        const t = 1 - r;
        return t * t * t * e;
    }
    function iC(r, e) {
        const t = 1 - r;
        return 3 * t * t * r * e;
    }
    function sC(r, e) {
        return 3 * (1 - r) * r * r * e;
    }
    function aC(r, e) {
        return r * r * r * e;
    }
    function xm(r, e, t, n, i) {
        return nC(r, e) + iC(r, t) + sC(r, n) + aC(r, i);
    }
    class VS extends Mr {
        constructor(e = new Ie, t = new Ie, n = new Ie, i = new Ie){
            super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
        }
        getPoint(e, t = new Ie) {
            const n = t, i = this.v0, a = this.v1, l = this.v2, f = this.v3;
            return n.set(xm(e, i.x, a.x, l.x, f.x), xm(e, i.y, a.y, l.y, f.y)), n;
        }
        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
    }
    class NT extends Mr {
        constructor(e = new Y, t = new Y, n = new Y, i = new Y){
            super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
        }
        getPoint(e, t = new Y) {
            const n = t, i = this.v0, a = this.v1, l = this.v2, f = this.v3;
            return n.set(xm(e, i.x, a.x, l.x, f.x), xm(e, i.y, a.y, l.y, f.y), xm(e, i.z, a.z, l.z, f.z)), n;
        }
        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
    }
    class kS extends Mr {
        constructor(e = new Ie, t = new Ie){
            super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new Ie) {
            const n = t;
            return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
        }
        getPointAt(e, t) {
            return this.getPoint(e, t);
        }
        getTangent(e, t = new Ie) {
            return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
            return this.getTangent(e, t);
        }
        copy(e) {
            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
    }
    class UT extends Mr {
        constructor(e = new Y, t = new Y){
            super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new Y) {
            const n = t;
            return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
        }
        getPointAt(e, t) {
            return this.getPoint(e, t);
        }
        getTangent(e, t = new Y) {
            return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
            return this.getTangent(e, t);
        }
        copy(e) {
            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
    }
    class XS extends Mr {
        constructor(e = new Ie, t = new Ie, n = new Ie){
            super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
        }
        getPoint(e, t = new Ie) {
            const n = t, i = this.v0, a = this.v1, l = this.v2;
            return n.set(_m(e, i.x, a.x, l.x), _m(e, i.y, a.y, l.y)), n;
        }
        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
    }
    class jS extends Mr {
        constructor(e = new Y, t = new Y, n = new Y){
            super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
        }
        getPoint(e, t = new Y) {
            const n = t, i = this.v0, a = this.v1, l = this.v2;
            return n.set(_m(e, i.x, a.x, l.x), _m(e, i.y, a.y, l.y), _m(e, i.z, a.z, l.z)), n;
        }
        copy(e) {
            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
    }
    class qS extends Mr {
        constructor(e = []){
            super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
        }
        getPoint(e, t = new Ie) {
            const n = t, i = this.points, a = (i.length - 1) * e, l = Math.floor(a), f = a - l, d = i[l === 0 ? l : l - 1], p = i[l], g = i[l > i.length - 2 ? i.length - 1 : l + 1], y = i[l > i.length - 3 ? i.length - 1 : l + 2];
            return n.set(YM(f, d.x, p.x, g.x, y.x), YM(f, d.y, p.y, g.y, y.y)), n;
        }
        copy(e) {
            super.copy(e), this.points = [];
            for(let t = 0, n = e.points.length; t < n; t++){
                const i = e.points[t];
                this.points.push(i.clone());
            }
            return this;
        }
        toJSON() {
            const e = super.toJSON();
            e.points = [];
            for(let t = 0, n = this.points.length; t < n; t++){
                const i = this.points[t];
                e.points.push(i.toArray());
            }
            return e;
        }
        fromJSON(e) {
            super.fromJSON(e), this.points = [];
            for(let t = 0, n = e.points.length; t < n; t++){
                const i = e.points[t];
                this.points.push(new Ie().fromArray(i));
            }
            return this;
        }
    }
    var ay = Object.freeze({
        __proto__: null,
        ArcCurve: CT,
        CatmullRomCurve3: DT,
        CubicBezierCurve: VS,
        CubicBezierCurve3: NT,
        EllipseCurve: By,
        LineCurve: kS,
        LineCurve3: UT,
        QuadraticBezierCurve: XS,
        QuadraticBezierCurve3: jS,
        SplineCurve: qS
    });
    class LT extends Mr {
        constructor(){
            super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
        }
        add(e) {
            this.curves.push(e);
        }
        closePath() {
            const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
            if (!e.equals(t)) {
                const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                this.curves.push(new ay[n](t, e));
            }
            return this;
        }
        getPoint(e, t) {
            const n = e * this.getLength(), i = this.getCurveLengths();
            let a = 0;
            for(; a < i.length;){
                if (i[a] >= n) {
                    const l = i[a] - n, f = this.curves[a], d = f.getLength(), p = d === 0 ? 0 : 1 - l / d;
                    return f.getPointAt(p, t);
                }
                a++;
            }
            return null;
        }
        getLength() {
            const e = this.getCurveLengths();
            return e[e.length - 1];
        }
        updateArcLengths() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            const e = [];
            let t = 0;
            for(let n = 0, i = this.curves.length; n < i; n++)t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e, e;
        }
        getSpacedPoints(e = 40) {
            const t = [];
            for(let n = 0; n <= e; n++)t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
            const t = [];
            let n;
            for(let i = 0, a = this.curves; i < a.length; i++){
                const l = a[i], f = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, d = l.getPoints(f);
                for(let p = 0; p < d.length; p++){
                    const g = d[p];
                    n && n.equals(g) || (t.push(g), n = g);
                }
            }
            return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
        }
        copy(e) {
            super.copy(e), this.curves = [];
            for(let t = 0, n = e.curves.length; t < n; t++){
                const i = e.curves[t];
                this.curves.push(i.clone());
            }
            return this.autoClose = e.autoClose, this;
        }
        toJSON() {
            const e = super.toJSON();
            e.autoClose = this.autoClose, e.curves = [];
            for(let t = 0, n = this.curves.length; t < n; t++){
                const i = this.curves[t];
                e.curves.push(i.toJSON());
            }
            return e;
        }
        fromJSON(e) {
            super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
            for(let t = 0, n = e.curves.length; t < n; t++){
                const i = e.curves[t];
                this.curves.push(new ay[i.type]().fromJSON(i));
            }
            return this;
        }
    }
    class ry extends LT {
        constructor(e){
            super(), this.type = "Path", this.currentPoint = new Ie, e && this.setFromPoints(e);
        }
        setFromPoints(e) {
            this.moveTo(e[0].x, e[0].y);
            for(let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y);
            return this;
        }
        moveTo(e, t) {
            return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
            const n = new kS(this.currentPoint.clone(), new Ie(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
            const a = new XS(this.currentPoint.clone(), new Ie(e, t), new Ie(n, i));
            return this.curves.push(a), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, a, l) {
            const f = new VS(this.currentPoint.clone(), new Ie(e, t), new Ie(n, i), new Ie(a, l));
            return this.curves.push(f), this.currentPoint.set(a, l), this;
        }
        splineThru(e) {
            const t = [
                this.currentPoint.clone()
            ].concat(e), n = new qS(t);
            return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
        }
        arc(e, t, n, i, a, l) {
            const f = this.currentPoint.x, d = this.currentPoint.y;
            return this.absarc(e + f, t + d, n, i, a, l), this;
        }
        absarc(e, t, n, i, a, l) {
            return this.absellipse(e, t, n, n, i, a, l), this;
        }
        ellipse(e, t, n, i, a, l, f, d) {
            const p = this.currentPoint.x, g = this.currentPoint.y;
            return this.absellipse(e + p, t + g, n, i, a, l, f, d), this;
        }
        absellipse(e, t, n, i, a, l, f, d) {
            const p = new By(e, t, n, i, a, l, f, d);
            if (this.curves.length > 0) {
                const y = p.getPoint(0);
                y.equals(this.currentPoint) || this.lineTo(y.x, y.y);
            }
            this.curves.push(p);
            const g = p.getPoint(1);
            return this.currentPoint.copy(g), this;
        }
        copy(e) {
            return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.currentPoint = this.currentPoint.toArray(), e;
        }
        fromJSON(e) {
            return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
        }
    }
    class Mf extends ry {
        constructor(e){
            super(e), this.uuid = qa(), this.type = "Shape", this.holes = [];
        }
        getPointsHoles(e) {
            const t = [];
            for(let n = 0, i = this.holes.length; n < i; n++)t[n] = this.holes[n].getPoints(e);
            return t;
        }
        extractPoints(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            };
        }
        copy(e) {
            super.copy(e), this.holes = [];
            for(let t = 0, n = e.holes.length; t < n; t++){
                const i = e.holes[t];
                this.holes.push(i.clone());
            }
            return this;
        }
        toJSON() {
            const e = super.toJSON();
            e.uuid = this.uuid, e.holes = [];
            for(let t = 0, n = this.holes.length; t < n; t++){
                const i = this.holes[t];
                e.holes.push(i.toJSON());
            }
            return e;
        }
        fromJSON(e) {
            super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
            for(let t = 0, n = e.holes.length; t < n; t++){
                const i = e.holes[t];
                this.holes.push(new ry().fromJSON(i));
            }
            return this;
        }
    }
    function rC(r, e, t = 2) {
        const n = e && e.length, i = n ? e[0] * t : r.length;
        let a = OT(r, 0, i, t, !0);
        const l = [];
        if (!a || a.next === a.prev) return l;
        let f, d, p;
        if (n && (a = fC(r, e, a, t)), r.length > 80 * t) {
            f = 1 / 0, d = 1 / 0;
            let g = -1 / 0, y = -1 / 0;
            for(let _ = t; _ < i; _ += t){
                const x = r[_], M = r[_ + 1];
                x < f && (f = x), M < d && (d = M), x > g && (g = x), M > y && (y = M);
            }
            p = Math.max(g - f, y - d), p = p !== 0 ? 32767 / p : 0;
        }
        return Cm(a, l, t, f, d, p, 0), l;
    }
    function OT(r, e, t, n, i) {
        let a;
        if (i === bC(r, e, t, n) > 0) for(let l = e; l < t; l += n)a = WM(l / n | 0, r[l], r[l + 1], a);
        else for(let l = t - n; l >= e; l -= n)a = WM(l / n | 0, r[l], r[l + 1], a);
        return a && Ed(a, a.next) && (Nm(a), a = a.next), a;
    }
    function Af(r, e) {
        if (!r) return r;
        e || (e = r);
        let t = r, n;
        do if (n = !1, !t.steiner && (Ed(t, t.next) || di(t.prev, t, t.next) === 0)) {
            if (Nm(t), t = e = t.prev, t === t.next) break;
            n = !0;
        } else t = t.next;
        while (n || t !== e);
        return e;
    }
    function Cm(r, e, t, n, i, a, l) {
        if (!r) return;
        !l && a && gC(r, n, i, a);
        let f = r;
        for(; r.prev !== r.next;){
            const d = r.prev, p = r.next;
            if (a ? lC(r, n, i, a) : oC(r)) {
                e.push(d.i, r.i, p.i), Nm(r), r = p.next, f = p.next;
                continue;
            }
            if (r = p, r === f) {
                l ? l === 1 ? (r = cC(Af(r), e), Cm(r, e, t, n, i, a, 2)) : l === 2 && uC(r, e, t, n, i, a) : Cm(Af(r), e, t, n, i, a, 1);
                break;
            }
        }
    }
    function oC(r) {
        const e = r.prev, t = r, n = r.next;
        if (di(e, t, n) >= 0) return !1;
        const i = e.x, a = t.x, l = n.x, f = e.y, d = t.y, p = n.y, g = Math.min(i, a, l), y = Math.min(f, d, p), _ = Math.max(i, a, l), x = Math.max(f, d, p);
        let M = n.next;
        for(; M !== e;){
            if (M.x >= g && M.x <= _ && M.y >= y && M.y <= x && um(i, f, a, d, l, p, M.x, M.y) && di(M.prev, M, M.next) >= 0) return !1;
            M = M.next;
        }
        return !0;
    }
    function lC(r, e, t, n) {
        const i = r.prev, a = r, l = r.next;
        if (di(i, a, l) >= 0) return !1;
        const f = i.x, d = a.x, p = l.x, g = i.y, y = a.y, _ = l.y, x = Math.min(f, d, p), M = Math.min(g, y, _), R = Math.max(f, d, p), T = Math.max(g, y, _), E = aS(x, M, e, t, n), C = aS(R, T, e, t, n);
        let N = r.prevZ, D = r.nextZ;
        for(; N && N.z >= E && D && D.z <= C;){
            if (N.x >= x && N.x <= R && N.y >= M && N.y <= T && N !== i && N !== l && um(f, g, d, y, p, _, N.x, N.y) && di(N.prev, N, N.next) >= 0 || (N = N.prevZ, D.x >= x && D.x <= R && D.y >= M && D.y <= T && D !== i && D !== l && um(f, g, d, y, p, _, D.x, D.y) && di(D.prev, D, D.next) >= 0)) return !1;
            D = D.nextZ;
        }
        for(; N && N.z >= E;){
            if (N.x >= x && N.x <= R && N.y >= M && N.y <= T && N !== i && N !== l && um(f, g, d, y, p, _, N.x, N.y) && di(N.prev, N, N.next) >= 0) return !1;
            N = N.prevZ;
        }
        for(; D && D.z <= C;){
            if (D.x >= x && D.x <= R && D.y >= M && D.y <= T && D !== i && D !== l && um(f, g, d, y, p, _, D.x, D.y) && di(D.prev, D, D.next) >= 0) return !1;
            D = D.nextZ;
        }
        return !0;
    }
    function cC(r, e) {
        let t = r;
        do {
            const n = t.prev, i = t.next.next;
            !Ed(n, i) && BT(n, t, t.next, i) && Dm(n, i) && Dm(i, n) && (e.push(n.i, t.i, i.i), Nm(t), Nm(t.next), t = r = i), t = t.next;
        }while (t !== r);
        return Af(t);
    }
    function uC(r, e, t, n, i, a) {
        let l = r;
        do {
            let f = l.next.next;
            for(; f !== l.prev;){
                if (l.i !== f.i && _C(l, f)) {
                    let d = IT(l, f);
                    l = Af(l, l.next), d = Af(d, d.next), Cm(l, e, t, n, i, a, 0), Cm(d, e, t, n, i, a, 0);
                    return;
                }
                f = f.next;
            }
            l = l.next;
        }while (l !== r);
    }
    function fC(r, e, t, n) {
        const i = [];
        for(let a = 0, l = e.length; a < l; a++){
            const f = e[a] * n, d = a < l - 1 ? e[a + 1] * n : r.length, p = OT(r, f, d, n, !1);
            p === p.next && (p.steiner = !0), i.push(yC(p));
        }
        i.sort(hC);
        for(let a = 0; a < i.length; a++)t = dC(i[a], t);
        return t;
    }
    function hC(r, e) {
        let t = r.x - e.x;
        if (t === 0 && (t = r.y - e.y, t === 0)) {
            const n = (r.next.y - r.y) / (r.next.x - r.x), i = (e.next.y - e.y) / (e.next.x - e.x);
            t = n - i;
        }
        return t;
    }
    function dC(r, e) {
        const t = pC(r, e);
        if (!t) return e;
        const n = IT(t, r);
        return Af(n, n.next), Af(t, t.next);
    }
    function pC(r, e) {
        let t = e;
        const n = r.x, i = r.y;
        let a = -1 / 0, l;
        if (Ed(r, t)) return t;
        do {
            if (Ed(r, t.next)) return t.next;
            if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
                const y = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                if (y <= n && y > a && (a = y, l = t.x < t.next.x ? t : t.next, y === n)) return l;
            }
            t = t.next;
        }while (t !== e);
        if (!l) return null;
        const f = l, d = l.x, p = l.y;
        let g = 1 / 0;
        t = l;
        do {
            if (n >= t.x && t.x >= d && n !== t.x && zT(i < p ? n : a, i, d, p, i < p ? a : n, i, t.x, t.y)) {
                const y = Math.abs(i - t.y) / (n - t.x);
                Dm(t, r) && (y < g || y === g && (t.x > l.x || t.x === l.x && mC(l, t))) && (l = t, g = y);
            }
            t = t.next;
        }while (t !== f);
        return l;
    }
    function mC(r, e) {
        return di(r.prev, r, e.prev) < 0 && di(e.next, r, r.next) < 0;
    }
    function gC(r, e, t, n) {
        let i = r;
        do i.z === 0 && (i.z = aS(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
        while (i !== r);
        i.prevZ.nextZ = null, i.prevZ = null, vC(i);
    }
    function vC(r) {
        let e, t = 1;
        do {
            let n = r, i;
            r = null;
            let a = null;
            for(e = 0; n;){
                e++;
                let l = n, f = 0;
                for(let p = 0; p < t && (f++, l = l.nextZ, !!l); p++);
                let d = t;
                for(; f > 0 || d > 0 && l;)f !== 0 && (d === 0 || !l || n.z <= l.z) ? (i = n, n = n.nextZ, f--) : (i = l, l = l.nextZ, d--), a ? a.nextZ = i : r = i, i.prevZ = a, a = i;
                n = l;
            }
            a.nextZ = null, t *= 2;
        }while (e > 1);
        return r;
    }
    function aS(r, e, t, n, i) {
        return r = (r - t) * i | 0, e = (e - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
    }
    function yC(r) {
        let e = r, t = r;
        do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
        while (e !== r);
        return t;
    }
    function zT(r, e, t, n, i, a, l, f) {
        return (i - l) * (e - f) >= (r - l) * (a - f) && (r - l) * (n - f) >= (t - l) * (e - f) && (t - l) * (a - f) >= (i - l) * (n - f);
    }
    function um(r, e, t, n, i, a, l, f) {
        return !(r === l && e === f) && zT(r, e, t, n, i, a, l, f);
    }
    function _C(r, e) {
        return r.next.i !== e.i && r.prev.i !== e.i && !xC(r, e) && (Dm(r, e) && Dm(e, r) && SC(r, e) && (di(r.prev, r, e.prev) || di(r, e.prev, e)) || Ed(r, e) && di(r.prev, r, r.next) > 0 && di(e.prev, e, e.next) > 0);
    }
    function di(r, e, t) {
        return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
    }
    function Ed(r, e) {
        return r.x === e.x && r.y === e.y;
    }
    function BT(r, e, t, n) {
        const i = ev(di(r, e, t)), a = ev(di(r, e, n)), l = ev(di(t, n, r)), f = ev(di(t, n, e));
        return !!(i !== a && l !== f || i === 0 && $0(r, t, e) || a === 0 && $0(r, n, e) || l === 0 && $0(t, r, n) || f === 0 && $0(t, e, n));
    }
    function $0(r, e, t) {
        return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y);
    }
    function ev(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
    }
    function xC(r, e) {
        let t = r;
        do {
            if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && BT(t, t.next, r, e)) return !0;
            t = t.next;
        }while (t !== r);
        return !1;
    }
    function Dm(r, e) {
        return di(r.prev, r, r.next) < 0 ? di(r, e, r.next) >= 0 && di(r, r.prev, e) >= 0 : di(r, e, r.prev) < 0 || di(r, r.next, e) < 0;
    }
    function SC(r, e) {
        let t = r, n = !1;
        const i = (r.x + e.x) / 2, a = (r.y + e.y) / 2;
        do t.y > a != t.next.y > a && t.next.y !== t.y && i < (t.next.x - t.x) * (a - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
        while (t !== r);
        return n;
    }
    function IT(r, e) {
        const t = rS(r.i, r.x, r.y), n = rS(e.i, e.x, e.y), i = r.next, a = e.prev;
        return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, a.next = n, n.prev = a, n;
    }
    function WM(r, e, t, n) {
        const i = rS(r, e, t);
        return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
    }
    function Nm(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
    }
    function rS(r, e, t) {
        return {
            i: r,
            x: e,
            y: t,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
        };
    }
    function bC(r, e, t, n) {
        let i = 0;
        for(let a = e, l = t - n; a < t; a += n)i += (r[l] - r[a]) * (r[a + 1] + r[l + 1]), l = a;
        return i;
    }
    class MC {
        static triangulate(e, t, n = 2) {
            return rC(e, t, n);
        }
    }
    class io {
        static area(e) {
            const t = e.length;
            let n = 0;
            for(let i = t - 1, a = 0; a < t; i = a++)n += e[i].x * e[a].y - e[a].x * e[i].y;
            return n * .5;
        }
        static isClockWise(e) {
            return io.area(e) < 0;
        }
        static triangulateShape(e, t) {
            const n = [], i = [], a = [];
            ZM(e), KM(n, e);
            let l = e.length;
            t.forEach(ZM);
            for(let d = 0; d < t.length; d++)i.push(l), l += t[d].length, KM(n, t[d]);
            const f = MC.triangulate(n, i);
            for(let d = 0; d < f.length; d += 3)a.push(f.slice(d, d + 3));
            return a;
        }
    }
    function ZM(r) {
        const e = r.length;
        e > 2 && r[e - 1].equals(r[0]) && r.pop();
    }
    function KM(r, e) {
        for(let t = 0; t < e.length; t++)r.push(e[t].x), r.push(e[t].y);
    }
    class Iy extends Dt {
        constructor(e = new Mf([
            new Ie(.5, .5),
            new Ie(-.5, .5),
            new Ie(-.5, -.5),
            new Ie(.5, -.5)
        ]), t = {}){
            super(), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: e,
                options: t
            }, e = Array.isArray(e) ? e : [
                e
            ];
            const n = this, i = [], a = [];
            for(let f = 0, d = e.length; f < d; f++){
                const p = e[f];
                l(p);
            }
            this.setAttribute("position", new nt(i, 3)), this.setAttribute("uv", new nt(a, 2)), this.computeVertexNormals();
            function l(f) {
                const d = [], p = t.curveSegments !== void 0 ? t.curveSegments : 12, g = t.steps !== void 0 ? t.steps : 1, y = t.depth !== void 0 ? t.depth : 1;
                let _ = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, x = t.bevelThickness !== void 0 ? t.bevelThickness : .2, M = t.bevelSize !== void 0 ? t.bevelSize : x - .1, R = t.bevelOffset !== void 0 ? t.bevelOffset : 0, T = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
                const E = t.extrudePath, C = t.UVGenerator !== void 0 ? t.UVGenerator : EC;
                let N, D = !1, I, O, P, F;
                E && (N = E.getSpacedPoints(g), D = !0, _ = !1, I = E.computeFrenetFrames(g, !1), O = new Y, P = new Y, F = new Y), _ || (T = 0, x = 0, M = 0, R = 0);
                const z = f.extractPoints(p);
                let L = z.shape;
                const q = z.holes;
                if (!io.isClockWise(L)) {
                    L = L.reverse();
                    for(let W = 0, et = q.length; W < et; W++){
                        const Ye = q[W];
                        io.isClockWise(Ye) && (q[W] = Ye.reverse());
                    }
                }
                function se(W) {
                    const Ye = 10000000000000001e-36;
                    let We = W[0];
                    for(let Be = 1; Be <= W.length; Be++){
                        const ut = Be % W.length, Xe = W[ut], ot = Xe.x - We.x, It = Xe.y - We.y, Z = ot * ot + It * It, G = Math.max(Math.abs(Xe.x), Math.abs(Xe.y), Math.abs(We.x), Math.abs(We.y)), Se = Ye * G * G;
                        if (Z <= Se) {
                            W.splice(ut, 1), Be--;
                            continue;
                        }
                        We = Xe;
                    }
                }
                se(L), q.forEach(se);
                const ge = q.length, _e = L;
                for(let W = 0; W < ge; W++){
                    const et = q[W];
                    L = L.concat(et);
                }
                function H(W, et, Ye) {
                    return et || console.error("THREE.ExtrudeGeometry: vec does not exist"), W.clone().addScaledVector(et, Ye);
                }
                const K = L.length;
                function Q(W, et, Ye) {
                    let We, Be, ut;
                    const Xe = W.x - et.x, ot = W.y - et.y, It = Ye.x - W.x, Z = Ye.y - W.y, G = Xe * Xe + ot * ot, Se = Xe * Z - ot * It;
                    if (Math.abs(Se) > Number.EPSILON) {
                        const Ue = Math.sqrt(G), Le = Math.sqrt(It * It + Z * Z), Ne = et.x - ot / Ue, lt = et.y + Xe / Ue, it = Ye.x - Z / Le, vt = Ye.y + It / Le, yt = ((it - Ne) * Z - (vt - lt) * It) / (Xe * Z - ot * It);
                        We = Ne + Xe * yt - W.x, Be = lt + ot * yt - W.y;
                        const He = We * We + Be * Be;
                        if (He <= 2) return new Ie(We, Be);
                        ut = Math.sqrt(He / 2);
                    } else {
                        let Ue = !1;
                        Xe > Number.EPSILON ? It > Number.EPSILON && (Ue = !0) : Xe < -Number.EPSILON ? It < -Number.EPSILON && (Ue = !0) : Math.sign(ot) === Math.sign(Z) && (Ue = !0), Ue ? (We = -ot, Be = Xe, ut = Math.sqrt(G)) : (We = Xe, Be = ot, ut = Math.sqrt(G / 2));
                    }
                    return new Ie(We / ut, Be / ut);
                }
                const fe = [];
                for(let W = 0, et = _e.length, Ye = et - 1, We = W + 1; W < et; W++, Ye++, We++)Ye === et && (Ye = 0), We === et && (We = 0), fe[W] = Q(_e[W], _e[Ye], _e[We]);
                const X = [];
                let $, me = fe.concat();
                for(let W = 0, et = ge; W < et; W++){
                    const Ye = q[W];
                    $ = [];
                    for(let We = 0, Be = Ye.length, ut = Be - 1, Xe = We + 1; We < Be; We++, ut++, Xe++)ut === Be && (ut = 0), Xe === Be && (Xe = 0), $[We] = Q(Ye[We], Ye[ut], Ye[Xe]);
                    X.push($), me = me.concat($);
                }
                let ve;
                if (T === 0) ve = io.triangulateShape(_e, q);
                else {
                    const W = [], et = [];
                    for(let Ye = 0; Ye < T; Ye++){
                        const We = Ye / T, Be = x * Math.cos(We * Math.PI / 2), ut = M * Math.sin(We * Math.PI / 2) + R;
                        for(let Xe = 0, ot = _e.length; Xe < ot; Xe++){
                            const It = H(_e[Xe], fe[Xe], ut);
                            _t(It.x, It.y, -Be), We === 0 && W.push(It);
                        }
                        for(let Xe = 0, ot = ge; Xe < ot; Xe++){
                            const It = q[Xe];
                            $ = X[Xe];
                            const Z = [];
                            for(let G = 0, Se = It.length; G < Se; G++){
                                const Ue = H(It[G], $[G], ut);
                                _t(Ue.x, Ue.y, -Be), We === 0 && Z.push(Ue);
                            }
                            We === 0 && et.push(Z);
                        }
                    }
                    ve = io.triangulateShape(W, et);
                }
                const J = ve.length, ue = M + R;
                for(let W = 0; W < K; W++){
                    const et = _ ? H(L[W], me[W], ue) : L[W];
                    D ? (P.copy(I.normals[0]).multiplyScalar(et.x), O.copy(I.binormals[0]).multiplyScalar(et.y), F.copy(N[0]).add(P).add(O), _t(F.x, F.y, F.z)) : _t(et.x, et.y, 0);
                }
                for(let W = 1; W <= g; W++)for(let et = 0; et < K; et++){
                    const Ye = _ ? H(L[et], me[et], ue) : L[et];
                    D ? (P.copy(I.normals[W]).multiplyScalar(Ye.x), O.copy(I.binormals[W]).multiplyScalar(Ye.y), F.copy(N[W]).add(P).add(O), _t(F.x, F.y, F.z)) : _t(Ye.x, Ye.y, y / g * W);
                }
                for(let W = T - 1; W >= 0; W--){
                    const et = W / T, Ye = x * Math.cos(et * Math.PI / 2), We = M * Math.sin(et * Math.PI / 2) + R;
                    for(let Be = 0, ut = _e.length; Be < ut; Be++){
                        const Xe = H(_e[Be], fe[Be], We);
                        _t(Xe.x, Xe.y, y + Ye);
                    }
                    for(let Be = 0, ut = q.length; Be < ut; Be++){
                        const Xe = q[Be];
                        $ = X[Be];
                        for(let ot = 0, It = Xe.length; ot < It; ot++){
                            const Z = H(Xe[ot], $[ot], We);
                            D ? _t(Z.x, Z.y + N[g - 1].y, N[g - 1].x + Ye) : _t(Z.x, Z.y, y + Ye);
                        }
                    }
                }
                he(), De();
                function he() {
                    const W = i.length / 3;
                    if (_) {
                        let et = 0, Ye = K * et;
                        for(let We = 0; We < J; We++){
                            const Be = ve[We];
                            xt(Be[2] + Ye, Be[1] + Ye, Be[0] + Ye);
                        }
                        et = g + T * 2, Ye = K * et;
                        for(let We = 0; We < J; We++){
                            const Be = ve[We];
                            xt(Be[0] + Ye, Be[1] + Ye, Be[2] + Ye);
                        }
                    } else {
                        for(let et = 0; et < J; et++){
                            const Ye = ve[et];
                            xt(Ye[2], Ye[1], Ye[0]);
                        }
                        for(let et = 0; et < J; et++){
                            const Ye = ve[et];
                            xt(Ye[0] + K * g, Ye[1] + K * g, Ye[2] + K * g);
                        }
                    }
                    n.addGroup(W, i.length / 3 - W, 0);
                }
                function De() {
                    const W = i.length / 3;
                    let et = 0;
                    Pe(_e, et), et += _e.length;
                    for(let Ye = 0, We = q.length; Ye < We; Ye++){
                        const Be = q[Ye];
                        Pe(Be, et), et += Be.length;
                    }
                    n.addGroup(W, i.length / 3 - W, 1);
                }
                function Pe(W, et) {
                    let Ye = W.length;
                    for(; --Ye >= 0;){
                        const We = Ye;
                        let Be = Ye - 1;
                        Be < 0 && (Be = W.length - 1);
                        for(let ut = 0, Xe = g + T * 2; ut < Xe; ut++){
                            const ot = K * ut, It = K * (ut + 1), Z = et + We + ot, G = et + Be + ot, Se = et + Be + It, Ue = et + We + It;
                            on(Z, G, Se, Ue);
                        }
                    }
                }
                function _t(W, et, Ye) {
                    d.push(W), d.push(et), d.push(Ye);
                }
                function xt(W, et, Ye) {
                    Vt(W), Vt(et), Vt(Ye);
                    const We = i.length / 3, Be = C.generateTopUV(n, i, We - 3, We - 2, We - 1);
                    Nt(Be[0]), Nt(Be[1]), Nt(Be[2]);
                }
                function on(W, et, Ye, We) {
                    Vt(W), Vt(et), Vt(We), Vt(et), Vt(Ye), Vt(We);
                    const Be = i.length / 3, ut = C.generateSideWallUV(n, i, Be - 6, Be - 3, Be - 2, Be - 1);
                    Nt(ut[0]), Nt(ut[1]), Nt(ut[3]), Nt(ut[1]), Nt(ut[2]), Nt(ut[3]);
                }
                function Vt(W) {
                    i.push(d[W * 3 + 0]), i.push(d[W * 3 + 1]), i.push(d[W * 3 + 2]);
                }
                function Nt(W) {
                    a.push(W.x), a.push(W.y);
                }
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        toJSON() {
            const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
            return TC(t, n, e);
        }
        static fromJSON(e, t) {
            const n = [];
            for(let a = 0, l = e.shapes.length; a < l; a++){
                const f = t[e.shapes[a]];
                n.push(f);
            }
            const i = e.options.extrudePath;
            return i !== void 0 && (e.options.extrudePath = new ay[i.type]().fromJSON(i)), new Iy(n, e.options);
        }
    }
    const EC = {
        generateTopUV: function(r, e, t, n, i) {
            const a = e[t * 3], l = e[t * 3 + 1], f = e[n * 3], d = e[n * 3 + 1], p = e[i * 3], g = e[i * 3 + 1];
            return [
                new Ie(a, l),
                new Ie(f, d),
                new Ie(p, g)
            ];
        },
        generateSideWallUV: function(r, e, t, n, i, a) {
            const l = e[t * 3], f = e[t * 3 + 1], d = e[t * 3 + 2], p = e[n * 3], g = e[n * 3 + 1], y = e[n * 3 + 2], _ = e[i * 3], x = e[i * 3 + 1], M = e[i * 3 + 2], R = e[a * 3], T = e[a * 3 + 1], E = e[a * 3 + 2];
            return Math.abs(f - g) < Math.abs(l - p) ? [
                new Ie(l, 1 - d),
                new Ie(p, 1 - y),
                new Ie(_, 1 - M),
                new Ie(R, 1 - E)
            ] : [
                new Ie(f, 1 - d),
                new Ie(g, 1 - y),
                new Ie(x, 1 - M),
                new Ie(T, 1 - E)
            ];
        }
    };
    function TC(r, e, t) {
        if (t.shapes = [], Array.isArray(r)) for(let n = 0, i = r.length; n < i; n++){
            const a = r[n];
            t.shapes.push(a.uuid);
        }
        else t.shapes.push(r.uuid);
        return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
    }
    class Gm extends eu {
        constructor(e = 1, t = 0){
            const n = (1 + Math.sqrt(5)) / 2, i = [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1
            ], a = [
                0,
                11,
                5,
                0,
                5,
                1,
                0,
                1,
                7,
                0,
                7,
                10,
                0,
                10,
                11,
                1,
                5,
                9,
                5,
                11,
                4,
                11,
                10,
                2,
                10,
                7,
                6,
                7,
                1,
                8,
                3,
                9,
                4,
                3,
                4,
                2,
                3,
                2,
                6,
                3,
                6,
                8,
                3,
                8,
                9,
                4,
                9,
                5,
                2,
                4,
                11,
                6,
                2,
                10,
                8,
                6,
                7,
                9,
                8,
                1
            ];
            super(i, a, e, t), this.type = "IcosahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            };
        }
        static fromJSON(e) {
            return new Gm(e.radius, e.detail);
        }
    }
    class Py extends Dt {
        constructor(e = [
            new Ie(0, -.5),
            new Ie(.5, 0),
            new Ie(0, .5)
        ], t = 12, n = 0, i = Math.PI * 2){
            super(), this.type = "LatheGeometry", this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: i
            }, t = Math.floor(t), i = Wt(i, 0, Math.PI * 2);
            const a = [], l = [], f = [], d = [], p = [], g = 1 / t, y = new Y, _ = new Ie, x = new Y, M = new Y, R = new Y;
            let T = 0, E = 0;
            for(let C = 0; C <= e.length - 1; C++)switch(C){
                case 0:
                    T = e[C + 1].x - e[C].x, E = e[C + 1].y - e[C].y, x.x = E * 1, x.y = -T, x.z = E * 0, R.copy(x), x.normalize(), d.push(x.x, x.y, x.z);
                    break;
                case e.length - 1:
                    d.push(R.x, R.y, R.z);
                    break;
                default:
                    T = e[C + 1].x - e[C].x, E = e[C + 1].y - e[C].y, x.x = E * 1, x.y = -T, x.z = E * 0, M.copy(x), x.x += R.x, x.y += R.y, x.z += R.z, x.normalize(), d.push(x.x, x.y, x.z), R.copy(M);
            }
            for(let C = 0; C <= t; C++){
                const N = n + C * g * i, D = Math.sin(N), I = Math.cos(N);
                for(let O = 0; O <= e.length - 1; O++){
                    y.x = e[O].x * D, y.y = e[O].y, y.z = e[O].x * I, l.push(y.x, y.y, y.z), _.x = C / t, _.y = O / (e.length - 1), f.push(_.x, _.y);
                    const P = d[3 * O + 0] * D, F = d[3 * O + 1], z = d[3 * O + 0] * I;
                    p.push(P, F, z);
                }
            }
            for(let C = 0; C < t; C++)for(let N = 0; N < e.length - 1; N++){
                const D = N + C * e.length, I = D, O = D + e.length, P = D + e.length + 1, F = D + 1;
                a.push(I, O, F), a.push(P, F, O);
            }
            this.setIndex(a), this.setAttribute("position", new nt(l, 3)), this.setAttribute("uv", new nt(f, 2)), this.setAttribute("normal", new nt(p, 3));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Py(e.points, e.segments, e.phiStart, e.phiLength);
        }
    }
    class Vm extends eu {
        constructor(e = 1, t = 0){
            const n = [
                1,
                0,
                0,
                -1,
                0,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                0,
                0,
                1,
                0,
                0,
                -1
            ], i = [
                0,
                2,
                4,
                0,
                4,
                3,
                0,
                3,
                5,
                0,
                5,
                2,
                1,
                2,
                5,
                1,
                5,
                3,
                1,
                3,
                4,
                1,
                4,
                2
            ];
            super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            };
        }
        static fromJSON(e) {
            return new Vm(e.radius, e.detail);
        }
    }
    class Nd extends Dt {
        constructor(e = 1, t = 1, n = 1, i = 1){
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            const a = e / 2, l = t / 2, f = Math.floor(n), d = Math.floor(i), p = f + 1, g = d + 1, y = e / f, _ = t / d, x = [], M = [], R = [], T = [];
            for(let E = 0; E < g; E++){
                const C = E * _ - l;
                for(let N = 0; N < p; N++){
                    const D = N * y - a;
                    M.push(D, -C, 0), R.push(0, 0, 1), T.push(N / f), T.push(1 - E / d);
                }
            }
            for(let E = 0; E < d; E++)for(let C = 0; C < f; C++){
                const N = C + p * E, D = C + p * (E + 1), I = C + 1 + p * (E + 1), O = C + 1 + p * E;
                x.push(N, D, O), x.push(D, I, O);
            }
            this.setIndex(x), this.setAttribute("position", new nt(M, 3)), this.setAttribute("normal", new nt(R, 3)), this.setAttribute("uv", new nt(T, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Nd(e.width, e.height, e.widthSegments, e.heightSegments);
        }
    }
    class Hy extends Dt {
        constructor(e = .5, t = 1, n = 32, i = 1, a = 0, l = Math.PI * 2){
            super(), this.type = "RingGeometry", this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: a,
                thetaLength: l
            }, n = Math.max(3, n), i = Math.max(1, i);
            const f = [], d = [], p = [], g = [];
            let y = e;
            const _ = (t - e) / i, x = new Y, M = new Ie;
            for(let R = 0; R <= i; R++){
                for(let T = 0; T <= n; T++){
                    const E = a + T / n * l;
                    x.x = y * Math.cos(E), x.y = y * Math.sin(E), d.push(x.x, x.y, x.z), p.push(0, 0, 1), M.x = (x.x / t + 1) / 2, M.y = (x.y / t + 1) / 2, g.push(M.x, M.y);
                }
                y += _;
            }
            for(let R = 0; R < i; R++){
                const T = R * (n + 1);
                for(let E = 0; E < n; E++){
                    const C = E + T, N = C, D = C + n + 1, I = C + n + 2, O = C + 1;
                    f.push(N, D, O), f.push(D, I, O);
                }
            }
            this.setIndex(f), this.setAttribute("position", new nt(d, 3)), this.setAttribute("normal", new nt(p, 3)), this.setAttribute("uv", new nt(g, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Hy(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
        }
    }
    class Fy extends Dt {
        constructor(e = new Mf([
            new Ie(0, .5),
            new Ie(-.5, -.5),
            new Ie(.5, -.5)
        ]), t = 12){
            super(), this.type = "ShapeGeometry", this.parameters = {
                shapes: e,
                curveSegments: t
            };
            const n = [], i = [], a = [], l = [];
            let f = 0, d = 0;
            if (Array.isArray(e) === !1) p(e);
            else for(let g = 0; g < e.length; g++)p(e[g]), this.addGroup(f, d, g), f += d, d = 0;
            this.setIndex(n), this.setAttribute("position", new nt(i, 3)), this.setAttribute("normal", new nt(a, 3)), this.setAttribute("uv", new nt(l, 2));
            function p(g) {
                const y = i.length / 3, _ = g.extractPoints(t);
                let x = _.shape;
                const M = _.holes;
                io.isClockWise(x) === !1 && (x = x.reverse());
                for(let T = 0, E = M.length; T < E; T++){
                    const C = M[T];
                    io.isClockWise(C) === !0 && (M[T] = C.reverse());
                }
                const R = io.triangulateShape(x, M);
                for(let T = 0, E = M.length; T < E; T++){
                    const C = M[T];
                    x = x.concat(C);
                }
                for(let T = 0, E = x.length; T < E; T++){
                    const C = x[T];
                    i.push(C.x, C.y, 0), a.push(0, 0, 1), l.push(C.x, C.y);
                }
                for(let T = 0, E = R.length; T < E; T++){
                    const C = R[T], N = C[0] + y, D = C[1] + y, I = C[2] + y;
                    n.push(N, D, I), d += 3;
                }
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        toJSON() {
            const e = super.toJSON(), t = this.parameters.shapes;
            return AC(t, e);
        }
        static fromJSON(e, t) {
            const n = [];
            for(let i = 0, a = e.shapes.length; i < a; i++){
                const l = t[e.shapes[i]];
                n.push(l);
            }
            return new Fy(n, e.curveSegments);
        }
    }
    function AC(r, e) {
        if (e.shapes = [], Array.isArray(r)) for(let t = 0, n = r.length; t < n; t++){
            const i = r[t];
            e.shapes.push(i.uuid);
        }
        else e.shapes.push(r.uuid);
        return e;
    }
    class Nf extends Dt {
        constructor(e = 1, t = 32, n = 16, i = 0, a = Math.PI * 2, l = 0, f = Math.PI){
            super(), this.type = "SphereGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: a,
                thetaStart: l,
                thetaLength: f
            }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
            const d = Math.min(l + f, Math.PI);
            let p = 0;
            const g = [], y = new Y, _ = new Y, x = [], M = [], R = [], T = [];
            for(let E = 0; E <= n; E++){
                const C = [], N = E / n;
                let D = 0;
                E === 0 && l === 0 ? D = .5 / t : E === n && d === Math.PI && (D = -.5 / t);
                for(let I = 0; I <= t; I++){
                    const O = I / t;
                    y.x = -e * Math.cos(i + O * a) * Math.sin(l + N * f), y.y = e * Math.cos(l + N * f), y.z = e * Math.sin(i + O * a) * Math.sin(l + N * f), M.push(y.x, y.y, y.z), _.copy(y).normalize(), R.push(_.x, _.y, _.z), T.push(O + D, 1 - N), C.push(p++);
                }
                g.push(C);
            }
            for(let E = 0; E < n; E++)for(let C = 0; C < t; C++){
                const N = g[E][C + 1], D = g[E][C], I = g[E + 1][C], O = g[E + 1][C + 1];
                (E !== 0 || l > 0) && x.push(N, D, O), (E !== n - 1 || d < Math.PI) && x.push(D, I, O);
            }
            this.setIndex(x), this.setAttribute("position", new nt(M, 3)), this.setAttribute("normal", new nt(R, 3)), this.setAttribute("uv", new nt(T, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Nf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
        }
    }
    class km extends eu {
        constructor(e = 1, t = 0){
            const n = [
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                1,
                -1,
                -1
            ], i = [
                2,
                1,
                0,
                0,
                3,
                2,
                1,
                3,
                0,
                2,
                3,
                1
            ];
            super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            };
        }
        static fromJSON(e) {
            return new km(e.radius, e.detail);
        }
    }
    class Gy extends Dt {
        constructor(e = 1, t = .4, n = 12, i = 48, a = Math.PI * 2){
            super(), this.type = "TorusGeometry", this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: i,
                arc: a
            }, n = Math.floor(n), i = Math.floor(i);
            const l = [], f = [], d = [], p = [], g = new Y, y = new Y, _ = new Y;
            for(let x = 0; x <= n; x++)for(let M = 0; M <= i; M++){
                const R = M / i * a, T = x / n * Math.PI * 2;
                y.x = (e + t * Math.cos(T)) * Math.cos(R), y.y = (e + t * Math.cos(T)) * Math.sin(R), y.z = t * Math.sin(T), f.push(y.x, y.y, y.z), g.x = e * Math.cos(R), g.y = e * Math.sin(R), _.subVectors(y, g).normalize(), d.push(_.x, _.y, _.z), p.push(M / i), p.push(x / n);
            }
            for(let x = 1; x <= n; x++)for(let M = 1; M <= i; M++){
                const R = (i + 1) * x + M - 1, T = (i + 1) * (x - 1) + M - 1, E = (i + 1) * (x - 1) + M, C = (i + 1) * x + M;
                l.push(R, T, C), l.push(T, E, C);
            }
            this.setIndex(l), this.setAttribute("position", new nt(f, 3)), this.setAttribute("normal", new nt(d, 3)), this.setAttribute("uv", new nt(p, 2));
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Gy(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
        }
    }
    class Vy extends Dt {
        constructor(e = 1, t = .4, n = 64, i = 8, a = 2, l = 3){
            super(), this.type = "TorusKnotGeometry", this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: i,
                p: a,
                q: l
            }, n = Math.floor(n), i = Math.floor(i);
            const f = [], d = [], p = [], g = [], y = new Y, _ = new Y, x = new Y, M = new Y, R = new Y, T = new Y, E = new Y;
            for(let N = 0; N <= n; ++N){
                const D = N / n * a * Math.PI * 2;
                C(D, a, l, e, x), C(D + .01, a, l, e, M), T.subVectors(M, x), E.addVectors(M, x), R.crossVectors(T, E), E.crossVectors(R, T), R.normalize(), E.normalize();
                for(let I = 0; I <= i; ++I){
                    const O = I / i * Math.PI * 2, P = -t * Math.cos(O), F = t * Math.sin(O);
                    y.x = x.x + (P * E.x + F * R.x), y.y = x.y + (P * E.y + F * R.y), y.z = x.z + (P * E.z + F * R.z), d.push(y.x, y.y, y.z), _.subVectors(y, x).normalize(), p.push(_.x, _.y, _.z), g.push(N / n), g.push(I / i);
                }
            }
            for(let N = 1; N <= n; N++)for(let D = 1; D <= i; D++){
                const I = (i + 1) * (N - 1) + (D - 1), O = (i + 1) * N + (D - 1), P = (i + 1) * N + D, F = (i + 1) * (N - 1) + D;
                f.push(I, O, F), f.push(O, P, F);
            }
            this.setIndex(f), this.setAttribute("position", new nt(d, 3)), this.setAttribute("normal", new nt(p, 3)), this.setAttribute("uv", new nt(g, 2));
            function C(N, D, I, O, P) {
                const F = Math.cos(N), z = Math.sin(N), L = I / D * N, q = Math.cos(L);
                P.x = O * (2 + q) * .5 * F, P.y = O * (2 + q) * z * .5, P.z = O * Math.sin(L) * .5;
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
            return new Vy(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
        }
    }
    class ky extends Dt {
        constructor(e = new jS(new Y(-1, -1, 0), new Y(-1, 1, 0), new Y(1, 1, 0)), t = 64, n = 1, i = 8, a = !1){
            super(), this.type = "TubeGeometry", this.parameters = {
                path: e,
                tubularSegments: t,
                radius: n,
                radialSegments: i,
                closed: a
            };
            const l = e.computeFrenetFrames(t, a);
            this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
            const f = new Y, d = new Y, p = new Ie;
            let g = new Y;
            const y = [], _ = [], x = [], M = [];
            R(), this.setIndex(M), this.setAttribute("position", new nt(y, 3)), this.setAttribute("normal", new nt(_, 3)), this.setAttribute("uv", new nt(x, 2));
            function R() {
                for(let N = 0; N < t; N++)T(N);
                T(a === !1 ? t : 0), C(), E();
            }
            function T(N) {
                g = e.getPointAt(N / t, g);
                const D = l.normals[N], I = l.binormals[N];
                for(let O = 0; O <= i; O++){
                    const P = O / i * Math.PI * 2, F = Math.sin(P), z = -Math.cos(P);
                    d.x = z * D.x + F * I.x, d.y = z * D.y + F * I.y, d.z = z * D.z + F * I.z, d.normalize(), _.push(d.x, d.y, d.z), f.x = g.x + n * d.x, f.y = g.y + n * d.y, f.z = g.z + n * d.z, y.push(f.x, f.y, f.z);
                }
            }
            function E() {
                for(let N = 1; N <= t; N++)for(let D = 1; D <= i; D++){
                    const I = (i + 1) * (N - 1) + (D - 1), O = (i + 1) * N + (D - 1), P = (i + 1) * N + D, F = (i + 1) * (N - 1) + D;
                    M.push(I, O, F), M.push(O, P, F);
                }
            }
            function C() {
                for(let N = 0; N <= t; N++)for(let D = 0; D <= i; D++)p.x = N / t, p.y = D / i, x.push(p.x, p.y);
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.path = this.parameters.path.toJSON(), e;
        }
        static fromJSON(e) {
            return new ky(new ay[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
        }
    }
    class PT extends Dt {
        constructor(e = null){
            if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: e
            }, e !== null) {
                const t = [], n = new Set, i = new Y, a = new Y;
                if (e.index !== null) {
                    const l = e.attributes.position, f = e.index;
                    let d = e.groups;
                    d.length === 0 && (d = [
                        {
                            start: 0,
                            count: f.count,
                            materialIndex: 0
                        }
                    ]);
                    for(let p = 0, g = d.length; p < g; ++p){
                        const y = d[p], _ = y.start, x = y.count;
                        for(let M = _, R = _ + x; M < R; M += 3)for(let T = 0; T < 3; T++){
                            const E = f.getX(M + T), C = f.getX(M + (T + 1) % 3);
                            i.fromBufferAttribute(l, E), a.fromBufferAttribute(l, C), QM(i, a, n) === !0 && (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
                        }
                    }
                } else {
                    const l = e.attributes.position;
                    for(let f = 0, d = l.count / 3; f < d; f++)for(let p = 0; p < 3; p++){
                        const g = 3 * f + p, y = 3 * f + (p + 1) % 3;
                        i.fromBufferAttribute(l, g), a.fromBufferAttribute(l, y), QM(i, a, n) === !0 && (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
                    }
                }
                this.setAttribute("position", new nt(t, 3));
            }
        }
        copy(e) {
            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
    }
    function QM(r, e, t) {
        const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
        return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
    }
    var JM = Object.freeze({
        __proto__: null,
        BoxGeometry: $c,
        CapsuleGeometry: Ly,
        CircleGeometry: Oy,
        ConeGeometry: Fm,
        CylinderGeometry: Dd,
        DodecahedronGeometry: zy,
        EdgesGeometry: RT,
        ExtrudeGeometry: Iy,
        IcosahedronGeometry: Gm,
        LatheGeometry: Py,
        OctahedronGeometry: Vm,
        PlaneGeometry: Nd,
        PolyhedronGeometry: eu,
        RingGeometry: Hy,
        ShapeGeometry: Fy,
        SphereGeometry: Nf,
        TetrahedronGeometry: km,
        TorusGeometry: Gy,
        TorusKnotGeometry: Vy,
        TubeGeometry: ky,
        WireframeGeometry: PT
    });
    class HT extends Li {
        constructor(e){
            super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new tt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
        }
    }
    class FT extends ao {
        constructor(e){
            super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
        }
    }
    class Xm extends Li {
        constructor(e){
            super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                STANDARD: ""
            }, this.color = new tt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class Er extends Xm {
        constructor(e){
            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ie(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return Wt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t);
                }
            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
                100,
                400
            ], this.iridescenceThicknessMap = null, this.sheenColor = new tt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new tt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new tt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
            return this._anisotropy;
        }
        set anisotropy(e) {
            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
            return this._clearcoat;
        }
        set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
            return this._iridescence;
        }
        set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
            return this._dispersion;
        }
        set dispersion(e) {
            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
            return this._sheen;
        }
        set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
            return this._transmission;
        }
        set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
            return super.copy(e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
                ...e.iridescenceThicknessRange
            ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
    }
    class ud extends Li {
        constructor(e){
            super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new tt(16777215), this.specular = new tt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i, this.combine = Bm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class GT extends Li {
        constructor(e){
            super(), this.isMeshToonMaterial = !0, this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.color = new tt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
    }
    class VT extends Li {
        constructor(e){
            super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
        }
    }
    class YS extends Li {
        constructor(e){
            super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i, this.combine = Bm, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class WS extends Li {
        constructor(e){
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = aT, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
    }
    class ZS extends Li {
        constructor(e){
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
    }
    class kT extends Li {
        constructor(e){
            super(), this.isMeshMatcapMaterial = !0, this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new tt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jc, this.normalScale = new Ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.defines = {
                MATCAP: ""
            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
    }
    class XT extends Vi {
        constructor(e){
            super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
        }
    }
    function _f(r, e) {
        return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r);
    }
    function jT(r) {
        return ArrayBuffer.isView(r) && !(r instanceof DataView);
    }
    function qT(r) {
        function e(i, a) {
            return r[i] - r[a];
        }
        const t = r.length, n = new Array(t);
        for(let i = 0; i !== t; ++i)n[i] = i;
        return n.sort(e), n;
    }
    function oS(r, e, t) {
        const n = r.length, i = new r.constructor(n);
        for(let a = 0, l = 0; l !== n; ++a){
            const f = t[a] * e;
            for(let d = 0; d !== e; ++d)i[l++] = r[f + d];
        }
        return i;
    }
    function KS(r, e, t, n) {
        let i = 1, a = r[0];
        for(; a !== void 0 && a[n] === void 0;)a = r[i++];
        if (a === void 0) return;
        let l = a[n];
        if (l !== void 0) if (Array.isArray(l)) do l = a[n], l !== void 0 && (e.push(a.time), t.push(...l)), a = r[i++];
        while (a !== void 0);
        else if (l.toArray !== void 0) do l = a[n], l !== void 0 && (e.push(a.time), l.toArray(t, t.length)), a = r[i++];
        while (a !== void 0);
        else do l = a[n], l !== void 0 && (e.push(a.time), t.push(l)), a = r[i++];
        while (a !== void 0);
    }
    function wC(r, e, t, n, i = 30) {
        const a = r.clone();
        a.name = e;
        const l = [];
        for(let d = 0; d < a.tracks.length; ++d){
            const p = a.tracks[d], g = p.getValueSize(), y = [], _ = [];
            for(let x = 0; x < p.times.length; ++x){
                const M = p.times[x] * i;
                if (!(M < t || M >= n)) {
                    y.push(p.times[x]);
                    for(let R = 0; R < g; ++R)_.push(p.values[x * g + R]);
                }
            }
            y.length !== 0 && (p.times = _f(y, p.times.constructor), p.values = _f(_, p.values.constructor), l.push(p));
        }
        a.tracks = l;
        let f = 1 / 0;
        for(let d = 0; d < a.tracks.length; ++d)f > a.tracks[d].times[0] && (f = a.tracks[d].times[0]);
        for(let d = 0; d < a.tracks.length; ++d)a.tracks[d].shift(-1 * f);
        return a.resetDuration(), a;
    }
    function RC(r, e = 0, t = r, n = 30) {
        n <= 0 && (n = 30);
        const i = t.tracks.length, a = e / n;
        for(let l = 0; l < i; ++l){
            const f = t.tracks[l], d = f.ValueTypeName;
            if (d === "bool" || d === "string") continue;
            const p = r.tracks.find(function(E) {
                return E.name === f.name && E.ValueTypeName === d;
            });
            if (p === void 0) continue;
            let g = 0;
            const y = f.getValueSize();
            f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (g = y / 3);
            let _ = 0;
            const x = p.getValueSize();
            p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (_ = x / 3);
            const M = f.times.length - 1;
            let R;
            if (a <= f.times[0]) {
                const E = g, C = y - g;
                R = f.values.slice(E, C);
            } else if (a >= f.times[M]) {
                const E = M * y + g, C = E + y - g;
                R = f.values.slice(E, C);
            } else {
                const E = f.createInterpolant(), C = g, N = y - g;
                E.evaluate(a), R = E.resultBuffer.slice(C, N);
            }
            d === "quaternion" && new mi().fromArray(R).normalize().conjugate().toArray(R);
            const T = p.times.length;
            for(let E = 0; E < T; ++E){
                const C = E * x + _;
                if (d === "quaternion") mi.multiplyQuaternionsFlat(p.values, C, R, 0, p.values, C);
                else {
                    const N = x - _ * 2;
                    for(let D = 0; D < N; ++D)p.values[C + D] -= R[D];
                }
            }
        }
        return r.blendMode = NS, r;
    }
    class CC {
        static convertArray(e, t) {
            return _f(e, t);
        }
        static isTypedArray(e) {
            return jT(e);
        }
        static getKeyframeOrder(e) {
            return qT(e);
        }
        static sortedArray(e, t, n) {
            return oS(e, t, n);
        }
        static flattenJSON(e, t, n, i) {
            KS(e, t, n, i);
        }
        static subclip(e, t, n, i, a = 30) {
            return wC(e, t, n, i, a);
        }
        static makeClipAdditive(e, t = 0, n = e, i = 30) {
            return RC(e, t, n, i);
        }
    }
    class Ud {
        constructor(e, t, n, i){
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex, i = t[n], a = t[n - 1];
            e: {
                t: {
                    let l;
                    n: {
                        i: if (!(e < i)) {
                            for(let f = n + 2;;){
                                if (i === void 0) {
                                    if (e < a) break i;
                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                                }
                                if (n === f) break;
                                if (a = i, i = t[++n], e < i) break t;
                            }
                            l = t.length;
                            break n;
                        }
                        if (!(e >= a)) {
                            const f = t[1];
                            e < f && (n = 2, a = f);
                            for(let d = n - 2;;){
                                if (a === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === d) break;
                                if (i = a, a = t[--n - 1], e >= a) break t;
                            }
                            l = n, n = 0;
                            break n;
                        }
                        break e;
                    }
                    for(; n < l;){
                        const f = n + l >>> 1;
                        e < t[f] ? l = f : n = f + 1;
                    }
                    if (i = t[n], a = t[n - 1], a === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                this._cachedIndex = n, this.intervalChanged_(n, a, i);
            }
            return this.interpolate_(n, a, e, i);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, a = e * i;
            for(let l = 0; l !== i; ++l)t[l] = n[a + l];
            return t;
        }
        interpolate_() {
            throw new Error("call to abstract method");
        }
        intervalChanged_() {}
    }
    class YT extends Ud {
        constructor(e, t, n, i){
            super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: vf,
                endingEnd: vf
            };
        }
        intervalChanged_(e, t, n) {
            const i = this.parameterPositions;
            let a = e - 2, l = e + 1, f = i[a], d = i[l];
            if (f === void 0) switch(this.getSettings_().endingStart){
                case yf:
                    a = e, f = 2 * t - n;
                    break;
                case Em:
                    a = i.length - 2, f = t + i[a] - i[a + 1];
                    break;
                default:
                    a = e, f = n;
            }
            if (d === void 0) switch(this.getSettings_().endingEnd){
                case yf:
                    l = e, d = 2 * n - t;
                    break;
                case Em:
                    l = 1, d = n + i[1] - i[0];
                    break;
                default:
                    l = e - 1, d = t;
            }
            const p = (n - t) * .5, g = this.valueSize;
            this._weightPrev = p / (t - f), this._weightNext = p / (d - n), this._offsetPrev = a * g, this._offsetNext = l * g;
        }
        interpolate_(e, t, n, i) {
            const a = this.resultBuffer, l = this.sampleValues, f = this.valueSize, d = e * f, p = d - f, g = this._offsetPrev, y = this._offsetNext, _ = this._weightPrev, x = this._weightNext, M = (n - t) / (i - t), R = M * M, T = R * M, E = -_ * T + 2 * _ * R - _ * M, C = (1 + _) * T + (-1.5 - 2 * _) * R + (-.5 + _) * M + 1, N = (-1 - x) * T + (1.5 + x) * R + .5 * M, D = x * T - x * R;
            for(let I = 0; I !== f; ++I)a[I] = E * l[g + I] + C * l[p + I] + N * l[d + I] + D * l[y + I];
            return a;
        }
    }
    class QS extends Ud {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
            const a = this.resultBuffer, l = this.sampleValues, f = this.valueSize, d = e * f, p = d - f, g = (n - t) / (i - t), y = 1 - g;
            for(let _ = 0; _ !== f; ++_)a[_] = l[p + _] * y + l[d + _] * g;
            return a;
        }
    }
    class WT extends Ud {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1);
        }
    }
    class Tr {
        constructor(e, t, n, i){
            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = _f(t, this.TimeBufferType), this.values = _f(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
            const t = e.constructor;
            let n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: _f(e.times, Array),
                    values: _f(e.values, Array)
                };
                const i = e.getInterpolation();
                i !== e.DefaultInterpolation && (n.interpolation = i);
            }
            return n.type = e.ValueTypeName, n;
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new WT(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
            return new QS(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
            return new YT(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
            let t;
            switch(e){
                case yd:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case _d:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case mv:
                    t = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (t === void 0) {
                const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return this.createInterpolant = t, this;
        }
        getInterpolation() {
            switch(this.createInterpolant){
                case this.InterpolantFactoryMethodDiscrete:
                    return yd;
                case this.InterpolantFactoryMethodLinear:
                    return _d;
                case this.InterpolantFactoryMethodSmooth:
                    return mv;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(e) {
            if (e !== 0) {
                const t = this.times;
                for(let n = 0, i = t.length; n !== i; ++n)t[n] += e;
            }
            return this;
        }
        scale(e) {
            if (e !== 1) {
                const t = this.times;
                for(let n = 0, i = t.length; n !== i; ++n)t[n] *= e;
            }
            return this;
        }
        trim(e, t) {
            const n = this.times, i = n.length;
            let a = 0, l = i - 1;
            for(; a !== i && n[a] < e;)++a;
            for(; l !== -1 && n[l] > t;)--l;
            if (++l, a !== 0 || l !== i) {
                a >= l && (l = Math.max(l, 1), a = l - 1);
                const f = this.getValueSize();
                this.times = n.slice(a, l), this.values = this.values.slice(a * f, l * f);
            }
            return this;
        }
        validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            const n = this.times, i = this.values, a = n.length;
            a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            let l = null;
            for(let f = 0; f !== a; f++){
                const d = n[f];
                if (typeof d == "number" && isNaN(d)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, d), e = !1;
                    break;
                }
                if (l !== null && l > d) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, f, d, l), e = !1;
                    break;
                }
                l = d;
            }
            if (i !== void 0 && jT(i)) for(let f = 0, d = i.length; f !== d; ++f){
                const p = i[f];
                if (isNaN(p)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, p), e = !1;
                    break;
                }
            }
            return e;
        }
        optimize() {
            const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === mv, a = e.length - 1;
            let l = 1;
            for(let f = 1; f < a; ++f){
                let d = !1;
                const p = e[f], g = e[f + 1];
                if (p !== g && (f !== 1 || p !== e[0])) if (i) d = !0;
                else {
                    const y = f * n, _ = y - n, x = y + n;
                    for(let M = 0; M !== n; ++M){
                        const R = t[y + M];
                        if (R !== t[_ + M] || R !== t[x + M]) {
                            d = !0;
                            break;
                        }
                    }
                }
                if (d) {
                    if (f !== l) {
                        e[l] = e[f];
                        const y = f * n, _ = l * n;
                        for(let x = 0; x !== n; ++x)t[_ + x] = t[y + x];
                    }
                    ++l;
                }
            }
            if (a > 0) {
                e[l] = e[a];
                for(let f = a * n, d = l * n, p = 0; p !== n; ++p)t[d + p] = t[f + p];
                ++l;
            }
            return l !== e.length ? (this.times = e.slice(0, l), this.values = t.slice(0, l * n)) : (this.times = e, this.values = t), this;
        }
        clone() {
            const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
            return i.createInterpolant = this.createInterpolant, i;
        }
    }
    Tr.prototype.ValueTypeName = "";
    Tr.prototype.TimeBufferType = Float32Array;
    Tr.prototype.ValueBufferType = Float32Array;
    Tr.prototype.DefaultInterpolation = _d;
    class Uf extends Tr {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Uf.prototype.ValueTypeName = "bool";
    Uf.prototype.ValueBufferType = Array;
    Uf.prototype.DefaultInterpolation = yd;
    Uf.prototype.InterpolantFactoryMethodLinear = void 0;
    Uf.prototype.InterpolantFactoryMethodSmooth = void 0;
    class JS extends Tr {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
    }
    JS.prototype.ValueTypeName = "color";
    class Wc extends Tr {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
    }
    Wc.prototype.ValueTypeName = "number";
    class ZT extends Ud {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
            const a = this.resultBuffer, l = this.sampleValues, f = this.valueSize, d = (n - t) / (i - t);
            let p = e * f;
            for(let g = p + f; p !== g; p += 4)mi.slerpFlat(a, 0, l, p - f, l, p, d);
            return a;
        }
    }
    class Zc extends Tr {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
        InterpolantFactoryMethodLinear(e) {
            return new ZT(this.times, this.values, this.getValueSize(), e);
        }
    }
    Zc.prototype.ValueTypeName = "quaternion";
    Zc.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Lf extends Tr {
        constructor(e, t, n){
            super(e, t, n);
        }
    }
    Lf.prototype.ValueTypeName = "string";
    Lf.prototype.ValueBufferType = Array;
    Lf.prototype.DefaultInterpolation = yd;
    Lf.prototype.InterpolantFactoryMethodLinear = void 0;
    Lf.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Kc extends Tr {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
    }
    Kc.prototype.ValueTypeName = "vector";
    class wf {
        constructor(e = "", t = -1, n = [], i = by){
            this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = qa(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
            const t = [], n = e.tracks, i = 1 / (e.fps || 1);
            for(let l = 0, f = n.length; l !== f; ++l)t.push(NC(n[l]).scale(i));
            const a = new this(e.name, e.duration, t, e.blendMode);
            return a.uuid = e.uuid, a;
        }
        static toJSON(e) {
            const t = [], n = e.tracks, i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
            for(let a = 0, l = n.length; a !== l; ++a)t.push(Tr.toJSON(n[a]));
            return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
            const a = t.length, l = [];
            for(let f = 0; f < a; f++){
                let d = [], p = [];
                d.push((f + a - 1) % a, f, (f + 1) % a), p.push(0, 1, 0);
                const g = qT(d);
                d = oS(d, 1, g), p = oS(p, 1, g), !i && d[0] === 0 && (d.push(a), p.push(p[0])), l.push(new Wc(".morphTargetInfluences[" + t[f].name + "]", d, p).scale(1 / n));
            }
            return new this(e, -1, l);
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                const i = e;
                n = i.geometry && i.geometry.animations || i.animations;
            }
            for(let i = 0; i < n.length; i++)if (n[i].name === t) return n[i];
            return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            const i = {}, a = /^([\w-]*?)([\d]+)$/;
            for(let f = 0, d = e.length; f < d; f++){
                const p = e[f], g = p.name.match(a);
                if (g && g.length > 1) {
                    const y = g[1];
                    let _ = i[y];
                    _ || (i[y] = _ = []), _.push(p);
                }
            }
            const l = [];
            for(const f in i)l.push(this.CreateFromMorphTargetSequence(f, i[f], t, n));
            return l;
        }
        static parseAnimation(e, t) {
            if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            const n = function(y, _, x, M, R) {
                if (x.length !== 0) {
                    const T = [], E = [];
                    KS(x, T, E, M), T.length !== 0 && R.push(new y(_, T, E));
                }
            }, i = [], a = e.name || "default", l = e.fps || 30, f = e.blendMode;
            let d = e.length || -1;
            const p = e.hierarchy || [];
            for(let y = 0; y < p.length; y++){
                const _ = p[y].keys;
                if (!(!_ || _.length === 0)) if (_[0].morphTargets) {
                    const x = {};
                    let M;
                    for(M = 0; M < _.length; M++)if (_[M].morphTargets) for(let R = 0; R < _[M].morphTargets.length; R++)x[_[M].morphTargets[R]] = -1;
                    for(const R in x){
                        const T = [], E = [];
                        for(let C = 0; C !== _[M].morphTargets.length; ++C){
                            const N = _[M];
                            T.push(N.time), E.push(N.morphTarget === R ? 1 : 0);
                        }
                        i.push(new Wc(".morphTargetInfluence[" + R + "]", T, E));
                    }
                    d = x.length * l;
                } else {
                    const x = ".bones[" + t[y].name + "]";
                    n(Kc, x + ".position", _, "pos", i), n(Zc, x + ".quaternion", _, "rot", i), n(Kc, x + ".scale", _, "scl", i);
                }
            }
            return i.length === 0 ? null : new this(a, d, i, f);
        }
        resetDuration() {
            const e = this.tracks;
            let t = 0;
            for(let n = 0, i = e.length; n !== i; ++n){
                const a = this.tracks[n];
                t = Math.max(t, a.times[a.times.length - 1]);
            }
            return this.duration = t, this;
        }
        trim() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration);
            return this;
        }
        validate() {
            let e = !0;
            for(let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate();
            return e;
        }
        optimize() {
            for(let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize();
            return this;
        }
        clone() {
            const e = [];
            for(let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone());
            return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
            return this.constructor.toJSON(this);
        }
    }
    function DC(r) {
        switch(r.toLowerCase()){
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Wc;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Kc;
            case "color":
                return JS;
            case "quaternion":
                return Zc;
            case "bool":
            case "boolean":
                return Uf;
            case "string":
                return Lf;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
    }
    function NC(r) {
        if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = DC(r.type);
        if (r.times === void 0) {
            const t = [], n = [];
            KS(r.keys, t, n, "value"), r.times = t, r.values = n;
        }
        return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation);
    }
    const Xo = {
        enabled: !1,
        files: {},
        add: function(r, e) {
            this.enabled !== !1 && (this.files[r] = e);
        },
        get: function(r) {
            if (this.enabled !== !1) return this.files[r];
        },
        remove: function(r) {
            delete this.files[r];
        },
        clear: function() {
            this.files = {};
        }
    };
    class $S {
        constructor(e, t, n){
            const i = this;
            let a = !1, l = 0, f = 0, d;
            const p = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(g) {
                f++, a === !1 && i.onStart !== void 0 && i.onStart(g, l, f), a = !0;
            }, this.itemEnd = function(g) {
                l++, i.onProgress !== void 0 && i.onProgress(g, l, f), l === f && (a = !1, i.onLoad !== void 0 && i.onLoad());
            }, this.itemError = function(g) {
                i.onError !== void 0 && i.onError(g);
            }, this.resolveURL = function(g) {
                return d ? d(g) : g;
            }, this.setURLModifier = function(g) {
                return d = g, this;
            }, this.addHandler = function(g, y) {
                return p.push(g, y), this;
            }, this.removeHandler = function(g) {
                const y = p.indexOf(g);
                return y !== -1 && p.splice(y, 2), this;
            }, this.getHandler = function(g) {
                for(let y = 0, _ = p.length; y < _; y += 2){
                    const x = p[y], M = p[y + 1];
                    if (x.global && (x.lastIndex = 0), x.test(g)) return M;
                }
                return null;
            };
        }
    }
    const KT = new $S;
    class ki {
        constructor(e){
            this.manager = e !== void 0 ? e : KT, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {}
        loadAsync(e, t) {
            const n = this;
            return new Promise(function(i, a) {
                n.load(e, i, t, a);
            });
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
            return this.withCredentials = e, this;
        }
        setPath(e) {
            return this.path = e, this;
        }
        setResourcePath(e) {
            return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
            return this.requestHeader = e, this;
        }
    }
    ki.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Al = {};
    class UC extends Error {
        constructor(e, t){
            super(e), this.response = t;
        }
    }
    class bs extends ki {
        constructor(e){
            super(e), this.mimeType = "", this.responseType = "";
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const a = Xo.get(`file:${e}`);
            if (a !== void 0) return this.manager.itemStart(e), setTimeout(()=>{
                t && t(a), this.manager.itemEnd(e);
            }, 0), a;
            if (Al[e] !== void 0) {
                Al[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                return;
            }
            Al[e] = [], Al[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            const l = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }), f = this.mimeType, d = this.responseType;
            fetch(l).then((p)=>{
                if (p.status === 200 || p.status === 0) {
                    if (p.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || p.body === void 0 || p.body.getReader === void 0) return p;
                    const g = Al[e], y = p.body.getReader(), _ = p.headers.get("X-File-Size") || p.headers.get("Content-Length"), x = _ ? parseInt(_) : 0, M = x !== 0;
                    let R = 0;
                    const T = new ReadableStream({
                        start (E) {
                            C();
                            function C() {
                                y.read().then(({ done: N, value: D })=>{
                                    if (N) E.close();
                                    else {
                                        R += D.byteLength;
                                        const I = new ProgressEvent("progress", {
                                            lengthComputable: M,
                                            loaded: R,
                                            total: x
                                        });
                                        for(let O = 0, P = g.length; O < P; O++){
                                            const F = g[O];
                                            F.onProgress && F.onProgress(I);
                                        }
                                        E.enqueue(D), C();
                                    }
                                }, (N)=>{
                                    E.error(N);
                                });
                            }
                        }
                    });
                    return new Response(T);
                } else throw new UC(`fetch for "${p.url}" responded with ${p.status}: ${p.statusText}`, p);
            }).then((p)=>{
                switch(d){
                    case "arraybuffer":
                        return p.arrayBuffer();
                    case "blob":
                        return p.blob();
                    case "document":
                        return p.text().then((g)=>new DOMParser().parseFromString(g, f));
                    case "json":
                        return p.json();
                    default:
                        if (f === "") return p.text();
                        {
                            const y = /charset="?([^;"\s]*)"?/i.exec(f), _ = y && y[1] ? y[1].toLowerCase() : void 0, x = new TextDecoder(_);
                            return p.arrayBuffer().then((M)=>x.decode(M));
                        }
                }
            }).then((p)=>{
                Xo.add(`file:${e}`, p);
                const g = Al[e];
                delete Al[e];
                for(let y = 0, _ = g.length; y < _; y++){
                    const x = g[y];
                    x.onLoad && x.onLoad(p);
                }
            }).catch((p)=>{
                const g = Al[e];
                if (g === void 0) throw this.manager.itemError(e), p;
                delete Al[e];
                for(let y = 0, _ = g.length; y < _; y++){
                    const x = g[y];
                    x.onError && x.onError(p);
                }
                this.manager.itemError(e);
            }).finally(()=>{
                this.manager.itemEnd(e);
            }), this.manager.itemStart(e);
        }
        setResponseType(e) {
            return this.responseType = e, this;
        }
        setMimeType(e) {
            return this.mimeType = e, this;
        }
    }
    class LC extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = new bs(this.manager);
            l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(JSON.parse(f)));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        parse(e) {
            const t = [];
            for(let n = 0; n < e.length; n++){
                const i = wf.parse(e[n]);
                t.push(i);
            }
            return t;
        }
    }
    class OC extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = [], f = new Ny, d = new bs(this.manager);
            d.setPath(this.path), d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setWithCredentials(a.withCredentials);
            let p = 0;
            function g(y) {
                d.load(e[y], function(_) {
                    const x = a.parse(_, !0);
                    l[y] = {
                        width: x.width,
                        height: x.height,
                        format: x.format,
                        mipmaps: x.mipmaps
                    }, p += 1, p === 6 && (x.mipmapCount === 1 && (f.minFilter = pi), f.image = l, f.format = x.format, f.needsUpdate = !0, t && t(f));
                }, n, i);
            }
            if (Array.isArray(e)) for(let y = 0, _ = e.length; y < _; ++y)g(y);
            else d.load(e, function(y) {
                const _ = a.parse(y, !0);
                if (_.isCubemap) {
                    const x = _.mipmaps.length / _.mipmapCount;
                    for(let M = 0; M < x; M++){
                        l[M] = {
                            mipmaps: []
                        };
                        for(let R = 0; R < _.mipmapCount; R++)l[M].mipmaps.push(_.mipmaps[M * _.mipmapCount + R]), l[M].format = _.format, l[M].width = _.width, l[M].height = _.height;
                    }
                    f.image = l;
                } else f.image.width = _.width, f.image.height = _.height, f.mipmaps = _.mipmaps;
                _.mipmapCount === 1 && (f.minFilter = pi), f.format = _.format, f.needsUpdate = !0, t && t(f);
            }, n, i);
            return f;
        }
    }
    const Jh = new WeakMap;
    class Um extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const a = this, l = Xo.get(`image:${e}`);
            if (l !== void 0) {
                if (l.complete === !0) a.manager.itemStart(e), setTimeout(function() {
                    t && t(l), a.manager.itemEnd(e);
                }, 0);
                else {
                    let y = Jh.get(l);
                    y === void 0 && (y = [], Jh.set(l, y)), y.push({
                        onLoad: t,
                        onError: i
                    });
                }
                return l;
            }
            const f = Rm("img");
            function d() {
                g(), t && t(this);
                const y = Jh.get(this) || [];
                for(let _ = 0; _ < y.length; _++){
                    const x = y[_];
                    x.onLoad && x.onLoad(this);
                }
                Jh.delete(this), a.manager.itemEnd(e);
            }
            function p(y) {
                g(), i && i(y), Xo.remove(`image:${e}`);
                const _ = Jh.get(this) || [];
                for(let x = 0; x < _.length; x++){
                    const M = _[x];
                    M.onError && M.onError(y);
                }
                Jh.delete(this), a.manager.itemError(e), a.manager.itemEnd(e);
            }
            function g() {
                f.removeEventListener("load", d, !1), f.removeEventListener("error", p, !1);
            }
            return f.addEventListener("load", d, !1), f.addEventListener("error", p, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (f.crossOrigin = this.crossOrigin), Xo.add(`image:${e}`, f), a.manager.itemStart(e), f.src = e, f;
        }
    }
    class zC extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = new Pm;
            a.colorSpace = Bs;
            const l = new Um(this.manager);
            l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
            let f = 0;
            function d(p) {
                l.load(e[p], function(g) {
                    a.images[p] = g, f++, f === 6 && (a.needsUpdate = !0, t && t(a));
                }, void 0, i);
            }
            for(let p = 0; p < e.length; ++p)d(p);
            return a;
        }
    }
    class QT extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = new qo, f = new bs(this.manager);
            return f.setResponseType("arraybuffer"), f.setRequestHeader(this.requestHeader), f.setPath(this.path), f.setWithCredentials(a.withCredentials), f.load(e, function(d) {
                let p;
                try {
                    p = a.parse(d);
                } catch (g) {
                    if (i !== void 0) i(g);
                    else {
                        console.error(g);
                        return;
                    }
                }
                p.image !== void 0 ? l.image = p.image : p.data !== void 0 && (l.image.width = p.width, l.image.height = p.height, l.image.data = p.data), l.wrapS = p.wrapS !== void 0 ? p.wrapS : na, l.wrapT = p.wrapT !== void 0 ? p.wrapT : na, l.magFilter = p.magFilter !== void 0 ? p.magFilter : pi, l.minFilter = p.minFilter !== void 0 ? p.minFilter : pi, l.anisotropy = p.anisotropy !== void 0 ? p.anisotropy : 1, p.colorSpace !== void 0 && (l.colorSpace = p.colorSpace), p.flipY !== void 0 && (l.flipY = p.flipY), p.format !== void 0 && (l.format = p.format), p.type !== void 0 && (l.type = p.type), p.mipmaps !== void 0 && (l.mipmaps = p.mipmaps, l.minFilter = Xa), p.mipmapCount === 1 && (l.minFilter = pi), p.generateMipmaps !== void 0 && (l.generateMipmaps = p.generateMipmaps), l.needsUpdate = !0, t && t(l, p);
            }, n, i), l;
        }
    }
    class eb extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = new Qn, l = new Um(this.manager);
            return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(f) {
                a.image = f, a.needsUpdate = !0, t !== void 0 && t(a);
            }, n, i), a;
        }
    }
    class tu extends hn {
        constructor(e, t = 1){
            super(), this.isLight = !0, this.type = "Light", this.color = new tt(e), this.intensity = t;
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
    }
    class JT extends tu {
        constructor(e, t, n){
            super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(hn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new tt(t);
        }
        copy(e, t) {
            return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
        }
    }
    const px = new pt, $M = new Y, e1 = new Y;
    class tb {
        constructor(e){
            this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ie(512, 512), this.mapType = br, this.map = null, this.mapPass = null, this.matrix = new pt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Cd, this._frameExtents = new Ie(1, 1), this._viewportCount = 1, this._viewports = [
                new gn(0, 0, 1, 1)
            ];
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(e) {
            const t = this.camera, n = this.matrix;
            $M.setFromMatrixPosition(e.matrixWorld), t.position.copy($M), e1.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(e1), t.updateMatrixWorld(), px.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(px), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(px);
        }
        getViewport(e) {
            return this._viewports[e];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
            return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            const e = {};
            return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
        }
    }
    class BC extends tb {
        constructor(){
            super(new hi(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1;
        }
        updateMatrices(e) {
            const t = this.camera, n = xd * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height * this.aspect, a = e.distance || t.far;
            (n !== t.fov || i !== t.aspect || a !== t.far) && (t.fov = n, t.aspect = i, t.far = a, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
            return super.copy(e), this.focus = e.focus, this;
        }
    }
    class Xy extends tu {
        constructor(e, t, n = 0, i = Math.PI / 3, a = 0, l = 2){
            super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(hn.DEFAULT_UP), this.updateMatrix(), this.target = new hn, this.distance = n, this.angle = i, this.penumbra = a, this.decay = l, this.map = null, this.shadow = new BC;
        }
        get power() {
            return this.intensity * Math.PI;
        }
        set power(e) {
            this.intensity = e / Math.PI;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    const t1 = new pt, om = new Y, mx = new Y;
    class IC extends tb {
        constructor(){
            super(new hi(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ie(4, 2), this._viewportCount = 6, this._viewports = [
                new gn(2, 1, 1, 1),
                new gn(0, 1, 1, 1),
                new gn(3, 1, 1, 1),
                new gn(1, 1, 1, 1),
                new gn(3, 0, 1, 1),
                new gn(1, 0, 1, 1)
            ], this._cubeDirections = [
                new Y(1, 0, 0),
                new Y(-1, 0, 0),
                new Y(0, 0, 1),
                new Y(0, 0, -1),
                new Y(0, 1, 0),
                new Y(0, -1, 0)
            ], this._cubeUps = [
                new Y(0, 1, 0),
                new Y(0, 1, 0),
                new Y(0, 1, 0),
                new Y(0, 1, 0),
                new Y(0, 0, 1),
                new Y(0, 0, -1)
            ];
        }
        updateMatrices(e, t = 0) {
            const n = this.camera, i = this.matrix, a = e.distance || n.far;
            a !== n.far && (n.far = a, n.updateProjectionMatrix()), om.setFromMatrixPosition(e.matrixWorld), n.position.copy(om), mx.copy(n.position), mx.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(mx), n.updateMatrixWorld(), i.makeTranslation(-om.x, -om.y, -om.z), t1.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(t1);
        }
    }
    class Lm extends tu {
        constructor(e, t, n = 0, i = 2){
            super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new IC;
        }
        get power() {
            return this.intensity * 4 * Math.PI;
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI);
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e, t) {
            return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
    }
    class Yo extends Ay {
        constructor(e = -1, t = 1, n = 1, i = -1, a = .1, l = 2e3){
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = a, this.far = l, this.updateProjectionMatrix();
        }
        copy(e, t) {
            return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, n, i, a, l) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = l, this.updateProjectionMatrix();
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
            let a = n - e, l = n + e, f = i + t, d = i - t;
            if (this.view !== null && this.view.enabled) {
                const p = (this.right - this.left) / this.view.fullWidth / this.zoom, g = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                a += p * this.view.offsetX, l = a + p * this.view.width, f -= g * this.view.offsetY, d = f - g * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(a, l, f, d, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
    }
    class PC extends tb {
        constructor(){
            super(new Yo(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0;
        }
    }
    class jy extends tu {
        constructor(e, t){
            super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(hn.DEFAULT_UP), this.updateMatrix(), this.target = new hn, this.shadow = new PC;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(e) {
            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
    }
    class nb extends tu {
        constructor(e, t){
            super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
        }
    }
    class $T extends tu {
        constructor(e, t, n = 10, i = 10){
            super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
        }
        get power() {
            return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
            this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
            return super.copy(e), this.width = e.width, this.height = e.height, this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.width = this.width, t.object.height = this.height, t;
        }
    }
    class eA {
        constructor(){
            this.isSphericalHarmonics3 = !0, this.coefficients = [];
            for(let e = 0; e < 9; e++)this.coefficients.push(new Y);
        }
        set(e) {
            for(let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]);
            return this;
        }
        zero() {
            for(let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0);
            return this;
        }
        getAt(e, t) {
            const n = e.x, i = e.y, a = e.z, l = this.coefficients;
            return t.copy(l[0]).multiplyScalar(.282095), t.addScaledVector(l[1], .488603 * i), t.addScaledVector(l[2], .488603 * a), t.addScaledVector(l[3], .488603 * n), t.addScaledVector(l[4], 1.092548 * (n * i)), t.addScaledVector(l[5], 1.092548 * (i * a)), t.addScaledVector(l[6], .315392 * (3 * a * a - 1)), t.addScaledVector(l[7], 1.092548 * (n * a)), t.addScaledVector(l[8], .546274 * (n * n - i * i)), t;
        }
        getIrradianceAt(e, t) {
            const n = e.x, i = e.y, a = e.z, l = this.coefficients;
            return t.copy(l[0]).multiplyScalar(.886227), t.addScaledVector(l[1], 2 * .511664 * i), t.addScaledVector(l[2], 2 * .511664 * a), t.addScaledVector(l[3], 2 * .511664 * n), t.addScaledVector(l[4], 2 * .429043 * n * i), t.addScaledVector(l[5], 2 * .429043 * i * a), t.addScaledVector(l[6], .743125 * a * a - .247708), t.addScaledVector(l[7], 2 * .429043 * n * a), t.addScaledVector(l[8], .429043 * (n * n - i * i)), t;
        }
        add(e) {
            for(let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]);
            return this;
        }
        addScaledSH(e, t) {
            for(let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t);
            return this;
        }
        scale(e) {
            for(let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e);
            return this;
        }
        lerp(e, t) {
            for(let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t);
            return this;
        }
        equals(e) {
            for(let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0;
        }
        copy(e) {
            return this.set(e.coefficients);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
            const n = this.coefficients;
            for(let i = 0; i < 9; i++)n[i].fromArray(e, t + i * 3);
            return this;
        }
        toArray(e = [], t = 0) {
            const n = this.coefficients;
            for(let i = 0; i < 9; i++)n[i].toArray(e, t + i * 3);
            return e;
        }
        static getBasisAt(e, t) {
            const n = e.x, i = e.y, a = e.z;
            t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * a, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * a, t[6] = .315392 * (3 * a * a - 1), t[7] = 1.092548 * n * a, t[8] = .546274 * (n * n - i * i);
        }
    }
    class tA extends tu {
        constructor(e = new eA, t = 1){
            super(void 0, t), this.isLightProbe = !0, this.sh = e;
        }
        copy(e) {
            return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
            return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.sh = this.sh.toArray(), t;
        }
    }
    class qy extends ki {
        constructor(e){
            super(e), this.textures = {};
        }
        load(e, t, n, i) {
            const a = this, l = new bs(a.manager);
            l.setPath(a.path), l.setRequestHeader(a.requestHeader), l.setWithCredentials(a.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(JSON.parse(f)));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        parse(e) {
            const t = this.textures;
            function n(a) {
                return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a];
            }
            const i = this.createMaterialFromType(e.type);
            if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new tt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for(const a in e.uniforms){
                const l = e.uniforms[a];
                switch(i.uniforms[a] = {}, l.type){
                    case "t":
                        i.uniforms[a].value = n(l.value);
                        break;
                    case "c":
                        i.uniforms[a].value = new tt().setHex(l.value);
                        break;
                    case "v2":
                        i.uniforms[a].value = new Ie().fromArray(l.value);
                        break;
                    case "v3":
                        i.uniforms[a].value = new Y().fromArray(l.value);
                        break;
                    case "v4":
                        i.uniforms[a].value = new gn().fromArray(l.value);
                        break;
                    case "m3":
                        i.uniforms[a].value = new Yt().fromArray(l.value);
                        break;
                    case "m4":
                        i.uniforms[a].value = new pt().fromArray(l.value);
                        break;
                    default:
                        i.uniforms[a].value = l.value;
                }
            }
            if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for(const a in e.extensions)i.extensions[a] = e.extensions[a];
            if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
                let a = e.normalScale;
                Array.isArray(a) === !1 && (a = [
                    a,
                    a
                ]), i.normalScale = new Ie().fromArray(a);
            }
            return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Ie().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
        }
        setTextures(e) {
            return this.textures = e, this;
        }
        createMaterialFromType(e) {
            return qy.createMaterialFromType(e);
        }
        static createMaterialFromType(e) {
            const t = {
                ShadowMaterial: HT,
                SpriteMaterial: PS,
                RawShaderMaterial: FT,
                ShaderMaterial: ao,
                PointsMaterial: kc,
                MeshPhysicalMaterial: Er,
                MeshStandardMaterial: Xm,
                MeshPhongMaterial: ud,
                MeshToonMaterial: GT,
                MeshNormalMaterial: VT,
                MeshLambertMaterial: YS,
                MeshDepthMaterial: WS,
                MeshDistanceMaterial: ZS,
                MeshBasicMaterial: ja,
                MeshMatcapMaterial: kT,
                LineDashedMaterial: XT,
                LineBasicMaterial: Vi,
                Material: Li
            };
            return new t[e];
        }
    }
    class Ol {
        static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
    }
    class nA extends Dt {
        constructor(){
            super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(e) {
            return super.copy(e), this.instanceCount = e.instanceCount, this;
        }
        toJSON() {
            const e = super.toJSON();
            return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
        }
    }
    class iA extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = new bs(a.manager);
            l.setPath(a.path), l.setRequestHeader(a.requestHeader), l.setWithCredentials(a.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(JSON.parse(f)));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        parse(e) {
            const t = {}, n = {};
            function i(x, M) {
                if (t[M] !== void 0) return t[M];
                const T = x.interleavedBuffers[M], E = a(x, T.buffer), C = sd(T.type, E), N = new Hm(C, T.stride);
                return N.uuid = T.uuid, t[M] = N, N;
            }
            function a(x, M) {
                if (n[M] !== void 0) return n[M];
                const T = x.arrayBuffers[M], E = new Uint32Array(T).buffer;
                return n[M] = E, E;
            }
            const l = e.isInstancedBufferGeometry ? new nA : new Dt, f = e.data.index;
            if (f !== void 0) {
                const x = sd(f.type, f.array);
                l.setIndex(new vn(x, 1));
            }
            const d = e.data.attributes;
            for(const x in d){
                const M = d[x];
                let R;
                if (M.isInterleavedBufferAttribute) {
                    const T = i(e.data, M.data);
                    R = new Yc(T, M.itemSize, M.offset, M.normalized);
                } else {
                    const T = sd(M.type, M.array), E = M.isInstancedBufferAttribute ? Tf : vn;
                    R = new E(T, M.itemSize, M.normalized);
                }
                M.name !== void 0 && (R.name = M.name), M.usage !== void 0 && R.setUsage(M.usage), l.setAttribute(x, R);
            }
            const p = e.data.morphAttributes;
            if (p) for(const x in p){
                const M = p[x], R = [];
                for(let T = 0, E = M.length; T < E; T++){
                    const C = M[T];
                    let N;
                    if (C.isInterleavedBufferAttribute) {
                        const D = i(e.data, C.data);
                        N = new Yc(D, C.itemSize, C.offset, C.normalized);
                    } else {
                        const D = sd(C.type, C.array);
                        N = new vn(D, C.itemSize, C.normalized);
                    }
                    C.name !== void 0 && (N.name = C.name), R.push(N);
                }
                l.morphAttributes[x] = R;
            }
            e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
            const y = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (y !== void 0) for(let x = 0, M = y.length; x !== M; ++x){
                const R = y[x];
                l.addGroup(R.start, R.count, R.materialIndex);
            }
            const _ = e.data.boundingSphere;
            return _ !== void 0 && (l.boundingSphere = new us().fromJSON(_)), e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
        }
    }
    class HC extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = this.path === "" ? Ol.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || l;
            const f = new bs(this.manager);
            f.setPath(this.path), f.setRequestHeader(this.requestHeader), f.setWithCredentials(this.withCredentials), f.load(e, function(d) {
                let p = null;
                try {
                    p = JSON.parse(d);
                } catch (y) {
                    i !== void 0 && i(y), console.error("THREE:ObjectLoader: Can't parse " + e + ".", y.message);
                    return;
                }
                const g = p.metadata;
                if (g === void 0 || g.type === void 0 || g.type.toLowerCase() === "geometry") {
                    i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                    return;
                }
                a.parse(p, t);
            }, n, i);
        }
        async loadAsync(e, t) {
            const n = this, i = this.path === "" ? Ol.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || i;
            const a = new bs(this.manager);
            a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials);
            const l = await a.loadAsync(e, t), f = JSON.parse(l), d = f.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
            return await n.parseAsync(f);
        }
        parse(e, t) {
            const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), a = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
                t !== void 0 && t(p);
            }), f = this.parseTextures(e.textures, l), d = this.parseMaterials(e.materials, f), p = this.parseObject(e.object, a, d, f, n), g = this.parseSkeletons(e.skeletons, p);
            if (this.bindSkeletons(p, g), this.bindLightTargets(p), t !== void 0) {
                let y = !1;
                for(const _ in l)if (l[_].data instanceof HTMLImageElement) {
                    y = !0;
                    break;
                }
                y === !1 && t(p);
            }
            return p;
        }
        async parseAsync(e) {
            const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), a = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, a), f = this.parseMaterials(e.materials, l), d = this.parseObject(e.object, i, f, l, t), p = this.parseSkeletons(e.skeletons, d);
            return this.bindSkeletons(d, p), this.bindLightTargets(d), d;
        }
        parseShapes(e) {
            const t = {};
            if (e !== void 0) for(let n = 0, i = e.length; n < i; n++){
                const a = new Mf().fromJSON(e[n]);
                t[a.uuid] = a;
            }
            return t;
        }
        parseSkeletons(e, t) {
            const n = {}, i = {};
            if (t.traverse(function(a) {
                a.isBone && (i[a.uuid] = a);
            }), e !== void 0) for(let a = 0, l = e.length; a < l; a++){
                const f = new Rd().fromJSON(e[a], i);
                n[f.uuid] = f;
            }
            return n;
        }
        parseGeometries(e, t) {
            const n = {};
            if (e !== void 0) {
                const i = new iA;
                for(let a = 0, l = e.length; a < l; a++){
                    let f;
                    const d = e[a];
                    switch(d.type){
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            f = i.parse(d);
                            break;
                        default:
                            d.type in JM ? f = JM[d.type].fromJSON(d, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${d.type}"`);
                    }
                    f.uuid = d.uuid, d.name !== void 0 && (f.name = d.name), d.userData !== void 0 && (f.userData = d.userData), n[d.uuid] = f;
                }
            }
            return n;
        }
        parseMaterials(e, t) {
            const n = {}, i = {};
            if (e !== void 0) {
                const a = new qy;
                a.setTextures(t);
                for(let l = 0, f = e.length; l < f; l++){
                    const d = e[l];
                    n[d.uuid] === void 0 && (n[d.uuid] = a.parse(d)), i[d.uuid] = n[d.uuid];
                }
            }
            return i;
        }
        parseAnimations(e) {
            const t = {};
            if (e !== void 0) for(let n = 0; n < e.length; n++){
                const i = e[n], a = wf.parse(i);
                t[a.uuid] = a;
            }
            return t;
        }
        parseImages(e, t) {
            const n = this, i = {};
            let a;
            function l(d) {
                return n.manager.itemStart(d), a.load(d, function() {
                    n.manager.itemEnd(d);
                }, void 0, function() {
                    n.manager.itemError(d), n.manager.itemEnd(d);
                });
            }
            function f(d) {
                if (typeof d == "string") {
                    const p = d, g = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
                    return l(g);
                } else return d.data ? {
                    data: sd(d.type, d.data),
                    width: d.width,
                    height: d.height
                } : null;
            }
            if (e !== void 0 && e.length > 0) {
                const d = new $S(t);
                a = new Um(d), a.setCrossOrigin(this.crossOrigin);
                for(let p = 0, g = e.length; p < g; p++){
                    const y = e[p], _ = y.url;
                    if (Array.isArray(_)) {
                        const x = [];
                        for(let M = 0, R = _.length; M < R; M++){
                            const T = _[M], E = f(T);
                            E !== null && (E instanceof HTMLImageElement ? x.push(E) : x.push(new qo(E.data, E.width, E.height)));
                        }
                        i[y.uuid] = new Vc(x);
                    } else {
                        const x = f(y.url);
                        i[y.uuid] = new Vc(x);
                    }
                }
            }
            return i;
        }
        async parseImagesAsync(e) {
            const t = this, n = {};
            let i;
            async function a(l) {
                if (typeof l == "string") {
                    const f = l, d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : t.resourcePath + f;
                    return await i.loadAsync(d);
                } else return l.data ? {
                    data: sd(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null;
            }
            if (e !== void 0 && e.length > 0) {
                i = new Um(this.manager), i.setCrossOrigin(this.crossOrigin);
                for(let l = 0, f = e.length; l < f; l++){
                    const d = e[l], p = d.url;
                    if (Array.isArray(p)) {
                        const g = [];
                        for(let y = 0, _ = p.length; y < _; y++){
                            const x = p[y], M = await a(x);
                            M !== null && (M instanceof HTMLImageElement ? g.push(M) : g.push(new qo(M.data, M.width, M.height)));
                        }
                        n[d.uuid] = new Vc(g);
                    } else {
                        const g = await a(d.url);
                        n[d.uuid] = new Vc(g);
                    }
                }
            }
            return n;
        }
        parseTextures(e, t) {
            function n(a, l) {
                return typeof a == "number" ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), l[a]);
            }
            const i = {};
            if (e !== void 0) for(let a = 0, l = e.length; a < l; a++){
                const f = e[a];
                f.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', f.uuid), t[f.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", f.image);
                const d = t[f.image], p = d.data;
                let g;
                Array.isArray(p) ? (g = new Pm, p.length === 6 && (g.needsUpdate = !0)) : (p && p.data ? g = new qo : g = new Qn, p && (g.needsUpdate = !0)), g.source = d, g.uuid = f.uuid, f.name !== void 0 && (g.name = f.name), f.mapping !== void 0 && (g.mapping = n(f.mapping, FC)), f.channel !== void 0 && (g.channel = f.channel), f.offset !== void 0 && g.offset.fromArray(f.offset), f.repeat !== void 0 && g.repeat.fromArray(f.repeat), f.center !== void 0 && g.center.fromArray(f.center), f.rotation !== void 0 && (g.rotation = f.rotation), f.wrap !== void 0 && (g.wrapS = n(f.wrap[0], n1), g.wrapT = n(f.wrap[1], n1)), f.format !== void 0 && (g.format = f.format), f.internalFormat !== void 0 && (g.internalFormat = f.internalFormat), f.type !== void 0 && (g.type = f.type), f.colorSpace !== void 0 && (g.colorSpace = f.colorSpace), f.minFilter !== void 0 && (g.minFilter = n(f.minFilter, i1)), f.magFilter !== void 0 && (g.magFilter = n(f.magFilter, i1)), f.anisotropy !== void 0 && (g.anisotropy = f.anisotropy), f.flipY !== void 0 && (g.flipY = f.flipY), f.generateMipmaps !== void 0 && (g.generateMipmaps = f.generateMipmaps), f.premultiplyAlpha !== void 0 && (g.premultiplyAlpha = f.premultiplyAlpha), f.unpackAlignment !== void 0 && (g.unpackAlignment = f.unpackAlignment), f.compareFunction !== void 0 && (g.compareFunction = f.compareFunction), f.userData !== void 0 && (g.userData = f.userData), i[f.uuid] = g;
            }
            return i;
        }
        parseObject(e, t, n, i, a) {
            let l;
            function f(_) {
                return t[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", _), t[_];
            }
            function d(_) {
                if (_ !== void 0) {
                    if (Array.isArray(_)) {
                        const x = [];
                        for(let M = 0, R = _.length; M < R; M++){
                            const T = _[M];
                            n[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", T), x.push(n[T]);
                        }
                        return x;
                    }
                    return n[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", _), n[_];
                }
            }
            function p(_) {
                return i[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", _), i[_];
            }
            let g, y;
            switch(e.type){
                case "Scene":
                    l = new IS, e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new tt(e.background) : l.background = p(e.background)), e.environment !== void 0 && (l.environment = p(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new Ry(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new wy(e.fog.color, e.fog.density)), e.fog.name !== "" && (l.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (l.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (l.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && l.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (l.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && l.environmentRotation.fromArray(e.environmentRotation);
                    break;
                case "PerspectiveCamera":
                    l = new hi(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    l = new Yo(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    l = new nb(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    l = new jy(e.color, e.intensity), l.target = e.target || "";
                    break;
                case "PointLight":
                    l = new Lm(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    l = new $T(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    l = new Xy(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), l.target = e.target || "";
                    break;
                case "HemisphereLight":
                    l = new JT(e.color, e.groundColor, e.intensity);
                    break;
                case "LightProbe":
                    l = new tA().fromJSON(e);
                    break;
                case "SkinnedMesh":
                    g = f(e.geometry), y = d(e.material), l = new Cy(g, y), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
                    break;
                case "Mesh":
                    g = f(e.geometry), y = d(e.material), l = new ai(g, y);
                    break;
                case "InstancedMesh":
                    g = f(e.geometry), y = d(e.material);
                    const _ = e.count, x = e.instanceMatrix, M = e.instanceColor;
                    l = new HS(g, y, _), l.instanceMatrix = new Tf(new Float32Array(x.array), 16), M !== void 0 && (l.instanceColor = new Tf(new Float32Array(M.array), M.itemSize));
                    break;
                case "BatchedMesh":
                    g = f(e.geometry), y = d(e.material), l = new AT(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, y), l.geometry = g, l.perObjectFrustumCulled = e.perObjectFrustumCulled, l.sortObjects = e.sortObjects, l._drawRanges = e.drawRanges, l._reservedRanges = e.reservedRanges, l._geometryInfo = e.geometryInfo.map((R)=>{
                        let T = null, E = null;
                        return R.boundingBox !== void 0 && (T = new Ui().fromJSON(R.boundingBox)), R.boundingSphere !== void 0 && (E = new us().fromJSON(R.boundingSphere)), {
                            ...R,
                            boundingBox: T,
                            boundingSphere: E
                        };
                    }), l._instanceInfo = e.instanceInfo, l._availableInstanceIds = e._availableInstanceIds, l._availableGeometryIds = e._availableGeometryIds, l._nextIndexStart = e.nextIndexStart, l._nextVertexStart = e.nextVertexStart, l._geometryCount = e.geometryCount, l._maxInstanceCount = e.maxInstanceCount, l._maxVertexCount = e.maxVertexCount, l._maxIndexCount = e.maxIndexCount, l._geometryInitialized = e.geometryInitialized, l._matricesTexture = p(e.matricesTexture.uuid), l._indirectTexture = p(e.indirectTexture.uuid), e.colorsTexture !== void 0 && (l._colorsTexture = p(e.colorsTexture.uuid)), e.boundingSphere !== void 0 && (l.boundingSphere = new us().fromJSON(e.boundingSphere)), e.boundingBox !== void 0 && (l.boundingBox = new Ui().fromJSON(e.boundingBox));
                    break;
                case "LOD":
                    l = new TT;
                    break;
                case "Line":
                    l = new Ko(f(e.geometry), d(e.material));
                    break;
                case "LineLoop":
                    l = new FS(f(e.geometry), d(e.material));
                    break;
                case "LineSegments":
                    l = new Ya(f(e.geometry), d(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    l = new cd(f(e.geometry), d(e.material));
                    break;
                case "Sprite":
                    l = new ET(d(e.material));
                    break;
                case "Group":
                    l = new Sr;
                    break;
                case "Bone":
                    l = new Md;
                    break;
                default:
                    l = new hn;
            }
            if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.up !== void 0 && l.up.fromArray(e.up), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (l.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
                const _ = e.children;
                for(let x = 0; x < _.length; x++)l.add(this.parseObject(_[x], t, n, i, a));
            }
            if (e.animations !== void 0) {
                const _ = e.animations;
                for(let x = 0; x < _.length; x++){
                    const M = _[x];
                    l.animations.push(a[M]);
                }
            }
            if (e.type === "LOD") {
                e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
                const _ = e.levels;
                for(let x = 0; x < _.length; x++){
                    const M = _[x], R = l.getObjectByProperty("uuid", M.object);
                    R !== void 0 && l.addLevel(R, M.distance, M.hysteresis);
                }
            }
            return l;
        }
        bindSkeletons(e, t) {
            Object.keys(t).length !== 0 && e.traverse(function(n) {
                if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                    const i = t[n.skeleton];
                    i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
                }
            });
        }
        bindLightTargets(e) {
            e.traverse(function(t) {
                if (t.isDirectionalLight || t.isSpotLight) {
                    const n = t.target, i = e.getObjectByProperty("uuid", n);
                    i !== void 0 ? t.target = i : t.target = new hn;
                }
            });
        }
    }
    const FC = {
        UVMapping: py,
        CubeReflectionMapping: Bl,
        CubeRefractionMapping: jc,
        EquirectangularReflectionMapping: hd,
        EquirectangularRefractionMapping: Mm,
        CubeUVReflectionMapping: wd
    }, n1 = {
        RepeatWrapping: Zo,
        ClampToEdgeWrapping: na,
        MirroredRepeatWrapping: dd
    }, i1 = {
        NearestFilter: cs,
        NearestMipmapNearestFilter: my,
        NearestMipmapLinearFilter: gf,
        LinearFilter: pi,
        LinearMipmapNearestFilter: rd,
        LinearMipmapLinearFilter: Xa
    }, gx = new WeakMap;
    class sA extends ki {
        constructor(e){
            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                premultiplyAlpha: "none"
            };
        }
        setOptions(e) {
            return this.options = e, this;
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
            const a = this, l = Xo.get(`image-bitmap:${e}`);
            if (l !== void 0) {
                if (a.manager.itemStart(e), l.then) {
                    l.then((p)=>{
                        if (gx.has(l) === !0) i && i(gx.get(l)), a.manager.itemError(e), a.manager.itemEnd(e);
                        else return t && t(p), a.manager.itemEnd(e), p;
                    });
                    return;
                }
                return setTimeout(function() {
                    t && t(l), a.manager.itemEnd(e);
                }, 0), l;
            }
            const f = {};
            f.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", f.headers = this.requestHeader;
            const d = fetch(e, f).then(function(p) {
                return p.blob();
            }).then(function(p) {
                return createImageBitmap(p, Object.assign(a.options, {
                    colorSpaceConversion: "none"
                }));
            }).then(function(p) {
                return Xo.add(`image-bitmap:${e}`, p), t && t(p), a.manager.itemEnd(e), p;
            }).catch(function(p) {
                i && i(p), gx.set(d, p), Xo.remove(`image-bitmap:${e}`), a.manager.itemError(e), a.manager.itemEnd(e);
            });
            Xo.add(`image-bitmap:${e}`, d), a.manager.itemStart(e);
        }
    }
    let tv;
    class ib {
        static getContext() {
            return tv === void 0 && (tv = new (window.AudioContext || window.webkitAudioContext)), tv;
        }
        static setContext(e) {
            tv = e;
        }
    }
    class GC extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = new bs(this.manager);
            l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
                try {
                    const p = d.slice(0);
                    ib.getContext().decodeAudioData(p, function(y) {
                        t(y);
                    }).catch(f);
                } catch (p) {
                    f(p);
                }
            }, n, i);
            function f(d) {
                i ? i(d) : console.error(d), a.manager.itemError(e);
            }
        }
    }
    const s1 = new pt, a1 = new pt, ef = new pt;
    class VC {
        constructor(){
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new hi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new hi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            };
        }
        update(e) {
            const t = this._cache;
            if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ef.copy(e.projectionMatrix);
                const i = t.eyeSep / 2, a = i * t.near / t.focus, l = t.near * Math.tan(bf * t.fov * .5) / t.zoom;
                let f, d;
                a1.elements[12] = -i, s1.elements[12] = i, f = -l * t.aspect + a, d = l * t.aspect + a, ef.elements[0] = 2 * t.near / (d - f), ef.elements[8] = (d + f) / (d - f), this.cameraL.projectionMatrix.copy(ef), f = -l * t.aspect - a, d = l * t.aspect - a, ef.elements[0] = 2 * t.near / (d - f), ef.elements[8] = (d + f) / (d - f), this.cameraR.projectionMatrix.copy(ef);
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(a1), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(s1);
        }
    }
    class aA extends hi {
        constructor(e = []){
            super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e;
        }
    }
    class sb {
        constructor(e = !0){
            this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
        }
        start() {
            this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        }
        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const t = performance.now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
            }
            return e;
        }
    }
    const tf = new Y, vx = new mi, kC = new Y, nf = new Y, sf = new Y;
    class XC extends hn {
        constructor(){
            super(), this.type = "AudioListener", this.context = ib.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new sb;
        }
        getInput() {
            return this.gain;
        }
        removeFilter() {
            return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
            return this.filter;
        }
        setFilter(e) {
            return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
            return this.gain.gain.value;
        }
        setMasterVolume(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e);
            const t = this.context.listener;
            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(tf, vx, kC), nf.set(0, 0, -1).applyQuaternion(vx), sf.set(0, 1, 0).applyQuaternion(vx), t.positionX) {
                const n = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(tf.x, n), t.positionY.linearRampToValueAtTime(tf.y, n), t.positionZ.linearRampToValueAtTime(tf.z, n), t.forwardX.linearRampToValueAtTime(nf.x, n), t.forwardY.linearRampToValueAtTime(nf.y, n), t.forwardZ.linearRampToValueAtTime(nf.z, n), t.upX.linearRampToValueAtTime(sf.x, n), t.upY.linearRampToValueAtTime(sf.y, n), t.upZ.linearRampToValueAtTime(sf.z, n);
            } else t.setPosition(tf.x, tf.y, tf.z), t.setOrientation(nf.x, nf.y, nf.z, sf.x, sf.y, sf.z);
        }
    }
    class rA extends hn {
        constructor(e){
            super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
        }
        getOutput() {
            return this.gain;
        }
        setNodeSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
        }
        setMediaElementSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
        }
        setMediaStreamSource(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
        }
        setBuffer(e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(e = 0) {
            if (this.isPlaying === !0) {
                console.warn("THREE.Audio: Audio is already playing.");
                return;
            }
            if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
            }
            this._startedAt = this.context.currentTime + e;
            const t = this.context.createBufferSource();
            return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
            if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
            }
            return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
        }
        stop(e = 0) {
            if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
            }
            return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for(let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this._connected = !0, this;
        }
        disconnect() {
            if (this._connected !== !1) {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for(let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput());
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this;
            }
        }
        getFilters() {
            return this.filters;
        }
        setFilters(e) {
            return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
        }
        setDetune(e) {
            return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
        }
        getDetune() {
            return this.detune;
        }
        getFilter() {
            return this.getFilters()[0];
        }
        setFilter(e) {
            return this.setFilters(e ? [
                e
            ] : []);
        }
        setPlaybackRate(e) {
            if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
            }
            return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
        }
        getPlaybackRate() {
            return this.playbackRate;
        }
        onEnded() {
            this.isPlaying = !1, this._progress = 0;
        }
        getLoop() {
            return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
        }
        setLoop(e) {
            if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
            }
            return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
        }
        setLoopStart(e) {
            return this.loopStart = e, this;
        }
        setLoopEnd(e) {
            return this.loopEnd = e, this;
        }
        getVolume() {
            return this.gain.gain.value;
        }
        setVolume(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
        }
        copy(e, t) {
            return super.copy(e, t), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
        }
        clone(e) {
            return new this.constructor(this.listener).copy(this, e);
        }
    }
    const af = new Y, r1 = new mi, jC = new Y, rf = new Y;
    class qC extends rA {
        constructor(e){
            super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        connect() {
            return super.connect(), this.panner.connect(this.gain), this;
        }
        disconnect() {
            return super.disconnect(), this.panner.disconnect(this.gain), this;
        }
        getOutput() {
            return this.panner;
        }
        getRefDistance() {
            return this.panner.refDistance;
        }
        setRefDistance(e) {
            return this.panner.refDistance = e, this;
        }
        getRolloffFactor() {
            return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
            return this.panner.rolloffFactor = e, this;
        }
        getDistanceModel() {
            return this.panner.distanceModel;
        }
        setDistanceModel(e) {
            return this.panner.distanceModel = e, this;
        }
        getMaxDistance() {
            return this.panner.maxDistance;
        }
        setMaxDistance(e) {
            return this.panner.maxDistance = e, this;
        }
        setDirectionalCone(e, t, n) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
        }
        updateMatrixWorld(e) {
            if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
            this.matrixWorld.decompose(af, r1, jC), rf.set(0, 0, 1).applyQuaternion(r1);
            const t = this.panner;
            if (t.positionX) {
                const n = this.context.currentTime + this.listener.timeDelta;
                t.positionX.linearRampToValueAtTime(af.x, n), t.positionY.linearRampToValueAtTime(af.y, n), t.positionZ.linearRampToValueAtTime(af.z, n), t.orientationX.linearRampToValueAtTime(rf.x, n), t.orientationY.linearRampToValueAtTime(rf.y, n), t.orientationZ.linearRampToValueAtTime(rf.z, n);
            } else t.setPosition(af.x, af.y, af.z), t.setOrientation(rf.x, rf.y, rf.z);
        }
    }
    class YC {
        constructor(e, t = 2048){
            this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
            let e = 0;
            const t = this.getFrequencyData();
            for(let n = 0; n < t.length; n++)e += t[n];
            return e / t.length;
        }
    }
    class oA {
        constructor(e, t, n){
            this.binding = e, this.valueSize = n;
            let i, a, l;
            switch(t){
                case "quaternion":
                    i = this._slerp, a = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select, a = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                    break;
                default:
                    i = this._lerp, a = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
            }
            this._mixBufferRegion = i, this._mixBufferRegionAdditive = a, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e, t) {
            const n = this.buffer, i = this.valueSize, a = e * i + i;
            let l = this.cumulativeWeight;
            if (l === 0) {
                for(let f = 0; f !== i; ++f)n[a + f] = n[f];
                l = t;
            } else {
                l += t;
                const f = t / l;
                this._mixBufferRegion(n, a, 0, f, i);
            }
            this.cumulativeWeight = l;
        }
        accumulateAdditive(e) {
            const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
            this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
        }
        apply(e) {
            const t = this.valueSize, n = this.buffer, i = e * t + t, a = this.cumulativeWeight, l = this.cumulativeWeightAdditive, f = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1) {
                const d = t * this._origIndex;
                this._mixBufferRegion(n, i, d, 1 - a, t);
            }
            l > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
            for(let d = t, p = t + t; d !== p; ++d)if (n[d] !== n[d + t]) {
                f.setValue(n, i);
                break;
            }
        }
        saveOriginalState() {
            const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
            e.getValue(t, i);
            for(let a = n, l = i; a !== l; ++a)t[a] = t[i + a % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
            const e = this.valueSize * 3;
            this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
            const e = this._addIndex * this.valueSize, t = e + this.valueSize;
            for(let n = e; n < t; n++)this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
            const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
            for(let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, a) {
            if (i >= .5) for(let l = 0; l !== a; ++l)e[t + l] = e[n + l];
        }
        _slerp(e, t, n, i) {
            mi.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, a) {
            const l = this._workIndex * a;
            mi.multiplyQuaternionsFlat(e, l, e, t, e, n), mi.slerpFlat(e, t, e, t, e, l, i);
        }
        _lerp(e, t, n, i, a) {
            const l = 1 - i;
            for(let f = 0; f !== a; ++f){
                const d = t + f;
                e[d] = e[d] * l + e[n + f] * i;
            }
        }
        _lerpAdditive(e, t, n, i, a) {
            for(let l = 0; l !== a; ++l){
                const f = t + l;
                e[f] = e[f] + e[n + l] * i;
            }
        }
    }
    const ab = "\\[\\]\\.:\\/", WC = new RegExp("[" + ab + "]", "g"), rb = "[^" + ab + "]", ZC = "[^" + ab.replace("\\.", "") + "]", KC = /((?:WC+[\/:])*)/.source.replace("WC", rb), QC = /(WCOD+)?/.source.replace("WCOD", ZC), JC = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rb), $C = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rb), e3 = new RegExp("^" + KC + QC + JC + $C + "$"), t3 = [
        "material",
        "materials",
        "bones",
        "map"
    ];
    class n3 {
        constructor(e, t, n){
            const i = n || fn.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, i);
        }
        getValue(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
            i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
            const n = this._bindings;
            for(let i = this._targetGroup.nCachedObjects_, a = n.length; i !== a; ++i)n[i].setValue(e, t);
        }
        bind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind();
        }
        unbind() {
            const e = this._bindings;
            for(let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind();
        }
    }
    class fn {
        constructor(e, t, n){
            this.path = t, this.parsedPath = n || fn.parseTrackName(t), this.node = fn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new fn.Composite(e, t, n) : new fn(e, t, n);
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(WC, "");
        }
        static parseTrackName(e) {
            const t = e3.exec(e);
            if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }, i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (i !== void 0 && i !== -1) {
                const a = n.nodeName.substring(i + 1);
                t3.indexOf(a) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = a);
            }
            if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n;
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n;
            }
            if (e.children) {
                const n = function(a) {
                    for(let l = 0; l < a.length; l++){
                        const f = a[l];
                        if (f.name === t || f.uuid === t) return f;
                        const d = n(f.children);
                        if (d) return d;
                    }
                    return null;
                }, i = n(e.children);
                if (i) return i;
            }
            return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let i = 0, a = n.length; i !== a; ++i)e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_array(e, t) {
            const n = this.resolvedProperty;
            for(let i = 0, a = n.length; i !== a; ++i)n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let i = 0, a = n.length; i !== a; ++i)n[i] = e[t++];
            this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const n = this.resolvedProperty;
            for(let i = 0, a = n.length; i !== a; ++i)n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t);
        }
        bind() {
            let e = this.node;
            const t = this.parsedPath, n = t.objectName, i = t.propertyName;
            let a = t.propertyIndex;
            if (e || (e = fn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return;
            }
            if (n) {
                let p = t.objectIndex;
                switch(n){
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return;
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return;
                        }
                        e = e.skeleton.bones;
                        for(let g = 0; g < e.length; g++)if (e[g].name === p) {
                            p = g;
                            break;
                        }
                        break;
                    case "map":
                        if ("map" in e) {
                            e = e.map;
                            break;
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return;
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return;
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return;
                        }
                        e = e[n];
                }
                if (p !== void 0) {
                    if (e[p] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return;
                    }
                    e = e[p];
                }
            }
            const l = e[i];
            if (l === void 0) {
                const p = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + p + "." + i + " but it wasn't found.", e);
                return;
            }
            let f = this.Versioning.None;
            this.targetObject = e, e.isMaterial === !0 ? f = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (f = this.Versioning.MatrixWorldNeedsUpdate);
            let d = this.BindingType.Direct;
            if (a !== void 0) {
                if (i === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return;
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a]);
                }
                d = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = a;
            } else l.fromArray !== void 0 && l.toArray !== void 0 ? (d = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (d = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[d], this.setValue = this.SetterByBindingTypeAndVersioning[d][f];
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }
    fn.Composite = n3;
    fn.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    fn.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    fn.prototype.GetterByBindingType = [
        fn.prototype._getValue_direct,
        fn.prototype._getValue_array,
        fn.prototype._getValue_arrayElement,
        fn.prototype._getValue_toArray
    ];
    fn.prototype.SetterByBindingTypeAndVersioning = [
        [
            fn.prototype._setValue_direct,
            fn.prototype._setValue_direct_setNeedsUpdate,
            fn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
            fn.prototype._setValue_array,
            fn.prototype._setValue_array_setNeedsUpdate,
            fn.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
            fn.prototype._setValue_arrayElement,
            fn.prototype._setValue_arrayElement_setNeedsUpdate,
            fn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
            fn.prototype._setValue_fromArray,
            fn.prototype._setValue_fromArray_setNeedsUpdate,
            fn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
    ];
    class i3 {
        constructor(){
            this.isAnimationObjectGroup = !0, this.uuid = qa(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            const e = {};
            this._indicesByUUID = e;
            for(let n = 0, i = arguments.length; n !== i; ++n)e[arguments[n].uuid] = n;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            const t = this;
            this.stats = {
                objects: {
                    get total () {
                        return t._objects.length;
                    },
                    get inUse () {
                        return this.total - t.nCachedObjects_;
                    }
                },
                get bindingsPerObject () {
                    return t._bindings.length;
                }
            };
        }
        add() {
            const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, a = this._bindings, l = a.length;
            let f, d = e.length, p = this.nCachedObjects_;
            for(let g = 0, y = arguments.length; g !== y; ++g){
                const _ = arguments[g], x = _.uuid;
                let M = t[x];
                if (M === void 0) {
                    M = d++, t[x] = M, e.push(_);
                    for(let R = 0, T = l; R !== T; ++R)a[R].push(new fn(_, n[R], i[R]));
                } else if (M < p) {
                    f = e[M];
                    const R = --p, T = e[R];
                    t[T.uuid] = M, e[M] = T, t[x] = R, e[R] = _;
                    for(let E = 0, C = l; E !== C; ++E){
                        const N = a[E], D = N[R];
                        let I = N[M];
                        N[M] = D, I === void 0 && (I = new fn(_, n[E], i[E])), N[R] = I;
                    }
                } else e[M] !== f && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
            this.nCachedObjects_ = p;
        }
        remove() {
            const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
            let a = this.nCachedObjects_;
            for(let l = 0, f = arguments.length; l !== f; ++l){
                const d = arguments[l], p = d.uuid, g = t[p];
                if (g !== void 0 && g >= a) {
                    const y = a++, _ = e[y];
                    t[_.uuid] = g, e[g] = _, t[p] = y, e[y] = d;
                    for(let x = 0, M = i; x !== M; ++x){
                        const R = n[x], T = R[y], E = R[g];
                        R[g] = T, R[y] = E;
                    }
                }
            }
            this.nCachedObjects_ = a;
        }
        uncache() {
            const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
            let a = this.nCachedObjects_, l = e.length;
            for(let f = 0, d = arguments.length; f !== d; ++f){
                const p = arguments[f], g = p.uuid, y = t[g];
                if (y !== void 0) if (delete t[g], y < a) {
                    const _ = --a, x = e[_], M = --l, R = e[M];
                    t[x.uuid] = y, e[y] = x, t[R.uuid] = _, e[_] = R, e.pop();
                    for(let T = 0, E = i; T !== E; ++T){
                        const C = n[T], N = C[_], D = C[M];
                        C[y] = N, C[_] = D, C.pop();
                    }
                } else {
                    const _ = --l, x = e[_];
                    _ > 0 && (t[x.uuid] = y), e[y] = x, e.pop();
                    for(let M = 0, R = i; M !== R; ++M){
                        const T = n[M];
                        T[y] = T[_], T.pop();
                    }
                }
            }
            this.nCachedObjects_ = a;
        }
        subscribe_(e, t) {
            const n = this._bindingsIndicesByPath;
            let i = n[e];
            const a = this._bindings;
            if (i !== void 0) return a[i];
            const l = this._paths, f = this._parsedPaths, d = this._objects, p = d.length, g = this.nCachedObjects_, y = new Array(p);
            i = a.length, n[e] = i, l.push(e), f.push(t), a.push(y);
            for(let _ = g, x = d.length; _ !== x; ++_){
                const M = d[_];
                y[_] = new fn(M, e, t);
            }
            return y;
        }
        unsubscribe_(e) {
            const t = this._bindingsIndicesByPath, n = t[e];
            if (n !== void 0) {
                const i = this._paths, a = this._parsedPaths, l = this._bindings, f = l.length - 1, d = l[f], p = e[f];
                t[p] = n, l[n] = d, l.pop(), a[n] = a[f], a.pop(), i[n] = i[f], i.pop();
            }
        }
    }
    class lA {
        constructor(e, t, n = null, i = t.blendMode){
            this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
            const a = t.tracks, l = a.length, f = new Array(l), d = {
                endingStart: vf,
                endingEnd: vf
            };
            for(let p = 0; p !== l; ++p){
                const g = a[p].createInterpolant(null);
                f[p] = g, g.settings = d;
            }
            this._interpolantSettings = d, this._interpolants = f, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = nT, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
        }
        play() {
            return this._mixer._activateAction(this), this;
        }
        stop() {
            return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(e) {
            return this._startTime = e, this;
        }
        setLoop(e, t) {
            return this.loop = e, this.repetitions = t, this;
        }
        setEffectiveWeight(e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(e) {
            return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
            return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n = !1) {
            if (e.fadeOut(t), this.fadeIn(t), n === !0) {
                const i = this._clip.duration, a = e._clip.duration, l = a / i, f = i / a;
                e.warp(1, l, t), this.warp(f, 1, t);
            }
            return this;
        }
        crossFadeTo(e, t, n = !1) {
            return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
            const e = this._weightInterpolant;
            return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        setEffectiveTimeScale(e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping();
        }
        syncWith(e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
        }
        halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
            const i = this._mixer, a = i.time, l = this.timeScale;
            let f = this._timeScaleInterpolant;
            f === null && (f = i._lendControlInterpolant(), this._timeScaleInterpolant = f);
            const d = f.parameterPositions, p = f.sampleValues;
            return d[0] = a, d[1] = a + n, p[0] = e / l, p[1] = t / l, this;
        }
        stopWarping() {
            const e = this._timeScaleInterpolant;
            return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
            if (!this.enabled) {
                this._updateWeight(e);
                return;
            }
            const a = this._startTime;
            if (a !== null) {
                const d = (e - a) * n;
                d < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * d);
            }
            t *= this._updateTimeScale(e);
            const l = this._updateTime(t), f = this._updateWeight(e);
            if (f > 0) {
                const d = this._interpolants, p = this._propertyBindings;
                switch(this.blendMode){
                    case NS:
                        for(let g = 0, y = d.length; g !== y; ++g)d[g].evaluate(l), p[g].accumulateAdditive(f);
                        break;
                    case by:
                    default:
                        for(let g = 0, y = d.length; g !== y; ++g)d[g].evaluate(l), p[g].accumulate(i, f);
                }
            }
        }
        _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
                t = this.weight;
                const n = this._weightInterpolant;
                if (n !== null) {
                    const i = n.evaluate(e)[0];
                    t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = t, t;
        }
        _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
                t = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (n !== null) {
                    const i = n.evaluate(e)[0];
                    t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
                }
            }
            return this._effectiveTimeScale = t, t;
        }
        _updateTime(e) {
            const t = this._clip.duration, n = this.loop;
            let i = this.time + e, a = this._loopCount;
            const l = n === iT;
            if (e === 0) return a === -1 ? i : l && (a & 1) === 1 ? t - i : i;
            if (n === tT) {
                a === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                e: {
                    if (i >= t) i = t;
                    else if (i < 0) i = 0;
                    else {
                        this.time = i;
                        break e;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    });
                }
            } else {
                if (a === -1 && (e >= 0 ? (a = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
                    const f = Math.floor(i / t);
                    i -= t * f, a += Math.abs(f);
                    const d = this.repetitions - a;
                    if (d <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                    else {
                        if (d === 1) {
                            const p = e < 0;
                            this._setEndings(p, !p, l);
                        } else this._setEndings(!1, !1, l);
                        this._loopCount = a, this.time = i, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: f
                        });
                    }
                } else this.time = i;
                if (l && (a & 1) === 1) return t - i;
            }
            return i;
        }
        _setEndings(e, t, n) {
            const i = this._interpolantSettings;
            n ? (i.endingStart = yf, i.endingEnd = yf) : (e ? i.endingStart = this.zeroSlopeAtStart ? yf : vf : i.endingStart = Em, t ? i.endingEnd = this.zeroSlopeAtEnd ? yf : vf : i.endingEnd = Em);
        }
        _scheduleFading(e, t, n) {
            const i = this._mixer, a = i.time;
            let l = this._weightInterpolant;
            l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
            const f = l.parameterPositions, d = l.sampleValues;
            return f[0] = a, d[0] = t, f[1] = a + e, d[1] = n, this;
        }
    }
    const s3 = new Float32Array(1);
    class a3 extends Qo {
        constructor(e){
            super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e, t) {
            const n = e._localRoot || this._root, i = e._clip.tracks, a = i.length, l = e._propertyBindings, f = e._interpolants, d = n.uuid, p = this._bindingsByRootAndName;
            let g = p[d];
            g === void 0 && (g = {}, p[d] = g);
            for(let y = 0; y !== a; ++y){
                const _ = i[y], x = _.name;
                let M = g[x];
                if (M !== void 0) ++M.referenceCount, l[y] = M;
                else {
                    if (M = l[y], M !== void 0) {
                        M._cacheIndex === null && (++M.referenceCount, this._addInactiveBinding(M, d, x));
                        continue;
                    }
                    const R = t && t._propertyBindings[y].binding.parsedPath;
                    M = new oA(fn.create(n, x, R), _.ValueTypeName, _.getValueSize()), ++M.referenceCount, this._addInactiveBinding(M, d, x), l[y] = M;
                }
                f[y].resultBuffer = M.buffer;
            }
        }
        _activateAction(e) {
            if (!this._isActiveAction(e)) {
                if (e._cacheIndex === null) {
                    const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, a = this._actionsByClip[i];
                    this._bindAction(e, a && a.knownActions[0]), this._addInactiveAction(e, i, n);
                }
                const t = e._propertyBindings;
                for(let n = 0, i = t.length; n !== i; ++n){
                    const a = t[n];
                    a.useCount++ === 0 && (this._lendBinding(a), a.saveOriginalState());
                }
                this._lendAction(e);
            }
        }
        _deactivateAction(e) {
            if (this._isActiveAction(e)) {
                const t = e._propertyBindings;
                for(let n = 0, i = t.length; n !== i; ++n){
                    const a = t[n];
                    --a.useCount === 0 && (a.restoreOriginalState(), this._takeBackBinding(a));
                }
                this._takeBackAction(e);
            }
        }
        _initMemoryManager() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            const e = this;
            this.stats = {
                actions: {
                    get total () {
                        return e._actions.length;
                    },
                    get inUse () {
                        return e._nActiveActions;
                    }
                },
                bindings: {
                    get total () {
                        return e._bindings.length;
                    },
                    get inUse () {
                        return e._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total () {
                        return e._controlInterpolants.length;
                    },
                    get inUse () {
                        return e._nActiveControlInterpolants;
                    }
                }
            };
        }
        _isActiveAction(e) {
            const t = e._cacheIndex;
            return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
            const i = this._actions, a = this._actionsByClip;
            let l = a[t];
            if (l === void 0) l = {
                knownActions: [
                    e
                ],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, a[t] = l;
            else {
                const f = l.knownActions;
                e._byClipCacheIndex = f.length, f.push(e);
            }
            e._cacheIndex = i.length, i.push(e), l.actionByRoot[n] = e;
        }
        _removeInactiveAction(e) {
            const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
            n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
            const a = e._clip.uuid, l = this._actionsByClip, f = l[a], d = f.knownActions, p = d[d.length - 1], g = e._byClipCacheIndex;
            p._byClipCacheIndex = g, d[g] = p, d.pop(), e._byClipCacheIndex = null;
            const y = f.actionByRoot, _ = (e._localRoot || this._root).uuid;
            delete y[_], d.length === 0 && delete l[a], this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
            const t = e._propertyBindings;
            for(let n = 0, i = t.length; n !== i; ++n){
                const a = t[n];
                --a.referenceCount === 0 && this._removeInactiveBinding(a);
            }
        }
        _lendAction(e) {
            const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, a = t[i];
            e._cacheIndex = i, t[i] = e, a._cacheIndex = n, t[n] = a;
        }
        _takeBackAction(e) {
            const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, a = t[i];
            e._cacheIndex = i, t[i] = e, a._cacheIndex = n, t[n] = a;
        }
        _addInactiveBinding(e, t, n) {
            const i = this._bindingsByRootAndName, a = this._bindings;
            let l = i[t];
            l === void 0 && (l = {}, i[t] = l), l[n] = e, e._cacheIndex = a.length, a.push(e);
        }
        _removeInactiveBinding(e) {
            const t = this._bindings, n = e.binding, i = n.rootNode.uuid, a = n.path, l = this._bindingsByRootAndName, f = l[i], d = t[t.length - 1], p = e._cacheIndex;
            d._cacheIndex = p, t[p] = d, t.pop(), delete f[a], Object.keys(f).length === 0 && delete l[i];
        }
        _lendBinding(e) {
            const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, a = t[i];
            e._cacheIndex = i, t[i] = e, a._cacheIndex = n, t[n] = a;
        }
        _takeBackBinding(e) {
            const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, a = t[i];
            e._cacheIndex = i, t[i] = e, a._cacheIndex = n, t[n] = a;
        }
        _lendControlInterpolant() {
            const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
            let n = e[t];
            return n === void 0 && (n = new QS(new Float32Array(2), new Float32Array(2), 1, s3), n.__cacheIndex = t, e[t] = n), n;
        }
        _takeBackControlInterpolant(e) {
            const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, a = t[i];
            e.__cacheIndex = i, t[i] = e, a.__cacheIndex = n, t[n] = a;
        }
        clipAction(e, t, n) {
            const i = t || this._root, a = i.uuid;
            let l = typeof e == "string" ? wf.findByName(i, e) : e;
            const f = l !== null ? l.uuid : e, d = this._actionsByClip[f];
            let p = null;
            if (n === void 0 && (l !== null ? n = l.blendMode : n = by), d !== void 0) {
                const y = d.actionByRoot[a];
                if (y !== void 0 && y.blendMode === n) return y;
                p = d.knownActions[0], l === null && (l = p._clip);
            }
            if (l === null) return null;
            const g = new lA(this, l, t, n);
            return this._bindAction(g, p), this._addInactiveAction(g, f, a), g;
        }
        existingAction(e, t) {
            const n = t || this._root, i = n.uuid, a = typeof e == "string" ? wf.findByName(n, e) : e, l = a ? a.uuid : e, f = this._actionsByClip[l];
            return f !== void 0 && f.actionByRoot[i] || null;
        }
        stopAllAction() {
            const e = this._actions, t = this._nActiveActions;
            for(let n = t - 1; n >= 0; --n)e[n].stop();
            return this;
        }
        update(e) {
            e *= this.timeScale;
            const t = this._actions, n = this._nActiveActions, i = this.time += e, a = Math.sign(e), l = this._accuIndex ^= 1;
            for(let p = 0; p !== n; ++p)t[p]._update(i, e, a, l);
            const f = this._bindings, d = this._nActiveBindings;
            for(let p = 0; p !== d; ++p)f[p].apply(l);
            return this;
        }
        setTime(e) {
            this.time = 0;
            for(let t = 0; t < this._actions.length; t++)this._actions[t].time = 0;
            return this.update(e);
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(e) {
            const t = this._actions, n = e.uuid, i = this._actionsByClip, a = i[n];
            if (a !== void 0) {
                const l = a.knownActions;
                for(let f = 0, d = l.length; f !== d; ++f){
                    const p = l[f];
                    this._deactivateAction(p);
                    const g = p._cacheIndex, y = t[t.length - 1];
                    p._cacheIndex = null, p._byClipCacheIndex = null, y._cacheIndex = g, t[g] = y, t.pop(), this._removeInactiveBindingsForAction(p);
                }
                delete i[n];
            }
        }
        uncacheRoot(e) {
            const t = e.uuid, n = this._actionsByClip;
            for(const l in n){
                const f = n[l].actionByRoot, d = f[t];
                d !== void 0 && (this._deactivateAction(d), this._removeInactiveAction(d));
            }
            const i = this._bindingsByRootAndName, a = i[t];
            if (a !== void 0) for(const l in a){
                const f = a[l];
                f.restoreOriginalState(), this._removeInactiveBinding(f);
            }
        }
        uncacheAction(e, t) {
            const n = this.existingAction(e, t);
            n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
    }
    class r3 extends zS {
        constructor(e = 1, t = 1, n = 1, i = {}){
            super(e, t, i), this.isRenderTarget3D = !0, this.depth = n, this.texture = new Ey(null, e, t, n), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0;
        }
    }
    class ob {
        constructor(e){
            this.value = e;
        }
        clone() {
            return new ob(this.value.clone === void 0 ? this.value : this.value.clone());
        }
    }
    let o3 = 0;
    class l3 extends Qo {
        constructor(){
            super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                value: o3++
            }), this.name = "", this.usage = Am, this.uniforms = [];
        }
        add(e) {
            return this.uniforms.push(e), this;
        }
        remove(e) {
            const t = this.uniforms.indexOf(e);
            return t !== -1 && this.uniforms.splice(t, 1), this;
        }
        setName(e) {
            return this.name = e, this;
        }
        setUsage(e) {
            return this.usage = e, this;
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
        copy(e) {
            this.name = e.name, this.usage = e.usage;
            const t = e.uniforms;
            this.uniforms.length = 0;
            for(let n = 0, i = t.length; n < i; n++){
                const a = Array.isArray(t[n]) ? t[n] : [
                    t[n]
                ];
                for(let l = 0; l < a.length; l++)this.uniforms.push(a[l].clone());
            }
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class c3 extends Hm {
        constructor(e, t, n = 1){
            super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
        }
        copy(e) {
            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        clone(e) {
            const t = super.clone(e);
            return t.meshPerAttribute = this.meshPerAttribute, t;
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
        }
    }
    class u3 {
        constructor(e, t, n, i, a, l = !1){
            this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = a, this.normalized = l, this.version = 0;
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setBuffer(e) {
            return this.buffer = e, this;
        }
        setType(e, t) {
            return this.type = e, this.elementSize = t, this;
        }
        setItemSize(e) {
            return this.itemSize = e, this;
        }
        setCount(e) {
            return this.count = e, this;
        }
    }
    const o1 = new pt;
    class cA {
        constructor(e, t, n = 0, i = 1 / 0){
            this.ray = new Df(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Sd, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            };
        }
        set(e, t) {
            this.ray.set(e, t);
        }
        setFromCamera(e, t) {
            t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
        }
        setFromXRController(e) {
            return o1.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(o1), this;
        }
        intersectObject(e, t = !0, n = []) {
            return lS(e, this, n, t), n.sort(l1), n;
        }
        intersectObjects(e, t = !0, n = []) {
            for(let i = 0, a = e.length; i < a; i++)lS(e[i], this, n, t);
            return n.sort(l1), n;
        }
    }
    function l1(r, e) {
        return r.distance - e.distance;
    }
    function lS(r, e, t, n) {
        let i = !0;
        if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
            const a = r.children;
            for(let l = 0, f = a.length; l < f; l++)lS(a[l], e, t, !0);
        }
    }
    class cS {
        constructor(e = 1, t = 0, n = 0){
            this.radius = e, this.phi = t, this.theta = n;
        }
        set(e, t, n) {
            return this.radius = e, this.phi = t, this.theta = n, this;
        }
        copy(e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
        }
        makeSafe() {
            return this.phi = Wt(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
            return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Wt(t / this.radius, -1, 1))), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class f3 {
        constructor(e = 1, t = 0, n = 0){
            this.radius = e, this.theta = t, this.y = n;
        }
        set(e, t, n) {
            return this.radius = e, this.theta = t, this.y = n, this;
        }
        copy(e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
            return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class lb {
        constructor(e, t, n, i){
            lb.prototype.isMatrix2 = !0, this.elements = [
                1,
                0,
                0,
                1
            ], e !== void 0 && this.set(e, t, n, i);
        }
        identity() {
            return this.set(1, 0, 0, 1), this;
        }
        fromArray(e, t = 0) {
            for(let n = 0; n < 4; n++)this.elements[n] = e[n + t];
            return this;
        }
        set(e, t, n, i) {
            const a = this.elements;
            return a[0] = e, a[2] = t, a[1] = n, a[3] = i, this;
        }
    }
    const c1 = new Ie;
    class h3 {
        constructor(e = new Ie(1 / 0, 1 / 0), t = new Ie(-1 / 0, -1 / 0)){
            this.isBox2 = !0, this.min = e, this.max = t;
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for(let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            const n = c1.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(e) {
            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return this.clampPoint(e, c1).distanceTo(e);
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
    }
    const u1 = new Y, nv = new Y;
    class d3 {
        constructor(e = new Y, t = new Y){
            this.start = e, this.end = t;
        }
        set(e, t) {
            return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
            return e.addVectors(this.start, this.end).multiplyScalar(.5);
        }
        delta(e) {
            return e.subVectors(this.end, this.start);
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end);
        }
        distance() {
            return this.start.distanceTo(this.end);
        }
        at(e, t) {
            return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
            u1.subVectors(e, this.start), nv.subVectors(this.end, this.start);
            const n = nv.dot(nv);
            let a = nv.dot(u1) / n;
            return t && (a = Wt(a, 0, 1)), a;
        }
        closestPointToPoint(e, t, n) {
            const i = this.closestPointToPointParameter(e, t);
            return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
            return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const f1 = new Y;
    class p3 extends hn {
        constructor(e, t){
            super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
            const n = new Dt, i = [
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1,
                0,
                1,
                0,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                1,
                0,
                0,
                0,
                0,
                -1,
                1
            ];
            for(let l = 0, f = 1, d = 32; l < d; l++, f++){
                const p = l / d * Math.PI * 2, g = f / d * Math.PI * 2;
                i.push(Math.cos(p), Math.sin(p), 1, Math.cos(g), Math.sin(g), 1);
            }
            n.setAttribute("position", new nt(i, 3));
            const a = new Vi({
                fog: !1,
                toneMapped: !1
            });
            this.cone = new Ya(n, a), this.add(this.cone), this.update();
        }
        dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
            const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e), f1.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(f1), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        }
    }
    const Ic = new Y, iv = new pt, yx = new pt;
    class m3 extends Ya {
        constructor(e){
            const t = uA(e), n = new Dt, i = [], a = [], l = new tt(0, 0, 1), f = new tt(0, 1, 0);
            for(let p = 0; p < t.length; p++){
                const g = t[p];
                g.parent && g.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), a.push(l.r, l.g, l.b), a.push(f.r, f.g, f.b));
            }
            n.setAttribute("position", new nt(i, 3)), n.setAttribute("color", new nt(a, 3));
            const d = new Vi({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            });
            super(n, d), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        }
        updateMatrixWorld(e) {
            const t = this.bones, n = this.geometry, i = n.getAttribute("position");
            yx.copy(this.root.matrixWorld).invert();
            for(let a = 0, l = 0; a < t.length; a++){
                const f = t[a];
                f.parent && f.parent.isBone && (iv.multiplyMatrices(yx, f.matrixWorld), Ic.setFromMatrixPosition(iv), i.setXYZ(l, Ic.x, Ic.y, Ic.z), iv.multiplyMatrices(yx, f.parent.matrixWorld), Ic.setFromMatrixPosition(iv), i.setXYZ(l + 1, Ic.x, Ic.y, Ic.z), l += 2);
            }
            n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    function uA(r) {
        const e = [];
        r.isBone === !0 && e.push(r);
        for(let t = 0; t < r.children.length; t++)e.push(...uA(r.children[t]));
        return e;
    }
    class g3 extends ai {
        constructor(e, t, n){
            const i = new Nf(t, 4, 2), a = new ja({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
            super(i, a), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
        }
    }
    const v3 = new Y, h1 = new tt, d1 = new tt;
    class y3 extends hn {
        constructor(e, t, n){
            super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
            const i = new Vm(t);
            i.rotateY(Math.PI * .5), this.material = new ja({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            }), this.color === void 0 && (this.material.vertexColors = !0);
            const a = i.getAttribute("position"), l = new Float32Array(a.count * 3);
            i.setAttribute("color", new vn(l, 3)), this.add(new ai(i, this.material)), this.update();
        }
        dispose() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }
        update() {
            const e = this.children[0];
            if (this.color !== void 0) this.material.color.set(this.color);
            else {
                const t = e.geometry.getAttribute("color");
                h1.copy(this.light.color), d1.copy(this.light.groundColor);
                for(let n = 0, i = t.count; n < i; n++){
                    const a = n < i / 2 ? h1 : d1;
                    t.setXYZ(n, a.r, a.g, a.b);
                }
                t.needsUpdate = !0;
            }
            this.light.updateWorldMatrix(!0, !1), e.lookAt(v3.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
    }
    class _3 extends Ya {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848){
            n = new tt(n), i = new tt(i);
            const a = t / 2, l = e / t, f = e / 2, d = [], p = [];
            for(let _ = 0, x = 0, M = -f; _ <= t; _++, M += l){
                d.push(-f, 0, M, f, 0, M), d.push(M, 0, -f, M, 0, f);
                const R = _ === a ? n : i;
                R.toArray(p, x), x += 3, R.toArray(p, x), x += 3, R.toArray(p, x), x += 3, R.toArray(p, x), x += 3;
            }
            const g = new Dt;
            g.setAttribute("position", new nt(d, 3)), g.setAttribute("color", new nt(p, 3));
            const y = new Vi({
                vertexColors: !0,
                toneMapped: !1
            });
            super(g, y), this.type = "GridHelper";
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    class x3 extends Ya {
        constructor(e = 10, t = 16, n = 8, i = 64, a = 4473924, l = 8947848){
            a = new tt(a), l = new tt(l);
            const f = [], d = [];
            if (t > 1) for(let y = 0; y < t; y++){
                const _ = y / t * (Math.PI * 2), x = Math.sin(_) * e, M = Math.cos(_) * e;
                f.push(0, 0, 0), f.push(x, 0, M);
                const R = y & 1 ? a : l;
                d.push(R.r, R.g, R.b), d.push(R.r, R.g, R.b);
            }
            for(let y = 0; y < n; y++){
                const _ = y & 1 ? a : l, x = e - e / n * y;
                for(let M = 0; M < i; M++){
                    let R = M / i * (Math.PI * 2), T = Math.sin(R) * x, E = Math.cos(R) * x;
                    f.push(T, 0, E), d.push(_.r, _.g, _.b), R = (M + 1) / i * (Math.PI * 2), T = Math.sin(R) * x, E = Math.cos(R) * x, f.push(T, 0, E), d.push(_.r, _.g, _.b);
                }
            }
            const p = new Dt;
            p.setAttribute("position", new nt(f, 3)), p.setAttribute("color", new nt(d, 3));
            const g = new Vi({
                vertexColors: !0,
                toneMapped: !1
            });
            super(p, g), this.type = "PolarGridHelper";
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    const p1 = new Y, sv = new Y, m1 = new Y;
    class S3 extends hn {
        constructor(e, t, n){
            super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
            let i = new Dt;
            i.setAttribute("position", new nt([
                -t,
                t,
                0,
                t,
                t,
                0,
                t,
                -t,
                0,
                -t,
                -t,
                0,
                -t,
                t,
                0
            ], 3));
            const a = new Vi({
                fog: !1,
                toneMapped: !1
            });
            this.lightPlane = new Ko(i, a), this.add(this.lightPlane), i = new Dt, i.setAttribute("position", new nt([
                0,
                0,
                0,
                0,
                0,
                1
            ], 3)), this.targetLine = new Ko(i, a), this.add(this.targetLine), this.update();
        }
        dispose() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), p1.setFromMatrixPosition(this.light.matrixWorld), sv.setFromMatrixPosition(this.light.target.matrixWorld), m1.subVectors(sv, p1), this.lightPlane.lookAt(sv), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(sv), this.targetLine.scale.z = m1.length();
        }
    }
    const av = new Y, Mi = new Ay;
    class b3 extends Ya {
        constructor(e){
            const t = new Dt, n = new Vi({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }), i = [], a = [], l = {};
            f("n1", "n2"), f("n2", "n4"), f("n4", "n3"), f("n3", "n1"), f("f1", "f2"), f("f2", "f4"), f("f4", "f3"), f("f3", "f1"), f("n1", "f1"), f("n2", "f2"), f("n3", "f3"), f("n4", "f4"), f("p", "n1"), f("p", "n2"), f("p", "n3"), f("p", "n4"), f("u1", "u2"), f("u2", "u3"), f("u3", "u1"), f("c", "t"), f("p", "c"), f("cn1", "cn2"), f("cn3", "cn4"), f("cf1", "cf2"), f("cf3", "cf4");
            function f(M, R) {
                d(M), d(R);
            }
            function d(M) {
                i.push(0, 0, 0), a.push(0, 0, 0), l[M] === void 0 && (l[M] = []), l[M].push(i.length / 3 - 1);
            }
            t.setAttribute("position", new nt(i, 3)), t.setAttribute("color", new nt(a, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
            const p = new tt(16755200), g = new tt(16711680), y = new tt(43775), _ = new tt(16777215), x = new tt(3355443);
            this.setColors(p, g, y, _, x);
        }
        setColors(e, t, n, i, a) {
            const f = this.geometry.getAttribute("color");
            f.setXYZ(0, e.r, e.g, e.b), f.setXYZ(1, e.r, e.g, e.b), f.setXYZ(2, e.r, e.g, e.b), f.setXYZ(3, e.r, e.g, e.b), f.setXYZ(4, e.r, e.g, e.b), f.setXYZ(5, e.r, e.g, e.b), f.setXYZ(6, e.r, e.g, e.b), f.setXYZ(7, e.r, e.g, e.b), f.setXYZ(8, e.r, e.g, e.b), f.setXYZ(9, e.r, e.g, e.b), f.setXYZ(10, e.r, e.g, e.b), f.setXYZ(11, e.r, e.g, e.b), f.setXYZ(12, e.r, e.g, e.b), f.setXYZ(13, e.r, e.g, e.b), f.setXYZ(14, e.r, e.g, e.b), f.setXYZ(15, e.r, e.g, e.b), f.setXYZ(16, e.r, e.g, e.b), f.setXYZ(17, e.r, e.g, e.b), f.setXYZ(18, e.r, e.g, e.b), f.setXYZ(19, e.r, e.g, e.b), f.setXYZ(20, e.r, e.g, e.b), f.setXYZ(21, e.r, e.g, e.b), f.setXYZ(22, e.r, e.g, e.b), f.setXYZ(23, e.r, e.g, e.b), f.setXYZ(24, t.r, t.g, t.b), f.setXYZ(25, t.r, t.g, t.b), f.setXYZ(26, t.r, t.g, t.b), f.setXYZ(27, t.r, t.g, t.b), f.setXYZ(28, t.r, t.g, t.b), f.setXYZ(29, t.r, t.g, t.b), f.setXYZ(30, t.r, t.g, t.b), f.setXYZ(31, t.r, t.g, t.b), f.setXYZ(32, n.r, n.g, n.b), f.setXYZ(33, n.r, n.g, n.b), f.setXYZ(34, n.r, n.g, n.b), f.setXYZ(35, n.r, n.g, n.b), f.setXYZ(36, n.r, n.g, n.b), f.setXYZ(37, n.r, n.g, n.b), f.setXYZ(38, i.r, i.g, i.b), f.setXYZ(39, i.r, i.g, i.b), f.setXYZ(40, a.r, a.g, a.b), f.setXYZ(41, a.r, a.g, a.b), f.setXYZ(42, a.r, a.g, a.b), f.setXYZ(43, a.r, a.g, a.b), f.setXYZ(44, a.r, a.g, a.b), f.setXYZ(45, a.r, a.g, a.b), f.setXYZ(46, a.r, a.g, a.b), f.setXYZ(47, a.r, a.g, a.b), f.setXYZ(48, a.r, a.g, a.b), f.setXYZ(49, a.r, a.g, a.b), f.needsUpdate = !0;
        }
        update() {
            const e = this.geometry, t = this.pointMap, n = 1, i = 1;
            Mi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
            const a = this.camera.coordinateSystem === xr ? -1 : 0;
            Di("c", t, e, Mi, 0, 0, a), Di("t", t, e, Mi, 0, 0, 1), Di("n1", t, e, Mi, -n, -i, a), Di("n2", t, e, Mi, n, -i, a), Di("n3", t, e, Mi, -n, i, a), Di("n4", t, e, Mi, n, i, a), Di("f1", t, e, Mi, -n, -i, 1), Di("f2", t, e, Mi, n, -i, 1), Di("f3", t, e, Mi, -n, i, 1), Di("f4", t, e, Mi, n, i, 1), Di("u1", t, e, Mi, n * .7, i * 1.1, a), Di("u2", t, e, Mi, -n * .7, i * 1.1, a), Di("u3", t, e, Mi, 0, i * 2, a), Di("cf1", t, e, Mi, -n, 0, 1), Di("cf2", t, e, Mi, n, 0, 1), Di("cf3", t, e, Mi, 0, -i, 1), Di("cf4", t, e, Mi, 0, i, 1), Di("cn1", t, e, Mi, -n, 0, a), Di("cn2", t, e, Mi, n, 0, a), Di("cn3", t, e, Mi, 0, -i, a), Di("cn4", t, e, Mi, 0, i, a), e.getAttribute("position").needsUpdate = !0;
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    function Di(r, e, t, n, i, a, l) {
        av.set(i, a, l).unproject(n);
        const f = e[r];
        if (f !== void 0) {
            const d = t.getAttribute("position");
            for(let p = 0, g = f.length; p < g; p++)d.setXYZ(f[p], av.x, av.y, av.z);
        }
    }
    const rv = new Ui;
    class M3 extends Ya {
        constructor(e, t = 16776960){
            const n = new Uint16Array([
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                0,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                4,
                0,
                4,
                1,
                5,
                2,
                6,
                3,
                7
            ]), i = new Float32Array(24), a = new Dt;
            a.setIndex(new vn(n, 1)), a.setAttribute("position", new vn(i, 3)), super(a, new Vi({
                color: t,
                toneMapped: !1
            })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
        }
        update() {
            if (this.object !== void 0 && rv.setFromObject(this.object), rv.isEmpty()) return;
            const e = rv.min, t = rv.max, n = this.geometry.attributes.position, i = n.array;
            i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = e.x, i[4] = t.y, i[5] = t.z, i[6] = e.x, i[7] = e.y, i[8] = t.z, i[9] = t.x, i[10] = e.y, i[11] = t.z, i[12] = t.x, i[13] = t.y, i[14] = e.z, i[15] = e.x, i[16] = t.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = t.x, i[22] = e.y, i[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
        }
        setFromObject(e) {
            return this.object = e, this.update(), this;
        }
        copy(e, t) {
            return super.copy(e, t), this.object = e.object, this;
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    class E3 extends Ya {
        constructor(e, t = 16776960){
            const n = new Uint16Array([
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                0,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                4,
                0,
                4,
                1,
                5,
                2,
                6,
                3,
                7
            ]), i = [
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                -1
            ], a = new Dt;
            a.setIndex(new vn(n, 1)), a.setAttribute("position", new nt(i, 3)), super(a, new Vi({
                color: t,
                toneMapped: !1
            })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e) {
            const t = this.box;
            t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e));
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    class T3 extends Ko {
        constructor(e, t = 1, n = 16776960){
            const i = n, a = [
                1,
                -1,
                0,
                -1,
                1,
                0,
                -1,
                -1,
                0,
                1,
                1,
                0,
                -1,
                1,
                0,
                -1,
                -1,
                0,
                1,
                -1,
                0,
                1,
                1,
                0
            ], l = new Dt;
            l.setAttribute("position", new nt(a, 3)), l.computeBoundingSphere(), super(l, new Vi({
                color: i,
                toneMapped: !1
            })), this.type = "PlaneHelper", this.plane = e, this.size = t;
            const f = [
                1,
                1,
                0,
                -1,
                1,
                0,
                -1,
                -1,
                0,
                1,
                1,
                0,
                -1,
                -1,
                0,
                1,
                -1,
                0
            ], d = new Dt;
            d.setAttribute("position", new nt(f, 3)), d.computeBoundingSphere(), this.add(new ai(d, new ja({
                color: i,
                opacity: .2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1
            })));
        }
        updateMatrixWorld(e) {
            this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }
    }
    const g1 = new Y;
    let ov, _x;
    class A3 extends hn {
        constructor(e = new Y(0, 0, 1), t = new Y(0, 0, 0), n = 1, i = 16776960, a = n * .2, l = a * .2){
            super(), this.type = "ArrowHelper", ov === void 0 && (ov = new Dt, ov.setAttribute("position", new nt([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3)), _x = new Fm(.5, 1, 5, 1), _x.translate(0, -.5, 0)), this.position.copy(t), this.line = new Ko(ov, new Vi({
                color: i,
                toneMapped: !1
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ai(_x, new ja({
                color: i,
                toneMapped: !1
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, a, l);
        }
        setDirection(e) {
            if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
            else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
            else {
                g1.set(e.z, 0, -e.x).normalize();
                const t = Math.acos(e.y);
                this.quaternion.setFromAxisAngle(g1, t);
            }
        }
        setLength(e, t = e * .2, n = t * .2) {
            this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
        }
        setColor(e) {
            this.line.material.color.set(e), this.cone.material.color.set(e);
        }
        copy(e) {
            return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
        }
        dispose() {
            this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
        }
    }
    class w3 extends Ya {
        constructor(e = 1){
            const t = [
                0,
                0,
                0,
                e,
                0,
                0,
                0,
                0,
                0,
                0,
                e,
                0,
                0,
                0,
                0,
                0,
                0,
                e
            ], n = [
                1,
                0,
                0,
                1,
                .6,
                0,
                0,
                1,
                0,
                .6,
                1,
                0,
                0,
                0,
                1,
                0,
                .6,
                1
            ], i = new Dt;
            i.setAttribute("position", new nt(t, 3)), i.setAttribute("color", new nt(n, 3));
            const a = new Vi({
                vertexColors: !0,
                toneMapped: !1
            });
            super(i, a), this.type = "AxesHelper";
        }
        setColors(e, t, n) {
            const i = new tt, a = this.geometry.attributes.color.array;
            return i.set(e), i.toArray(a, 0), i.toArray(a, 3), i.set(t), i.toArray(a, 6), i.toArray(a, 9), i.set(n), i.toArray(a, 12), i.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this;
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    }
    class R3 {
        constructor(){
            this.type = "ShapePath", this.color = new tt, this.subPaths = [], this.currentPath = null;
        }
        moveTo(e, t) {
            return this.currentPath = new ry, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
        }
        lineTo(e, t) {
            return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
            return this.currentPath.quadraticCurveTo(e, t, n, i), this;
        }
        bezierCurveTo(e, t, n, i, a, l) {
            return this.currentPath.bezierCurveTo(e, t, n, i, a, l), this;
        }
        splineThru(e) {
            return this.currentPath.splineThru(e), this;
        }
        toShapes(e) {
            function t(E) {
                const C = [];
                for(let N = 0, D = E.length; N < D; N++){
                    const I = E[N], O = new Mf;
                    O.curves = I.curves, C.push(O);
                }
                return C;
            }
            function n(E, C) {
                const N = C.length;
                let D = !1;
                for(let I = N - 1, O = 0; O < N; I = O++){
                    let P = C[I], F = C[O], z = F.x - P.x, L = F.y - P.y;
                    if (Math.abs(L) > Number.EPSILON) {
                        if (L < 0 && (P = C[O], z = -z, F = C[I], L = -L), E.y < P.y || E.y > F.y) continue;
                        if (E.y === P.y) {
                            if (E.x === P.x) return !0;
                        } else {
                            const q = L * (E.x - P.x) - z * (E.y - P.y);
                            if (q === 0) return !0;
                            if (q < 0) continue;
                            D = !D;
                        }
                    } else {
                        if (E.y !== P.y) continue;
                        if (F.x <= E.x && E.x <= P.x || P.x <= E.x && E.x <= F.x) return !0;
                    }
                }
                return D;
            }
            const i = io.isClockWise, a = this.subPaths;
            if (a.length === 0) return [];
            let l, f, d;
            const p = [];
            if (a.length === 1) return f = a[0], d = new Mf, d.curves = f.curves, p.push(d), p;
            let g = !i(a[0].getPoints());
            g = e ? !g : g;
            const y = [], _ = [];
            let x = [], M = 0, R;
            _[M] = void 0, x[M] = [];
            for(let E = 0, C = a.length; E < C; E++)f = a[E], R = f.getPoints(), l = i(R), l = e ? !l : l, l ? (!g && _[M] && M++, _[M] = {
                s: new Mf,
                p: R
            }, _[M].s.curves = f.curves, g && M++, x[M] = []) : x[M].push({
                h: f,
                p: R[0]
            });
            if (!_[0]) return t(a);
            if (_.length > 1) {
                let E = !1, C = 0;
                for(let N = 0, D = _.length; N < D; N++)y[N] = [];
                for(let N = 0, D = _.length; N < D; N++){
                    const I = x[N];
                    for(let O = 0; O < I.length; O++){
                        const P = I[O];
                        let F = !0;
                        for(let z = 0; z < _.length; z++)n(P.p, _[z].p) && (N !== z && C++, F ? (F = !1, y[z].push(P)) : E = !0);
                        F && y[N].push(P);
                    }
                }
                C > 0 && E === !1 && (x = y);
            }
            let T;
            for(let E = 0, C = _.length; E < C; E++){
                d = _[E].s, p.push(d), T = x[E];
                for(let N = 0, D = T.length; N < D; N++)d.holes.push(T[N].h);
            }
            return p;
        }
    }
    class C3 extends Qo {
        constructor(e, t = null){
            super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
                LEFT: null,
                MIDDLE: null,
                RIGHT: null
            }, this.touches = {
                ONE: null,
                TWO: null
            };
        }
        connect(e) {
            if (e === void 0) {
                console.warn("THREE.Controls: connect() now requires an element.");
                return;
            }
            this.domElement !== null && this.disconnect(), this.domElement = e;
        }
        disconnect() {}
        dispose() {}
        update() {}
    }
    function D3(r, e) {
        const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
        return t > e ? (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2) : (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0), r;
    }
    function N3(r, e) {
        const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
        return t > e ? (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0) : (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2), r;
    }
    function U3(r) {
        return r.repeat.x = 1, r.repeat.y = 1, r.offset.x = 0, r.offset.y = 0, r;
    }
    function uS(r, e, t, n) {
        const i = L3(n);
        switch(t){
            case wS:
                return r * e;
            case _y:
                return r * e / i.components * i.byteLength;
            case Im:
                return r * e / i.components * i.byteLength;
            case CS:
                return r * e * 2 / i.components * i.byteLength;
            case xy:
                return r * e * 2 / i.components * i.byteLength;
            case RS:
                return r * e * 3 / i.components * i.byteLength;
            case Is:
                return r * e * 4 / i.components * i.byteLength;
            case Sy:
                return r * e * 4 / i.components * i.byteLength;
            case dm:
            case pm:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case mm:
            case gm:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Nv:
            case Lv:
                return Math.max(r, 16) * Math.max(e, 8) / 4;
            case Dv:
            case Uv:
                return Math.max(r, 8) * Math.max(e, 8) / 2;
            case Ov:
            case zv:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
            case Bv:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Iv:
                return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
            case Pv:
                return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
            case Hv:
                return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
            case Fv:
                return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
            case Gv:
                return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
            case Vv:
                return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
            case kv:
                return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
            case Xv:
                return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
            case jv:
                return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
            case qv:
                return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
            case Yv:
                return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
            case Wv:
                return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
            case Zv:
                return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
            case Kv:
                return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
            case vm:
            case Qv:
            case Jv:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
            case DS:
            case $v:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
            case ey:
            case ty:
                return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
    }
    function L3(r) {
        switch(r){
            case br:
            case ES:
                return {
                    byteLength: 1,
                    components: 1
                };
            case pd:
            case TS:
            case Cf:
                return {
                    byteLength: 2,
                    components: 1
                };
            case vy:
            case yy:
                return {
                    byteLength: 2,
                    components: 4
                };
            case Il:
            case gy:
            case ia:
                return {
                    byteLength: 4,
                    components: 1
                };
            case AS:
                return {
                    byteLength: 4,
                    components: 3
                };
        }
        throw new Error(`Unknown texture type ${r}.`);
    }
    class O3 {
        static contain(e, t) {
            return D3(e, t);
        }
        static cover(e, t) {
            return N3(e, t);
        }
        static fill(e) {
            return U3(e);
        }
        static getByteLength(e, t, n, i) {
            return uS(e, t, n, i);
        }
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: zm
        }
    }));
    typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = zm);
    function fA() {
        let r = null, e = !1, t = null, n = null;
        function i(a, l) {
            t(a, l), n = r.requestAnimationFrame(i);
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0);
            },
            stop: function() {
                r.cancelAnimationFrame(n), e = !1;
            },
            setAnimationLoop: function(a) {
                t = a;
            },
            setContext: function(a) {
                r = a;
            }
        };
    }
    function z3(r) {
        const e = new WeakMap;
        function t(f, d) {
            const p = f.array, g = f.usage, y = p.byteLength, _ = r.createBuffer();
            r.bindBuffer(d, _), r.bufferData(d, p, g), f.onUploadCallback();
            let x;
            if (p instanceof Float32Array) x = r.FLOAT;
            else if (typeof Float16Array < "u" && p instanceof Float16Array) x = r.HALF_FLOAT;
            else if (p instanceof Uint16Array) f.isFloat16BufferAttribute ? x = r.HALF_FLOAT : x = r.UNSIGNED_SHORT;
            else if (p instanceof Int16Array) x = r.SHORT;
            else if (p instanceof Uint32Array) x = r.UNSIGNED_INT;
            else if (p instanceof Int32Array) x = r.INT;
            else if (p instanceof Int8Array) x = r.BYTE;
            else if (p instanceof Uint8Array) x = r.UNSIGNED_BYTE;
            else if (p instanceof Uint8ClampedArray) x = r.UNSIGNED_BYTE;
            else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + p);
            return {
                buffer: _,
                type: x,
                bytesPerElement: p.BYTES_PER_ELEMENT,
                version: f.version,
                size: y
            };
        }
        function n(f, d, p) {
            const g = d.array, y = d.updateRanges;
            if (r.bindBuffer(p, f), y.length === 0) r.bufferSubData(p, 0, g);
            else {
                y.sort((x, M)=>x.start - M.start);
                let _ = 0;
                for(let x = 1; x < y.length; x++){
                    const M = y[_], R = y[x];
                    R.start <= M.start + M.count + 1 ? M.count = Math.max(M.count, R.start + R.count - M.start) : (++_, y[_] = R);
                }
                y.length = _ + 1;
                for(let x = 0, M = y.length; x < M; x++){
                    const R = y[x];
                    r.bufferSubData(p, R.start * g.BYTES_PER_ELEMENT, g, R.start, R.count);
                }
                d.clearUpdateRanges();
            }
            d.onUploadCallback();
        }
        function i(f) {
            return f.isInterleavedBufferAttribute && (f = f.data), e.get(f);
        }
        function a(f) {
            f.isInterleavedBufferAttribute && (f = f.data);
            const d = e.get(f);
            d && (r.deleteBuffer(d.buffer), e.delete(f));
        }
        function l(f, d) {
            if (f.isInterleavedBufferAttribute && (f = f.data), f.isGLBufferAttribute) {
                const g = e.get(f);
                (!g || g.version < f.version) && e.set(f, {
                    buffer: f.buffer,
                    type: f.type,
                    bytesPerElement: f.elementSize,
                    version: f.version
                });
                return;
            }
            const p = e.get(f);
            if (p === void 0) e.set(f, t(f, d));
            else if (p.version < f.version) {
                if (p.size !== f.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                n(p.buffer, f, d), p.version = f.version;
            }
        }
        return {
            get: i,
            remove: a,
            update: l
        };
    }
    var B3 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, I3 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, P3 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, H3 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, F3 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, G3 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, V3 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, k3 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, X3 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, j3 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, q3 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Y3 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, W3 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Z3 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, K3 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Q3 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, J3 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, $3 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, eD = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, tD = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, nD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, iD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, sD = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, aD = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, rD = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, oD = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, lD = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, cD = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, uD = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, fD = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, hD = "gl_FragColor = linearToOutputTexel( gl_FragColor );", dD = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, pD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, mD = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, gD = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, vD = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, yD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, _D = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, xD = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, SD = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, bD = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, MD = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, ED = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, TD = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, AD = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, wD = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, RD = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, CD = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, DD = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ND = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, UD = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, LD = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, OD = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, zD = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, BD = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, ID = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, PD = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, HD = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, FD = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, GD = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, VD = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, kD = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, XD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, jD = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, qD = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, YD = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, WD = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, ZD = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, KD = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, QD = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, JD = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, $D = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, eN = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, tN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, iN = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, sN = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, aN = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, rN = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, oN = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, lN = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cN = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, uN = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, fN = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, hN = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dN = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, pN = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, mN = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, gN = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, vN = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, yN = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, _N = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, xN = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, SN = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, bN = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, MN = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, EN = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, TN = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, AN = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, wN = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, RN = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, CN = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, DN = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, NN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, UN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, LN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, ON = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const zN = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, BN = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, IN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, PN = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, HN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, FN = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, GN = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, VN = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, kN = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, XN = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, jN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, qN = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, YN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, WN = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, ZN = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, KN = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QN = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JN = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, $N = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, eU = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, tU = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, nU = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, iU = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sU = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, aU = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, rU = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, oU = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, lU = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, cU = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, uU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, fU = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hU = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, dU = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, pU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, sn = {
        alphahash_fragment: B3,
        alphahash_pars_fragment: I3,
        alphamap_fragment: P3,
        alphamap_pars_fragment: H3,
        alphatest_fragment: F3,
        alphatest_pars_fragment: G3,
        aomap_fragment: V3,
        aomap_pars_fragment: k3,
        batching_pars_vertex: X3,
        batching_vertex: j3,
        begin_vertex: q3,
        beginnormal_vertex: Y3,
        bsdfs: W3,
        iridescence_fragment: Z3,
        bumpmap_pars_fragment: K3,
        clipping_planes_fragment: Q3,
        clipping_planes_pars_fragment: J3,
        clipping_planes_pars_vertex: $3,
        clipping_planes_vertex: eD,
        color_fragment: tD,
        color_pars_fragment: nD,
        color_pars_vertex: iD,
        color_vertex: sD,
        common: aD,
        cube_uv_reflection_fragment: rD,
        defaultnormal_vertex: oD,
        displacementmap_pars_vertex: lD,
        displacementmap_vertex: cD,
        emissivemap_fragment: uD,
        emissivemap_pars_fragment: fD,
        colorspace_fragment: hD,
        colorspace_pars_fragment: dD,
        envmap_fragment: pD,
        envmap_common_pars_fragment: mD,
        envmap_pars_fragment: gD,
        envmap_pars_vertex: vD,
        envmap_physical_pars_fragment: RD,
        envmap_vertex: yD,
        fog_vertex: _D,
        fog_pars_vertex: xD,
        fog_fragment: SD,
        fog_pars_fragment: bD,
        gradientmap_pars_fragment: MD,
        lightmap_pars_fragment: ED,
        lights_lambert_fragment: TD,
        lights_lambert_pars_fragment: AD,
        lights_pars_begin: wD,
        lights_toon_fragment: CD,
        lights_toon_pars_fragment: DD,
        lights_phong_fragment: ND,
        lights_phong_pars_fragment: UD,
        lights_physical_fragment: LD,
        lights_physical_pars_fragment: OD,
        lights_fragment_begin: zD,
        lights_fragment_maps: BD,
        lights_fragment_end: ID,
        logdepthbuf_fragment: PD,
        logdepthbuf_pars_fragment: HD,
        logdepthbuf_pars_vertex: FD,
        logdepthbuf_vertex: GD,
        map_fragment: VD,
        map_pars_fragment: kD,
        map_particle_fragment: XD,
        map_particle_pars_fragment: jD,
        metalnessmap_fragment: qD,
        metalnessmap_pars_fragment: YD,
        morphinstance_vertex: WD,
        morphcolor_vertex: ZD,
        morphnormal_vertex: KD,
        morphtarget_pars_vertex: QD,
        morphtarget_vertex: JD,
        normal_fragment_begin: $D,
        normal_fragment_maps: eN,
        normal_pars_fragment: tN,
        normal_pars_vertex: nN,
        normal_vertex: iN,
        normalmap_pars_fragment: sN,
        clearcoat_normal_fragment_begin: aN,
        clearcoat_normal_fragment_maps: rN,
        clearcoat_pars_fragment: oN,
        iridescence_pars_fragment: lN,
        opaque_fragment: cN,
        packing: uN,
        premultiplied_alpha_fragment: fN,
        project_vertex: hN,
        dithering_fragment: dN,
        dithering_pars_fragment: pN,
        roughnessmap_fragment: mN,
        roughnessmap_pars_fragment: gN,
        shadowmap_pars_fragment: vN,
        shadowmap_pars_vertex: yN,
        shadowmap_vertex: _N,
        shadowmask_pars_fragment: xN,
        skinbase_vertex: SN,
        skinning_pars_vertex: bN,
        skinning_vertex: MN,
        skinnormal_vertex: EN,
        specularmap_fragment: TN,
        specularmap_pars_fragment: AN,
        tonemapping_fragment: wN,
        tonemapping_pars_fragment: RN,
        transmission_fragment: CN,
        transmission_pars_fragment: DN,
        uv_pars_fragment: NN,
        uv_pars_vertex: UN,
        uv_vertex: LN,
        worldpos_vertex: ON,
        background_vert: zN,
        background_frag: BN,
        backgroundCube_vert: IN,
        backgroundCube_frag: PN,
        cube_vert: HN,
        cube_frag: FN,
        depth_vert: GN,
        depth_frag: VN,
        distanceRGBA_vert: kN,
        distanceRGBA_frag: XN,
        equirect_vert: jN,
        equirect_frag: qN,
        linedashed_vert: YN,
        linedashed_frag: WN,
        meshbasic_vert: ZN,
        meshbasic_frag: KN,
        meshlambert_vert: QN,
        meshlambert_frag: JN,
        meshmatcap_vert: $N,
        meshmatcap_frag: eU,
        meshnormal_vert: tU,
        meshnormal_frag: nU,
        meshphong_vert: iU,
        meshphong_frag: sU,
        meshphysical_vert: aU,
        meshphysical_frag: rU,
        meshtoon_vert: oU,
        meshtoon_frag: lU,
        points_vert: cU,
        points_frag: uU,
        shadow_vert: fU,
        shadow_frag: hU,
        sprite_vert: dU,
        sprite_frag: pU
    }, ht = {
        common: {
            diffuse: {
                value: new tt(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Yt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Yt
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new Yt
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new Yt
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new Yt
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new Yt
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new Yt
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new Yt
            },
            normalScale: {
                value: new Ie(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new Yt
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new Yt
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new Yt
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new Yt
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new tt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new tt(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Yt
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Yt
            }
        },
        sprite: {
            diffuse: {
                value: new tt(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ie(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new Yt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new Yt
            },
            alphaTest: {
                value: 0
            }
        }
    }, no = {
        basic: {
            uniforms: ea([
                ht.common,
                ht.specularmap,
                ht.envmap,
                ht.aomap,
                ht.lightmap,
                ht.fog
            ]),
            vertexShader: sn.meshbasic_vert,
            fragmentShader: sn.meshbasic_frag
        },
        lambert: {
            uniforms: ea([
                ht.common,
                ht.specularmap,
                ht.envmap,
                ht.aomap,
                ht.lightmap,
                ht.emissivemap,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                ht.fog,
                ht.lights,
                {
                    emissive: {
                        value: new tt(0)
                    }
                }
            ]),
            vertexShader: sn.meshlambert_vert,
            fragmentShader: sn.meshlambert_frag
        },
        phong: {
            uniforms: ea([
                ht.common,
                ht.specularmap,
                ht.envmap,
                ht.aomap,
                ht.lightmap,
                ht.emissivemap,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                ht.fog,
                ht.lights,
                {
                    emissive: {
                        value: new tt(0)
                    },
                    specular: {
                        value: new tt(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }
            ]),
            vertexShader: sn.meshphong_vert,
            fragmentShader: sn.meshphong_frag
        },
        standard: {
            uniforms: ea([
                ht.common,
                ht.envmap,
                ht.aomap,
                ht.lightmap,
                ht.emissivemap,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                ht.roughnessmap,
                ht.metalnessmap,
                ht.fog,
                ht.lights,
                {
                    emissive: {
                        value: new tt(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: sn.meshphysical_vert,
            fragmentShader: sn.meshphysical_frag
        },
        toon: {
            uniforms: ea([
                ht.common,
                ht.aomap,
                ht.lightmap,
                ht.emissivemap,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                ht.gradientmap,
                ht.fog,
                ht.lights,
                {
                    emissive: {
                        value: new tt(0)
                    }
                }
            ]),
            vertexShader: sn.meshtoon_vert,
            fragmentShader: sn.meshtoon_frag
        },
        matcap: {
            uniforms: ea([
                ht.common,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                ht.fog,
                {
                    matcap: {
                        value: null
                    }
                }
            ]),
            vertexShader: sn.meshmatcap_vert,
            fragmentShader: sn.meshmatcap_frag
        },
        points: {
            uniforms: ea([
                ht.points,
                ht.fog
            ]),
            vertexShader: sn.points_vert,
            fragmentShader: sn.points_frag
        },
        dashed: {
            uniforms: ea([
                ht.common,
                ht.fog,
                {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }
            ]),
            vertexShader: sn.linedashed_vert,
            fragmentShader: sn.linedashed_frag
        },
        depth: {
            uniforms: ea([
                ht.common,
                ht.displacementmap
            ]),
            vertexShader: sn.depth_vert,
            fragmentShader: sn.depth_frag
        },
        normal: {
            uniforms: ea([
                ht.common,
                ht.bumpmap,
                ht.normalmap,
                ht.displacementmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: sn.meshnormal_vert,
            fragmentShader: sn.meshnormal_frag
        },
        sprite: {
            uniforms: ea([
                ht.sprite,
                ht.fog
            ]),
            vertexShader: sn.sprite_vert,
            fragmentShader: sn.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Yt
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: sn.background_vert,
            fragmentShader: sn.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new Yt
                }
            },
            vertexShader: sn.backgroundCube_vert,
            fragmentShader: sn.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: sn.cube_vert,
            fragmentShader: sn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: sn.equirect_vert,
            fragmentShader: sn.equirect_frag
        },
        distanceRGBA: {
            uniforms: ea([
                ht.common,
                ht.displacementmap,
                {
                    referencePosition: {
                        value: new Y
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }
            ]),
            vertexShader: sn.distanceRGBA_vert,
            fragmentShader: sn.distanceRGBA_frag
        },
        shadow: {
            uniforms: ea([
                ht.lights,
                ht.fog,
                {
                    color: {
                        value: new tt(0)
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: sn.shadow_vert,
            fragmentShader: sn.shadow_frag
        }
    };
    no.physical = {
        uniforms: ea([
            no.standard.uniforms,
            {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Yt
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Yt
                },
                clearcoatNormalScale: {
                    value: new Ie(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Yt
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Yt
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Yt
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new tt(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Yt
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Yt
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Yt
                },
                transmissionSamplerSize: {
                    value: new Ie
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Yt
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new tt(0)
                },
                specularColor: {
                    value: new tt(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Yt
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Yt
                },
                anisotropyVector: {
                    value: new Ie
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Yt
                }
            }
        ]),
        vertexShader: sn.meshphysical_vert,
        fragmentShader: sn.meshphysical_frag
    };
    const lv = {
        r: 0,
        b: 0,
        g: 0
    }, of = new $i, mU = new pt;
    function gU(r, e, t, n, i, a, l) {
        const f = new tt(0);
        let d = a === !0 ? 0 : 1, p, g, y = null, _ = 0, x = null;
        function M(N) {
            let D = N.isScene === !0 ? N.background : null;
            return D && D.isTexture && (D = (N.backgroundBlurriness > 0 ? t : e).get(D)), D;
        }
        function R(N) {
            let D = !1;
            const I = M(N);
            I === null ? E(f, d) : I && I.isColor && (E(I, 1), D = !0);
            const O = r.xr.getEnvironmentBlendMode();
            O === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, l) : O === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l), (r.autoClear || D) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
        }
        function T(N, D) {
            const I = M(D);
            I && (I.isCubeTexture || I.mapping === wd) ? (g === void 0 && (g = new ai(new $c(1, 1, 1), new ao({
                name: "BackgroundCubeMaterial",
                uniforms: bd(no.backgroundCube.uniforms),
                vertexShader: no.backgroundCube.vertexShader,
                fragmentShader: no.backgroundCube.fragmentShader,
                side: sa,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), g.geometry.deleteAttribute("normal"), g.geometry.deleteAttribute("uv"), g.onBeforeRender = function(O, P, F) {
                this.matrixWorld.copyPosition(F.matrixWorld);
            }, Object.defineProperty(g.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value;
                }
            }), i.update(g)), of.copy(D.backgroundRotation), of.x *= -1, of.y *= -1, of.z *= -1, I.isCubeTexture && I.isRenderTargetTexture === !1 && (of.y *= -1, of.z *= -1), g.material.uniforms.envMap.value = I, g.material.uniforms.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1, g.material.uniforms.backgroundBlurriness.value = D.backgroundBlurriness, g.material.uniforms.backgroundIntensity.value = D.backgroundIntensity, g.material.uniforms.backgroundRotation.value.setFromMatrix4(mU.makeRotationFromEuler(of)), g.material.toneMapped = Sn.getTransfer(I.colorSpace) !== Fn, (y !== I || _ !== I.version || x !== r.toneMapping) && (g.material.needsUpdate = !0, y = I, _ = I.version, x = r.toneMapping), g.layers.enableAll(), N.unshift(g, g.geometry, g.material, 0, 0, null)) : I && I.isTexture && (p === void 0 && (p = new ai(new Nd(2, 2), new ao({
                name: "BackgroundMaterial",
                uniforms: bd(no.background.uniforms),
                vertexShader: no.background.vertexShader,
                fragmentShader: no.background.fragmentShader,
                side: Wo,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), p.geometry.deleteAttribute("normal"), Object.defineProperty(p.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value;
                }
            }), i.update(p)), p.material.uniforms.t2D.value = I, p.material.uniforms.backgroundIntensity.value = D.backgroundIntensity, p.material.toneMapped = Sn.getTransfer(I.colorSpace) !== Fn, I.matrixAutoUpdate === !0 && I.updateMatrix(), p.material.uniforms.uvTransform.value.copy(I.matrix), (y !== I || _ !== I.version || x !== r.toneMapping) && (p.material.needsUpdate = !0, y = I, _ = I.version, x = r.toneMapping), p.layers.enableAll(), N.unshift(p, p.geometry, p.material, 0, 0, null));
        }
        function E(N, D) {
            N.getRGB(lv, _T(r)), n.buffers.color.setClear(lv.r, lv.g, lv.b, D, l);
        }
        function C() {
            g !== void 0 && (g.geometry.dispose(), g.material.dispose(), g = void 0), p !== void 0 && (p.geometry.dispose(), p.material.dispose(), p = void 0);
        }
        return {
            getClearColor: function() {
                return f;
            },
            setClearColor: function(N, D = 1) {
                f.set(N), d = D, E(f, d);
            },
            getClearAlpha: function() {
                return d;
            },
            setClearAlpha: function(N) {
                d = N, E(f, d);
            },
            render: R,
            addToRenderList: T,
            dispose: C
        };
    }
    function vU(r, e) {
        const t = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, i = _(null);
        let a = i, l = !1;
        function f(L, q, oe, se, ge) {
            let _e = !1;
            const H = y(se, oe, q);
            a !== H && (a = H, p(a.object)), _e = x(L, se, oe, ge), _e && M(L, se, oe, ge), ge !== null && e.update(ge, r.ELEMENT_ARRAY_BUFFER), (_e || l) && (l = !1, D(L, q, oe, se), ge !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(ge).buffer));
        }
        function d() {
            return r.createVertexArray();
        }
        function p(L) {
            return r.bindVertexArray(L);
        }
        function g(L) {
            return r.deleteVertexArray(L);
        }
        function y(L, q, oe) {
            const se = oe.wireframe === !0;
            let ge = n[L.id];
            ge === void 0 && (ge = {}, n[L.id] = ge);
            let _e = ge[q.id];
            _e === void 0 && (_e = {}, ge[q.id] = _e);
            let H = _e[se];
            return H === void 0 && (H = _(d()), _e[se] = H), H;
        }
        function _(L) {
            const q = [], oe = [], se = [];
            for(let ge = 0; ge < t; ge++)q[ge] = 0, oe[ge] = 0, se[ge] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: q,
                enabledAttributes: oe,
                attributeDivisors: se,
                object: L,
                attributes: {},
                index: null
            };
        }
        function x(L, q, oe, se) {
            const ge = a.attributes, _e = q.attributes;
            let H = 0;
            const K = oe.getAttributes();
            for(const Q in K)if (K[Q].location >= 0) {
                const X = ge[Q];
                let $ = _e[Q];
                if ($ === void 0 && (Q === "instanceMatrix" && L.instanceMatrix && ($ = L.instanceMatrix), Q === "instanceColor" && L.instanceColor && ($ = L.instanceColor)), X === void 0 || X.attribute !== $ || $ && X.data !== $.data) return !0;
                H++;
            }
            return a.attributesNum !== H || a.index !== se;
        }
        function M(L, q, oe, se) {
            const ge = {}, _e = q.attributes;
            let H = 0;
            const K = oe.getAttributes();
            for(const Q in K)if (K[Q].location >= 0) {
                let X = _e[Q];
                X === void 0 && (Q === "instanceMatrix" && L.instanceMatrix && (X = L.instanceMatrix), Q === "instanceColor" && L.instanceColor && (X = L.instanceColor));
                const $ = {};
                $.attribute = X, X && X.data && ($.data = X.data), ge[Q] = $, H++;
            }
            a.attributes = ge, a.attributesNum = H, a.index = se;
        }
        function R() {
            const L = a.newAttributes;
            for(let q = 0, oe = L.length; q < oe; q++)L[q] = 0;
        }
        function T(L) {
            E(L, 0);
        }
        function E(L, q) {
            const oe = a.newAttributes, se = a.enabledAttributes, ge = a.attributeDivisors;
            oe[L] = 1, se[L] === 0 && (r.enableVertexAttribArray(L), se[L] = 1), ge[L] !== q && (r.vertexAttribDivisor(L, q), ge[L] = q);
        }
        function C() {
            const L = a.newAttributes, q = a.enabledAttributes;
            for(let oe = 0, se = q.length; oe < se; oe++)q[oe] !== L[oe] && (r.disableVertexAttribArray(oe), q[oe] = 0);
        }
        function N(L, q, oe, se, ge, _e, H) {
            H === !0 ? r.vertexAttribIPointer(L, q, oe, ge, _e) : r.vertexAttribPointer(L, q, oe, se, ge, _e);
        }
        function D(L, q, oe, se) {
            R();
            const ge = se.attributes, _e = oe.getAttributes(), H = q.defaultAttributeValues;
            for(const K in _e){
                const Q = _e[K];
                if (Q.location >= 0) {
                    let fe = ge[K];
                    if (fe === void 0 && (K === "instanceMatrix" && L.instanceMatrix && (fe = L.instanceMatrix), K === "instanceColor" && L.instanceColor && (fe = L.instanceColor)), fe !== void 0) {
                        const X = fe.normalized, $ = fe.itemSize, me = e.get(fe);
                        if (me === void 0) continue;
                        const ve = me.buffer, J = me.type, ue = me.bytesPerElement, he = J === r.INT || J === r.UNSIGNED_INT || fe.gpuType === gy;
                        if (fe.isInterleavedBufferAttribute) {
                            const De = fe.data, Pe = De.stride, _t = fe.offset;
                            if (De.isInstancedInterleavedBuffer) {
                                for(let xt = 0; xt < Q.locationSize; xt++)E(Q.location + xt, De.meshPerAttribute);
                                L.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = De.meshPerAttribute * De.count);
                            } else for(let xt = 0; xt < Q.locationSize; xt++)T(Q.location + xt);
                            r.bindBuffer(r.ARRAY_BUFFER, ve);
                            for(let xt = 0; xt < Q.locationSize; xt++)N(Q.location + xt, $ / Q.locationSize, J, X, Pe * ue, (_t + $ / Q.locationSize * xt) * ue, he);
                        } else {
                            if (fe.isInstancedBufferAttribute) {
                                for(let De = 0; De < Q.locationSize; De++)E(Q.location + De, fe.meshPerAttribute);
                                L.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = fe.meshPerAttribute * fe.count);
                            } else for(let De = 0; De < Q.locationSize; De++)T(Q.location + De);
                            r.bindBuffer(r.ARRAY_BUFFER, ve);
                            for(let De = 0; De < Q.locationSize; De++)N(Q.location + De, $ / Q.locationSize, J, X, $ * ue, $ / Q.locationSize * De * ue, he);
                        }
                    } else if (H !== void 0) {
                        const X = H[K];
                        if (X !== void 0) switch(X.length){
                            case 2:
                                r.vertexAttrib2fv(Q.location, X);
                                break;
                            case 3:
                                r.vertexAttrib3fv(Q.location, X);
                                break;
                            case 4:
                                r.vertexAttrib4fv(Q.location, X);
                                break;
                            default:
                                r.vertexAttrib1fv(Q.location, X);
                        }
                    }
                }
            }
            C();
        }
        function I() {
            F();
            for(const L in n){
                const q = n[L];
                for(const oe in q){
                    const se = q[oe];
                    for(const ge in se)g(se[ge].object), delete se[ge];
                    delete q[oe];
                }
                delete n[L];
            }
        }
        function O(L) {
            if (n[L.id] === void 0) return;
            const q = n[L.id];
            for(const oe in q){
                const se = q[oe];
                for(const ge in se)g(se[ge].object), delete se[ge];
                delete q[oe];
            }
            delete n[L.id];
        }
        function P(L) {
            for(const q in n){
                const oe = n[q];
                if (oe[L.id] === void 0) continue;
                const se = oe[L.id];
                for(const ge in se)g(se[ge].object), delete se[ge];
                delete oe[L.id];
            }
        }
        function F() {
            z(), l = !0, a !== i && (a = i, p(a.object));
        }
        function z() {
            i.geometry = null, i.program = null, i.wireframe = !1;
        }
        return {
            setup: f,
            reset: F,
            resetDefaultState: z,
            dispose: I,
            releaseStatesOfGeometry: O,
            releaseStatesOfProgram: P,
            initAttributes: R,
            enableAttribute: T,
            disableUnusedAttributes: C
        };
    }
    function yU(r, e, t) {
        let n;
        function i(p) {
            n = p;
        }
        function a(p, g) {
            r.drawArrays(n, p, g), t.update(g, n, 1);
        }
        function l(p, g, y) {
            y !== 0 && (r.drawArraysInstanced(n, p, g, y), t.update(g, n, y));
        }
        function f(p, g, y) {
            if (y === 0) return;
            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, p, 0, g, 0, y);
            let x = 0;
            for(let M = 0; M < y; M++)x += g[M];
            t.update(x, n, 1);
        }
        function d(p, g, y, _) {
            if (y === 0) return;
            const x = e.get("WEBGL_multi_draw");
            if (x === null) for(let M = 0; M < p.length; M++)l(p[M], g[M], _[M]);
            else {
                x.multiDrawArraysInstancedWEBGL(n, p, 0, g, 0, _, 0, y);
                let M = 0;
                for(let R = 0; R < y; R++)M += g[R] * _[R];
                t.update(M, n, 1);
            }
        }
        this.setMode = i, this.render = a, this.renderInstances = l, this.renderMultiDraw = f, this.renderMultiDrawInstances = d;
    }
    function _U(r, e, t, n) {
        let i;
        function a() {
            if (i !== void 0) return i;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                const P = e.get("EXT_texture_filter_anisotropic");
                i = r.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
        }
        function l(P) {
            return !(P !== Is && n.convert(P) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function f(P) {
            const F = P === Cf && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(P !== br && n.convert(P) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && P !== ia && !F);
        }
        function d(P) {
            if (P === "highp") {
                if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
                P = "mediump";
            }
            return P === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let p = t.precision !== void 0 ? t.precision : "highp";
        const g = d(p);
        g !== p && (console.warn("THREE.WebGLRenderer:", p, "not supported, using", g, "instead."), p = g);
        const y = t.logarithmicDepthBuffer === !0, _ = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), x = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), M = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), R = r.getParameter(r.MAX_TEXTURE_SIZE), T = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), E = r.getParameter(r.MAX_VERTEX_ATTRIBS), C = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), N = r.getParameter(r.MAX_VARYING_VECTORS), D = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), I = M > 0, O = r.getParameter(r.MAX_SAMPLES);
        return {
            isWebGL2: !0,
            getMaxAnisotropy: a,
            getMaxPrecision: d,
            textureFormatReadable: l,
            textureTypeReadable: f,
            precision: p,
            logarithmicDepthBuffer: y,
            reverseDepthBuffer: _,
            maxTextures: x,
            maxVertexTextures: M,
            maxTextureSize: R,
            maxCubemapSize: T,
            maxAttributes: E,
            maxVertexUniforms: C,
            maxVaryings: N,
            maxFragmentUniforms: D,
            vertexTextures: I,
            maxSamples: O
        };
    }
    function xU(r) {
        const e = this;
        let t = null, n = 0, i = !1, a = !1;
        const l = new Cl, f = new Yt, d = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = d, this.numPlanes = 0, this.numIntersection = 0, this.init = function(y, _) {
            const x = y.length !== 0 || _ || n !== 0 || i;
            return i = _, n = y.length, x;
        }, this.beginShadows = function() {
            a = !0, g(null);
        }, this.endShadows = function() {
            a = !1;
        }, this.setGlobalState = function(y, _) {
            t = g(y, _, 0);
        }, this.setState = function(y, _, x) {
            const M = y.clippingPlanes, R = y.clipIntersection, T = y.clipShadows, E = r.get(y);
            if (!i || M === null || M.length === 0 || a && !T) a ? g(null) : p();
            else {
                const C = a ? 0 : n, N = C * 4;
                let D = E.clippingState || null;
                d.value = D, D = g(M, _, N, x);
                for(let I = 0; I !== N; ++I)D[I] = t[I];
                E.clippingState = D, this.numIntersection = R ? this.numPlanes : 0, this.numPlanes += C;
            }
        };
        function p() {
            d.value !== t && (d.value = t, d.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
        }
        function g(y, _, x, M) {
            const R = y !== null ? y.length : 0;
            let T = null;
            if (R !== 0) {
                if (T = d.value, M !== !0 || T === null) {
                    const E = x + R * 4, C = _.matrixWorldInverse;
                    f.getNormalMatrix(C), (T === null || T.length < E) && (T = new Float32Array(E));
                    for(let N = 0, D = x; N !== R; ++N, D += 4)l.copy(y[N]).applyMatrix4(C, f), l.normal.toArray(T, D), T[D + 3] = l.constant;
                }
                d.value = T, d.needsUpdate = !0;
            }
            return e.numPlanes = R, e.numIntersection = 0, T;
        }
    }
    function SU(r) {
        let e = new WeakMap;
        function t(l, f) {
            return f === hd ? l.mapping = Bl : f === Mm && (l.mapping = jc), l;
        }
        function n(l) {
            if (l && l.isTexture) {
                const f = l.mapping;
                if (f === hd || f === Mm) if (e.has(l)) {
                    const d = e.get(l).texture;
                    return t(d, l.mapping);
                } else {
                    const d = l.image;
                    if (d && d.height > 0) {
                        const p = new bT(d.height);
                        return p.fromEquirectangularTexture(r, l), e.set(l, p), l.addEventListener("dispose", i), t(p.texture, l.mapping);
                    } else return null;
                }
            }
            return l;
        }
        function i(l) {
            const f = l.target;
            f.removeEventListener("dispose", i);
            const d = e.get(f);
            d !== void 0 && (e.delete(f), d.dispose());
        }
        function a() {
            e = new WeakMap;
        }
        return {
            get: n,
            dispose: a
        };
    }
    const ad = 4, v1 = [
        .125,
        .215,
        .35,
        .446,
        .526,
        .582
    ], pf = 20, xx = new Yo, y1 = new tt;
    let Sx = null, bx = 0, Mx = 0, Ex = !1;
    const df = (1 + Math.sqrt(5)) / 2, $h = 1 / df, _1 = [
        new Y(-df, $h, 0),
        new Y(df, $h, 0),
        new Y(-$h, 0, df),
        new Y($h, 0, df),
        new Y(0, df, -$h),
        new Y(0, df, $h),
        new Y(-1, 1, -1),
        new Y(1, 1, -1),
        new Y(-1, 1, 1),
        new Y(1, 1, 1)
    ], bU = new Y;
    class fS {
        constructor(e){
            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = .1, i = 100, a = {}) {
            const { size: l = 256, position: f = bU } = a;
            Sx = this._renderer.getRenderTarget(), bx = this._renderer.getActiveCubeFace(), Mx = this._renderer.getActiveMipmapLevel(), Ex = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(l);
            const d = this._allocateTargets();
            return d.depthBuffer = !0, this._sceneToCubeUV(e, n, i, d, f), t > 0 && this._blur(d, 0, 0, t), this._applyPMREM(d), this._cleanup(d), d;
        }
        fromEquirectangular(e, t = null) {
            return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
            return this._fromTexture(e, t);
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = b1(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = S1(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for(let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(Sx, bx, Mx), this._renderer.xr.enabled = Ex, e.scissorTest = !1, cv(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
            e.mapping === Bl || e.mapping === jc ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Sx = this._renderer.getRenderTarget(), bx = this._renderer.getActiveCubeFace(), Mx = this._renderer.getActiveMipmapLevel(), Ex = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
            const n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
        }
        _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
                magFilter: pi,
                minFilter: pi,
                generateMipmaps: !1,
                type: Cf,
                format: Is,
                colorSpace: qc,
                depthBuffer: !1
            }, i = x1(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = x1(e, t, n);
                const { _lodMax: a } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = MU(a)), this._blurMaterial = EU(a, e, t);
            }
            return i;
        }
        _compileMaterial(e) {
            const t = new ai(this._lodPlanes[0], e);
            this._renderer.compile(t, xx);
        }
        _sceneToCubeUV(e, t, n, i, a) {
            const d = new hi(90, 1, t, n), p = [
                1,
                -1,
                1,
                1,
                1,
                1
            ], g = [
                1,
                1,
                1,
                -1,
                -1,
                -1
            ], y = this._renderer, _ = y.autoClear, x = y.toneMapping;
            y.getClearColor(y1), y.toneMapping = jo, y.autoClear = !1;
            const M = new ja({
                name: "PMREM.Background",
                side: sa,
                depthWrite: !1,
                depthTest: !1
            }), R = new ai(new $c, M);
            let T = !1;
            const E = e.background;
            E ? E.isColor && (M.color.copy(E), e.background = null, T = !0) : (M.color.copy(y1), T = !0);
            for(let C = 0; C < 6; C++){
                const N = C % 3;
                N === 0 ? (d.up.set(0, p[C], 0), d.position.set(a.x, a.y, a.z), d.lookAt(a.x + g[C], a.y, a.z)) : N === 1 ? (d.up.set(0, 0, p[C]), d.position.set(a.x, a.y, a.z), d.lookAt(a.x, a.y + g[C], a.z)) : (d.up.set(0, p[C], 0), d.position.set(a.x, a.y, a.z), d.lookAt(a.x, a.y, a.z + g[C]));
                const D = this._cubeSize;
                cv(i, N * D, C > 2 ? D : 0, D, D), y.setRenderTarget(i), T && y.render(R, d), y.render(e, d);
            }
            R.geometry.dispose(), R.material.dispose(), y.toneMapping = x, y.autoClear = _, e.background = E;
        }
        _textureToCubeUV(e, t) {
            const n = this._renderer, i = e.mapping === Bl || e.mapping === jc;
            i ? (this._cubemapMaterial === null && (this._cubemapMaterial = b1()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = S1());
            const a = i ? this._cubemapMaterial : this._equirectMaterial, l = new ai(this._lodPlanes[0], a), f = a.uniforms;
            f.envMap.value = e;
            const d = this._cubeSize;
            cv(t, 0, 0, 3 * d, 2 * d), n.setRenderTarget(t), n.render(l, xx);
        }
        _applyPMREM(e) {
            const t = this._renderer, n = t.autoClear;
            t.autoClear = !1;
            const i = this._lodPlanes.length;
            for(let a = 1; a < i; a++){
                const l = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), f = _1[(i - a - 1) % _1.length];
                this._blur(e, a - 1, a, l, f);
            }
            t.autoClear = n;
        }
        _blur(e, t, n, i, a) {
            const l = this._pingPongRenderTarget;
            this._halfBlur(e, l, t, n, i, "latitudinal", a), this._halfBlur(l, e, n, n, i, "longitudinal", a);
        }
        _halfBlur(e, t, n, i, a, l, f) {
            const d = this._renderer, p = this._blurMaterial;
            l !== "latitudinal" && l !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            const g = 3, y = new ai(this._lodPlanes[i], p), _ = p.uniforms, x = this._sizeLods[n] - 1, M = isFinite(a) ? Math.PI / (2 * x) : 2 * Math.PI / (2 * pf - 1), R = a / M, T = isFinite(a) ? 1 + Math.floor(g * R) : pf;
            T > pf && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${T} samples when the maximum is set to ${pf}`);
            const E = [];
            let C = 0;
            for(let P = 0; P < pf; ++P){
                const F = P / R, z = Math.exp(-F * F / 2);
                E.push(z), P === 0 ? C += z : P < T && (C += 2 * z);
            }
            for(let P = 0; P < E.length; P++)E[P] = E[P] / C;
            _.envMap.value = e.texture, _.samples.value = T, _.weights.value = E, _.latitudinal.value = l === "latitudinal", f && (_.poleAxis.value = f);
            const { _lodMax: N } = this;
            _.dTheta.value = M, _.mipInt.value = N - n;
            const D = this._sizeLods[i], I = 3 * D * (i > N - ad ? i - N + ad : 0), O = 4 * (this._cubeSize - D);
            cv(t, I, O, 3 * D, 2 * D), d.setRenderTarget(t), d.render(y, xx);
        }
    }
    function MU(r) {
        const e = [], t = [], n = [];
        let i = r;
        const a = r - ad + 1 + v1.length;
        for(let l = 0; l < a; l++){
            const f = Math.pow(2, i);
            t.push(f);
            let d = 1 / f;
            l > r - ad ? d = v1[l - r + ad - 1] : l === 0 && (d = 0), n.push(d);
            const p = 1 / (f - 2), g = -p, y = 1 + p, _ = [
                g,
                g,
                y,
                g,
                y,
                y,
                g,
                g,
                y,
                y,
                g,
                y
            ], x = 6, M = 6, R = 3, T = 2, E = 1, C = new Float32Array(R * M * x), N = new Float32Array(T * M * x), D = new Float32Array(E * M * x);
            for(let O = 0; O < x; O++){
                const P = O % 3 * 2 / 3 - 1, F = O > 2 ? 0 : -1, z = [
                    P,
                    F,
                    0,
                    P + 2 / 3,
                    F,
                    0,
                    P + 2 / 3,
                    F + 1,
                    0,
                    P,
                    F,
                    0,
                    P + 2 / 3,
                    F + 1,
                    0,
                    P,
                    F + 1,
                    0
                ];
                C.set(z, R * M * O), N.set(_, T * M * O);
                const L = [
                    O,
                    O,
                    O,
                    O,
                    O,
                    O
                ];
                D.set(L, E * M * O);
            }
            const I = new Dt;
            I.setAttribute("position", new vn(C, R)), I.setAttribute("uv", new vn(N, T)), I.setAttribute("faceIndex", new vn(D, E)), e.push(I), i > ad && i--;
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        };
    }
    function x1(r, e, t) {
        const n = new so(r, e, t);
        return n.texture.mapping = wd, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
    }
    function cv(r, e, t, n, i) {
        r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
    }
    function EU(r, e, t) {
        const n = new Float32Array(pf), i = new Y(0, 1, 0);
        return new ao({
            name: "SphericalGaussianBlur",
            defines: {
                n: pf,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${r}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: i
                }
            },
            vertexShader: cb(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: Ul,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function S1() {
        return new ao({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: cb(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: Ul,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function b1() {
        return new ao({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: cb(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: Ul,
            depthTest: !1,
            depthWrite: !1
        });
    }
    function cb() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
    }
    function TU(r) {
        let e = new WeakMap, t = null;
        function n(f) {
            if (f && f.isTexture) {
                const d = f.mapping, p = d === hd || d === Mm, g = d === Bl || d === jc;
                if (p || g) {
                    let y = e.get(f);
                    const _ = y !== void 0 ? y.texture.pmremVersion : 0;
                    if (f.isRenderTargetTexture && f.pmremVersion !== _) return t === null && (t = new fS(r)), y = p ? t.fromEquirectangular(f, y) : t.fromCubemap(f, y), y.texture.pmremVersion = f.pmremVersion, e.set(f, y), y.texture;
                    if (y !== void 0) return y.texture;
                    {
                        const x = f.image;
                        return p && x && x.height > 0 || g && x && i(x) ? (t === null && (t = new fS(r)), y = p ? t.fromEquirectangular(f) : t.fromCubemap(f), y.texture.pmremVersion = f.pmremVersion, e.set(f, y), f.addEventListener("dispose", a), y.texture) : null;
                    }
                }
            }
            return f;
        }
        function i(f) {
            let d = 0;
            const p = 6;
            for(let g = 0; g < p; g++)f[g] !== void 0 && d++;
            return d === p;
        }
        function a(f) {
            const d = f.target;
            d.removeEventListener("dispose", a);
            const p = e.get(d);
            p !== void 0 && (e.delete(d), p.dispose());
        }
        function l() {
            e = new WeakMap, t !== null && (t.dispose(), t = null);
        }
        return {
            get: n,
            dispose: l
        };
    }
    function AU(r) {
        const e = {};
        function t(n) {
            if (e[n] !== void 0) return e[n];
            let i;
            switch(n){
                case "WEBGL_depth_texture":
                    i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = r.getExtension(n);
            }
            return e[n] = i, i;
        }
        return {
            has: function(n) {
                return t(n) !== null;
            },
            init: function() {
                t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
            },
            get: function(n) {
                const i = t(n);
                return i === null && od("THREE.WebGLRenderer: " + n + " extension not supported."), i;
            }
        };
    }
    function wU(r, e, t, n) {
        const i = {}, a = new WeakMap;
        function l(y) {
            const _ = y.target;
            _.index !== null && e.remove(_.index);
            for(const M in _.attributes)e.remove(_.attributes[M]);
            _.removeEventListener("dispose", l), delete i[_.id];
            const x = a.get(_);
            x && (e.remove(x), a.delete(_)), n.releaseStatesOfGeometry(_), _.isInstancedBufferGeometry === !0 && delete _._maxInstanceCount, t.memory.geometries--;
        }
        function f(y, _) {
            return i[_.id] === !0 || (_.addEventListener("dispose", l), i[_.id] = !0, t.memory.geometries++), _;
        }
        function d(y) {
            const _ = y.attributes;
            for(const x in _)e.update(_[x], r.ARRAY_BUFFER);
        }
        function p(y) {
            const _ = [], x = y.index, M = y.attributes.position;
            let R = 0;
            if (x !== null) {
                const C = x.array;
                R = x.version;
                for(let N = 0, D = C.length; N < D; N += 3){
                    const I = C[N + 0], O = C[N + 1], P = C[N + 2];
                    _.push(I, O, O, P, P, I);
                }
            } else if (M !== void 0) {
                const C = M.array;
                R = M.version;
                for(let N = 0, D = C.length / 3 - 1; N < D; N += 3){
                    const I = N + 0, O = N + 1, P = N + 2;
                    _.push(I, O, O, P, P, I);
                }
            } else return;
            const T = new (mT(_) ? BS : Ty)(_, 1);
            T.version = R;
            const E = a.get(y);
            E && e.remove(E), a.set(y, T);
        }
        function g(y) {
            const _ = a.get(y);
            if (_) {
                const x = y.index;
                x !== null && _.version < x.version && p(y);
            } else p(y);
            return a.get(y);
        }
        return {
            get: f,
            update: d,
            getWireframeAttribute: g
        };
    }
    function RU(r, e, t) {
        let n;
        function i(_) {
            n = _;
        }
        let a, l;
        function f(_) {
            a = _.type, l = _.bytesPerElement;
        }
        function d(_, x) {
            r.drawElements(n, x, a, _ * l), t.update(x, n, 1);
        }
        function p(_, x, M) {
            M !== 0 && (r.drawElementsInstanced(n, x, a, _ * l, M), t.update(x, n, M));
        }
        function g(_, x, M) {
            if (M === 0) return;
            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, x, 0, a, _, 0, M);
            let T = 0;
            for(let E = 0; E < M; E++)T += x[E];
            t.update(T, n, 1);
        }
        function y(_, x, M, R) {
            if (M === 0) return;
            const T = e.get("WEBGL_multi_draw");
            if (T === null) for(let E = 0; E < _.length; E++)p(_[E] / l, x[E], R[E]);
            else {
                T.multiDrawElementsInstancedWEBGL(n, x, 0, a, _, 0, R, 0, M);
                let E = 0;
                for(let C = 0; C < M; C++)E += x[C] * R[C];
                t.update(E, n, 1);
            }
        }
        this.setMode = i, this.setIndex = f, this.render = d, this.renderInstances = p, this.renderMultiDraw = g, this.renderMultiDrawInstances = y;
    }
    function CU(r) {
        const e = {
            geometries: 0,
            textures: 0
        }, t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function n(a, l, f) {
            switch(t.calls++, l){
                case r.TRIANGLES:
                    t.triangles += f * (a / 3);
                    break;
                case r.LINES:
                    t.lines += f * (a / 2);
                    break;
                case r.LINE_STRIP:
                    t.lines += f * (a - 1);
                    break;
                case r.LINE_LOOP:
                    t.lines += f * a;
                    break;
                case r.POINTS:
                    t.points += f * a;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", l);
                    break;
            }
        }
        function i() {
            t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: i,
            update: n
        };
    }
    function DU(r, e, t) {
        const n = new WeakMap, i = new gn;
        function a(l, f, d) {
            const p = l.morphTargetInfluences, g = f.morphAttributes.position || f.morphAttributes.normal || f.morphAttributes.color, y = g !== void 0 ? g.length : 0;
            let _ = n.get(f);
            if (_ === void 0 || _.count !== y) {
                let L = function() {
                    F.dispose(), n.delete(f), f.removeEventListener("dispose", L);
                };
                var x = L;
                _ !== void 0 && _.texture.dispose();
                const M = f.morphAttributes.position !== void 0, R = f.morphAttributes.normal !== void 0, T = f.morphAttributes.color !== void 0, E = f.morphAttributes.position || [], C = f.morphAttributes.normal || [], N = f.morphAttributes.color || [];
                let D = 0;
                M === !0 && (D = 1), R === !0 && (D = 2), T === !0 && (D = 3);
                let I = f.attributes.position.count * D, O = 1;
                I > e.maxTextureSize && (O = Math.ceil(I / e.maxTextureSize), I = e.maxTextureSize);
                const P = new Float32Array(I * O * 4 * y), F = new My(P, I, O, y);
                F.type = ia, F.needsUpdate = !0;
                const z = D * 4;
                for(let q = 0; q < y; q++){
                    const oe = E[q], se = C[q], ge = N[q], _e = I * O * 4 * q;
                    for(let H = 0; H < oe.count; H++){
                        const K = H * z;
                        M === !0 && (i.fromBufferAttribute(oe, H), P[_e + K + 0] = i.x, P[_e + K + 1] = i.y, P[_e + K + 2] = i.z, P[_e + K + 3] = 0), R === !0 && (i.fromBufferAttribute(se, H), P[_e + K + 4] = i.x, P[_e + K + 5] = i.y, P[_e + K + 6] = i.z, P[_e + K + 7] = 0), T === !0 && (i.fromBufferAttribute(ge, H), P[_e + K + 8] = i.x, P[_e + K + 9] = i.y, P[_e + K + 10] = i.z, P[_e + K + 11] = ge.itemSize === 4 ? i.w : 1);
                    }
                }
                _ = {
                    count: y,
                    texture: F,
                    size: new Ie(I, O)
                }, n.set(f, _), f.addEventListener("dispose", L);
            }
            if (l.isInstancedMesh === !0 && l.morphTexture !== null) d.getUniforms().setValue(r, "morphTexture", l.morphTexture, t);
            else {
                let M = 0;
                for(let T = 0; T < p.length; T++)M += p[T];
                const R = f.morphTargetsRelative ? 1 : 1 - M;
                d.getUniforms().setValue(r, "morphTargetBaseInfluence", R), d.getUniforms().setValue(r, "morphTargetInfluences", p);
            }
            d.getUniforms().setValue(r, "morphTargetsTexture", _.texture, t), d.getUniforms().setValue(r, "morphTargetsTextureSize", _.size);
        }
        return {
            update: a
        };
    }
    function NU(r, e, t, n) {
        let i = new WeakMap;
        function a(d) {
            const p = n.render.frame, g = d.geometry, y = e.get(d, g);
            if (i.get(y) !== p && (e.update(y), i.set(y, p)), d.isInstancedMesh && (d.hasEventListener("dispose", f) === !1 && d.addEventListener("dispose", f), i.get(d) !== p && (t.update(d.instanceMatrix, r.ARRAY_BUFFER), d.instanceColor !== null && t.update(d.instanceColor, r.ARRAY_BUFFER), i.set(d, p))), d.isSkinnedMesh) {
                const _ = d.skeleton;
                i.get(_) !== p && (_.update(), i.set(_, p));
            }
            return y;
        }
        function l() {
            i = new WeakMap;
        }
        function f(d) {
            const p = d.target;
            p.removeEventListener("dispose", f), t.remove(p.instanceMatrix), p.instanceColor !== null && t.remove(p.instanceColor);
        }
        return {
            update: a,
            dispose: l
        };
    }
    const hA = new Qn, M1 = new Uy(1, 1), dA = new My, pA = new Ey, mA = new Pm, E1 = [], T1 = [], A1 = new Float32Array(16), w1 = new Float32Array(9), R1 = new Float32Array(4);
    function Ld(r, e, t) {
        const n = r[0];
        if (n <= 0 || n > 0) return r;
        const i = e * t;
        let a = E1[i];
        if (a === void 0 && (a = new Float32Array(i), E1[i] = a), e !== 0) {
            n.toArray(a, 0);
            for(let l = 1, f = 0; l !== e; ++l)f += t, r[l].toArray(a, f);
        }
        return a;
    }
    function es(r, e) {
        if (r.length !== e.length) return !1;
        for(let t = 0, n = r.length; t < n; t++)if (r[t] !== e[t]) return !1;
        return !0;
    }
    function ts(r, e) {
        for(let t = 0, n = e.length; t < n; t++)r[t] = e[t];
    }
    function Yy(r, e) {
        let t = T1[e];
        t === void 0 && (t = new Int32Array(e), T1[e] = t);
        for(let n = 0; n !== e; ++n)t[n] = r.allocateTextureUnit();
        return t;
    }
    function UU(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e);
    }
    function LU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (es(t, e)) return;
            r.uniform2fv(this.addr, e), ts(t, e);
        }
    }
    function OU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
            if (es(t, e)) return;
            r.uniform3fv(this.addr, e), ts(t, e);
        }
    }
    function zU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (es(t, e)) return;
            r.uniform4fv(this.addr, e), ts(t, e);
        }
    }
    function BU(r, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (es(t, e)) return;
            r.uniformMatrix2fv(this.addr, !1, e), ts(t, e);
        } else {
            if (es(t, n)) return;
            R1.set(n), r.uniformMatrix2fv(this.addr, !1, R1), ts(t, n);
        }
    }
    function IU(r, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (es(t, e)) return;
            r.uniformMatrix3fv(this.addr, !1, e), ts(t, e);
        } else {
            if (es(t, n)) return;
            w1.set(n), r.uniformMatrix3fv(this.addr, !1, w1), ts(t, n);
        }
    }
    function PU(r, e) {
        const t = this.cache, n = e.elements;
        if (n === void 0) {
            if (es(t, e)) return;
            r.uniformMatrix4fv(this.addr, !1, e), ts(t, e);
        } else {
            if (es(t, n)) return;
            A1.set(n), r.uniformMatrix4fv(this.addr, !1, A1), ts(t, n);
        }
    }
    function HU(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e);
    }
    function FU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (es(t, e)) return;
            r.uniform2iv(this.addr, e), ts(t, e);
        }
    }
    function GU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (es(t, e)) return;
            r.uniform3iv(this.addr, e), ts(t, e);
        }
    }
    function VU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (es(t, e)) return;
            r.uniform4iv(this.addr, e), ts(t, e);
        }
    }
    function kU(r, e) {
        const t = this.cache;
        t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e);
    }
    function XU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
            if (es(t, e)) return;
            r.uniform2uiv(this.addr, e), ts(t, e);
        }
    }
    function jU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
            if (es(t, e)) return;
            r.uniform3uiv(this.addr, e), ts(t, e);
        }
    }
    function qU(r, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
            if (es(t, e)) return;
            r.uniform4uiv(this.addr, e), ts(t, e);
        }
    }
    function YU(r, e, t) {
        const n = this.cache, i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
        let a;
        this.type === r.SAMPLER_2D_SHADOW ? (M1.compareFunction = LS, a = M1) : a = hA, t.setTexture2D(e || a, i);
    }
    function WU(r, e, t) {
        const n = this.cache, i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || pA, i);
    }
    function ZU(r, e, t) {
        const n = this.cache, i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || mA, i);
    }
    function KU(r, e, t) {
        const n = this.cache, i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || dA, i);
    }
    function QU(r) {
        switch(r){
            case 5126:
                return UU;
            case 35664:
                return LU;
            case 35665:
                return OU;
            case 35666:
                return zU;
            case 35674:
                return BU;
            case 35675:
                return IU;
            case 35676:
                return PU;
            case 5124:
            case 35670:
                return HU;
            case 35667:
            case 35671:
                return FU;
            case 35668:
            case 35672:
                return GU;
            case 35669:
            case 35673:
                return VU;
            case 5125:
                return kU;
            case 36294:
                return XU;
            case 36295:
                return jU;
            case 36296:
                return qU;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return YU;
            case 35679:
            case 36299:
            case 36307:
                return WU;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return ZU;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return KU;
        }
    }
    function JU(r, e) {
        r.uniform1fv(this.addr, e);
    }
    function $U(r, e) {
        const t = Ld(e, this.size, 2);
        r.uniform2fv(this.addr, t);
    }
    function eL(r, e) {
        const t = Ld(e, this.size, 3);
        r.uniform3fv(this.addr, t);
    }
    function tL(r, e) {
        const t = Ld(e, this.size, 4);
        r.uniform4fv(this.addr, t);
    }
    function nL(r, e) {
        const t = Ld(e, this.size, 4);
        r.uniformMatrix2fv(this.addr, !1, t);
    }
    function iL(r, e) {
        const t = Ld(e, this.size, 9);
        r.uniformMatrix3fv(this.addr, !1, t);
    }
    function sL(r, e) {
        const t = Ld(e, this.size, 16);
        r.uniformMatrix4fv(this.addr, !1, t);
    }
    function aL(r, e) {
        r.uniform1iv(this.addr, e);
    }
    function rL(r, e) {
        r.uniform2iv(this.addr, e);
    }
    function oL(r, e) {
        r.uniform3iv(this.addr, e);
    }
    function lL(r, e) {
        r.uniform4iv(this.addr, e);
    }
    function cL(r, e) {
        r.uniform1uiv(this.addr, e);
    }
    function uL(r, e) {
        r.uniform2uiv(this.addr, e);
    }
    function fL(r, e) {
        r.uniform3uiv(this.addr, e);
    }
    function hL(r, e) {
        r.uniform4uiv(this.addr, e);
    }
    function dL(r, e, t) {
        const n = this.cache, i = e.length, a = Yy(t, i);
        es(n, a) || (r.uniform1iv(this.addr, a), ts(n, a));
        for(let l = 0; l !== i; ++l)t.setTexture2D(e[l] || hA, a[l]);
    }
    function pL(r, e, t) {
        const n = this.cache, i = e.length, a = Yy(t, i);
        es(n, a) || (r.uniform1iv(this.addr, a), ts(n, a));
        for(let l = 0; l !== i; ++l)t.setTexture3D(e[l] || pA, a[l]);
    }
    function mL(r, e, t) {
        const n = this.cache, i = e.length, a = Yy(t, i);
        es(n, a) || (r.uniform1iv(this.addr, a), ts(n, a));
        for(let l = 0; l !== i; ++l)t.setTextureCube(e[l] || mA, a[l]);
    }
    function gL(r, e, t) {
        const n = this.cache, i = e.length, a = Yy(t, i);
        es(n, a) || (r.uniform1iv(this.addr, a), ts(n, a));
        for(let l = 0; l !== i; ++l)t.setTexture2DArray(e[l] || dA, a[l]);
    }
    function vL(r) {
        switch(r){
            case 5126:
                return JU;
            case 35664:
                return $U;
            case 35665:
                return eL;
            case 35666:
                return tL;
            case 35674:
                return nL;
            case 35675:
                return iL;
            case 35676:
                return sL;
            case 5124:
            case 35670:
                return aL;
            case 35667:
            case 35671:
                return rL;
            case 35668:
            case 35672:
                return oL;
            case 35669:
            case 35673:
                return lL;
            case 5125:
                return cL;
            case 36294:
                return uL;
            case 36295:
                return fL;
            case 36296:
                return hL;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return dL;
            case 35679:
            case 36299:
            case 36307:
                return pL;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return mL;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return gL;
        }
    }
    class yL {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = QU(t.type);
        }
    }
    class _L {
        constructor(e, t, n){
            this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = vL(t.type);
        }
    }
    class xL {
        constructor(e){
            this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, n) {
            const i = this.seq;
            for(let a = 0, l = i.length; a !== l; ++a){
                const f = i[a];
                f.setValue(e, t[f.id], n);
            }
        }
    }
    const Tx = /(\w+)(\])?(\[|\.)?/g;
    function C1(r, e) {
        r.seq.push(e), r.map[e.id] = e;
    }
    function SL(r, e, t) {
        const n = r.name, i = n.length;
        for(Tx.lastIndex = 0;;){
            const a = Tx.exec(n), l = Tx.lastIndex;
            let f = a[1];
            const d = a[2] === "]", p = a[3];
            if (d && (f = f | 0), p === void 0 || p === "[" && l + 2 === i) {
                C1(t, p === void 0 ? new yL(f, r, e) : new _L(f, r, e));
                break;
            } else {
                let y = t.map[f];
                y === void 0 && (y = new xL(f), C1(t, y)), t = y;
            }
        }
    }
    class vv {
        constructor(e, t){
            this.seq = [], this.map = {};
            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for(let i = 0; i < n; ++i){
                const a = e.getActiveUniform(t, i), l = e.getUniformLocation(t, a.name);
                SL(a, l, this);
            }
        }
        setValue(e, t, n, i) {
            const a = this.map[t];
            a !== void 0 && a.setValue(e, n, i);
        }
        setOptional(e, t, n) {
            const i = t[n];
            i !== void 0 && this.setValue(e, n, i);
        }
        static upload(e, t, n, i) {
            for(let a = 0, l = t.length; a !== l; ++a){
                const f = t[a], d = n[f.id];
                d.needsUpdate !== !1 && f.setValue(e, d.value, i);
            }
        }
        static seqWithValue(e, t) {
            const n = [];
            for(let i = 0, a = e.length; i !== a; ++i){
                const l = e[i];
                l.id in t && n.push(l);
            }
            return n;
        }
    }
    function D1(r, e, t) {
        const n = r.createShader(e);
        return r.shaderSource(n, t), r.compileShader(n), n;
    }
    const bL = 37297;
    let ML = 0;
    function EL(r, e) {
        const t = r.split(`
`), n = [], i = Math.max(e - 6, 0), a = Math.min(e + 6, t.length);
        for(let l = i; l < a; l++){
            const f = l + 1;
            n.push(`${f === e ? ">" : " "} ${f}: ${t[l]}`);
        }
        return n.join(`
`);
    }
    const N1 = new Yt;
    function TL(r) {
        Sn._getMatrix(N1, Sn.workingColorSpace, r);
        const e = `mat3( ${N1.elements.map((t)=>t.toFixed(4))} )`;
        switch(Sn.getTransfer(r)){
            case Tm:
                return [
                    e,
                    "LinearTransferOETF"
                ];
            case Fn:
                return [
                    e,
                    "sRGBTransferOETF"
                ];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [
                    e,
                    "LinearTransferOETF"
                ];
        }
    }
    function U1(r, e, t) {
        const n = r.getShaderParameter(e, r.COMPILE_STATUS), i = r.getShaderInfoLog(e).trim();
        if (n && i === "") return "";
        const a = /ERROR: 0:(\d+)/.exec(i);
        if (a) {
            const l = parseInt(a[1]);
            return t.toUpperCase() + `

` + i + `

` + EL(r.getShaderSource(e), l);
        } else return i;
    }
    function AL(r, e) {
        const t = TL(e);
        return [
            `vec4 ${r}( vec4 value ) {`,
            `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
            "}"
        ].join(`
`);
    }
    function wL(r, e) {
        let t;
        switch(e){
            case WE:
                t = "Linear";
                break;
            case ZE:
                t = "Reinhard";
                break;
            case KE:
                t = "Cineon";
                break;
            case MS:
                t = "ACESFilmic";
                break;
            case JE:
                t = "AgX";
                break;
            case $E:
                t = "Neutral";
                break;
            case QE:
                t = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
        }
        return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
    }
    const uv = new Y;
    function RL() {
        Sn.getLuminanceCoefficients(uv);
        const r = uv.x.toFixed(4), e = uv.y.toFixed(4), t = uv.z.toFixed(4);
        return [
            "float luminance( const in vec3 rgb ) {",
            `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`,
            "	return dot( weights, rgb );",
            "}"
        ].join(`
`);
    }
    function CL(r) {
        return [
            r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
            r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(fm).join(`
`);
    }
    function DL(r) {
        const e = [];
        for(const t in r){
            const n = r[t];
            n !== !1 && e.push("#define " + t + " " + n);
        }
        return e.join(`
`);
    }
    function NL(r, e) {
        const t = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
        for(let i = 0; i < n; i++){
            const a = r.getActiveAttrib(e, i), l = a.name;
            let f = 1;
            a.type === r.FLOAT_MAT2 && (f = 2), a.type === r.FLOAT_MAT3 && (f = 3), a.type === r.FLOAT_MAT4 && (f = 4), t[l] = {
                type: a.type,
                location: r.getAttribLocation(e, l),
                locationSize: f
            };
        }
        return t;
    }
    function fm(r) {
        return r !== "";
    }
    function L1(r, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function O1(r, e) {
        return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
    }
    const UL = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function hS(r) {
        return r.replace(UL, OL);
    }
    const LL = new Map;
    function OL(r, e) {
        let t = sn[e];
        if (t === void 0) {
            const n = LL.get(e);
            if (n !== void 0) t = sn[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
            else throw new Error("Can not resolve #include <" + e + ">");
        }
        return hS(t);
    }
    const zL = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function z1(r) {
        return r.replace(zL, BL);
    }
    function BL(r, e, t, n) {
        let i = "";
        for(let a = parseInt(e); a < parseInt(t); a++)i += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
        return i;
    }
    function B1(r) {
        let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
        return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
    }
    function IL(r) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return r.shadowMapType === dy ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === hm ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === to && (e = "SHADOWMAP_TYPE_VSM"), e;
    }
    function PL(r) {
        let e = "ENVMAP_TYPE_CUBE";
        if (r.envMap) switch(r.envMapMode){
            case Bl:
            case jc:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case wd:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
        return e;
    }
    function HL(r) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (r.envMap) switch(r.envMapMode){
            case jc:
                e = "ENVMAP_MODE_REFRACTION";
                break;
        }
        return e;
    }
    function FL(r) {
        let e = "ENVMAP_BLENDING_NONE";
        if (r.envMap) switch(r.combine){
            case Bm:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case qE:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case YE:
                e = "ENVMAP_BLENDING_ADD";
                break;
        }
        return e;
    }
    function GL(r) {
        const e = r.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2, n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
            texelHeight: n,
            maxMip: t
        };
    }
    function VL(r, e, t, n) {
        const i = r.getContext(), a = t.defines;
        let l = t.vertexShader, f = t.fragmentShader;
        const d = IL(t), p = PL(t), g = HL(t), y = FL(t), _ = GL(t), x = CL(t), M = DL(a), R = i.createProgram();
        let T, E, C = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (T = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            M
        ].filter(fm).join(`
`), T.length > 0 && (T += `
`), E = [
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            M
        ].filter(fm).join(`
`), E.length > 0 && (E += `
`)) : (T = [
            B1(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            M,
            t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
            t.batching ? "#define USE_BATCHING" : "",
            t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
            t.instancing ? "#define USE_INSTANCING" : "",
            t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.map ? "#define USE_MAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + g : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.mapUv ? "#define MAP_UV " + t.mapUv : "",
            t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
            t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
            t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
            t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
            t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
            t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
            t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
            t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
            t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
            t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
            t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
            t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
            t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
            t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
            t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
            t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
            t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
            t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
            t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
            t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
            t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
            t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.skinning ? "#define USE_SKINNING" : "",
            t.morphTargets ? "#define USE_MORPHTARGETS" : "",
            t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
            t.morphColors ? "#define USE_MORPHCOLORS" : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
            t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + d : "",
            t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "#ifdef USE_INSTANCING_MORPH",
            "	uniform sampler2D morphTexture;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_UV1",
            "	attribute vec2 uv1;",
            "#endif",
            "#ifdef USE_UV2",
            "	attribute vec2 uv2;",
            "#endif",
            "#ifdef USE_UV3",
            "	attribute vec2 uv3;",
            "#endif",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "	attribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            `
`
        ].filter(fm).join(`
`), E = [
            B1(t),
            "#define SHADER_TYPE " + t.shaderType,
            "#define SHADER_NAME " + t.shaderName,
            M,
            t.useFog && t.fog ? "#define USE_FOG" : "",
            t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
            t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
            t.map ? "#define USE_MAP" : "",
            t.matcap ? "#define USE_MATCAP" : "",
            t.envMap ? "#define USE_ENVMAP" : "",
            t.envMap ? "#define " + p : "",
            t.envMap ? "#define " + g : "",
            t.envMap ? "#define " + y : "",
            _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "",
            _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "",
            _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "",
            t.lightMap ? "#define USE_LIGHTMAP" : "",
            t.aoMap ? "#define USE_AOMAP" : "",
            t.bumpMap ? "#define USE_BUMPMAP" : "",
            t.normalMap ? "#define USE_NORMALMAP" : "",
            t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            t.anisotropy ? "#define USE_ANISOTROPY" : "",
            t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            t.clearcoat ? "#define USE_CLEARCOAT" : "",
            t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            t.dispersion ? "#define USE_DISPERSION" : "",
            t.iridescence ? "#define USE_IRIDESCENCE" : "",
            t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            t.specularMap ? "#define USE_SPECULARMAP" : "",
            t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            t.metalnessMap ? "#define USE_METALNESSMAP" : "",
            t.alphaMap ? "#define USE_ALPHAMAP" : "",
            t.alphaTest ? "#define USE_ALPHATEST" : "",
            t.alphaHash ? "#define USE_ALPHAHASH" : "",
            t.sheen ? "#define USE_SHEEN" : "",
            t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            t.transmission ? "#define USE_TRANSMISSION" : "",
            t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
            t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
            t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            t.vertexUv1s ? "#define USE_UV1" : "",
            t.vertexUv2s ? "#define USE_UV2" : "",
            t.vertexUv3s ? "#define USE_UV3" : "",
            t.pointsUvs ? "#define USE_POINTS_UV" : "",
            t.gradientMap ? "#define USE_GRADIENTMAP" : "",
            t.flatShading ? "#define FLAT_SHADED" : "",
            t.doubleSided ? "#define DOUBLE_SIDED" : "",
            t.flipSided ? "#define FLIP_SIDED" : "",
            t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            t.shadowMapEnabled ? "#define " + d : "",
            t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
            t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
            t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            t.toneMapping !== jo ? "#define TONE_MAPPING" : "",
            t.toneMapping !== jo ? sn.tonemapping_pars_fragment : "",
            t.toneMapping !== jo ? wL("toneMapping", t.toneMapping) : "",
            t.dithering ? "#define DITHERING" : "",
            t.opaque ? "#define OPAQUE" : "",
            sn.colorspace_pars_fragment,
            AL("linearToOutputTexel", t.outputColorSpace),
            RL(),
            t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
            `
`
        ].filter(fm).join(`
`)), l = hS(l), l = L1(l, t), l = O1(l, t), f = hS(f), f = L1(f, t), f = O1(f, t), l = z1(l), f = z1(f), t.isRawShaderMaterial !== !0 && (C = `#version 300 es
`, T = [
            x,
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join(`
`) + `
` + T, E = [
            "#define varying in",
            t.glslVersion === iS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
            t.glslVersion === iS ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + E);
        const N = C + T + l, D = C + E + f, I = D1(i, i.VERTEX_SHADER, N), O = D1(i, i.FRAGMENT_SHADER, D);
        i.attachShader(R, I), i.attachShader(R, O), t.index0AttributeName !== void 0 ? i.bindAttribLocation(R, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(R, 0, "position"), i.linkProgram(R);
        function P(q) {
            if (r.debug.checkShaderErrors) {
                const oe = i.getProgramInfoLog(R).trim(), se = i.getShaderInfoLog(I).trim(), ge = i.getShaderInfoLog(O).trim();
                let _e = !0, H = !0;
                if (i.getProgramParameter(R, i.LINK_STATUS) === !1) if (_e = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, R, I, O);
                else {
                    const K = U1(i, I, "vertex"), Q = U1(i, O, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(R, i.VALIDATE_STATUS) + `

Material Name: ` + q.name + `
Material Type: ` + q.type + `

Program Info Log: ` + oe + `
` + K + `
` + Q);
                }
                else oe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", oe) : (se === "" || ge === "") && (H = !1);
                H && (q.diagnostics = {
                    runnable: _e,
                    programLog: oe,
                    vertexShader: {
                        log: se,
                        prefix: T
                    },
                    fragmentShader: {
                        log: ge,
                        prefix: E
                    }
                });
            }
            i.deleteShader(I), i.deleteShader(O), F = new vv(i, R), z = NL(i, R);
        }
        let F;
        this.getUniforms = function() {
            return F === void 0 && P(this), F;
        };
        let z;
        this.getAttributes = function() {
            return z === void 0 && P(this), z;
        };
        let L = t.rendererExtensionParallelShaderCompile === !1;
        return this.isReady = function() {
            return L === !1 && (L = i.getProgramParameter(R, bL)), L;
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), i.deleteProgram(R), this.program = void 0;
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = ML++, this.cacheKey = e, this.usedTimes = 1, this.program = R, this.vertexShader = I, this.fragmentShader = O, this;
    }
    let kL = 0;
    class XL {
        constructor(){
            this.shaderCache = new Map, this.materialCache = new Map;
        }
        update(e) {
            const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), a = this._getShaderStage(n), l = this._getShaderCacheForMaterial(e);
            return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(a) === !1 && (l.add(a), a.usedTimes++), this;
        }
        remove(e) {
            const t = this.materialCache.get(e);
            for (const n of t)n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            let n = t.get(e);
            return n === void 0 && (n = new Set, t.set(e, n)), n;
        }
        _getShaderStage(e) {
            const t = this.shaderCache;
            let n = t.get(e);
            return n === void 0 && (n = new jL(e), t.set(e, n)), n;
        }
    }
    class jL {
        constructor(e){
            this.id = kL++, this.code = e, this.usedTimes = 0;
        }
    }
    function qL(r, e, t, n, i, a, l) {
        const f = new Sd, d = new XL, p = new Set, g = [], y = i.logarithmicDepthBuffer, _ = i.vertexTextures;
        let x = i.precision;
        const M = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };
        function R(z) {
            return p.add(z), z === 0 ? "uv" : `uv${z}`;
        }
        function T(z, L, q, oe, se) {
            const ge = oe.fog, _e = se.geometry, H = z.isMeshStandardMaterial ? oe.environment : null, K = (z.isMeshStandardMaterial ? t : e).get(z.envMap || H), Q = K && K.mapping === wd ? K.image.height : null, fe = M[z.type];
            z.precision !== null && (x = i.getMaxPrecision(z.precision), x !== z.precision && console.warn("THREE.WebGLProgram.getParameters:", z.precision, "not supported, using", x, "instead."));
            const X = _e.morphAttributes.position || _e.morphAttributes.normal || _e.morphAttributes.color, $ = X !== void 0 ? X.length : 0;
            let me = 0;
            _e.morphAttributes.position !== void 0 && (me = 1), _e.morphAttributes.normal !== void 0 && (me = 2), _e.morphAttributes.color !== void 0 && (me = 3);
            let ve, J, ue, he;
            if (fe) {
                const Zt = no[fe];
                ve = Zt.vertexShader, J = Zt.fragmentShader;
            } else ve = z.vertexShader, J = z.fragmentShader, d.update(z), ue = d.getVertexShaderID(z), he = d.getFragmentShaderID(z);
            const De = r.getRenderTarget(), Pe = r.state.buffers.depth.getReversed(), _t = se.isInstancedMesh === !0, xt = se.isBatchedMesh === !0, on = !!z.map, Vt = !!z.matcap, Nt = !!K, W = !!z.aoMap, et = !!z.lightMap, Ye = !!z.bumpMap, We = !!z.normalMap, Be = !!z.displacementMap, ut = !!z.emissiveMap, Xe = !!z.metalnessMap, ot = !!z.roughnessMap, It = z.anisotropy > 0, Z = z.clearcoat > 0, G = z.dispersion > 0, Se = z.iridescence > 0, Ue = z.sheen > 0, Le = z.transmission > 0, Ne = It && !!z.anisotropyMap, lt = Z && !!z.clearcoatMap, it = Z && !!z.clearcoatNormalMap, vt = Z && !!z.clearcoatRoughnessMap, yt = Se && !!z.iridescenceMap, He = Se && !!z.iridescenceThicknessMap, st = Ue && !!z.sheenColorMap, St = Ue && !!z.sheenRoughnessMap, ie = !!z.specularMap, xe = !!z.specularColorMap, Ze = !!z.specularIntensityMap, te = Le && !!z.transmissionMap, Qe = Le && !!z.thicknessMap, Ve = !!z.gradientMap, rt = !!z.alphaMap, Ke = z.alphaTest > 0, Fe = !!z.alphaHash, ct = !!z.extensions;
            let Mt = jo;
            z.toneMapped && (De === null || De.isXRRenderTarget === !0) && (Mt = r.toneMapping);
            const tn = {
                shaderID: fe,
                shaderType: z.type,
                shaderName: z.name,
                vertexShader: ve,
                fragmentShader: J,
                defines: z.defines,
                customVertexShaderID: ue,
                customFragmentShaderID: he,
                isRawShaderMaterial: z.isRawShaderMaterial === !0,
                glslVersion: z.glslVersion,
                precision: x,
                batching: xt,
                batchingColor: xt && se._colorsTexture !== null,
                instancing: _t,
                instancingColor: _t && se.instanceColor !== null,
                instancingMorph: _t && se.morphTexture !== null,
                supportsVertexTextures: _,
                outputColorSpace: De === null ? r.outputColorSpace : De.isXRRenderTarget === !0 ? De.texture.colorSpace : qc,
                alphaToCoverage: !!z.alphaToCoverage,
                map: on,
                matcap: Vt,
                envMap: Nt,
                envMapMode: Nt && K.mapping,
                envMapCubeUVHeight: Q,
                aoMap: W,
                lightMap: et,
                bumpMap: Ye,
                normalMap: We,
                displacementMap: _ && Be,
                emissiveMap: ut,
                normalMapObjectSpace: We && z.normalMapType === oT,
                normalMapTangentSpace: We && z.normalMapType === Jc,
                metalnessMap: Xe,
                roughnessMap: ot,
                anisotropy: It,
                anisotropyMap: Ne,
                clearcoat: Z,
                clearcoatMap: lt,
                clearcoatNormalMap: it,
                clearcoatRoughnessMap: vt,
                dispersion: G,
                iridescence: Se,
                iridescenceMap: yt,
                iridescenceThicknessMap: He,
                sheen: Ue,
                sheenColorMap: st,
                sheenRoughnessMap: St,
                specularMap: ie,
                specularColorMap: xe,
                specularIntensityMap: Ze,
                transmission: Le,
                transmissionMap: te,
                thicknessMap: Qe,
                gradientMap: Ve,
                opaque: z.transparent === !1 && z.blending === Sf && z.alphaToCoverage === !1,
                alphaMap: rt,
                alphaTest: Ke,
                alphaHash: Fe,
                combine: z.combine,
                mapUv: on && R(z.map.channel),
                aoMapUv: W && R(z.aoMap.channel),
                lightMapUv: et && R(z.lightMap.channel),
                bumpMapUv: Ye && R(z.bumpMap.channel),
                normalMapUv: We && R(z.normalMap.channel),
                displacementMapUv: Be && R(z.displacementMap.channel),
                emissiveMapUv: ut && R(z.emissiveMap.channel),
                metalnessMapUv: Xe && R(z.metalnessMap.channel),
                roughnessMapUv: ot && R(z.roughnessMap.channel),
                anisotropyMapUv: Ne && R(z.anisotropyMap.channel),
                clearcoatMapUv: lt && R(z.clearcoatMap.channel),
                clearcoatNormalMapUv: it && R(z.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: vt && R(z.clearcoatRoughnessMap.channel),
                iridescenceMapUv: yt && R(z.iridescenceMap.channel),
                iridescenceThicknessMapUv: He && R(z.iridescenceThicknessMap.channel),
                sheenColorMapUv: st && R(z.sheenColorMap.channel),
                sheenRoughnessMapUv: St && R(z.sheenRoughnessMap.channel),
                specularMapUv: ie && R(z.specularMap.channel),
                specularColorMapUv: xe && R(z.specularColorMap.channel),
                specularIntensityMapUv: Ze && R(z.specularIntensityMap.channel),
                transmissionMapUv: te && R(z.transmissionMap.channel),
                thicknessMapUv: Qe && R(z.thicknessMap.channel),
                alphaMapUv: rt && R(z.alphaMap.channel),
                vertexTangents: !!_e.attributes.tangent && (We || It),
                vertexColors: z.vertexColors,
                vertexAlphas: z.vertexColors === !0 && !!_e.attributes.color && _e.attributes.color.itemSize === 4,
                pointsUvs: se.isPoints === !0 && !!_e.attributes.uv && (on || rt),
                fog: !!ge,
                useFog: z.fog === !0,
                fogExp2: !!ge && ge.isFogExp2,
                flatShading: z.flatShading === !0 && z.wireframe === !1,
                sizeAttenuation: z.sizeAttenuation === !0,
                logarithmicDepthBuffer: y,
                reverseDepthBuffer: Pe,
                skinning: se.isSkinnedMesh === !0,
                morphTargets: _e.morphAttributes.position !== void 0,
                morphNormals: _e.morphAttributes.normal !== void 0,
                morphColors: _e.morphAttributes.color !== void 0,
                morphTargetsCount: $,
                morphTextureStride: me,
                numDirLights: L.directional.length,
                numPointLights: L.point.length,
                numSpotLights: L.spot.length,
                numSpotLightMaps: L.spotLightMap.length,
                numRectAreaLights: L.rectArea.length,
                numHemiLights: L.hemi.length,
                numDirLightShadows: L.directionalShadowMap.length,
                numPointLightShadows: L.pointShadowMap.length,
                numSpotLightShadows: L.spotShadowMap.length,
                numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
                numLightProbes: L.numLightProbes,
                numClippingPlanes: l.numPlanes,
                numClipIntersection: l.numIntersection,
                dithering: z.dithering,
                shadowMapEnabled: r.shadowMap.enabled && q.length > 0,
                shadowMapType: r.shadowMap.type,
                toneMapping: Mt,
                decodeVideoTexture: on && z.map.isVideoTexture === !0 && Sn.getTransfer(z.map.colorSpace) === Fn,
                decodeVideoTextureEmissive: ut && z.emissiveMap.isVideoTexture === !0 && Sn.getTransfer(z.emissiveMap.colorSpace) === Fn,
                premultipliedAlpha: z.premultipliedAlpha,
                doubleSided: z.side === ka,
                flipSided: z.side === sa,
                useDepthPacking: z.depthPacking >= 0,
                depthPacking: z.depthPacking || 0,
                index0AttributeName: z.index0AttributeName,
                extensionClipCullDistance: ct && z.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ct && z.extensions.multiDraw === !0 || xt) && n.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: z.customProgramCacheKey()
            };
            return tn.vertexUv1s = p.has(1), tn.vertexUv2s = p.has(2), tn.vertexUv3s = p.has(3), p.clear(), tn;
        }
        function E(z) {
            const L = [];
            if (z.shaderID ? L.push(z.shaderID) : (L.push(z.customVertexShaderID), L.push(z.customFragmentShaderID)), z.defines !== void 0) for(const q in z.defines)L.push(q), L.push(z.defines[q]);
            return z.isRawShaderMaterial === !1 && (C(L, z), N(L, z), L.push(r.outputColorSpace)), L.push(z.customProgramCacheKey), L.join();
        }
        function C(z, L) {
            z.push(L.precision), z.push(L.outputColorSpace), z.push(L.envMapMode), z.push(L.envMapCubeUVHeight), z.push(L.mapUv), z.push(L.alphaMapUv), z.push(L.lightMapUv), z.push(L.aoMapUv), z.push(L.bumpMapUv), z.push(L.normalMapUv), z.push(L.displacementMapUv), z.push(L.emissiveMapUv), z.push(L.metalnessMapUv), z.push(L.roughnessMapUv), z.push(L.anisotropyMapUv), z.push(L.clearcoatMapUv), z.push(L.clearcoatNormalMapUv), z.push(L.clearcoatRoughnessMapUv), z.push(L.iridescenceMapUv), z.push(L.iridescenceThicknessMapUv), z.push(L.sheenColorMapUv), z.push(L.sheenRoughnessMapUv), z.push(L.specularMapUv), z.push(L.specularColorMapUv), z.push(L.specularIntensityMapUv), z.push(L.transmissionMapUv), z.push(L.thicknessMapUv), z.push(L.combine), z.push(L.fogExp2), z.push(L.sizeAttenuation), z.push(L.morphTargetsCount), z.push(L.morphAttributeCount), z.push(L.numDirLights), z.push(L.numPointLights), z.push(L.numSpotLights), z.push(L.numSpotLightMaps), z.push(L.numHemiLights), z.push(L.numRectAreaLights), z.push(L.numDirLightShadows), z.push(L.numPointLightShadows), z.push(L.numSpotLightShadows), z.push(L.numSpotLightShadowsWithMaps), z.push(L.numLightProbes), z.push(L.shadowMapType), z.push(L.toneMapping), z.push(L.numClippingPlanes), z.push(L.numClipIntersection), z.push(L.depthPacking);
        }
        function N(z, L) {
            f.disableAll(), L.supportsVertexTextures && f.enable(0), L.instancing && f.enable(1), L.instancingColor && f.enable(2), L.instancingMorph && f.enable(3), L.matcap && f.enable(4), L.envMap && f.enable(5), L.normalMapObjectSpace && f.enable(6), L.normalMapTangentSpace && f.enable(7), L.clearcoat && f.enable(8), L.iridescence && f.enable(9), L.alphaTest && f.enable(10), L.vertexColors && f.enable(11), L.vertexAlphas && f.enable(12), L.vertexUv1s && f.enable(13), L.vertexUv2s && f.enable(14), L.vertexUv3s && f.enable(15), L.vertexTangents && f.enable(16), L.anisotropy && f.enable(17), L.alphaHash && f.enable(18), L.batching && f.enable(19), L.dispersion && f.enable(20), L.batchingColor && f.enable(21), L.gradientMap && f.enable(22), z.push(f.mask), f.disableAll(), L.fog && f.enable(0), L.useFog && f.enable(1), L.flatShading && f.enable(2), L.logarithmicDepthBuffer && f.enable(3), L.reverseDepthBuffer && f.enable(4), L.skinning && f.enable(5), L.morphTargets && f.enable(6), L.morphNormals && f.enable(7), L.morphColors && f.enable(8), L.premultipliedAlpha && f.enable(9), L.shadowMapEnabled && f.enable(10), L.doubleSided && f.enable(11), L.flipSided && f.enable(12), L.useDepthPacking && f.enable(13), L.dithering && f.enable(14), L.transmission && f.enable(15), L.sheen && f.enable(16), L.opaque && f.enable(17), L.pointsUvs && f.enable(18), L.decodeVideoTexture && f.enable(19), L.decodeVideoTextureEmissive && f.enable(20), L.alphaToCoverage && f.enable(21), z.push(f.mask);
        }
        function D(z) {
            const L = M[z.type];
            let q;
            if (L) {
                const oe = no[L];
                q = xT.clone(oe.uniforms);
            } else q = z.uniforms;
            return q;
        }
        function I(z, L) {
            let q;
            for(let oe = 0, se = g.length; oe < se; oe++){
                const ge = g[oe];
                if (ge.cacheKey === L) {
                    q = ge, ++q.usedTimes;
                    break;
                }
            }
            return q === void 0 && (q = new VL(r, L, z, a), g.push(q)), q;
        }
        function O(z) {
            if (--z.usedTimes === 0) {
                const L = g.indexOf(z);
                g[L] = g[g.length - 1], g.pop(), z.destroy();
            }
        }
        function P(z) {
            d.remove(z);
        }
        function F() {
            d.dispose();
        }
        return {
            getParameters: T,
            getProgramCacheKey: E,
            getUniforms: D,
            acquireProgram: I,
            releaseProgram: O,
            releaseShaderCache: P,
            programs: g,
            dispose: F
        };
    }
    function YL() {
        let r = new WeakMap;
        function e(l) {
            return r.has(l);
        }
        function t(l) {
            let f = r.get(l);
            return f === void 0 && (f = {}, r.set(l, f)), f;
        }
        function n(l) {
            r.delete(l);
        }
        function i(l, f, d) {
            r.get(l)[f] = d;
        }
        function a() {
            r = new WeakMap;
        }
        return {
            has: e,
            get: t,
            remove: n,
            update: i,
            dispose: a
        };
    }
    function WL(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
    }
    function I1(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
    }
    function P1() {
        const r = [];
        let e = 0;
        const t = [], n = [], i = [];
        function a() {
            e = 0, t.length = 0, n.length = 0, i.length = 0;
        }
        function l(y, _, x, M, R, T) {
            let E = r[e];
            return E === void 0 ? (E = {
                id: y.id,
                object: y,
                geometry: _,
                material: x,
                groupOrder: M,
                renderOrder: y.renderOrder,
                z: R,
                group: T
            }, r[e] = E) : (E.id = y.id, E.object = y, E.geometry = _, E.material = x, E.groupOrder = M, E.renderOrder = y.renderOrder, E.z = R, E.group = T), e++, E;
        }
        function f(y, _, x, M, R, T) {
            const E = l(y, _, x, M, R, T);
            x.transmission > 0 ? n.push(E) : x.transparent === !0 ? i.push(E) : t.push(E);
        }
        function d(y, _, x, M, R, T) {
            const E = l(y, _, x, M, R, T);
            x.transmission > 0 ? n.unshift(E) : x.transparent === !0 ? i.unshift(E) : t.unshift(E);
        }
        function p(y, _) {
            t.length > 1 && t.sort(y || WL), n.length > 1 && n.sort(_ || I1), i.length > 1 && i.sort(_ || I1);
        }
        function g() {
            for(let y = e, _ = r.length; y < _; y++){
                const x = r[y];
                if (x.id === null) break;
                x.id = null, x.object = null, x.geometry = null, x.material = null, x.group = null;
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: i,
            init: a,
            push: f,
            unshift: d,
            finish: g,
            sort: p
        };
    }
    function ZL() {
        let r = new WeakMap;
        function e(n, i) {
            const a = r.get(n);
            let l;
            return a === void 0 ? (l = new P1, r.set(n, [
                l
            ])) : i >= a.length ? (l = new P1, a.push(l)) : l = a[i], l;
        }
        function t() {
            r = new WeakMap;
        }
        return {
            get: e,
            dispose: t
        };
    }
    function KL() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            direction: new Y,
                            color: new tt
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new Y,
                            direction: new Y,
                            color: new tt,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new Y,
                            color: new tt,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new Y,
                            skyColor: new tt,
                            groundColor: new tt
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new tt,
                            position: new Y,
                            halfWidth: new Y,
                            halfHeight: new Y
                        };
                        break;
                }
                return r[e.id] = t, t;
            }
        };
    }
    function QL() {
        const r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0) return r[e.id];
                let t;
                switch(e.type){
                    case "DirectionalLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ie
                        };
                        break;
                    case "SpotLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ie
                        };
                        break;
                    case "PointLight":
                        t = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ie,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                }
                return r[e.id] = t, t;
            }
        };
    }
    let JL = 0;
    function $L(r, e) {
        return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
    }
    function eO(r) {
        const e = new KL, t = QL(), n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [
                0,
                0,
                0
            ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
        for(let p = 0; p < 9; p++)n.probe.push(new Y);
        const i = new Y, a = new pt, l = new pt;
        function f(p) {
            let g = 0, y = 0, _ = 0;
            for(let z = 0; z < 9; z++)n.probe[z].set(0, 0, 0);
            let x = 0, M = 0, R = 0, T = 0, E = 0, C = 0, N = 0, D = 0, I = 0, O = 0, P = 0;
            p.sort($L);
            for(let z = 0, L = p.length; z < L; z++){
                const q = p[z], oe = q.color, se = q.intensity, ge = q.distance, _e = q.shadow && q.shadow.map ? q.shadow.map.texture : null;
                if (q.isAmbientLight) g += oe.r * se, y += oe.g * se, _ += oe.b * se;
                else if (q.isLightProbe) {
                    for(let H = 0; H < 9; H++)n.probe[H].addScaledVector(q.sh.coefficients[H], se);
                    P++;
                } else if (q.isDirectionalLight) {
                    const H = e.get(q);
                    if (H.color.copy(q.color).multiplyScalar(q.intensity), q.castShadow) {
                        const K = q.shadow, Q = t.get(q);
                        Q.shadowIntensity = K.intensity, Q.shadowBias = K.bias, Q.shadowNormalBias = K.normalBias, Q.shadowRadius = K.radius, Q.shadowMapSize = K.mapSize, n.directionalShadow[x] = Q, n.directionalShadowMap[x] = _e, n.directionalShadowMatrix[x] = q.shadow.matrix, C++;
                    }
                    n.directional[x] = H, x++;
                } else if (q.isSpotLight) {
                    const H = e.get(q);
                    H.position.setFromMatrixPosition(q.matrixWorld), H.color.copy(oe).multiplyScalar(se), H.distance = ge, H.coneCos = Math.cos(q.angle), H.penumbraCos = Math.cos(q.angle * (1 - q.penumbra)), H.decay = q.decay, n.spot[R] = H;
                    const K = q.shadow;
                    if (q.map && (n.spotLightMap[I] = q.map, I++, K.updateMatrices(q), q.castShadow && O++), n.spotLightMatrix[R] = K.matrix, q.castShadow) {
                        const Q = t.get(q);
                        Q.shadowIntensity = K.intensity, Q.shadowBias = K.bias, Q.shadowNormalBias = K.normalBias, Q.shadowRadius = K.radius, Q.shadowMapSize = K.mapSize, n.spotShadow[R] = Q, n.spotShadowMap[R] = _e, D++;
                    }
                    R++;
                } else if (q.isRectAreaLight) {
                    const H = e.get(q);
                    H.color.copy(oe).multiplyScalar(se), H.halfWidth.set(q.width * .5, 0, 0), H.halfHeight.set(0, q.height * .5, 0), n.rectArea[T] = H, T++;
                } else if (q.isPointLight) {
                    const H = e.get(q);
                    if (H.color.copy(q.color).multiplyScalar(q.intensity), H.distance = q.distance, H.decay = q.decay, q.castShadow) {
                        const K = q.shadow, Q = t.get(q);
                        Q.shadowIntensity = K.intensity, Q.shadowBias = K.bias, Q.shadowNormalBias = K.normalBias, Q.shadowRadius = K.radius, Q.shadowMapSize = K.mapSize, Q.shadowCameraNear = K.camera.near, Q.shadowCameraFar = K.camera.far, n.pointShadow[M] = Q, n.pointShadowMap[M] = _e, n.pointShadowMatrix[M] = q.shadow.matrix, N++;
                    }
                    n.point[M] = H, M++;
                } else if (q.isHemisphereLight) {
                    const H = e.get(q);
                    H.skyColor.copy(q.color).multiplyScalar(se), H.groundColor.copy(q.groundColor).multiplyScalar(se), n.hemi[E] = H, E++;
                }
            }
            T > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ht.LTC_FLOAT_1, n.rectAreaLTC2 = ht.LTC_FLOAT_2) : (n.rectAreaLTC1 = ht.LTC_HALF_1, n.rectAreaLTC2 = ht.LTC_HALF_2)), n.ambient[0] = g, n.ambient[1] = y, n.ambient[2] = _;
            const F = n.hash;
            (F.directionalLength !== x || F.pointLength !== M || F.spotLength !== R || F.rectAreaLength !== T || F.hemiLength !== E || F.numDirectionalShadows !== C || F.numPointShadows !== N || F.numSpotShadows !== D || F.numSpotMaps !== I || F.numLightProbes !== P) && (n.directional.length = x, n.spot.length = R, n.rectArea.length = T, n.point.length = M, n.hemi.length = E, n.directionalShadow.length = C, n.directionalShadowMap.length = C, n.pointShadow.length = N, n.pointShadowMap.length = N, n.spotShadow.length = D, n.spotShadowMap.length = D, n.directionalShadowMatrix.length = C, n.pointShadowMatrix.length = N, n.spotLightMatrix.length = D + I - O, n.spotLightMap.length = I, n.numSpotLightShadowsWithMaps = O, n.numLightProbes = P, F.directionalLength = x, F.pointLength = M, F.spotLength = R, F.rectAreaLength = T, F.hemiLength = E, F.numDirectionalShadows = C, F.numPointShadows = N, F.numSpotShadows = D, F.numSpotMaps = I, F.numLightProbes = P, n.version = JL++);
        }
        function d(p, g) {
            let y = 0, _ = 0, x = 0, M = 0, R = 0;
            const T = g.matrixWorldInverse;
            for(let E = 0, C = p.length; E < C; E++){
                const N = p[E];
                if (N.isDirectionalLight) {
                    const D = n.directional[y];
                    D.direction.setFromMatrixPosition(N.matrixWorld), i.setFromMatrixPosition(N.target.matrixWorld), D.direction.sub(i), D.direction.transformDirection(T), y++;
                } else if (N.isSpotLight) {
                    const D = n.spot[x];
                    D.position.setFromMatrixPosition(N.matrixWorld), D.position.applyMatrix4(T), D.direction.setFromMatrixPosition(N.matrixWorld), i.setFromMatrixPosition(N.target.matrixWorld), D.direction.sub(i), D.direction.transformDirection(T), x++;
                } else if (N.isRectAreaLight) {
                    const D = n.rectArea[M];
                    D.position.setFromMatrixPosition(N.matrixWorld), D.position.applyMatrix4(T), l.identity(), a.copy(N.matrixWorld), a.premultiply(T), l.extractRotation(a), D.halfWidth.set(N.width * .5, 0, 0), D.halfHeight.set(0, N.height * .5, 0), D.halfWidth.applyMatrix4(l), D.halfHeight.applyMatrix4(l), M++;
                } else if (N.isPointLight) {
                    const D = n.point[_];
                    D.position.setFromMatrixPosition(N.matrixWorld), D.position.applyMatrix4(T), _++;
                } else if (N.isHemisphereLight) {
                    const D = n.hemi[R];
                    D.direction.setFromMatrixPosition(N.matrixWorld), D.direction.transformDirection(T), R++;
                }
            }
        }
        return {
            setup: f,
            setupView: d,
            state: n
        };
    }
    function H1(r) {
        const e = new eO(r), t = [], n = [];
        function i(g) {
            p.camera = g, t.length = 0, n.length = 0;
        }
        function a(g) {
            t.push(g);
        }
        function l(g) {
            n.push(g);
        }
        function f() {
            e.setup(t);
        }
        function d(g) {
            e.setupView(t, g);
        }
        const p = {
            lightsArray: t,
            shadowsArray: n,
            camera: null,
            lights: e,
            transmissionRenderTarget: {}
        };
        return {
            init: i,
            state: p,
            setupLights: f,
            setupLightsView: d,
            pushLight: a,
            pushShadow: l
        };
    }
    function tO(r) {
        let e = new WeakMap;
        function t(i, a = 0) {
            const l = e.get(i);
            let f;
            return l === void 0 ? (f = new H1(r), e.set(i, [
                f
            ])) : a >= l.length ? (f = new H1(r), l.push(f)) : f = l[a], f;
        }
        function n() {
            e = new WeakMap;
        }
        return {
            get: t,
            dispose: n
        };
    }
    const nO = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, iO = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function sO(r, e, t) {
        let n = new Cd;
        const i = new Ie, a = new Ie, l = new gn, f = new WS({
            depthPacking: rT
        }), d = new ZS, p = {}, g = t.maxTextureSize, y = {
            [Wo]: sa,
            [sa]: Wo,
            [ka]: ka
        }, _ = new ao({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ie
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: nO,
            fragmentShader: iO
        }), x = _.clone();
        x.defines.HORIZONTAL_PASS = 1;
        const M = new Dt;
        M.setAttribute("position", new vn(new Float32Array([
            -1,
            -1,
            .5,
            3,
            -1,
            .5,
            -1,
            3,
            .5
        ]), 3));
        const R = new ai(M, _), T = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = dy;
        let E = this.type;
        this.render = function(O, P, F) {
            if (T.enabled === !1 || T.autoUpdate === !1 && T.needsUpdate === !1 || O.length === 0) return;
            const z = r.getRenderTarget(), L = r.getActiveCubeFace(), q = r.getActiveMipmapLevel(), oe = r.state;
            oe.setBlending(Ul), oe.buffers.color.setClear(1, 1, 1, 1), oe.buffers.depth.setTest(!0), oe.setScissorTest(!1);
            const se = E !== to && this.type === to, ge = E === to && this.type !== to;
            for(let _e = 0, H = O.length; _e < H; _e++){
                const K = O[_e], Q = K.shadow;
                if (Q === void 0) {
                    console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
                    continue;
                }
                if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue;
                i.copy(Q.mapSize);
                const fe = Q.getFrameExtents();
                if (i.multiply(fe), a.copy(Q.mapSize), (i.x > g || i.y > g) && (i.x > g && (a.x = Math.floor(g / fe.x), i.x = a.x * fe.x, Q.mapSize.x = a.x), i.y > g && (a.y = Math.floor(g / fe.y), i.y = a.y * fe.y, Q.mapSize.y = a.y)), Q.map === null || se === !0 || ge === !0) {
                    const $ = this.type !== to ? {
                        minFilter: cs,
                        magFilter: cs
                    } : {};
                    Q.map !== null && Q.map.dispose(), Q.map = new so(i.x, i.y, $), Q.map.texture.name = K.name + ".shadowMap", Q.camera.updateProjectionMatrix();
                }
                r.setRenderTarget(Q.map), r.clear();
                const X = Q.getViewportCount();
                for(let $ = 0; $ < X; $++){
                    const me = Q.getViewport($);
                    l.set(a.x * me.x, a.y * me.y, a.x * me.z, a.y * me.w), oe.viewport(l), Q.updateMatrices(K, $), n = Q.getFrustum(), D(P, F, Q.camera, K, this.type);
                }
                Q.isPointLightShadow !== !0 && this.type === to && C(Q, F), Q.needsUpdate = !1;
            }
            E = this.type, T.needsUpdate = !1, r.setRenderTarget(z, L, q);
        };
        function C(O, P) {
            const F = e.update(R);
            _.defines.VSM_SAMPLES !== O.blurSamples && (_.defines.VSM_SAMPLES = O.blurSamples, x.defines.VSM_SAMPLES = O.blurSamples, _.needsUpdate = !0, x.needsUpdate = !0), O.mapPass === null && (O.mapPass = new so(i.x, i.y)), _.uniforms.shadow_pass.value = O.map.texture, _.uniforms.resolution.value = O.mapSize, _.uniforms.radius.value = O.radius, r.setRenderTarget(O.mapPass), r.clear(), r.renderBufferDirect(P, null, F, _, R, null), x.uniforms.shadow_pass.value = O.mapPass.texture, x.uniforms.resolution.value = O.mapSize, x.uniforms.radius.value = O.radius, r.setRenderTarget(O.map), r.clear(), r.renderBufferDirect(P, null, F, x, R, null);
        }
        function N(O, P, F, z) {
            let L = null;
            const q = F.isPointLight === !0 ? O.customDistanceMaterial : O.customDepthMaterial;
            if (q !== void 0) L = q;
            else if (L = F.isPointLight === !0 ? d : f, r.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0 || P.alphaToCoverage === !0) {
                const oe = L.uuid, se = P.uuid;
                let ge = p[oe];
                ge === void 0 && (ge = {}, p[oe] = ge);
                let _e = ge[se];
                _e === void 0 && (_e = L.clone(), ge[se] = _e, P.addEventListener("dispose", I)), L = _e;
            }
            if (L.visible = P.visible, L.wireframe = P.wireframe, z === to ? L.side = P.shadowSide !== null ? P.shadowSide : P.side : L.side = P.shadowSide !== null ? P.shadowSide : y[P.side], L.alphaMap = P.alphaMap, L.alphaTest = P.alphaToCoverage === !0 ? .5 : P.alphaTest, L.map = P.map, L.clipShadows = P.clipShadows, L.clippingPlanes = P.clippingPlanes, L.clipIntersection = P.clipIntersection, L.displacementMap = P.displacementMap, L.displacementScale = P.displacementScale, L.displacementBias = P.displacementBias, L.wireframeLinewidth = P.wireframeLinewidth, L.linewidth = P.linewidth, F.isPointLight === !0 && L.isMeshDistanceMaterial === !0) {
                const oe = r.properties.get(L);
                oe.light = F;
            }
            return L;
        }
        function D(O, P, F, z, L) {
            if (O.visible === !1) return;
            if (O.layers.test(P.layers) && (O.isMesh || O.isLine || O.isPoints) && (O.castShadow || O.receiveShadow && L === to) && (!O.frustumCulled || n.intersectsObject(O))) {
                O.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, O.matrixWorld);
                const se = e.update(O), ge = O.material;
                if (Array.isArray(ge)) {
                    const _e = se.groups;
                    for(let H = 0, K = _e.length; H < K; H++){
                        const Q = _e[H], fe = ge[Q.materialIndex];
                        if (fe && fe.visible) {
                            const X = N(O, fe, z, L);
                            O.onBeforeShadow(r, O, P, F, se, X, Q), r.renderBufferDirect(F, null, se, X, O, Q), O.onAfterShadow(r, O, P, F, se, X, Q);
                        }
                    }
                } else if (ge.visible) {
                    const _e = N(O, ge, z, L);
                    O.onBeforeShadow(r, O, P, F, se, _e, null), r.renderBufferDirect(F, null, se, _e, O, null), O.onAfterShadow(r, O, P, F, se, _e, null);
                }
            }
            const oe = O.children;
            for(let se = 0, ge = oe.length; se < ge; se++)D(oe[se], P, F, z, L);
        }
        function I(O) {
            O.target.removeEventListener("dispose", I);
            for(const F in p){
                const z = p[F], L = O.target.uuid;
                L in z && (z[L].dispose(), delete z[L]);
            }
        }
    }
    const aO = {
        [Mv]: Ev,
        [Tv]: Rv,
        [Av]: Cv,
        [Ef]: wv,
        [Ev]: Mv,
        [Rv]: Tv,
        [Cv]: Av,
        [wv]: Ef
    };
    function rO(r, e) {
        function t() {
            let te = !1;
            const Qe = new gn;
            let Ve = null;
            const rt = new gn(0, 0, 0, 0);
            return {
                setMask: function(Ke) {
                    Ve !== Ke && !te && (r.colorMask(Ke, Ke, Ke, Ke), Ve = Ke);
                },
                setLocked: function(Ke) {
                    te = Ke;
                },
                setClear: function(Ke, Fe, ct, Mt, tn) {
                    tn === !0 && (Ke *= Mt, Fe *= Mt, ct *= Mt), Qe.set(Ke, Fe, ct, Mt), rt.equals(Qe) === !1 && (r.clearColor(Ke, Fe, ct, Mt), rt.copy(Qe));
                },
                reset: function() {
                    te = !1, Ve = null, rt.set(-1, 0, 0, 0);
                }
            };
        }
        function n() {
            let te = !1, Qe = !1, Ve = null, rt = null, Ke = null;
            return {
                setReversed: function(Fe) {
                    if (Qe !== Fe) {
                        const ct = e.get("EXT_clip_control");
                        Fe ? ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.ZERO_TO_ONE_EXT) : ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.NEGATIVE_ONE_TO_ONE_EXT), Qe = Fe;
                        const Mt = Ke;
                        Ke = null, this.setClear(Mt);
                    }
                },
                getReversed: function() {
                    return Qe;
                },
                setTest: function(Fe) {
                    Fe ? De(r.DEPTH_TEST) : Pe(r.DEPTH_TEST);
                },
                setMask: function(Fe) {
                    Ve !== Fe && !te && (r.depthMask(Fe), Ve = Fe);
                },
                setFunc: function(Fe) {
                    if (Qe && (Fe = aO[Fe]), rt !== Fe) {
                        switch(Fe){
                            case Mv:
                                r.depthFunc(r.NEVER);
                                break;
                            case Ev:
                                r.depthFunc(r.ALWAYS);
                                break;
                            case Tv:
                                r.depthFunc(r.LESS);
                                break;
                            case Ef:
                                r.depthFunc(r.LEQUAL);
                                break;
                            case Av:
                                r.depthFunc(r.EQUAL);
                                break;
                            case wv:
                                r.depthFunc(r.GEQUAL);
                                break;
                            case Rv:
                                r.depthFunc(r.GREATER);
                                break;
                            case Cv:
                                r.depthFunc(r.NOTEQUAL);
                                break;
                            default:
                                r.depthFunc(r.LEQUAL);
                        }
                        rt = Fe;
                    }
                },
                setLocked: function(Fe) {
                    te = Fe;
                },
                setClear: function(Fe) {
                    Ke !== Fe && (Qe && (Fe = 1 - Fe), r.clearDepth(Fe), Ke = Fe);
                },
                reset: function() {
                    te = !1, Ve = null, rt = null, Ke = null, Qe = !1;
                }
            };
        }
        function i() {
            let te = !1, Qe = null, Ve = null, rt = null, Ke = null, Fe = null, ct = null, Mt = null, tn = null;
            return {
                setTest: function(Zt) {
                    te || (Zt ? De(r.STENCIL_TEST) : Pe(r.STENCIL_TEST));
                },
                setMask: function(Zt) {
                    Qe !== Zt && !te && (r.stencilMask(Zt), Qe = Zt);
                },
                setFunc: function(Zt, gi, Zn) {
                    (Ve !== Zt || rt !== gi || Ke !== Zn) && (r.stencilFunc(Zt, gi, Zn), Ve = Zt, rt = gi, Ke = Zn);
                },
                setOp: function(Zt, gi, Zn) {
                    (Fe !== Zt || ct !== gi || Mt !== Zn) && (r.stencilOp(Zt, gi, Zn), Fe = Zt, ct = gi, Mt = Zn);
                },
                setLocked: function(Zt) {
                    te = Zt;
                },
                setClear: function(Zt) {
                    tn !== Zt && (r.clearStencil(Zt), tn = Zt);
                },
                reset: function() {
                    te = !1, Qe = null, Ve = null, rt = null, Ke = null, Fe = null, ct = null, Mt = null, tn = null;
                }
            };
        }
        const a = new t, l = new n, f = new i, d = new WeakMap, p = new WeakMap;
        let g = {}, y = {}, _ = new WeakMap, x = [], M = null, R = !1, T = null, E = null, C = null, N = null, D = null, I = null, O = null, P = new tt(0, 0, 0), F = 0, z = !1, L = null, q = null, oe = null, se = null, ge = null;
        const _e = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let H = !1, K = 0;
        const Q = r.getParameter(r.VERSION);
        Q.indexOf("WebGL") !== -1 ? (K = parseFloat(/^WebGL (\d)/.exec(Q)[1]), H = K >= 1) : Q.indexOf("OpenGL ES") !== -1 && (K = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), H = K >= 2);
        let fe = null, X = {};
        const $ = r.getParameter(r.SCISSOR_BOX), me = r.getParameter(r.VIEWPORT), ve = new gn().fromArray($), J = new gn().fromArray(me);
        function ue(te, Qe, Ve, rt) {
            const Ke = new Uint8Array(4), Fe = r.createTexture();
            r.bindTexture(te, Fe), r.texParameteri(te, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(te, r.TEXTURE_MAG_FILTER, r.NEAREST);
            for(let ct = 0; ct < Ve; ct++)te === r.TEXTURE_3D || te === r.TEXTURE_2D_ARRAY ? r.texImage3D(Qe, 0, r.RGBA, 1, 1, rt, 0, r.RGBA, r.UNSIGNED_BYTE, Ke) : r.texImage2D(Qe + ct, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ke);
            return Fe;
        }
        const he = {};
        he[r.TEXTURE_2D] = ue(r.TEXTURE_2D, r.TEXTURE_2D, 1), he[r.TEXTURE_CUBE_MAP] = ue(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), he[r.TEXTURE_2D_ARRAY] = ue(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), he[r.TEXTURE_3D] = ue(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), l.setClear(1), f.setClear(0), De(r.DEPTH_TEST), l.setFunc(Ef), Ye(!1), We(Qx), De(r.CULL_FACE), W(Ul);
        function De(te) {
            g[te] !== !0 && (r.enable(te), g[te] = !0);
        }
        function Pe(te) {
            g[te] !== !1 && (r.disable(te), g[te] = !1);
        }
        function _t(te, Qe) {
            return y[te] !== Qe ? (r.bindFramebuffer(te, Qe), y[te] = Qe, te === r.DRAW_FRAMEBUFFER && (y[r.FRAMEBUFFER] = Qe), te === r.FRAMEBUFFER && (y[r.DRAW_FRAMEBUFFER] = Qe), !0) : !1;
        }
        function xt(te, Qe) {
            let Ve = x, rt = !1;
            if (te) {
                Ve = _.get(Qe), Ve === void 0 && (Ve = [], _.set(Qe, Ve));
                const Ke = te.textures;
                if (Ve.length !== Ke.length || Ve[0] !== r.COLOR_ATTACHMENT0) {
                    for(let Fe = 0, ct = Ke.length; Fe < ct; Fe++)Ve[Fe] = r.COLOR_ATTACHMENT0 + Fe;
                    Ve.length = Ke.length, rt = !0;
                }
            } else Ve[0] !== r.BACK && (Ve[0] = r.BACK, rt = !0);
            rt && r.drawBuffers(Ve);
        }
        function on(te) {
            return M !== te ? (r.useProgram(te), M = te, !0) : !1;
        }
        const Vt = {
            [Fc]: r.FUNC_ADD,
            [CE]: r.FUNC_SUBTRACT,
            [DE]: r.FUNC_REVERSE_SUBTRACT
        };
        Vt[NE] = r.MIN, Vt[UE] = r.MAX;
        const Nt = {
            [LE]: r.ZERO,
            [OE]: r.ONE,
            [zE]: r.SRC_COLOR,
            [Sv]: r.SRC_ALPHA,
            [GE]: r.SRC_ALPHA_SATURATE,
            [HE]: r.DST_COLOR,
            [IE]: r.DST_ALPHA,
            [BE]: r.ONE_MINUS_SRC_COLOR,
            [bv]: r.ONE_MINUS_SRC_ALPHA,
            [FE]: r.ONE_MINUS_DST_COLOR,
            [PE]: r.ONE_MINUS_DST_ALPHA,
            [VE]: r.CONSTANT_COLOR,
            [kE]: r.ONE_MINUS_CONSTANT_COLOR,
            [XE]: r.CONSTANT_ALPHA,
            [jE]: r.ONE_MINUS_CONSTANT_ALPHA
        };
        function W(te, Qe, Ve, rt, Ke, Fe, ct, Mt, tn, Zt) {
            if (te === Ul) {
                R === !0 && (Pe(r.BLEND), R = !1);
                return;
            }
            if (R === !1 && (De(r.BLEND), R = !0), te !== RE) {
                if (te !== T || Zt !== z) {
                    if ((E !== Fc || D !== Fc) && (r.blendEquation(r.FUNC_ADD), E = Fc, D = Fc), Zt) switch(te){
                        case Sf:
                            r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Jx:
                            r.blendFunc(r.ONE, r.ONE);
                            break;
                        case $x:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case eS:
                            r.blendFuncSeparate(r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ZERO, r.ONE);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", te);
                            break;
                    }
                    else switch(te){
                        case Sf:
                            r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Jx:
                            r.blendFuncSeparate(r.SRC_ALPHA, r.ONE, r.ONE, r.ONE);
                            break;
                        case $x:
                            console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                            break;
                        case eS:
                            console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", te);
                            break;
                    }
                    C = null, N = null, I = null, O = null, P.set(0, 0, 0), F = 0, T = te, z = Zt;
                }
                return;
            }
            Ke = Ke || Qe, Fe = Fe || Ve, ct = ct || rt, (Qe !== E || Ke !== D) && (r.blendEquationSeparate(Vt[Qe], Vt[Ke]), E = Qe, D = Ke), (Ve !== C || rt !== N || Fe !== I || ct !== O) && (r.blendFuncSeparate(Nt[Ve], Nt[rt], Nt[Fe], Nt[ct]), C = Ve, N = rt, I = Fe, O = ct), (Mt.equals(P) === !1 || tn !== F) && (r.blendColor(Mt.r, Mt.g, Mt.b, tn), P.copy(Mt), F = tn), T = te, z = !1;
        }
        function et(te, Qe) {
            te.side === ka ? Pe(r.CULL_FACE) : De(r.CULL_FACE);
            let Ve = te.side === sa;
            Qe && (Ve = !Ve), Ye(Ve), te.blending === Sf && te.transparent === !1 ? W(Ul) : W(te.blending, te.blendEquation, te.blendSrc, te.blendDst, te.blendEquationAlpha, te.blendSrcAlpha, te.blendDstAlpha, te.blendColor, te.blendAlpha, te.premultipliedAlpha), l.setFunc(te.depthFunc), l.setTest(te.depthTest), l.setMask(te.depthWrite), a.setMask(te.colorWrite);
            const rt = te.stencilWrite;
            f.setTest(rt), rt && (f.setMask(te.stencilWriteMask), f.setFunc(te.stencilFunc, te.stencilRef, te.stencilFuncMask), f.setOp(te.stencilFail, te.stencilZFail, te.stencilZPass)), ut(te.polygonOffset, te.polygonOffsetFactor, te.polygonOffsetUnits), te.alphaToCoverage === !0 ? De(r.SAMPLE_ALPHA_TO_COVERAGE) : Pe(r.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function Ye(te) {
            L !== te && (te ? r.frontFace(r.CW) : r.frontFace(r.CCW), L = te);
        }
        function We(te) {
            te !== TE ? (De(r.CULL_FACE), te !== q && (te === Qx ? r.cullFace(r.BACK) : te === AE ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : Pe(r.CULL_FACE), q = te;
        }
        function Be(te) {
            te !== oe && (H && r.lineWidth(te), oe = te);
        }
        function ut(te, Qe, Ve) {
            te ? (De(r.POLYGON_OFFSET_FILL), (se !== Qe || ge !== Ve) && (r.polygonOffset(Qe, Ve), se = Qe, ge = Ve)) : Pe(r.POLYGON_OFFSET_FILL);
        }
        function Xe(te) {
            te ? De(r.SCISSOR_TEST) : Pe(r.SCISSOR_TEST);
        }
        function ot(te) {
            te === void 0 && (te = r.TEXTURE0 + _e - 1), fe !== te && (r.activeTexture(te), fe = te);
        }
        function It(te, Qe, Ve) {
            Ve === void 0 && (fe === null ? Ve = r.TEXTURE0 + _e - 1 : Ve = fe);
            let rt = X[Ve];
            rt === void 0 && (rt = {
                type: void 0,
                texture: void 0
            }, X[Ve] = rt), (rt.type !== te || rt.texture !== Qe) && (fe !== Ve && (r.activeTexture(Ve), fe = Ve), r.bindTexture(te, Qe || he[te]), rt.type = te, rt.texture = Qe);
        }
        function Z() {
            const te = X[fe];
            te !== void 0 && te.type !== void 0 && (r.bindTexture(te.type, null), te.type = void 0, te.texture = void 0);
        }
        function G() {
            try {
                r.compressedTexImage2D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function Se() {
            try {
                r.compressedTexImage3D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function Ue() {
            try {
                r.texSubImage2D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function Le() {
            try {
                r.texSubImage3D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function Ne() {
            try {
                r.compressedTexSubImage2D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function lt() {
            try {
                r.compressedTexSubImage3D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function it() {
            try {
                r.texStorage2D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function vt() {
            try {
                r.texStorage3D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function yt() {
            try {
                r.texImage2D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function He() {
            try {
                r.texImage3D(...arguments);
            } catch (te) {
                console.error("THREE.WebGLState:", te);
            }
        }
        function st(te) {
            ve.equals(te) === !1 && (r.scissor(te.x, te.y, te.z, te.w), ve.copy(te));
        }
        function St(te) {
            J.equals(te) === !1 && (r.viewport(te.x, te.y, te.z, te.w), J.copy(te));
        }
        function ie(te, Qe) {
            let Ve = p.get(Qe);
            Ve === void 0 && (Ve = new WeakMap, p.set(Qe, Ve));
            let rt = Ve.get(te);
            rt === void 0 && (rt = r.getUniformBlockIndex(Qe, te.name), Ve.set(te, rt));
        }
        function xe(te, Qe) {
            const rt = p.get(Qe).get(te);
            d.get(Qe) !== rt && (r.uniformBlockBinding(Qe, rt, te.__bindingPointIndex), d.set(Qe, rt));
        }
        function Ze() {
            r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), l.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), g = {}, fe = null, X = {}, y = {}, _ = new WeakMap, x = [], M = null, R = !1, T = null, E = null, C = null, N = null, D = null, I = null, O = null, P = new tt(0, 0, 0), F = 0, z = !1, L = null, q = null, oe = null, se = null, ge = null, ve.set(0, 0, r.canvas.width, r.canvas.height), J.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), l.reset(), f.reset();
        }
        return {
            buffers: {
                color: a,
                depth: l,
                stencil: f
            },
            enable: De,
            disable: Pe,
            bindFramebuffer: _t,
            drawBuffers: xt,
            useProgram: on,
            setBlending: W,
            setMaterial: et,
            setFlipSided: Ye,
            setCullFace: We,
            setLineWidth: Be,
            setPolygonOffset: ut,
            setScissorTest: Xe,
            activeTexture: ot,
            bindTexture: It,
            unbindTexture: Z,
            compressedTexImage2D: G,
            compressedTexImage3D: Se,
            texImage2D: yt,
            texImage3D: He,
            updateUBOMapping: ie,
            uniformBlockBinding: xe,
            texStorage2D: it,
            texStorage3D: vt,
            texSubImage2D: Ue,
            texSubImage3D: Le,
            compressedTexSubImage2D: Ne,
            compressedTexSubImage3D: lt,
            scissor: st,
            viewport: St,
            reset: Ze
        };
    }
    function oO(r, e, t, n, i, a, l) {
        const f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, d = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), p = new Ie, g = new WeakMap;
        let y;
        const _ = new WeakMap;
        let x = !1;
        try {
            x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch  {}
        function M(Z, G) {
            return x ? new OffscreenCanvas(Z, G) : Rm("canvas");
        }
        function R(Z, G, Se) {
            let Ue = 1;
            const Le = It(Z);
            if ((Le.width > Se || Le.height > Se) && (Ue = Se / Math.max(Le.width, Le.height)), Ue < 1) if (typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Z instanceof ImageBitmap || typeof VideoFrame < "u" && Z instanceof VideoFrame) {
                const Ne = Math.floor(Ue * Le.width), lt = Math.floor(Ue * Le.height);
                y === void 0 && (y = M(Ne, lt));
                const it = G ? M(Ne, lt) : y;
                return it.width = Ne, it.height = lt, it.getContext("2d").drawImage(Z, 0, 0, Ne, lt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Le.width + "x" + Le.height + ") to (" + Ne + "x" + lt + ")."), it;
            } else return "data" in Z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Le.width + "x" + Le.height + ")."), Z;
            return Z;
        }
        function T(Z) {
            return Z.generateMipmaps;
        }
        function E(Z) {
            r.generateMipmap(Z);
        }
        function C(Z) {
            return Z.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : Z.isWebGL3DRenderTarget ? r.TEXTURE_3D : Z.isWebGLArrayRenderTarget || Z.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
        }
        function N(Z, G, Se, Ue, Le = !1) {
            if (Z !== null) {
                if (r[Z] !== void 0) return r[Z];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Z + "'");
            }
            let Ne = G;
            if (G === r.RED && (Se === r.FLOAT && (Ne = r.R32F), Se === r.HALF_FLOAT && (Ne = r.R16F), Se === r.UNSIGNED_BYTE && (Ne = r.R8)), G === r.RED_INTEGER && (Se === r.UNSIGNED_BYTE && (Ne = r.R8UI), Se === r.UNSIGNED_SHORT && (Ne = r.R16UI), Se === r.UNSIGNED_INT && (Ne = r.R32UI), Se === r.BYTE && (Ne = r.R8I), Se === r.SHORT && (Ne = r.R16I), Se === r.INT && (Ne = r.R32I)), G === r.RG && (Se === r.FLOAT && (Ne = r.RG32F), Se === r.HALF_FLOAT && (Ne = r.RG16F), Se === r.UNSIGNED_BYTE && (Ne = r.RG8)), G === r.RG_INTEGER && (Se === r.UNSIGNED_BYTE && (Ne = r.RG8UI), Se === r.UNSIGNED_SHORT && (Ne = r.RG16UI), Se === r.UNSIGNED_INT && (Ne = r.RG32UI), Se === r.BYTE && (Ne = r.RG8I), Se === r.SHORT && (Ne = r.RG16I), Se === r.INT && (Ne = r.RG32I)), G === r.RGB_INTEGER && (Se === r.UNSIGNED_BYTE && (Ne = r.RGB8UI), Se === r.UNSIGNED_SHORT && (Ne = r.RGB16UI), Se === r.UNSIGNED_INT && (Ne = r.RGB32UI), Se === r.BYTE && (Ne = r.RGB8I), Se === r.SHORT && (Ne = r.RGB16I), Se === r.INT && (Ne = r.RGB32I)), G === r.RGBA_INTEGER && (Se === r.UNSIGNED_BYTE && (Ne = r.RGBA8UI), Se === r.UNSIGNED_SHORT && (Ne = r.RGBA16UI), Se === r.UNSIGNED_INT && (Ne = r.RGBA32UI), Se === r.BYTE && (Ne = r.RGBA8I), Se === r.SHORT && (Ne = r.RGBA16I), Se === r.INT && (Ne = r.RGBA32I)), G === r.RGB && Se === r.UNSIGNED_INT_5_9_9_9_REV && (Ne = r.RGB9_E5), G === r.RGBA) {
                const lt = Le ? Tm : Sn.getTransfer(Ue);
                Se === r.FLOAT && (Ne = r.RGBA32F), Se === r.HALF_FLOAT && (Ne = r.RGBA16F), Se === r.UNSIGNED_BYTE && (Ne = lt === Fn ? r.SRGB8_ALPHA8 : r.RGBA8), Se === r.UNSIGNED_SHORT_4_4_4_4 && (Ne = r.RGBA4), Se === r.UNSIGNED_SHORT_5_5_5_1 && (Ne = r.RGB5_A1);
            }
            return (Ne === r.R16F || Ne === r.R32F || Ne === r.RG16F || Ne === r.RG32F || Ne === r.RGBA16F || Ne === r.RGBA32F) && e.get("EXT_color_buffer_float"), Ne;
        }
        function D(Z, G) {
            let Se;
            return Z ? G === null || G === Il || G === md ? Se = r.DEPTH24_STENCIL8 : G === ia ? Se = r.DEPTH32F_STENCIL8 : G === pd && (Se = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : G === null || G === Il || G === md ? Se = r.DEPTH_COMPONENT24 : G === ia ? Se = r.DEPTH_COMPONENT32F : G === pd && (Se = r.DEPTH_COMPONENT16), Se;
        }
        function I(Z, G) {
            return T(Z) === !0 || Z.isFramebufferTexture && Z.minFilter !== cs && Z.minFilter !== pi ? Math.log2(Math.max(G.width, G.height)) + 1 : Z.mipmaps !== void 0 && Z.mipmaps.length > 0 ? Z.mipmaps.length : Z.isCompressedTexture && Array.isArray(Z.image) ? G.mipmaps.length : 1;
        }
        function O(Z) {
            const G = Z.target;
            G.removeEventListener("dispose", O), F(G), G.isVideoTexture && g.delete(G);
        }
        function P(Z) {
            const G = Z.target;
            G.removeEventListener("dispose", P), L(G);
        }
        function F(Z) {
            const G = n.get(Z);
            if (G.__webglInit === void 0) return;
            const Se = Z.source, Ue = _.get(Se);
            if (Ue) {
                const Le = Ue[G.__cacheKey];
                Le.usedTimes--, Le.usedTimes === 0 && z(Z), Object.keys(Ue).length === 0 && _.delete(Se);
            }
            n.remove(Z);
        }
        function z(Z) {
            const G = n.get(Z);
            r.deleteTexture(G.__webglTexture);
            const Se = Z.source, Ue = _.get(Se);
            delete Ue[G.__cacheKey], l.memory.textures--;
        }
        function L(Z) {
            const G = n.get(Z);
            if (Z.depthTexture && (Z.depthTexture.dispose(), n.remove(Z.depthTexture)), Z.isWebGLCubeRenderTarget) for(let Ue = 0; Ue < 6; Ue++){
                if (Array.isArray(G.__webglFramebuffer[Ue])) for(let Le = 0; Le < G.__webglFramebuffer[Ue].length; Le++)r.deleteFramebuffer(G.__webglFramebuffer[Ue][Le]);
                else r.deleteFramebuffer(G.__webglFramebuffer[Ue]);
                G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer[Ue]);
            }
            else {
                if (Array.isArray(G.__webglFramebuffer)) for(let Ue = 0; Ue < G.__webglFramebuffer.length; Ue++)r.deleteFramebuffer(G.__webglFramebuffer[Ue]);
                else r.deleteFramebuffer(G.__webglFramebuffer);
                if (G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer), G.__webglMultisampledFramebuffer && r.deleteFramebuffer(G.__webglMultisampledFramebuffer), G.__webglColorRenderbuffer) for(let Ue = 0; Ue < G.__webglColorRenderbuffer.length; Ue++)G.__webglColorRenderbuffer[Ue] && r.deleteRenderbuffer(G.__webglColorRenderbuffer[Ue]);
                G.__webglDepthRenderbuffer && r.deleteRenderbuffer(G.__webglDepthRenderbuffer);
            }
            const Se = Z.textures;
            for(let Ue = 0, Le = Se.length; Ue < Le; Ue++){
                const Ne = n.get(Se[Ue]);
                Ne.__webglTexture && (r.deleteTexture(Ne.__webglTexture), l.memory.textures--), n.remove(Se[Ue]);
            }
            n.remove(Z);
        }
        let q = 0;
        function oe() {
            q = 0;
        }
        function se() {
            const Z = q;
            return Z >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Z + " texture units while this GPU supports only " + i.maxTextures), q += 1, Z;
        }
        function ge(Z) {
            const G = [];
            return G.push(Z.wrapS), G.push(Z.wrapT), G.push(Z.wrapR || 0), G.push(Z.magFilter), G.push(Z.minFilter), G.push(Z.anisotropy), G.push(Z.internalFormat), G.push(Z.format), G.push(Z.type), G.push(Z.generateMipmaps), G.push(Z.premultiplyAlpha), G.push(Z.flipY), G.push(Z.unpackAlignment), G.push(Z.colorSpace), G.join();
        }
        function _e(Z, G) {
            const Se = n.get(Z);
            if (Z.isVideoTexture && Xe(Z), Z.isRenderTargetTexture === !1 && Z.version > 0 && Se.__version !== Z.version) {
                const Ue = Z.image;
                if (Ue === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (Ue.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    he(Se, Z, G);
                    return;
                }
            }
            t.bindTexture(r.TEXTURE_2D, Se.__webglTexture, r.TEXTURE0 + G);
        }
        function H(Z, G) {
            const Se = n.get(Z);
            if (Z.version > 0 && Se.__version !== Z.version) {
                he(Se, Z, G);
                return;
            }
            t.bindTexture(r.TEXTURE_2D_ARRAY, Se.__webglTexture, r.TEXTURE0 + G);
        }
        function K(Z, G) {
            const Se = n.get(Z);
            if (Z.version > 0 && Se.__version !== Z.version) {
                he(Se, Z, G);
                return;
            }
            t.bindTexture(r.TEXTURE_3D, Se.__webglTexture, r.TEXTURE0 + G);
        }
        function Q(Z, G) {
            const Se = n.get(Z);
            if (Z.version > 0 && Se.__version !== Z.version) {
                De(Se, Z, G);
                return;
            }
            t.bindTexture(r.TEXTURE_CUBE_MAP, Se.__webglTexture, r.TEXTURE0 + G);
        }
        const fe = {
            [Zo]: r.REPEAT,
            [na]: r.CLAMP_TO_EDGE,
            [dd]: r.MIRRORED_REPEAT
        }, X = {
            [cs]: r.NEAREST,
            [my]: r.NEAREST_MIPMAP_NEAREST,
            [gf]: r.NEAREST_MIPMAP_LINEAR,
            [pi]: r.LINEAR,
            [rd]: r.LINEAR_MIPMAP_NEAREST,
            [Xa]: r.LINEAR_MIPMAP_LINEAR
        }, $ = {
            [lT]: r.NEVER,
            [pT]: r.ALWAYS,
            [cT]: r.LESS,
            [LS]: r.LEQUAL,
            [uT]: r.EQUAL,
            [dT]: r.GEQUAL,
            [fT]: r.GREATER,
            [hT]: r.NOTEQUAL
        };
        function me(Z, G) {
            if (G.type === ia && e.has("OES_texture_float_linear") === !1 && (G.magFilter === pi || G.magFilter === rd || G.magFilter === gf || G.magFilter === Xa || G.minFilter === pi || G.minFilter === rd || G.minFilter === gf || G.minFilter === Xa) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(Z, r.TEXTURE_WRAP_S, fe[G.wrapS]), r.texParameteri(Z, r.TEXTURE_WRAP_T, fe[G.wrapT]), (Z === r.TEXTURE_3D || Z === r.TEXTURE_2D_ARRAY) && r.texParameteri(Z, r.TEXTURE_WRAP_R, fe[G.wrapR]), r.texParameteri(Z, r.TEXTURE_MAG_FILTER, X[G.magFilter]), r.texParameteri(Z, r.TEXTURE_MIN_FILTER, X[G.minFilter]), G.compareFunction && (r.texParameteri(Z, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(Z, r.TEXTURE_COMPARE_FUNC, $[G.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                if (G.magFilter === cs || G.minFilter !== gf && G.minFilter !== Xa || G.type === ia && e.has("OES_texture_float_linear") === !1) return;
                if (G.anisotropy > 1 || n.get(G).__currentAnisotropy) {
                    const Se = e.get("EXT_texture_filter_anisotropic");
                    r.texParameterf(Z, Se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, i.getMaxAnisotropy())), n.get(G).__currentAnisotropy = G.anisotropy;
                }
            }
        }
        function ve(Z, G) {
            let Se = !1;
            Z.__webglInit === void 0 && (Z.__webglInit = !0, G.addEventListener("dispose", O));
            const Ue = G.source;
            let Le = _.get(Ue);
            Le === void 0 && (Le = {}, _.set(Ue, Le));
            const Ne = ge(G);
            if (Ne !== Z.__cacheKey) {
                Le[Ne] === void 0 && (Le[Ne] = {
                    texture: r.createTexture(),
                    usedTimes: 0
                }, l.memory.textures++, Se = !0), Le[Ne].usedTimes++;
                const lt = Le[Z.__cacheKey];
                lt !== void 0 && (Le[Z.__cacheKey].usedTimes--, lt.usedTimes === 0 && z(G)), Z.__cacheKey = Ne, Z.__webglTexture = Le[Ne].texture;
            }
            return Se;
        }
        function J(Z, G, Se) {
            return Math.floor(Math.floor(Z / Se) / G);
        }
        function ue(Z, G, Se, Ue) {
            const Ne = Z.updateRanges;
            if (Ne.length === 0) t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, G.width, G.height, Se, Ue, G.data);
            else {
                Ne.sort((He, st)=>He.start - st.start);
                let lt = 0;
                for(let He = 1; He < Ne.length; He++){
                    const st = Ne[lt], St = Ne[He], ie = st.start + st.count, xe = J(St.start, G.width, 4), Ze = J(st.start, G.width, 4);
                    St.start <= ie + 1 && xe === Ze && J(St.start + St.count - 1, G.width, 4) === xe ? st.count = Math.max(st.count, St.start + St.count - st.start) : (++lt, Ne[lt] = St);
                }
                Ne.length = lt + 1;
                const it = r.getParameter(r.UNPACK_ROW_LENGTH), vt = r.getParameter(r.UNPACK_SKIP_PIXELS), yt = r.getParameter(r.UNPACK_SKIP_ROWS);
                r.pixelStorei(r.UNPACK_ROW_LENGTH, G.width);
                for(let He = 0, st = Ne.length; He < st; He++){
                    const St = Ne[He], ie = Math.floor(St.start / 4), xe = Math.ceil(St.count / 4), Ze = ie % G.width, te = Math.floor(ie / G.width), Qe = xe, Ve = 1;
                    r.pixelStorei(r.UNPACK_SKIP_PIXELS, Ze), r.pixelStorei(r.UNPACK_SKIP_ROWS, te), t.texSubImage2D(r.TEXTURE_2D, 0, Ze, te, Qe, Ve, Se, Ue, G.data);
                }
                Z.clearUpdateRanges(), r.pixelStorei(r.UNPACK_ROW_LENGTH, it), r.pixelStorei(r.UNPACK_SKIP_PIXELS, vt), r.pixelStorei(r.UNPACK_SKIP_ROWS, yt);
            }
        }
        function he(Z, G, Se) {
            let Ue = r.TEXTURE_2D;
            (G.isDataArrayTexture || G.isCompressedArrayTexture) && (Ue = r.TEXTURE_2D_ARRAY), G.isData3DTexture && (Ue = r.TEXTURE_3D);
            const Le = ve(Z, G), Ne = G.source;
            t.bindTexture(Ue, Z.__webglTexture, r.TEXTURE0 + Se);
            const lt = n.get(Ne);
            if (Ne.version !== lt.__version || Le === !0) {
                t.activeTexture(r.TEXTURE0 + Se);
                const it = Sn.getPrimaries(Sn.workingColorSpace), vt = G.colorSpace === Dl ? null : Sn.getPrimaries(G.colorSpace), yt = G.colorSpace === Dl || it === vt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, yt);
                let He = R(G.image, !1, i.maxTextureSize);
                He = ot(G, He);
                const st = a.convert(G.format, G.colorSpace), St = a.convert(G.type);
                let ie = N(G.internalFormat, st, St, G.colorSpace, G.isVideoTexture);
                me(Ue, G);
                let xe;
                const Ze = G.mipmaps, te = G.isVideoTexture !== !0, Qe = lt.__version === void 0 || Le === !0, Ve = Ne.dataReady, rt = I(G, He);
                if (G.isDepthTexture) ie = D(G.format === vd, G.type), Qe && (te ? t.texStorage2D(r.TEXTURE_2D, 1, ie, He.width, He.height) : t.texImage2D(r.TEXTURE_2D, 0, ie, He.width, He.height, 0, st, St, null));
                else if (G.isDataTexture) if (Ze.length > 0) {
                    te && Qe && t.texStorage2D(r.TEXTURE_2D, rt, ie, Ze[0].width, Ze[0].height);
                    for(let Ke = 0, Fe = Ze.length; Ke < Fe; Ke++)xe = Ze[Ke], te ? Ve && t.texSubImage2D(r.TEXTURE_2D, Ke, 0, 0, xe.width, xe.height, st, St, xe.data) : t.texImage2D(r.TEXTURE_2D, Ke, ie, xe.width, xe.height, 0, st, St, xe.data);
                    G.generateMipmaps = !1;
                } else te ? (Qe && t.texStorage2D(r.TEXTURE_2D, rt, ie, He.width, He.height), Ve && ue(G, He, st, St)) : t.texImage2D(r.TEXTURE_2D, 0, ie, He.width, He.height, 0, st, St, He.data);
                else if (G.isCompressedTexture) if (G.isCompressedArrayTexture) {
                    te && Qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, rt, ie, Ze[0].width, Ze[0].height, He.depth);
                    for(let Ke = 0, Fe = Ze.length; Ke < Fe; Ke++)if (xe = Ze[Ke], G.format !== Is) if (st !== null) if (te) {
                        if (Ve) if (G.layerUpdates.size > 0) {
                            const ct = uS(xe.width, xe.height, G.format, G.type);
                            for (const Mt of G.layerUpdates){
                                const tn = xe.data.subarray(Mt * ct / xe.data.BYTES_PER_ELEMENT, (Mt + 1) * ct / xe.data.BYTES_PER_ELEMENT);
                                t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Ke, 0, 0, Mt, xe.width, xe.height, 1, st, tn);
                            }
                            G.clearLayerUpdates();
                        } else t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Ke, 0, 0, 0, xe.width, xe.height, He.depth, st, xe.data);
                    } else t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, Ke, ie, xe.width, xe.height, He.depth, 0, xe.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else te ? Ve && t.texSubImage3D(r.TEXTURE_2D_ARRAY, Ke, 0, 0, 0, xe.width, xe.height, He.depth, st, St, xe.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, Ke, ie, xe.width, xe.height, He.depth, 0, st, St, xe.data);
                } else {
                    te && Qe && t.texStorage2D(r.TEXTURE_2D, rt, ie, Ze[0].width, Ze[0].height);
                    for(let Ke = 0, Fe = Ze.length; Ke < Fe; Ke++)xe = Ze[Ke], G.format !== Is ? st !== null ? te ? Ve && t.compressedTexSubImage2D(r.TEXTURE_2D, Ke, 0, 0, xe.width, xe.height, st, xe.data) : t.compressedTexImage2D(r.TEXTURE_2D, Ke, ie, xe.width, xe.height, 0, xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : te ? Ve && t.texSubImage2D(r.TEXTURE_2D, Ke, 0, 0, xe.width, xe.height, st, St, xe.data) : t.texImage2D(r.TEXTURE_2D, Ke, ie, xe.width, xe.height, 0, st, St, xe.data);
                }
                else if (G.isDataArrayTexture) if (te) {
                    if (Qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, rt, ie, He.width, He.height, He.depth), Ve) if (G.layerUpdates.size > 0) {
                        const Ke = uS(He.width, He.height, G.format, G.type);
                        for (const Fe of G.layerUpdates){
                            const ct = He.data.subarray(Fe * Ke / He.data.BYTES_PER_ELEMENT, (Fe + 1) * Ke / He.data.BYTES_PER_ELEMENT);
                            t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Fe, He.width, He.height, 1, st, St, ct);
                        }
                        G.clearLayerUpdates();
                    } else t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, He.width, He.height, He.depth, st, St, He.data);
                } else t.texImage3D(r.TEXTURE_2D_ARRAY, 0, ie, He.width, He.height, He.depth, 0, st, St, He.data);
                else if (G.isData3DTexture) te ? (Qe && t.texStorage3D(r.TEXTURE_3D, rt, ie, He.width, He.height, He.depth), Ve && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, He.width, He.height, He.depth, st, St, He.data)) : t.texImage3D(r.TEXTURE_3D, 0, ie, He.width, He.height, He.depth, 0, st, St, He.data);
                else if (G.isFramebufferTexture) {
                    if (Qe) if (te) t.texStorage2D(r.TEXTURE_2D, rt, ie, He.width, He.height);
                    else {
                        let Ke = He.width, Fe = He.height;
                        for(let ct = 0; ct < rt; ct++)t.texImage2D(r.TEXTURE_2D, ct, ie, Ke, Fe, 0, st, St, null), Ke >>= 1, Fe >>= 1;
                    }
                } else if (Ze.length > 0) {
                    if (te && Qe) {
                        const Ke = It(Ze[0]);
                        t.texStorage2D(r.TEXTURE_2D, rt, ie, Ke.width, Ke.height);
                    }
                    for(let Ke = 0, Fe = Ze.length; Ke < Fe; Ke++)xe = Ze[Ke], te ? Ve && t.texSubImage2D(r.TEXTURE_2D, Ke, 0, 0, st, St, xe) : t.texImage2D(r.TEXTURE_2D, Ke, ie, st, St, xe);
                    G.generateMipmaps = !1;
                } else if (te) {
                    if (Qe) {
                        const Ke = It(He);
                        t.texStorage2D(r.TEXTURE_2D, rt, ie, Ke.width, Ke.height);
                    }
                    Ve && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, st, St, He);
                } else t.texImage2D(r.TEXTURE_2D, 0, ie, st, St, He);
                T(G) && E(Ue), lt.__version = Ne.version, G.onUpdate && G.onUpdate(G);
            }
            Z.__version = G.version;
        }
        function De(Z, G, Se) {
            if (G.image.length !== 6) return;
            const Ue = ve(Z, G), Le = G.source;
            t.bindTexture(r.TEXTURE_CUBE_MAP, Z.__webglTexture, r.TEXTURE0 + Se);
            const Ne = n.get(Le);
            if (Le.version !== Ne.__version || Ue === !0) {
                t.activeTexture(r.TEXTURE0 + Se);
                const lt = Sn.getPrimaries(Sn.workingColorSpace), it = G.colorSpace === Dl ? null : Sn.getPrimaries(G.colorSpace), vt = G.colorSpace === Dl || lt === it ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, vt);
                const yt = G.isCompressedTexture || G.image[0].isCompressedTexture, He = G.image[0] && G.image[0].isDataTexture, st = [];
                for(let Fe = 0; Fe < 6; Fe++)!yt && !He ? st[Fe] = R(G.image[Fe], !0, i.maxCubemapSize) : st[Fe] = He ? G.image[Fe].image : G.image[Fe], st[Fe] = ot(G, st[Fe]);
                const St = st[0], ie = a.convert(G.format, G.colorSpace), xe = a.convert(G.type), Ze = N(G.internalFormat, ie, xe, G.colorSpace), te = G.isVideoTexture !== !0, Qe = Ne.__version === void 0 || Ue === !0, Ve = Le.dataReady;
                let rt = I(G, St);
                me(r.TEXTURE_CUBE_MAP, G);
                let Ke;
                if (yt) {
                    te && Qe && t.texStorage2D(r.TEXTURE_CUBE_MAP, rt, Ze, St.width, St.height);
                    for(let Fe = 0; Fe < 6; Fe++){
                        Ke = st[Fe].mipmaps;
                        for(let ct = 0; ct < Ke.length; ct++){
                            const Mt = Ke[ct];
                            G.format !== Is ? ie !== null ? te ? Ve && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct, 0, 0, Mt.width, Mt.height, ie, Mt.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct, Ze, Mt.width, Mt.height, 0, Mt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : te ? Ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct, 0, 0, Mt.width, Mt.height, ie, xe, Mt.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct, Ze, Mt.width, Mt.height, 0, ie, xe, Mt.data);
                        }
                    }
                } else {
                    if (Ke = G.mipmaps, te && Qe) {
                        Ke.length > 0 && rt++;
                        const Fe = It(st[0]);
                        t.texStorage2D(r.TEXTURE_CUBE_MAP, rt, Ze, Fe.width, Fe.height);
                    }
                    for(let Fe = 0; Fe < 6; Fe++)if (He) {
                        te ? Ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, 0, 0, st[Fe].width, st[Fe].height, ie, xe, st[Fe].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, Ze, st[Fe].width, st[Fe].height, 0, ie, xe, st[Fe].data);
                        for(let ct = 0; ct < Ke.length; ct++){
                            const tn = Ke[ct].image[Fe].image;
                            te ? Ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct + 1, 0, 0, tn.width, tn.height, ie, xe, tn.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct + 1, Ze, tn.width, tn.height, 0, ie, xe, tn.data);
                        }
                    } else {
                        te ? Ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, 0, 0, ie, xe, st[Fe]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, Ze, ie, xe, st[Fe]);
                        for(let ct = 0; ct < Ke.length; ct++){
                            const Mt = Ke[ct];
                            te ? Ve && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct + 1, 0, 0, ie, xe, Mt.image[Fe]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ct + 1, Ze, ie, xe, Mt.image[Fe]);
                        }
                    }
                }
                T(G) && E(r.TEXTURE_CUBE_MAP), Ne.__version = Le.version, G.onUpdate && G.onUpdate(G);
            }
            Z.__version = G.version;
        }
        function Pe(Z, G, Se, Ue, Le, Ne) {
            const lt = a.convert(Se.format, Se.colorSpace), it = a.convert(Se.type), vt = N(Se.internalFormat, lt, it, Se.colorSpace), yt = n.get(G), He = n.get(Se);
            if (He.__renderTarget = G, !yt.__hasExternalTextures) {
                const st = Math.max(1, G.width >> Ne), St = Math.max(1, G.height >> Ne);
                Le === r.TEXTURE_3D || Le === r.TEXTURE_2D_ARRAY ? t.texImage3D(Le, Ne, vt, st, St, G.depth, 0, lt, it, null) : t.texImage2D(Le, Ne, vt, st, St, 0, lt, it, null);
            }
            t.bindFramebuffer(r.FRAMEBUFFER, Z), ut(G) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Ue, Le, He.__webglTexture, 0, Be(G)) : (Le === r.TEXTURE_2D || Le >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Le <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Ue, Le, He.__webglTexture, Ne), t.bindFramebuffer(r.FRAMEBUFFER, null);
        }
        function _t(Z, G, Se) {
            if (r.bindRenderbuffer(r.RENDERBUFFER, Z), G.depthBuffer) {
                const Ue = G.depthTexture, Le = Ue && Ue.isDepthTexture ? Ue.type : null, Ne = D(G.stencilBuffer, Le), lt = G.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, it = Be(G);
                ut(G) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, it, Ne, G.width, G.height) : Se ? r.renderbufferStorageMultisample(r.RENDERBUFFER, it, Ne, G.width, G.height) : r.renderbufferStorage(r.RENDERBUFFER, Ne, G.width, G.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, lt, r.RENDERBUFFER, Z);
            } else {
                const Ue = G.textures;
                for(let Le = 0; Le < Ue.length; Le++){
                    const Ne = Ue[Le], lt = a.convert(Ne.format, Ne.colorSpace), it = a.convert(Ne.type), vt = N(Ne.internalFormat, lt, it, Ne.colorSpace), yt = Be(G);
                    Se && ut(G) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, yt, vt, G.width, G.height) : ut(G) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, yt, vt, G.width, G.height) : r.renderbufferStorage(r.RENDERBUFFER, vt, G.width, G.height);
                }
            }
            r.bindRenderbuffer(r.RENDERBUFFER, null);
        }
        function xt(Z, G) {
            if (G && G.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(r.FRAMEBUFFER, Z), !(G.depthTexture && G.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            const Ue = n.get(G.depthTexture);
            Ue.__renderTarget = G, (!Ue.__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), _e(G.depthTexture, 0);
            const Le = Ue.__webglTexture, Ne = Be(G);
            if (G.depthTexture.format === gd) ut(G) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Le, 0, Ne) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Le, 0);
            else if (G.depthTexture.format === vd) ut(G) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Le, 0, Ne) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Le, 0);
            else throw new Error("Unknown depthTexture format");
        }
        function on(Z) {
            const G = n.get(Z), Se = Z.isWebGLCubeRenderTarget === !0;
            if (G.__boundDepthTexture !== Z.depthTexture) {
                const Ue = Z.depthTexture;
                if (G.__depthDisposeCallback && G.__depthDisposeCallback(), Ue) {
                    const Le = ()=>{
                        delete G.__boundDepthTexture, delete G.__depthDisposeCallback, Ue.removeEventListener("dispose", Le);
                    };
                    Ue.addEventListener("dispose", Le), G.__depthDisposeCallback = Le;
                }
                G.__boundDepthTexture = Ue;
            }
            if (Z.depthTexture && !G.__autoAllocateDepthBuffer) {
                if (Se) throw new Error("target.depthTexture not supported in Cube render targets");
                const Ue = Z.texture.mipmaps;
                Ue && Ue.length > 0 ? xt(G.__webglFramebuffer[0], Z) : xt(G.__webglFramebuffer, Z);
            } else if (Se) {
                G.__webglDepthbuffer = [];
                for(let Ue = 0; Ue < 6; Ue++)if (t.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer[Ue]), G.__webglDepthbuffer[Ue] === void 0) G.__webglDepthbuffer[Ue] = r.createRenderbuffer(), _t(G.__webglDepthbuffer[Ue], Z, !1);
                else {
                    const Le = Z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ne = G.__webglDepthbuffer[Ue];
                    r.bindRenderbuffer(r.RENDERBUFFER, Ne), r.framebufferRenderbuffer(r.FRAMEBUFFER, Le, r.RENDERBUFFER, Ne);
                }
            } else {
                const Ue = Z.texture.mipmaps;
                if (Ue && Ue.length > 0 ? t.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer[0]) : t.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer === void 0) G.__webglDepthbuffer = r.createRenderbuffer(), _t(G.__webglDepthbuffer, Z, !1);
                else {
                    const Le = Z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ne = G.__webglDepthbuffer;
                    r.bindRenderbuffer(r.RENDERBUFFER, Ne), r.framebufferRenderbuffer(r.FRAMEBUFFER, Le, r.RENDERBUFFER, Ne);
                }
            }
            t.bindFramebuffer(r.FRAMEBUFFER, null);
        }
        function Vt(Z, G, Se) {
            const Ue = n.get(Z);
            G !== void 0 && Pe(Ue.__webglFramebuffer, Z, Z.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), Se !== void 0 && on(Z);
        }
        function Nt(Z) {
            const G = Z.texture, Se = n.get(Z), Ue = n.get(G);
            Z.addEventListener("dispose", P);
            const Le = Z.textures, Ne = Z.isWebGLCubeRenderTarget === !0, lt = Le.length > 1;
            if (lt || (Ue.__webglTexture === void 0 && (Ue.__webglTexture = r.createTexture()), Ue.__version = G.version, l.memory.textures++), Ne) {
                Se.__webglFramebuffer = [];
                for(let it = 0; it < 6; it++)if (G.mipmaps && G.mipmaps.length > 0) {
                    Se.__webglFramebuffer[it] = [];
                    for(let vt = 0; vt < G.mipmaps.length; vt++)Se.__webglFramebuffer[it][vt] = r.createFramebuffer();
                } else Se.__webglFramebuffer[it] = r.createFramebuffer();
            } else {
                if (G.mipmaps && G.mipmaps.length > 0) {
                    Se.__webglFramebuffer = [];
                    for(let it = 0; it < G.mipmaps.length; it++)Se.__webglFramebuffer[it] = r.createFramebuffer();
                } else Se.__webglFramebuffer = r.createFramebuffer();
                if (lt) for(let it = 0, vt = Le.length; it < vt; it++){
                    const yt = n.get(Le[it]);
                    yt.__webglTexture === void 0 && (yt.__webglTexture = r.createTexture(), l.memory.textures++);
                }
                if (Z.samples > 0 && ut(Z) === !1) {
                    Se.__webglMultisampledFramebuffer = r.createFramebuffer(), Se.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, Se.__webglMultisampledFramebuffer);
                    for(let it = 0; it < Le.length; it++){
                        const vt = Le[it];
                        Se.__webglColorRenderbuffer[it] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, Se.__webglColorRenderbuffer[it]);
                        const yt = a.convert(vt.format, vt.colorSpace), He = a.convert(vt.type), st = N(vt.internalFormat, yt, He, vt.colorSpace, Z.isXRRenderTarget === !0), St = Be(Z);
                        r.renderbufferStorageMultisample(r.RENDERBUFFER, St, st, Z.width, Z.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + it, r.RENDERBUFFER, Se.__webglColorRenderbuffer[it]);
                    }
                    r.bindRenderbuffer(r.RENDERBUFFER, null), Z.depthBuffer && (Se.__webglDepthRenderbuffer = r.createRenderbuffer(), _t(Se.__webglDepthRenderbuffer, Z, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null);
                }
            }
            if (Ne) {
                t.bindTexture(r.TEXTURE_CUBE_MAP, Ue.__webglTexture), me(r.TEXTURE_CUBE_MAP, G);
                for(let it = 0; it < 6; it++)if (G.mipmaps && G.mipmaps.length > 0) for(let vt = 0; vt < G.mipmaps.length; vt++)Pe(Se.__webglFramebuffer[it][vt], Z, G, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + it, vt);
                else Pe(Se.__webglFramebuffer[it], Z, G, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + it, 0);
                T(G) && E(r.TEXTURE_CUBE_MAP), t.unbindTexture();
            } else if (lt) {
                for(let it = 0, vt = Le.length; it < vt; it++){
                    const yt = Le[it], He = n.get(yt);
                    t.bindTexture(r.TEXTURE_2D, He.__webglTexture), me(r.TEXTURE_2D, yt), Pe(Se.__webglFramebuffer, Z, yt, r.COLOR_ATTACHMENT0 + it, r.TEXTURE_2D, 0), T(yt) && E(r.TEXTURE_2D);
                }
                t.unbindTexture();
            } else {
                let it = r.TEXTURE_2D;
                if ((Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) && (it = Z.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(it, Ue.__webglTexture), me(it, G), G.mipmaps && G.mipmaps.length > 0) for(let vt = 0; vt < G.mipmaps.length; vt++)Pe(Se.__webglFramebuffer[vt], Z, G, r.COLOR_ATTACHMENT0, it, vt);
                else Pe(Se.__webglFramebuffer, Z, G, r.COLOR_ATTACHMENT0, it, 0);
                T(G) && E(it), t.unbindTexture();
            }
            Z.depthBuffer && on(Z);
        }
        function W(Z) {
            const G = Z.textures;
            for(let Se = 0, Ue = G.length; Se < Ue; Se++){
                const Le = G[Se];
                if (T(Le)) {
                    const Ne = C(Z), lt = n.get(Le).__webglTexture;
                    t.bindTexture(Ne, lt), E(Ne), t.unbindTexture();
                }
            }
        }
        const et = [], Ye = [];
        function We(Z) {
            if (Z.samples > 0) {
                if (ut(Z) === !1) {
                    const G = Z.textures, Se = Z.width, Ue = Z.height;
                    let Le = r.COLOR_BUFFER_BIT;
                    const Ne = Z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, lt = n.get(Z), it = G.length > 1;
                    if (it) for(let yt = 0; yt < G.length; yt++)t.bindFramebuffer(r.FRAMEBUFFER, lt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + yt, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, lt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + yt, r.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(r.READ_FRAMEBUFFER, lt.__webglMultisampledFramebuffer);
                    const vt = Z.texture.mipmaps;
                    vt && vt.length > 0 ? t.bindFramebuffer(r.DRAW_FRAMEBUFFER, lt.__webglFramebuffer[0]) : t.bindFramebuffer(r.DRAW_FRAMEBUFFER, lt.__webglFramebuffer);
                    for(let yt = 0; yt < G.length; yt++){
                        if (Z.resolveDepthBuffer && (Z.depthBuffer && (Le |= r.DEPTH_BUFFER_BIT), Z.stencilBuffer && Z.resolveStencilBuffer && (Le |= r.STENCIL_BUFFER_BIT)), it) {
                            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, lt.__webglColorRenderbuffer[yt]);
                            const He = n.get(G[yt]).__webglTexture;
                            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, He, 0);
                        }
                        r.blitFramebuffer(0, 0, Se, Ue, 0, 0, Se, Ue, Le, r.NEAREST), d === !0 && (et.length = 0, Ye.length = 0, et.push(r.COLOR_ATTACHMENT0 + yt), Z.depthBuffer && Z.resolveDepthBuffer === !1 && (et.push(Ne), Ye.push(Ne), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Ye)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, et));
                    }
                    if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), it) for(let yt = 0; yt < G.length; yt++){
                        t.bindFramebuffer(r.FRAMEBUFFER, lt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + yt, r.RENDERBUFFER, lt.__webglColorRenderbuffer[yt]);
                        const He = n.get(G[yt]).__webglTexture;
                        t.bindFramebuffer(r.FRAMEBUFFER, lt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + yt, r.TEXTURE_2D, He, 0);
                    }
                    t.bindFramebuffer(r.DRAW_FRAMEBUFFER, lt.__webglMultisampledFramebuffer);
                } else if (Z.depthBuffer && Z.resolveDepthBuffer === !1 && d) {
                    const G = Z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [
                        G
                    ]);
                }
            }
        }
        function Be(Z) {
            return Math.min(i.maxSamples, Z.samples);
        }
        function ut(Z) {
            const G = n.get(Z);
            return Z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1;
        }
        function Xe(Z) {
            const G = l.render.frame;
            g.get(Z) !== G && (g.set(Z, G), Z.update());
        }
        function ot(Z, G) {
            const Se = Z.colorSpace, Ue = Z.format, Le = Z.type;
            return Z.isCompressedTexture === !0 || Z.isVideoTexture === !0 || Se !== qc && Se !== Dl && (Sn.getTransfer(Se) === Fn ? (Ue !== Is || Le !== br) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Se)), G;
        }
        function It(Z) {
            return typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement ? (p.width = Z.naturalWidth || Z.width, p.height = Z.naturalHeight || Z.height) : typeof VideoFrame < "u" && Z instanceof VideoFrame ? (p.width = Z.displayWidth, p.height = Z.displayHeight) : (p.width = Z.width, p.height = Z.height), p;
        }
        this.allocateTextureUnit = se, this.resetTextureUnits = oe, this.setTexture2D = _e, this.setTexture2DArray = H, this.setTexture3D = K, this.setTextureCube = Q, this.rebindTextures = Vt, this.setupRenderTarget = Nt, this.updateRenderTargetMipmap = W, this.updateMultisampleRenderTarget = We, this.setupDepthRenderbuffer = on, this.setupFrameBufferTexture = Pe, this.useMultisampledRTT = ut;
    }
    function gA(r, e) {
        function t(n, i = Dl) {
            let a;
            const l = Sn.getTransfer(i);
            if (n === br) return r.UNSIGNED_BYTE;
            if (n === vy) return r.UNSIGNED_SHORT_4_4_4_4;
            if (n === yy) return r.UNSIGNED_SHORT_5_5_5_1;
            if (n === AS) return r.UNSIGNED_INT_5_9_9_9_REV;
            if (n === ES) return r.BYTE;
            if (n === TS) return r.SHORT;
            if (n === pd) return r.UNSIGNED_SHORT;
            if (n === gy) return r.INT;
            if (n === Il) return r.UNSIGNED_INT;
            if (n === ia) return r.FLOAT;
            if (n === Cf) return r.HALF_FLOAT;
            if (n === wS) return r.ALPHA;
            if (n === RS) return r.RGB;
            if (n === Is) return r.RGBA;
            if (n === gd) return r.DEPTH_COMPONENT;
            if (n === vd) return r.DEPTH_STENCIL;
            if (n === _y) return r.RED;
            if (n === Im) return r.RED_INTEGER;
            if (n === CS) return r.RG;
            if (n === xy) return r.RG_INTEGER;
            if (n === Sy) return r.RGBA_INTEGER;
            if (n === dm || n === pm || n === mm || n === gm) if (l === Fn) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                if (n === dm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === pm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === mm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === gm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
                if (n === dm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === pm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === mm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === gm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
            if (n === Dv || n === Nv || n === Uv || n === Lv) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
                if (n === Dv) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === Nv) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === Uv) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === Lv) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
            if (n === Ov || n === zv || n === Bv) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
                if (n === Ov || n === zv) return l === Fn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (n === Bv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
            if (n === Iv || n === Pv || n === Hv || n === Fv || n === Gv || n === Vv || n === kv || n === Xv || n === jv || n === qv || n === Yv || n === Wv || n === Zv || n === Kv) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
                if (n === Iv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === Pv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === Hv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Fv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === Gv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Vv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === kv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Xv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === jv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === qv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Yv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Wv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === Zv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Kv) return l === Fn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
            if (n === vm || n === Qv || n === Jv) if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
                if (n === vm) return l === Fn ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Qv) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Jv) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
            if (n === DS || n === $v || n === ey || n === ty) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
                if (n === vm) return a.COMPRESSED_RED_RGTC1_EXT;
                if (n === $v) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === ey) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === ty) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
            return n === md ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
        }
        return {
            convert: t
        };
    }
    const lO = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, cO = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class uO {
        constructor(){
            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(e, t, n) {
            if (this.texture === null) {
                const i = new Qn, a = e.properties.get(i);
                a.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
            }
        }
        getMesh(e) {
            if (this.texture !== null && this.mesh === null) {
                const t = e.cameras[0].viewport, n = new ao({
                    vertexShader: lO,
                    fragmentShader: cO,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: t.z
                        },
                        depthHeight: {
                            value: t.w
                        }
                    }
                });
                this.mesh = new ai(new Nd(20, 20), n);
            }
            return this.mesh;
        }
        reset() {
            this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
            return this.texture;
        }
    }
    class fO extends Qo {
        constructor(e, t){
            super();
            const n = this;
            let i = null, a = 1, l = null, f = "local-floor", d = 1, p = null, g = null, y = null, _ = null, x = null, M = null;
            const R = new uO, T = t.getContextAttributes();
            let E = null, C = null;
            const N = [], D = [], I = new Ie;
            let O = null;
            const P = new hi;
            P.viewport = new gn;
            const F = new hi;
            F.viewport = new gn;
            const z = [
                P,
                F
            ], L = new aA;
            let q = null, oe = null;
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(J) {
                let ue = N[J];
                return ue === void 0 && (ue = new gv, N[J] = ue), ue.getTargetRaySpace();
            }, this.getControllerGrip = function(J) {
                let ue = N[J];
                return ue === void 0 && (ue = new gv, N[J] = ue), ue.getGripSpace();
            }, this.getHand = function(J) {
                let ue = N[J];
                return ue === void 0 && (ue = new gv, N[J] = ue), ue.getHandSpace();
            };
            function se(J) {
                const ue = D.indexOf(J.inputSource);
                if (ue === -1) return;
                const he = N[ue];
                he !== void 0 && (he.update(J.inputSource, J.frame, p || l), he.dispatchEvent({
                    type: J.type,
                    data: J.inputSource
                }));
            }
            function ge() {
                i.removeEventListener("select", se), i.removeEventListener("selectstart", se), i.removeEventListener("selectend", se), i.removeEventListener("squeeze", se), i.removeEventListener("squeezestart", se), i.removeEventListener("squeezeend", se), i.removeEventListener("end", ge), i.removeEventListener("inputsourceschange", _e);
                for(let J = 0; J < N.length; J++){
                    const ue = D[J];
                    ue !== null && (D[J] = null, N[J].disconnect(ue));
                }
                q = null, oe = null, R.reset(), e.setRenderTarget(E), x = null, _ = null, y = null, i = null, C = null, ve.stop(), n.isPresenting = !1, e.setPixelRatio(O), e.setSize(I.width, I.height, !1), n.dispatchEvent({
                    type: "sessionend"
                });
            }
            this.setFramebufferScaleFactor = function(J) {
                a = J, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }, this.setReferenceSpaceType = function(J) {
                f = J, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }, this.getReferenceSpace = function() {
                return p || l;
            }, this.setReferenceSpace = function(J) {
                p = J;
            }, this.getBaseLayer = function() {
                return _ !== null ? _ : x;
            }, this.getBinding = function() {
                return y;
            }, this.getFrame = function() {
                return M;
            }, this.getSession = function() {
                return i;
            }, this.setSession = async function(J) {
                if (i = J, i !== null) {
                    if (E = e.getRenderTarget(), i.addEventListener("select", se), i.addEventListener("selectstart", se), i.addEventListener("selectend", se), i.addEventListener("squeeze", se), i.addEventListener("squeezestart", se), i.addEventListener("squeezeend", se), i.addEventListener("end", ge), i.addEventListener("inputsourceschange", _e), T.xrCompatible !== !0 && await t.makeXRCompatible(), O = e.getPixelRatio(), e.getSize(I), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                        let he = null, De = null, Pe = null;
                        T.depth && (Pe = T.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, he = T.stencil ? vd : gd, De = T.stencil ? md : Il);
                        const _t = {
                            colorFormat: t.RGBA8,
                            depthFormat: Pe,
                            scaleFactor: a
                        };
                        y = new XRWebGLBinding(i, t), _ = y.createProjectionLayer(_t), i.updateRenderState({
                            layers: [
                                _
                            ]
                        }), e.setPixelRatio(1), e.setSize(_.textureWidth, _.textureHeight, !1), C = new so(_.textureWidth, _.textureHeight, {
                            format: Is,
                            type: br,
                            depthTexture: new Uy(_.textureWidth, _.textureHeight, De, void 0, void 0, void 0, void 0, void 0, void 0, he),
                            stencilBuffer: T.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: T.antialias ? 4 : 0,
                            resolveDepthBuffer: _.ignoreDepthValues === !1,
                            resolveStencilBuffer: _.ignoreDepthValues === !1
                        });
                    } else {
                        const he = {
                            antialias: T.antialias,
                            alpha: !0,
                            depth: T.depth,
                            stencil: T.stencil,
                            framebufferScaleFactor: a
                        };
                        x = new XRWebGLLayer(i, t, he), i.updateRenderState({
                            baseLayer: x
                        }), e.setPixelRatio(1), e.setSize(x.framebufferWidth, x.framebufferHeight, !1), C = new so(x.framebufferWidth, x.framebufferHeight, {
                            format: Is,
                            type: br,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: T.stencil,
                            resolveDepthBuffer: x.ignoreDepthValues === !1,
                            resolveStencilBuffer: x.ignoreDepthValues === !1
                        });
                    }
                    C.isXRRenderTarget = !0, this.setFoveation(d), p = null, l = await i.requestReferenceSpace(f), ve.setContext(i), ve.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    });
                }
            }, this.getEnvironmentBlendMode = function() {
                if (i !== null) return i.environmentBlendMode;
            }, this.getDepthTexture = function() {
                return R.getDepthTexture();
            };
            function _e(J) {
                for(let ue = 0; ue < J.removed.length; ue++){
                    const he = J.removed[ue], De = D.indexOf(he);
                    De >= 0 && (D[De] = null, N[De].disconnect(he));
                }
                for(let ue = 0; ue < J.added.length; ue++){
                    const he = J.added[ue];
                    let De = D.indexOf(he);
                    if (De === -1) {
                        for(let _t = 0; _t < N.length; _t++)if (_t >= D.length) {
                            D.push(he), De = _t;
                            break;
                        } else if (D[_t] === null) {
                            D[_t] = he, De = _t;
                            break;
                        }
                        if (De === -1) break;
                    }
                    const Pe = N[De];
                    Pe && Pe.connect(he);
                }
            }
            const H = new Y, K = new Y;
            function Q(J, ue, he) {
                H.setFromMatrixPosition(ue.matrixWorld), K.setFromMatrixPosition(he.matrixWorld);
                const De = H.distanceTo(K), Pe = ue.projectionMatrix.elements, _t = he.projectionMatrix.elements, xt = Pe[14] / (Pe[10] - 1), on = Pe[14] / (Pe[10] + 1), Vt = (Pe[9] + 1) / Pe[5], Nt = (Pe[9] - 1) / Pe[5], W = (Pe[8] - 1) / Pe[0], et = (_t[8] + 1) / _t[0], Ye = xt * W, We = xt * et, Be = De / (-W + et), ut = Be * -W;
                if (ue.matrixWorld.decompose(J.position, J.quaternion, J.scale), J.translateX(ut), J.translateZ(Be), J.matrixWorld.compose(J.position, J.quaternion, J.scale), J.matrixWorldInverse.copy(J.matrixWorld).invert(), Pe[10] === -1) J.projectionMatrix.copy(ue.projectionMatrix), J.projectionMatrixInverse.copy(ue.projectionMatrixInverse);
                else {
                    const Xe = xt + Be, ot = on + Be, It = Ye - ut, Z = We + (De - ut), G = Vt * on / ot * Xe, Se = Nt * on / ot * Xe;
                    J.projectionMatrix.makePerspective(It, Z, G, Se, Xe, ot), J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
                }
            }
            function fe(J, ue) {
                ue === null ? J.matrixWorld.copy(J.matrix) : J.matrixWorld.multiplyMatrices(ue.matrixWorld, J.matrix), J.matrixWorldInverse.copy(J.matrixWorld).invert();
            }
            this.updateCamera = function(J) {
                if (i === null) return;
                let ue = J.near, he = J.far;
                R.texture !== null && (R.depthNear > 0 && (ue = R.depthNear), R.depthFar > 0 && (he = R.depthFar)), L.near = F.near = P.near = ue, L.far = F.far = P.far = he, (q !== L.near || oe !== L.far) && (i.updateRenderState({
                    depthNear: L.near,
                    depthFar: L.far
                }), q = L.near, oe = L.far), P.layers.mask = J.layers.mask | 2, F.layers.mask = J.layers.mask | 4, L.layers.mask = P.layers.mask | F.layers.mask;
                const De = J.parent, Pe = L.cameras;
                fe(L, De);
                for(let _t = 0; _t < Pe.length; _t++)fe(Pe[_t], De);
                Pe.length === 2 ? Q(L, P, F) : L.projectionMatrix.copy(P.projectionMatrix), X(J, L, De);
            };
            function X(J, ue, he) {
                he === null ? J.matrix.copy(ue.matrixWorld) : (J.matrix.copy(he.matrixWorld), J.matrix.invert(), J.matrix.multiply(ue.matrixWorld)), J.matrix.decompose(J.position, J.quaternion, J.scale), J.updateMatrixWorld(!0), J.projectionMatrix.copy(ue.projectionMatrix), J.projectionMatrixInverse.copy(ue.projectionMatrixInverse), J.isPerspectiveCamera && (J.fov = xd * 2 * Math.atan(1 / J.projectionMatrix.elements[5]), J.zoom = 1);
            }
            this.getCamera = function() {
                return L;
            }, this.getFoveation = function() {
                if (!(_ === null && x === null)) return d;
            }, this.setFoveation = function(J) {
                d = J, _ !== null && (_.fixedFoveation = J), x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = J);
            }, this.hasDepthSensing = function() {
                return R.texture !== null;
            }, this.getDepthSensingMesh = function() {
                return R.getMesh(L);
            };
            let $ = null;
            function me(J, ue) {
                if (g = ue.getViewerPose(p || l), M = ue, g !== null) {
                    const he = g.views;
                    x !== null && (e.setRenderTargetFramebuffer(C, x.framebuffer), e.setRenderTarget(C));
                    let De = !1;
                    he.length !== L.cameras.length && (L.cameras.length = 0, De = !0);
                    for(let xt = 0; xt < he.length; xt++){
                        const on = he[xt];
                        let Vt = null;
                        if (x !== null) Vt = x.getViewport(on);
                        else {
                            const W = y.getViewSubImage(_, on);
                            Vt = W.viewport, xt === 0 && (e.setRenderTargetTextures(C, W.colorTexture, W.depthStencilTexture), e.setRenderTarget(C));
                        }
                        let Nt = z[xt];
                        Nt === void 0 && (Nt = new hi, Nt.layers.enable(xt), Nt.viewport = new gn, z[xt] = Nt), Nt.matrix.fromArray(on.transform.matrix), Nt.matrix.decompose(Nt.position, Nt.quaternion, Nt.scale), Nt.projectionMatrix.fromArray(on.projectionMatrix), Nt.projectionMatrixInverse.copy(Nt.projectionMatrix).invert(), Nt.viewport.set(Vt.x, Vt.y, Vt.width, Vt.height), xt === 0 && (L.matrix.copy(Nt.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), De === !0 && L.cameras.push(Nt);
                    }
                    const Pe = i.enabledFeatures;
                    if (Pe && Pe.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && y) {
                        const xt = y.getDepthInformation(he[0]);
                        xt && xt.isValid && xt.texture && R.init(e, xt, i.renderState);
                    }
                }
                for(let he = 0; he < N.length; he++){
                    const De = D[he], Pe = N[he];
                    De !== null && Pe !== void 0 && Pe.update(De, ue, p || l);
                }
                $ && $(J, ue), ue.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: ue
                }), M = null;
            }
            const ve = new fA;
            ve.setAnimationLoop(me), this.setAnimationLoop = function(J) {
                $ = J;
            }, this.dispose = function() {};
        }
    }
    const lf = new $i, hO = new pt;
    function dO(r, e) {
        function t(T, E) {
            T.matrixAutoUpdate === !0 && T.updateMatrix(), E.value.copy(T.matrix);
        }
        function n(T, E) {
            E.color.getRGB(T.fogColor.value, _T(r)), E.isFog ? (T.fogNear.value = E.near, T.fogFar.value = E.far) : E.isFogExp2 && (T.fogDensity.value = E.density);
        }
        function i(T, E, C, N, D) {
            E.isMeshBasicMaterial || E.isMeshLambertMaterial ? a(T, E) : E.isMeshToonMaterial ? (a(T, E), y(T, E)) : E.isMeshPhongMaterial ? (a(T, E), g(T, E)) : E.isMeshStandardMaterial ? (a(T, E), _(T, E), E.isMeshPhysicalMaterial && x(T, E, D)) : E.isMeshMatcapMaterial ? (a(T, E), M(T, E)) : E.isMeshDepthMaterial ? a(T, E) : E.isMeshDistanceMaterial ? (a(T, E), R(T, E)) : E.isMeshNormalMaterial ? a(T, E) : E.isLineBasicMaterial ? (l(T, E), E.isLineDashedMaterial && f(T, E)) : E.isPointsMaterial ? d(T, E, C, N) : E.isSpriteMaterial ? p(T, E) : E.isShadowMaterial ? (T.color.value.copy(E.color), T.opacity.value = E.opacity) : E.isShaderMaterial && (E.uniformsNeedUpdate = !1);
        }
        function a(T, E) {
            T.opacity.value = E.opacity, E.color && T.diffuse.value.copy(E.color), E.emissive && T.emissive.value.copy(E.emissive).multiplyScalar(E.emissiveIntensity), E.map && (T.map.value = E.map, t(E.map, T.mapTransform)), E.alphaMap && (T.alphaMap.value = E.alphaMap, t(E.alphaMap, T.alphaMapTransform)), E.bumpMap && (T.bumpMap.value = E.bumpMap, t(E.bumpMap, T.bumpMapTransform), T.bumpScale.value = E.bumpScale, E.side === sa && (T.bumpScale.value *= -1)), E.normalMap && (T.normalMap.value = E.normalMap, t(E.normalMap, T.normalMapTransform), T.normalScale.value.copy(E.normalScale), E.side === sa && T.normalScale.value.negate()), E.displacementMap && (T.displacementMap.value = E.displacementMap, t(E.displacementMap, T.displacementMapTransform), T.displacementScale.value = E.displacementScale, T.displacementBias.value = E.displacementBias), E.emissiveMap && (T.emissiveMap.value = E.emissiveMap, t(E.emissiveMap, T.emissiveMapTransform)), E.specularMap && (T.specularMap.value = E.specularMap, t(E.specularMap, T.specularMapTransform)), E.alphaTest > 0 && (T.alphaTest.value = E.alphaTest);
            const C = e.get(E), N = C.envMap, D = C.envMapRotation;
            N && (T.envMap.value = N, lf.copy(D), lf.x *= -1, lf.y *= -1, lf.z *= -1, N.isCubeTexture && N.isRenderTargetTexture === !1 && (lf.y *= -1, lf.z *= -1), T.envMapRotation.value.setFromMatrix4(hO.makeRotationFromEuler(lf)), T.flipEnvMap.value = N.isCubeTexture && N.isRenderTargetTexture === !1 ? -1 : 1, T.reflectivity.value = E.reflectivity, T.ior.value = E.ior, T.refractionRatio.value = E.refractionRatio), E.lightMap && (T.lightMap.value = E.lightMap, T.lightMapIntensity.value = E.lightMapIntensity, t(E.lightMap, T.lightMapTransform)), E.aoMap && (T.aoMap.value = E.aoMap, T.aoMapIntensity.value = E.aoMapIntensity, t(E.aoMap, T.aoMapTransform));
        }
        function l(T, E) {
            T.diffuse.value.copy(E.color), T.opacity.value = E.opacity, E.map && (T.map.value = E.map, t(E.map, T.mapTransform));
        }
        function f(T, E) {
            T.dashSize.value = E.dashSize, T.totalSize.value = E.dashSize + E.gapSize, T.scale.value = E.scale;
        }
        function d(T, E, C, N) {
            T.diffuse.value.copy(E.color), T.opacity.value = E.opacity, T.size.value = E.size * C, T.scale.value = N * .5, E.map && (T.map.value = E.map, t(E.map, T.uvTransform)), E.alphaMap && (T.alphaMap.value = E.alphaMap, t(E.alphaMap, T.alphaMapTransform)), E.alphaTest > 0 && (T.alphaTest.value = E.alphaTest);
        }
        function p(T, E) {
            T.diffuse.value.copy(E.color), T.opacity.value = E.opacity, T.rotation.value = E.rotation, E.map && (T.map.value = E.map, t(E.map, T.mapTransform)), E.alphaMap && (T.alphaMap.value = E.alphaMap, t(E.alphaMap, T.alphaMapTransform)), E.alphaTest > 0 && (T.alphaTest.value = E.alphaTest);
        }
        function g(T, E) {
            T.specular.value.copy(E.specular), T.shininess.value = Math.max(E.shininess, 1e-4);
        }
        function y(T, E) {
            E.gradientMap && (T.gradientMap.value = E.gradientMap);
        }
        function _(T, E) {
            T.metalness.value = E.metalness, E.metalnessMap && (T.metalnessMap.value = E.metalnessMap, t(E.metalnessMap, T.metalnessMapTransform)), T.roughness.value = E.roughness, E.roughnessMap && (T.roughnessMap.value = E.roughnessMap, t(E.roughnessMap, T.roughnessMapTransform)), E.envMap && (T.envMapIntensity.value = E.envMapIntensity);
        }
        function x(T, E, C) {
            T.ior.value = E.ior, E.sheen > 0 && (T.sheenColor.value.copy(E.sheenColor).multiplyScalar(E.sheen), T.sheenRoughness.value = E.sheenRoughness, E.sheenColorMap && (T.sheenColorMap.value = E.sheenColorMap, t(E.sheenColorMap, T.sheenColorMapTransform)), E.sheenRoughnessMap && (T.sheenRoughnessMap.value = E.sheenRoughnessMap, t(E.sheenRoughnessMap, T.sheenRoughnessMapTransform))), E.clearcoat > 0 && (T.clearcoat.value = E.clearcoat, T.clearcoatRoughness.value = E.clearcoatRoughness, E.clearcoatMap && (T.clearcoatMap.value = E.clearcoatMap, t(E.clearcoatMap, T.clearcoatMapTransform)), E.clearcoatRoughnessMap && (T.clearcoatRoughnessMap.value = E.clearcoatRoughnessMap, t(E.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)), E.clearcoatNormalMap && (T.clearcoatNormalMap.value = E.clearcoatNormalMap, t(E.clearcoatNormalMap, T.clearcoatNormalMapTransform), T.clearcoatNormalScale.value.copy(E.clearcoatNormalScale), E.side === sa && T.clearcoatNormalScale.value.negate())), E.dispersion > 0 && (T.dispersion.value = E.dispersion), E.iridescence > 0 && (T.iridescence.value = E.iridescence, T.iridescenceIOR.value = E.iridescenceIOR, T.iridescenceThicknessMinimum.value = E.iridescenceThicknessRange[0], T.iridescenceThicknessMaximum.value = E.iridescenceThicknessRange[1], E.iridescenceMap && (T.iridescenceMap.value = E.iridescenceMap, t(E.iridescenceMap, T.iridescenceMapTransform)), E.iridescenceThicknessMap && (T.iridescenceThicknessMap.value = E.iridescenceThicknessMap, t(E.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))), E.transmission > 0 && (T.transmission.value = E.transmission, T.transmissionSamplerMap.value = C.texture, T.transmissionSamplerSize.value.set(C.width, C.height), E.transmissionMap && (T.transmissionMap.value = E.transmissionMap, t(E.transmissionMap, T.transmissionMapTransform)), T.thickness.value = E.thickness, E.thicknessMap && (T.thicknessMap.value = E.thicknessMap, t(E.thicknessMap, T.thicknessMapTransform)), T.attenuationDistance.value = E.attenuationDistance, T.attenuationColor.value.copy(E.attenuationColor)), E.anisotropy > 0 && (T.anisotropyVector.value.set(E.anisotropy * Math.cos(E.anisotropyRotation), E.anisotropy * Math.sin(E.anisotropyRotation)), E.anisotropyMap && (T.anisotropyMap.value = E.anisotropyMap, t(E.anisotropyMap, T.anisotropyMapTransform))), T.specularIntensity.value = E.specularIntensity, T.specularColor.value.copy(E.specularColor), E.specularColorMap && (T.specularColorMap.value = E.specularColorMap, t(E.specularColorMap, T.specularColorMapTransform)), E.specularIntensityMap && (T.specularIntensityMap.value = E.specularIntensityMap, t(E.specularIntensityMap, T.specularIntensityMapTransform));
        }
        function M(T, E) {
            E.matcap && (T.matcap.value = E.matcap);
        }
        function R(T, E) {
            const C = e.get(E).light;
            T.referencePosition.value.setFromMatrixPosition(C.matrixWorld), T.nearDistance.value = C.shadow.camera.near, T.farDistance.value = C.shadow.camera.far;
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: i
        };
    }
    function pO(r, e, t, n) {
        let i = {}, a = {}, l = [];
        const f = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
        function d(C, N) {
            const D = N.program;
            n.uniformBlockBinding(C, D);
        }
        function p(C, N) {
            let D = i[C.id];
            D === void 0 && (M(C), D = g(C), i[C.id] = D, C.addEventListener("dispose", T));
            const I = N.program;
            n.updateUBOMapping(C, I);
            const O = e.render.frame;
            a[C.id] !== O && (_(C), a[C.id] = O);
        }
        function g(C) {
            const N = y();
            C.__bindingPointIndex = N;
            const D = r.createBuffer(), I = C.__size, O = C.usage;
            return r.bindBuffer(r.UNIFORM_BUFFER, D), r.bufferData(r.UNIFORM_BUFFER, I, O), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, N, D), D;
        }
        function y() {
            for(let C = 0; C < f; C++)if (l.indexOf(C) === -1) return l.push(C), C;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function _(C) {
            const N = i[C.id], D = C.uniforms, I = C.__cache;
            r.bindBuffer(r.UNIFORM_BUFFER, N);
            for(let O = 0, P = D.length; O < P; O++){
                const F = Array.isArray(D[O]) ? D[O] : [
                    D[O]
                ];
                for(let z = 0, L = F.length; z < L; z++){
                    const q = F[z];
                    if (x(q, O, z, I) === !0) {
                        const oe = q.__offset, se = Array.isArray(q.value) ? q.value : [
                            q.value
                        ];
                        let ge = 0;
                        for(let _e = 0; _e < se.length; _e++){
                            const H = se[_e], K = R(H);
                            typeof H == "number" || typeof H == "boolean" ? (q.__data[0] = H, r.bufferSubData(r.UNIFORM_BUFFER, oe + ge, q.__data)) : H.isMatrix3 ? (q.__data[0] = H.elements[0], q.__data[1] = H.elements[1], q.__data[2] = H.elements[2], q.__data[3] = 0, q.__data[4] = H.elements[3], q.__data[5] = H.elements[4], q.__data[6] = H.elements[5], q.__data[7] = 0, q.__data[8] = H.elements[6], q.__data[9] = H.elements[7], q.__data[10] = H.elements[8], q.__data[11] = 0) : (H.toArray(q.__data, ge), ge += K.storage / Float32Array.BYTES_PER_ELEMENT);
                        }
                        r.bufferSubData(r.UNIFORM_BUFFER, oe, q.__data);
                    }
                }
            }
            r.bindBuffer(r.UNIFORM_BUFFER, null);
        }
        function x(C, N, D, I) {
            const O = C.value, P = N + "_" + D;
            if (I[P] === void 0) return typeof O == "number" || typeof O == "boolean" ? I[P] = O : I[P] = O.clone(), !0;
            {
                const F = I[P];
                if (typeof O == "number" || typeof O == "boolean") {
                    if (F !== O) return I[P] = O, !0;
                } else if (F.equals(O) === !1) return F.copy(O), !0;
            }
            return !1;
        }
        function M(C) {
            const N = C.uniforms;
            let D = 0;
            const I = 16;
            for(let P = 0, F = N.length; P < F; P++){
                const z = Array.isArray(N[P]) ? N[P] : [
                    N[P]
                ];
                for(let L = 0, q = z.length; L < q; L++){
                    const oe = z[L], se = Array.isArray(oe.value) ? oe.value : [
                        oe.value
                    ];
                    for(let ge = 0, _e = se.length; ge < _e; ge++){
                        const H = se[ge], K = R(H), Q = D % I, fe = Q % K.boundary, X = Q + fe;
                        D += fe, X !== 0 && I - X < K.storage && (D += I - X), oe.__data = new Float32Array(K.storage / Float32Array.BYTES_PER_ELEMENT), oe.__offset = D, D += K.storage;
                    }
                }
            }
            const O = D % I;
            return O > 0 && (D += I - O), C.__size = D, C.__cache = {}, this;
        }
        function R(C) {
            const N = {
                boundary: 0,
                storage: 0
            };
            return typeof C == "number" || typeof C == "boolean" ? (N.boundary = 4, N.storage = 4) : C.isVector2 ? (N.boundary = 8, N.storage = 8) : C.isVector3 || C.isColor ? (N.boundary = 16, N.storage = 12) : C.isVector4 ? (N.boundary = 16, N.storage = 16) : C.isMatrix3 ? (N.boundary = 48, N.storage = 48) : C.isMatrix4 ? (N.boundary = 64, N.storage = 64) : C.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", C), N;
        }
        function T(C) {
            const N = C.target;
            N.removeEventListener("dispose", T);
            const D = l.indexOf(N.__bindingPointIndex);
            l.splice(D, 1), r.deleteBuffer(i[N.id]), delete i[N.id], delete a[N.id];
        }
        function E() {
            for(const C in i)r.deleteBuffer(i[C]);
            l = [], i = {}, a = {};
        }
        return {
            bind: d,
            update: p,
            dispose: E
        };
    }
    class vA {
        constructor(e = {}){
            const { canvas: t = gT(), context: n = null, depth: i = !0, stencil: a = !1, alpha: l = !1, antialias: f = !1, premultipliedAlpha: d = !0, preserveDrawingBuffer: p = !1, powerPreference: g = "default", failIfMajorPerformanceCaveat: y = !1, reverseDepthBuffer: _ = !1 } = e;
            this.isWebGLRenderer = !0;
            let x;
            if (n !== null) {
                if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                x = n.getContextAttributes().alpha;
            } else x = l;
            const M = new Uint32Array(4), R = new Int32Array(4);
            let T = null, E = null;
            const C = [], N = [];
            this.domElement = t, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = jo, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
            const D = this;
            let I = !1;
            this._outputColorSpace = Bs;
            let O = 0, P = 0, F = null, z = -1, L = null;
            const q = new gn, oe = new gn;
            let se = null;
            const ge = new tt(0);
            let _e = 0, H = t.width, K = t.height, Q = 1, fe = null, X = null;
            const $ = new gn(0, 0, H, K), me = new gn(0, 0, H, K);
            let ve = !1;
            const J = new Cd;
            let ue = !1, he = !1;
            const De = new pt, Pe = new pt, _t = new Y, xt = new gn, on = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            let Vt = !1;
            function Nt() {
                return F === null ? Q : 1;
            }
            let W = n;
            function et(k, ce) {
                return t.getContext(k, ce);
            }
            try {
                const k = {
                    alpha: !0,
                    depth: i,
                    stencil: a,
                    antialias: f,
                    premultipliedAlpha: d,
                    preserveDrawingBuffer: p,
                    powerPreference: g,
                    failIfMajorPerformanceCaveat: y
                };
                if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${zm}`), t.addEventListener("webglcontextlost", rt, !1), t.addEventListener("webglcontextrestored", Ke, !1), t.addEventListener("webglcontextcreationerror", Fe, !1), W === null) {
                    const ce = "webgl2";
                    if (W = et(ce, k), W === null) throw et(ce) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                }
            } catch (k) {
                throw console.error("THREE.WebGLRenderer: " + k.message), k;
            }
            let Ye, We, Be, ut, Xe, ot, It, Z, G, Se, Ue, Le, Ne, lt, it, vt, yt, He, st, St, ie, xe, Ze, te;
            function Qe() {
                Ye = new AU(W), Ye.init(), xe = new gA(W, Ye), We = new _U(W, Ye, e, xe), Be = new rO(W, Ye), We.reverseDepthBuffer && _ && Be.buffers.depth.setReversed(!0), ut = new CU(W), Xe = new YL, ot = new oO(W, Ye, Be, Xe, We, xe, ut), It = new SU(D), Z = new TU(D), G = new z3(W), Ze = new vU(W, G), Se = new wU(W, G, ut, Ze), Ue = new NU(W, Se, G, ut), st = new DU(W, We, ot), vt = new xU(Xe), Le = new qL(D, It, Z, Ye, We, Ze, vt), Ne = new dO(D, Xe), lt = new ZL, it = new tO(Ye), He = new gU(D, It, Z, Be, Ue, x, d), yt = new sO(D, Ue, We), te = new pO(W, ut, We, Be), St = new yU(W, Ye, ut), ie = new RU(W, Ye, ut), ut.programs = Le.programs, D.capabilities = We, D.extensions = Ye, D.properties = Xe, D.renderLists = lt, D.shadowMap = yt, D.state = Be, D.info = ut;
            }
            Qe();
            const Ve = new fO(D, W);
            this.xr = Ve, this.getContext = function() {
                return W;
            }, this.getContextAttributes = function() {
                return W.getContextAttributes();
            }, this.forceContextLoss = function() {
                const k = Ye.get("WEBGL_lose_context");
                k && k.loseContext();
            }, this.forceContextRestore = function() {
                const k = Ye.get("WEBGL_lose_context");
                k && k.restoreContext();
            }, this.getPixelRatio = function() {
                return Q;
            }, this.setPixelRatio = function(k) {
                k !== void 0 && (Q = k, this.setSize(H, K, !1));
            }, this.getSize = function(k) {
                return k.set(H, K);
            }, this.setSize = function(k, ce, Ae = !0) {
                if (Ve.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return;
                }
                H = k, K = ce, t.width = Math.floor(k * Q), t.height = Math.floor(ce * Q), Ae === !0 && (t.style.width = k + "px", t.style.height = ce + "px"), this.setViewport(0, 0, k, ce);
            }, this.getDrawingBufferSize = function(k) {
                return k.set(H * Q, K * Q).floor();
            }, this.setDrawingBufferSize = function(k, ce, Ae) {
                H = k, K = ce, Q = Ae, t.width = Math.floor(k * Ae), t.height = Math.floor(ce * Ae), this.setViewport(0, 0, k, ce);
            }, this.getCurrentViewport = function(k) {
                return k.copy(q);
            }, this.getViewport = function(k) {
                return k.copy($);
            }, this.setViewport = function(k, ce, Ae, we) {
                k.isVector4 ? $.set(k.x, k.y, k.z, k.w) : $.set(k, ce, Ae, we), Be.viewport(q.copy($).multiplyScalar(Q).round());
            }, this.getScissor = function(k) {
                return k.copy(me);
            }, this.setScissor = function(k, ce, Ae, we) {
                k.isVector4 ? me.set(k.x, k.y, k.z, k.w) : me.set(k, ce, Ae, we), Be.scissor(oe.copy(me).multiplyScalar(Q).round());
            }, this.getScissorTest = function() {
                return ve;
            }, this.setScissorTest = function(k) {
                Be.setScissorTest(ve = k);
            }, this.setOpaqueSort = function(k) {
                fe = k;
            }, this.setTransparentSort = function(k) {
                X = k;
            }, this.getClearColor = function(k) {
                return k.copy(He.getClearColor());
            }, this.setClearColor = function() {
                He.setClearColor(...arguments);
            }, this.getClearAlpha = function() {
                return He.getClearAlpha();
            }, this.setClearAlpha = function() {
                He.setClearAlpha(...arguments);
            }, this.clear = function(k = !0, ce = !0, Ae = !0) {
                let we = 0;
                if (k) {
                    let pe = !1;
                    if (F !== null) {
                        const je = F.texture.format;
                        pe = je === Sy || je === xy || je === Im;
                    }
                    if (pe) {
                        const je = F.texture.type, at = je === br || je === Il || je === pd || je === md || je === vy || je === yy, dt = He.getClearColor(), mt = He.getClearAlpha(), Lt = dt.r, wt = dt.g, Et = dt.b;
                        at ? (M[0] = Lt, M[1] = wt, M[2] = Et, M[3] = mt, W.clearBufferuiv(W.COLOR, 0, M)) : (R[0] = Lt, R[1] = wt, R[2] = Et, R[3] = mt, W.clearBufferiv(W.COLOR, 0, R));
                    } else we |= W.COLOR_BUFFER_BIT;
                }
                ce && (we |= W.DEPTH_BUFFER_BIT), Ae && (we |= W.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), W.clear(we);
            }, this.clearColor = function() {
                this.clear(!0, !1, !1);
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1);
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0);
            }, this.dispose = function() {
                t.removeEventListener("webglcontextlost", rt, !1), t.removeEventListener("webglcontextrestored", Ke, !1), t.removeEventListener("webglcontextcreationerror", Fe, !1), He.dispose(), lt.dispose(), it.dispose(), Xe.dispose(), It.dispose(), Z.dispose(), Ue.dispose(), Ze.dispose(), te.dispose(), Le.dispose(), Ve.dispose(), Ve.removeEventListener("sessionstart", vi), Ve.removeEventListener("sessionend", Ei), ns.stop();
            };
            function rt(k) {
                k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = !0;
            }
            function Ke() {
                console.log("THREE.WebGLRenderer: Context Restored."), I = !1;
                const k = ut.autoReset, ce = yt.enabled, Ae = yt.autoUpdate, we = yt.needsUpdate, pe = yt.type;
                Qe(), ut.autoReset = k, yt.enabled = ce, yt.autoUpdate = Ae, yt.needsUpdate = we, yt.type = pe;
            }
            function Fe(k) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
            }
            function ct(k) {
                const ce = k.target;
                ce.removeEventListener("dispose", ct), Mt(ce);
            }
            function Mt(k) {
                tn(k), Xe.remove(k);
            }
            function tn(k) {
                const ce = Xe.get(k).programs;
                ce !== void 0 && (ce.forEach(function(Ae) {
                    Le.releaseProgram(Ae);
                }), k.isShaderMaterial && Le.releaseShaderCache(k));
            }
            this.renderBufferDirect = function(k, ce, Ae, we, pe, je) {
                ce === null && (ce = on);
                const at = pe.isMesh && pe.matrixWorld.determinant() < 0, dt = ro(k, ce, Ae, we, pe);
                Be.setMaterial(we, at);
                let mt = Ae.index, Lt = 1;
                if (we.wireframe === !0) {
                    if (mt = Se.getWireframeAttribute(Ae), mt === void 0) return;
                    Lt = 2;
                }
                const wt = Ae.drawRange, Et = Ae.attributes.position;
                let Kt = wt.start * Lt, En = (wt.start + wt.count) * Lt;
                je !== null && (Kt = Math.max(Kt, je.start * Lt), En = Math.min(En, (je.start + je.count) * Lt)), mt !== null ? (Kt = Math.max(Kt, 0), En = Math.min(En, mt.count)) : Et != null && (Kt = Math.max(Kt, 0), En = Math.min(En, Et.count));
                const Gn = En - Kt;
                if (Gn < 0 || Gn === 1 / 0) return;
                Ze.setup(pe, we, dt, Ae, mt);
                let Jt, Tn = St;
                if (mt !== null && (Jt = G.get(mt), Tn = ie, Tn.setIndex(Jt)), pe.isMesh) we.wireframe === !0 ? (Be.setLineWidth(we.wireframeLinewidth * Nt()), Tn.setMode(W.LINES)) : Tn.setMode(W.TRIANGLES);
                else if (pe.isLine) {
                    let Rt = we.linewidth;
                    Rt === void 0 && (Rt = 1), Be.setLineWidth(Rt * Nt()), pe.isLineSegments ? Tn.setMode(W.LINES) : pe.isLineLoop ? Tn.setMode(W.LINE_LOOP) : Tn.setMode(W.LINE_STRIP);
                } else pe.isPoints ? Tn.setMode(W.POINTS) : pe.isSprite && Tn.setMode(W.TRIANGLES);
                if (pe.isBatchedMesh) if (pe._multiDrawInstances !== null) od("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Tn.renderMultiDrawInstances(pe._multiDrawStarts, pe._multiDrawCounts, pe._multiDrawCount, pe._multiDrawInstances);
                else if (Ye.get("WEBGL_multi_draw")) Tn.renderMultiDraw(pe._multiDrawStarts, pe._multiDrawCounts, pe._multiDrawCount);
                else {
                    const Rt = pe._multiDrawStarts, Dn = pe._multiDrawCounts, ln = pe._multiDrawCount, Ti = mt ? G.get(mt).bytesPerElement : 1, Wa = Xe.get(we).currentProgram.getUniforms();
                    for(let zn = 0; zn < ln; zn++)Wa.setValue(W, "_gl_DrawID", zn), Tn.render(Rt[zn] / Ti, Dn[zn]);
                }
                else if (pe.isInstancedMesh) Tn.renderInstances(Kt, Gn, pe.count);
                else if (Ae.isInstancedBufferGeometry) {
                    const Rt = Ae._maxInstanceCount !== void 0 ? Ae._maxInstanceCount : 1 / 0, Dn = Math.min(Ae.instanceCount, Rt);
                    Tn.renderInstances(Kt, Gn, Dn);
                } else Tn.render(Kt, Gn);
            };
            function Zt(k, ce, Ae) {
                k.transparent === !0 && k.side === ka && k.forceSinglePass === !1 ? (k.side = sa, k.needsUpdate = !0, Un(k, ce, Ae), k.side = Wo, k.needsUpdate = !0, Un(k, ce, Ae), k.side = ka) : Un(k, ce, Ae);
            }
            this.compile = function(k, ce, Ae = null) {
                Ae === null && (Ae = k), E = it.get(Ae), E.init(ce), N.push(E), Ae.traverseVisible(function(pe) {
                    pe.isLight && pe.layers.test(ce.layers) && (E.pushLight(pe), pe.castShadow && E.pushShadow(pe));
                }), k !== Ae && k.traverseVisible(function(pe) {
                    pe.isLight && pe.layers.test(ce.layers) && (E.pushLight(pe), pe.castShadow && E.pushShadow(pe));
                }), E.setupLights();
                const we = new Set;
                return k.traverse(function(pe) {
                    if (!(pe.isMesh || pe.isPoints || pe.isLine || pe.isSprite)) return;
                    const je = pe.material;
                    if (je) if (Array.isArray(je)) for(let at = 0; at < je.length; at++){
                        const dt = je[at];
                        Zt(dt, Ae, pe), we.add(dt);
                    }
                    else Zt(je, Ae, pe), we.add(je);
                }), E = N.pop(), we;
            }, this.compileAsync = function(k, ce, Ae = null) {
                const we = this.compile(k, ce, Ae);
                return new Promise((pe)=>{
                    function je() {
                        if (we.forEach(function(at) {
                            Xe.get(at).currentProgram.isReady() && we.delete(at);
                        }), we.size === 0) {
                            pe(k);
                            return;
                        }
                        setTimeout(je, 10);
                    }
                    Ye.get("KHR_parallel_shader_compile") !== null ? je() : setTimeout(je, 10);
                });
            };
            let gi = null;
            function Zn(k) {
                gi && gi(k);
            }
            function vi() {
                ns.stop();
            }
            function Ei() {
                ns.start();
            }
            const ns = new fA;
            ns.setAnimationLoop(Zn), typeof self < "u" && ns.setContext(self), this.setAnimationLoop = function(k) {
                gi = k, Ve.setAnimationLoop(k), k === null ? ns.stop() : ns.start();
            }, Ve.addEventListener("sessionstart", vi), Ve.addEventListener("sessionend", Ei), this.render = function(k, ce) {
                if (ce !== void 0 && ce.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return;
                }
                if (I === !0) return;
                if (k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(), ce.parent === null && ce.matrixWorldAutoUpdate === !0 && ce.updateMatrixWorld(), Ve.enabled === !0 && Ve.isPresenting === !0 && (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(ce), ce = Ve.getCamera()), k.isScene === !0 && k.onBeforeRender(D, k, ce, F), E = it.get(k, N.length), E.init(ce), N.push(E), Pe.multiplyMatrices(ce.projectionMatrix, ce.matrixWorldInverse), J.setFromProjectionMatrix(Pe), he = this.localClippingEnabled, ue = vt.init(this.clippingPlanes, he), T = lt.get(k, C.length), T.init(), C.push(T), Ve.enabled === !0 && Ve.isPresenting === !0) {
                    const je = D.xr.getDepthSensingMesh();
                    je !== null && Ms(je, ce, -1 / 0, D.sortObjects);
                }
                Ms(k, ce, 0, D.sortObjects), T.finish(), D.sortObjects === !0 && T.sort(fe, X), Vt = Ve.enabled === !1 || Ve.isPresenting === !1 || Ve.hasDepthSensing() === !1, Vt && He.addToRenderList(T, k), this.info.render.frame++, ue === !0 && vt.beginShadows();
                const Ae = E.state.shadowsArray;
                yt.render(Ae, k, ce), ue === !0 && vt.endShadows(), this.info.autoReset === !0 && this.info.reset();
                const we = T.opaque, pe = T.transmissive;
                if (E.setupLights(), ce.isArrayCamera) {
                    const je = ce.cameras;
                    if (pe.length > 0) for(let at = 0, dt = je.length; at < dt; at++){
                        const mt = je[at];
                        Ma(we, pe, k, mt);
                    }
                    Vt && He.render(k);
                    for(let at = 0, dt = je.length; at < dt; at++){
                        const mt = je[at];
                        nu(T, k, mt, mt.viewport);
                    }
                } else pe.length > 0 && Ma(we, pe, k, ce), Vt && He.render(k), nu(T, k, ce);
                F !== null && P === 0 && (ot.updateMultisampleRenderTarget(F), ot.updateRenderTargetMipmap(F)), k.isScene === !0 && k.onAfterRender(D, k, ce), Ze.resetDefaultState(), z = -1, L = null, N.pop(), N.length > 0 ? (E = N[N.length - 1], ue === !0 && vt.setGlobalState(D.clippingPlanes, E.state.camera)) : E = null, C.pop(), C.length > 0 ? T = C[C.length - 1] : T = null;
            };
            function Ms(k, ce, Ae, we) {
                if (k.visible === !1) return;
                if (k.layers.test(ce.layers)) {
                    if (k.isGroup) Ae = k.renderOrder;
                    else if (k.isLOD) k.autoUpdate === !0 && k.update(ce);
                    else if (k.isLight) E.pushLight(k), k.castShadow && E.pushShadow(k);
                    else if (k.isSprite) {
                        if (!k.frustumCulled || J.intersectsSprite(k)) {
                            we && xt.setFromMatrixPosition(k.matrixWorld).applyMatrix4(Pe);
                            const at = Ue.update(k), dt = k.material;
                            dt.visible && T.push(k, at, dt, Ae, xt.z, null);
                        }
                    } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || J.intersectsObject(k))) {
                        const at = Ue.update(k), dt = k.material;
                        if (we && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), xt.copy(k.boundingSphere.center)) : (at.boundingSphere === null && at.computeBoundingSphere(), xt.copy(at.boundingSphere.center)), xt.applyMatrix4(k.matrixWorld).applyMatrix4(Pe)), Array.isArray(dt)) {
                            const mt = at.groups;
                            for(let Lt = 0, wt = mt.length; Lt < wt; Lt++){
                                const Et = mt[Lt], Kt = dt[Et.materialIndex];
                                Kt && Kt.visible && T.push(k, at, Kt, Ae, xt.z, Et);
                            }
                        } else dt.visible && T.push(k, at, dt, Ae, xt.z, null);
                    }
                }
                const je = k.children;
                for(let at = 0, dt = je.length; at < dt; at++)Ms(je[at], ce, Ae, we);
            }
            function nu(k, ce, Ae, we) {
                const pe = k.opaque, je = k.transmissive, at = k.transparent;
                E.setupLightsView(Ae), ue === !0 && vt.setGlobalState(D.clippingPlanes, Ae), we && Be.viewport(q.copy(we)), pe.length > 0 && fs(pe, ce, Ae), je.length > 0 && fs(je, ce, Ae), at.length > 0 && fs(at, ce, Ae), Be.buffers.depth.setTest(!0), Be.buffers.depth.setMask(!0), Be.buffers.color.setMask(!0), Be.setPolygonOffset(!1);
            }
            function Ma(k, ce, Ae, we) {
                if ((Ae.isScene === !0 ? Ae.overrideMaterial : null) !== null) return;
                E.state.transmissionRenderTarget[we.id] === void 0 && (E.state.transmissionRenderTarget[we.id] = new so(1, 1, {
                    generateMipmaps: !0,
                    type: Ye.has("EXT_color_buffer_half_float") || Ye.has("EXT_color_buffer_float") ? Cf : br,
                    minFilter: Xa,
                    samples: 4,
                    stencilBuffer: a,
                    resolveDepthBuffer: !1,
                    resolveStencilBuffer: !1,
                    colorSpace: Sn.workingColorSpace
                }));
                const je = E.state.transmissionRenderTarget[we.id], at = we.viewport || q;
                je.setSize(at.z * D.transmissionResolutionScale, at.w * D.transmissionResolutionScale);
                const dt = D.getRenderTarget(), mt = D.getActiveCubeFace(), Lt = D.getActiveMipmapLevel();
                D.setRenderTarget(je), D.getClearColor(ge), _e = D.getClearAlpha(), _e < 1 && D.setClearColor(16777215, .5), D.clear(), Vt && He.render(Ae);
                const wt = D.toneMapping;
                D.toneMapping = jo;
                const Et = we.viewport;
                if (we.viewport !== void 0 && (we.viewport = void 0), E.setupLightsView(we), ue === !0 && vt.setGlobalState(D.clippingPlanes, we), fs(k, Ae, we), ot.updateMultisampleRenderTarget(je), ot.updateRenderTargetMipmap(je), Ye.has("WEBGL_multisampled_render_to_texture") === !1) {
                    let Kt = !1;
                    for(let En = 0, Gn = ce.length; En < Gn; En++){
                        const Jt = ce[En], Tn = Jt.object, Rt = Jt.geometry, Dn = Jt.material, ln = Jt.group;
                        if (Dn.side === ka && Tn.layers.test(we.layers)) {
                            const Ti = Dn.side;
                            Dn.side = sa, Dn.needsUpdate = !0, Ea(Tn, Ae, we, Rt, Dn, ln), Dn.side = Ti, Dn.needsUpdate = !0, Kt = !0;
                        }
                    }
                    Kt === !0 && (ot.updateMultisampleRenderTarget(je), ot.updateRenderTargetMipmap(je));
                }
                D.setRenderTarget(dt, mt, Lt), D.setClearColor(ge, _e), Et !== void 0 && (we.viewport = Et), D.toneMapping = wt;
            }
            function fs(k, ce, Ae) {
                const we = ce.isScene === !0 ? ce.overrideMaterial : null;
                for(let pe = 0, je = k.length; pe < je; pe++){
                    const at = k[pe], dt = at.object, mt = at.geometry, Lt = at.group;
                    let wt = at.material;
                    wt.allowOverride === !0 && we !== null && (wt = we), dt.layers.test(Ae.layers) && Ea(dt, ce, Ae, mt, wt, Lt);
                }
            }
            function Ea(k, ce, Ae, we, pe, je) {
                k.onBeforeRender(D, ce, Ae, we, pe, je), k.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), pe.onBeforeRender(D, ce, Ae, we, k, je), pe.transparent === !0 && pe.side === ka && pe.forceSinglePass === !1 ? (pe.side = sa, pe.needsUpdate = !0, D.renderBufferDirect(Ae, ce, we, pe, k, je), pe.side = Wo, pe.needsUpdate = !0, D.renderBufferDirect(Ae, ce, we, pe, k, je), pe.side = ka) : D.renderBufferDirect(Ae, ce, we, pe, k, je), k.onAfterRender(D, ce, Ae, we, pe, je);
            }
            function Un(k, ce, Ae) {
                ce.isScene !== !0 && (ce = on);
                const we = Xe.get(k), pe = E.state.lights, je = E.state.shadowsArray, at = pe.state.version, dt = Le.getParameters(k, pe.state, je, ce, Ae), mt = Le.getProgramCacheKey(dt);
                let Lt = we.programs;
                we.environment = k.isMeshStandardMaterial ? ce.environment : null, we.fog = ce.fog, we.envMap = (k.isMeshStandardMaterial ? Z : It).get(k.envMap || we.environment), we.envMapRotation = we.environment !== null && k.envMap === null ? ce.environmentRotation : k.envMapRotation, Lt === void 0 && (k.addEventListener("dispose", ct), Lt = new Map, we.programs = Lt);
                let wt = Lt.get(mt);
                if (wt !== void 0) {
                    if (we.currentProgram === wt && we.lightsStateVersion === at) return Aa(k, dt), wt;
                } else dt.uniforms = Le.getUniforms(k), k.onBeforeCompile(dt, D), wt = Le.acquireProgram(dt, mt), Lt.set(mt, wt), we.uniforms = dt.uniforms;
                const Et = we.uniforms;
                return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (Et.clippingPlanes = vt.uniform), Aa(k, dt), we.needsLights = yi(k), we.lightsStateVersion = at, we.needsLights && (Et.ambientLightColor.value = pe.state.ambient, Et.lightProbe.value = pe.state.probe, Et.directionalLights.value = pe.state.directional, Et.directionalLightShadows.value = pe.state.directionalShadow, Et.spotLights.value = pe.state.spot, Et.spotLightShadows.value = pe.state.spotShadow, Et.rectAreaLights.value = pe.state.rectArea, Et.ltc_1.value = pe.state.rectAreaLTC1, Et.ltc_2.value = pe.state.rectAreaLTC2, Et.pointLights.value = pe.state.point, Et.pointLightShadows.value = pe.state.pointShadow, Et.hemisphereLights.value = pe.state.hemi, Et.directionalShadowMap.value = pe.state.directionalShadowMap, Et.directionalShadowMatrix.value = pe.state.directionalShadowMatrix, Et.spotShadowMap.value = pe.state.spotShadowMap, Et.spotLightMatrix.value = pe.state.spotLightMatrix, Et.spotLightMap.value = pe.state.spotLightMap, Et.pointShadowMap.value = pe.state.pointShadowMap, Et.pointShadowMatrix.value = pe.state.pointShadowMatrix), we.currentProgram = wt, we.uniformsList = null, wt;
            }
            function Ta(k) {
                if (k.uniformsList === null) {
                    const ce = k.currentProgram.getUniforms();
                    k.uniformsList = vv.seqWithValue(ce.seq, k.uniforms);
                }
                return k.uniformsList;
            }
            function Aa(k, ce) {
                const Ae = Xe.get(k);
                Ae.outputColorSpace = ce.outputColorSpace, Ae.batching = ce.batching, Ae.batchingColor = ce.batchingColor, Ae.instancing = ce.instancing, Ae.instancingColor = ce.instancingColor, Ae.instancingMorph = ce.instancingMorph, Ae.skinning = ce.skinning, Ae.morphTargets = ce.morphTargets, Ae.morphNormals = ce.morphNormals, Ae.morphColors = ce.morphColors, Ae.morphTargetsCount = ce.morphTargetsCount, Ae.numClippingPlanes = ce.numClippingPlanes, Ae.numIntersection = ce.numClipIntersection, Ae.vertexAlphas = ce.vertexAlphas, Ae.vertexTangents = ce.vertexTangents, Ae.toneMapping = ce.toneMapping;
            }
            function ro(k, ce, Ae, we, pe) {
                ce.isScene !== !0 && (ce = on), ot.resetTextureUnits();
                const je = ce.fog, at = we.isMeshStandardMaterial ? ce.environment : null, dt = F === null ? D.outputColorSpace : F.isXRRenderTarget === !0 ? F.texture.colorSpace : qc, mt = (we.isMeshStandardMaterial ? Z : It).get(we.envMap || at), Lt = we.vertexColors === !0 && !!Ae.attributes.color && Ae.attributes.color.itemSize === 4, wt = !!Ae.attributes.tangent && (!!we.normalMap || we.anisotropy > 0), Et = !!Ae.morphAttributes.position, Kt = !!Ae.morphAttributes.normal, En = !!Ae.morphAttributes.color;
                let Gn = jo;
                we.toneMapped && (F === null || F.isXRRenderTarget === !0) && (Gn = D.toneMapping);
                const Jt = Ae.morphAttributes.position || Ae.morphAttributes.normal || Ae.morphAttributes.color, Tn = Jt !== void 0 ? Jt.length : 0, Rt = Xe.get(we), Dn = E.state.lights;
                if (ue === !0 && (he === !0 || k !== L)) {
                    const Oi = k === L && we.id === z;
                    vt.setState(we, k, Oi);
                }
                let ln = !1;
                we.version === Rt.__version ? (Rt.needsLights && Rt.lightsStateVersion !== Dn.state.version || Rt.outputColorSpace !== dt || pe.isBatchedMesh && Rt.batching === !1 || !pe.isBatchedMesh && Rt.batching === !0 || pe.isBatchedMesh && Rt.batchingColor === !0 && pe.colorTexture === null || pe.isBatchedMesh && Rt.batchingColor === !1 && pe.colorTexture !== null || pe.isInstancedMesh && Rt.instancing === !1 || !pe.isInstancedMesh && Rt.instancing === !0 || pe.isSkinnedMesh && Rt.skinning === !1 || !pe.isSkinnedMesh && Rt.skinning === !0 || pe.isInstancedMesh && Rt.instancingColor === !0 && pe.instanceColor === null || pe.isInstancedMesh && Rt.instancingColor === !1 && pe.instanceColor !== null || pe.isInstancedMesh && Rt.instancingMorph === !0 && pe.morphTexture === null || pe.isInstancedMesh && Rt.instancingMorph === !1 && pe.morphTexture !== null || Rt.envMap !== mt || we.fog === !0 && Rt.fog !== je || Rt.numClippingPlanes !== void 0 && (Rt.numClippingPlanes !== vt.numPlanes || Rt.numIntersection !== vt.numIntersection) || Rt.vertexAlphas !== Lt || Rt.vertexTangents !== wt || Rt.morphTargets !== Et || Rt.morphNormals !== Kt || Rt.morphColors !== En || Rt.toneMapping !== Gn || Rt.morphTargetsCount !== Tn) && (ln = !0) : (ln = !0, Rt.__version = we.version);
                let Ti = Rt.currentProgram;
                ln === !0 && (Ti = Un(we, ce, pe));
                let Wa = !1, zn = !1, Za = !1;
                const Ln = Ti.getUniforms(), Xi = Rt.uniforms;
                if (Be.useProgram(Ti.program) && (Wa = !0, zn = !0, Za = !0), we.id !== z && (z = we.id, zn = !0), Wa || L !== k) {
                    Be.buffers.depth.getReversed() ? (De.copy(k.projectionMatrix), a2(De), r2(De), Ln.setValue(W, "projectionMatrix", De)) : Ln.setValue(W, "projectionMatrix", k.projectionMatrix), Ln.setValue(W, "viewMatrix", k.matrixWorldInverse);
                    const zi = Ln.map.cameraPosition;
                    zi !== void 0 && zi.setValue(W, _t.setFromMatrixPosition(k.matrixWorld)), We.logarithmicDepthBuffer && Ln.setValue(W, "logDepthBufFC", 2 / (Math.log(k.far + 1) / Math.LN2)), (we.isMeshPhongMaterial || we.isMeshToonMaterial || we.isMeshLambertMaterial || we.isMeshBasicMaterial || we.isMeshStandardMaterial || we.isShaderMaterial) && Ln.setValue(W, "isOrthographic", k.isOrthographicCamera === !0), L !== k && (L = k, zn = !0, Za = !0);
                }
                if (pe.isSkinnedMesh) {
                    Ln.setOptional(W, pe, "bindMatrix"), Ln.setOptional(W, pe, "bindMatrixInverse");
                    const Oi = pe.skeleton;
                    Oi && (Oi.boneTexture === null && Oi.computeBoneTexture(), Ln.setValue(W, "boneTexture", Oi.boneTexture, ot));
                }
                pe.isBatchedMesh && (Ln.setOptional(W, pe, "batchingTexture"), Ln.setValue(W, "batchingTexture", pe._matricesTexture, ot), Ln.setOptional(W, pe, "batchingIdTexture"), Ln.setValue(W, "batchingIdTexture", pe._indirectTexture, ot), Ln.setOptional(W, pe, "batchingColorTexture"), pe._colorsTexture !== null && Ln.setValue(W, "batchingColorTexture", pe._colorsTexture, ot));
                const _i = Ae.morphAttributes;
                if ((_i.position !== void 0 || _i.normal !== void 0 || _i.color !== void 0) && st.update(pe, Ae, Ti), (zn || Rt.receiveShadow !== pe.receiveShadow) && (Rt.receiveShadow = pe.receiveShadow, Ln.setValue(W, "receiveShadow", pe.receiveShadow)), we.isMeshGouraudMaterial && we.envMap !== null && (Xi.envMap.value = mt, Xi.flipEnvMap.value = mt.isCubeTexture && mt.isRenderTargetTexture === !1 ? -1 : 1), we.isMeshStandardMaterial && we.envMap === null && ce.environment !== null && (Xi.envMapIntensity.value = ce.environmentIntensity), zn && (Ln.setValue(W, "toneMappingExposure", D.toneMappingExposure), Rt.needsLights && Ar(Xi, Za), je && we.fog === !0 && Ne.refreshFogUniforms(Xi, je), Ne.refreshMaterialUniforms(Xi, we, Q, K, E.state.transmissionRenderTarget[k.id]), vv.upload(W, Ta(Rt), Xi, ot)), we.isShaderMaterial && we.uniformsNeedUpdate === !0 && (vv.upload(W, Ta(Rt), Xi, ot), we.uniformsNeedUpdate = !1), we.isSpriteMaterial && Ln.setValue(W, "center", pe.center), Ln.setValue(W, "modelViewMatrix", pe.modelViewMatrix), Ln.setValue(W, "normalMatrix", pe.normalMatrix), Ln.setValue(W, "modelMatrix", pe.matrixWorld), we.isShaderMaterial || we.isRawShaderMaterial) {
                    const Oi = we.uniformsGroups;
                    for(let zi = 0, hs = Oi.length; zi < hs; zi++){
                        const Ka = Oi[zi];
                        te.update(Ka, Ti), te.bind(Ka, Ti);
                    }
                }
                return Ti;
            }
            function Ar(k, ce) {
                k.ambientLightColor.needsUpdate = ce, k.lightProbe.needsUpdate = ce, k.directionalLights.needsUpdate = ce, k.directionalLightShadows.needsUpdate = ce, k.pointLights.needsUpdate = ce, k.pointLightShadows.needsUpdate = ce, k.spotLights.needsUpdate = ce, k.spotLightShadows.needsUpdate = ce, k.rectAreaLights.needsUpdate = ce, k.hemisphereLights.needsUpdate = ce;
            }
            function yi(k) {
                return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0;
            }
            this.getActiveCubeFace = function() {
                return O;
            }, this.getActiveMipmapLevel = function() {
                return P;
            }, this.getRenderTarget = function() {
                return F;
            }, this.setRenderTargetTextures = function(k, ce, Ae) {
                const we = Xe.get(k);
                we.__autoAllocateDepthBuffer = k.resolveDepthBuffer === !1, we.__autoAllocateDepthBuffer === !1 && (we.__useRenderToTexture = !1), Xe.get(k.texture).__webglTexture = ce, Xe.get(k.depthTexture).__webglTexture = we.__autoAllocateDepthBuffer ? void 0 : Ae, we.__hasExternalTextures = !0;
            }, this.setRenderTargetFramebuffer = function(k, ce) {
                const Ae = Xe.get(k);
                Ae.__webglFramebuffer = ce, Ae.__useDefaultFramebuffer = ce === void 0;
            };
            const Pl = W.createFramebuffer();
            this.setRenderTarget = function(k, ce = 0, Ae = 0) {
                F = k, O = ce, P = Ae;
                let we = !0, pe = null, je = !1, at = !1;
                if (k) {
                    const mt = Xe.get(k);
                    if (mt.__useDefaultFramebuffer !== void 0) Be.bindFramebuffer(W.FRAMEBUFFER, null), we = !1;
                    else if (mt.__webglFramebuffer === void 0) ot.setupRenderTarget(k);
                    else if (mt.__hasExternalTextures) ot.rebindTextures(k, Xe.get(k.texture).__webglTexture, Xe.get(k.depthTexture).__webglTexture);
                    else if (k.depthBuffer) {
                        const Et = k.depthTexture;
                        if (mt.__boundDepthTexture !== Et) {
                            if (Et !== null && Xe.has(Et) && (k.width !== Et.image.width || k.height !== Et.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                            ot.setupDepthRenderbuffer(k);
                        }
                    }
                    const Lt = k.texture;
                    (Lt.isData3DTexture || Lt.isDataArrayTexture || Lt.isCompressedArrayTexture) && (at = !0);
                    const wt = Xe.get(k).__webglFramebuffer;
                    k.isWebGLCubeRenderTarget ? (Array.isArray(wt[ce]) ? pe = wt[ce][Ae] : pe = wt[ce], je = !0) : k.samples > 0 && ot.useMultisampledRTT(k) === !1 ? pe = Xe.get(k).__webglMultisampledFramebuffer : Array.isArray(wt) ? pe = wt[Ae] : pe = wt, q.copy(k.viewport), oe.copy(k.scissor), se = k.scissorTest;
                } else q.copy($).multiplyScalar(Q).floor(), oe.copy(me).multiplyScalar(Q).floor(), se = ve;
                if (Ae !== 0 && (pe = Pl), Be.bindFramebuffer(W.FRAMEBUFFER, pe) && we && Be.drawBuffers(k, pe), Be.viewport(q), Be.scissor(oe), Be.setScissorTest(se), je) {
                    const mt = Xe.get(k.texture);
                    W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_CUBE_MAP_POSITIVE_X + ce, mt.__webglTexture, Ae);
                } else if (at) {
                    const mt = Xe.get(k.texture), Lt = ce;
                    W.framebufferTextureLayer(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, mt.__webglTexture, Ae, Lt);
                } else if (k !== null && Ae !== 0) {
                    const mt = Xe.get(k.texture);
                    W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_2D, mt.__webglTexture, Ae);
                }
                z = -1;
            }, this.readRenderTargetPixels = function(k, ce, Ae, we, pe, je, at, dt = 0) {
                if (!(k && k.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return;
                }
                let mt = Xe.get(k).__webglFramebuffer;
                if (k.isWebGLCubeRenderTarget && at !== void 0 && (mt = mt[at]), mt) {
                    Be.bindFramebuffer(W.FRAMEBUFFER, mt);
                    try {
                        const Lt = k.textures[dt], wt = Lt.format, Et = Lt.type;
                        if (!We.textureFormatReadable(wt)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return;
                        }
                        if (!We.textureTypeReadable(Et)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return;
                        }
                        ce >= 0 && ce <= k.width - we && Ae >= 0 && Ae <= k.height - pe && (k.textures.length > 1 && W.readBuffer(W.COLOR_ATTACHMENT0 + dt), W.readPixels(ce, Ae, we, pe, xe.convert(wt), xe.convert(Et), je));
                    } finally{
                        const Lt = F !== null ? Xe.get(F).__webglFramebuffer : null;
                        Be.bindFramebuffer(W.FRAMEBUFFER, Lt);
                    }
                }
            }, this.readRenderTargetPixelsAsync = async function(k, ce, Ae, we, pe, je, at, dt = 0) {
                if (!(k && k.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let mt = Xe.get(k).__webglFramebuffer;
                if (k.isWebGLCubeRenderTarget && at !== void 0 && (mt = mt[at]), mt) if (ce >= 0 && ce <= k.width - we && Ae >= 0 && Ae <= k.height - pe) {
                    Be.bindFramebuffer(W.FRAMEBUFFER, mt);
                    const Lt = k.textures[dt], wt = Lt.format, Et = Lt.type;
                    if (!We.textureFormatReadable(wt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!We.textureTypeReadable(Et)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Kt = W.createBuffer();
                    W.bindBuffer(W.PIXEL_PACK_BUFFER, Kt), W.bufferData(W.PIXEL_PACK_BUFFER, je.byteLength, W.STREAM_READ), k.textures.length > 1 && W.readBuffer(W.COLOR_ATTACHMENT0 + dt), W.readPixels(ce, Ae, we, pe, xe.convert(wt), xe.convert(Et), 0);
                    const En = F !== null ? Xe.get(F).__webglFramebuffer : null;
                    Be.bindFramebuffer(W.FRAMEBUFFER, En);
                    const Gn = W.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return W.flush(), await s2(W, Gn, 4), W.bindBuffer(W.PIXEL_PACK_BUFFER, Kt), W.getBufferSubData(W.PIXEL_PACK_BUFFER, 0, je), W.deleteBuffer(Kt), W.deleteSync(Gn), je;
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }, this.copyFramebufferToTexture = function(k, ce = null, Ae = 0) {
                const we = Math.pow(2, -Ae), pe = Math.floor(k.image.width * we), je = Math.floor(k.image.height * we), at = ce !== null ? ce.x : 0, dt = ce !== null ? ce.y : 0;
                ot.setTexture2D(k, 0), W.copyTexSubImage2D(W.TEXTURE_2D, Ae, 0, 0, at, dt, pe, je), Be.unbindTexture();
            };
            const Hl = W.createFramebuffer(), wa = W.createFramebuffer();
            this.copyTextureToTexture = function(k, ce, Ae = null, we = null, pe = 0, je = null) {
                je === null && (pe !== 0 ? (od("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), je = pe, pe = 0) : je = 0);
                let at, dt, mt, Lt, wt, Et, Kt, En, Gn;
                const Jt = k.isCompressedTexture ? k.mipmaps[je] : k.image;
                if (Ae !== null) at = Ae.max.x - Ae.min.x, dt = Ae.max.y - Ae.min.y, mt = Ae.isBox3 ? Ae.max.z - Ae.min.z : 1, Lt = Ae.min.x, wt = Ae.min.y, Et = Ae.isBox3 ? Ae.min.z : 0;
                else {
                    const _i = Math.pow(2, -pe);
                    at = Math.floor(Jt.width * _i), dt = Math.floor(Jt.height * _i), k.isDataArrayTexture ? mt = Jt.depth : k.isData3DTexture ? mt = Math.floor(Jt.depth * _i) : mt = 1, Lt = 0, wt = 0, Et = 0;
                }
                we !== null ? (Kt = we.x, En = we.y, Gn = we.z) : (Kt = 0, En = 0, Gn = 0);
                const Tn = xe.convert(ce.format), Rt = xe.convert(ce.type);
                let Dn;
                ce.isData3DTexture ? (ot.setTexture3D(ce, 0), Dn = W.TEXTURE_3D) : ce.isDataArrayTexture || ce.isCompressedArrayTexture ? (ot.setTexture2DArray(ce, 0), Dn = W.TEXTURE_2D_ARRAY) : (ot.setTexture2D(ce, 0), Dn = W.TEXTURE_2D), W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, ce.flipY), W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha), W.pixelStorei(W.UNPACK_ALIGNMENT, ce.unpackAlignment);
                const ln = W.getParameter(W.UNPACK_ROW_LENGTH), Ti = W.getParameter(W.UNPACK_IMAGE_HEIGHT), Wa = W.getParameter(W.UNPACK_SKIP_PIXELS), zn = W.getParameter(W.UNPACK_SKIP_ROWS), Za = W.getParameter(W.UNPACK_SKIP_IMAGES);
                W.pixelStorei(W.UNPACK_ROW_LENGTH, Jt.width), W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Jt.height), W.pixelStorei(W.UNPACK_SKIP_PIXELS, Lt), W.pixelStorei(W.UNPACK_SKIP_ROWS, wt), W.pixelStorei(W.UNPACK_SKIP_IMAGES, Et);
                const Ln = k.isDataArrayTexture || k.isData3DTexture, Xi = ce.isDataArrayTexture || ce.isData3DTexture;
                if (k.isDepthTexture) {
                    const _i = Xe.get(k), Oi = Xe.get(ce), zi = Xe.get(_i.__renderTarget), hs = Xe.get(Oi.__renderTarget);
                    Be.bindFramebuffer(W.READ_FRAMEBUFFER, zi.__webglFramebuffer), Be.bindFramebuffer(W.DRAW_FRAMEBUFFER, hs.__webglFramebuffer);
                    for(let Ka = 0; Ka < mt; Ka++)Ln && (W.framebufferTextureLayer(W.READ_FRAMEBUFFER, W.COLOR_ATTACHMENT0, Xe.get(k).__webglTexture, pe, Et + Ka), W.framebufferTextureLayer(W.DRAW_FRAMEBUFFER, W.COLOR_ATTACHMENT0, Xe.get(ce).__webglTexture, je, Gn + Ka)), W.blitFramebuffer(Lt, wt, at, dt, Kt, En, at, dt, W.DEPTH_BUFFER_BIT, W.NEAREST);
                    Be.bindFramebuffer(W.READ_FRAMEBUFFER, null), Be.bindFramebuffer(W.DRAW_FRAMEBUFFER, null);
                } else if (pe !== 0 || k.isRenderTargetTexture || Xe.has(k)) {
                    const _i = Xe.get(k), Oi = Xe.get(ce);
                    Be.bindFramebuffer(W.READ_FRAMEBUFFER, Hl), Be.bindFramebuffer(W.DRAW_FRAMEBUFFER, wa);
                    for(let zi = 0; zi < mt; zi++)Ln ? W.framebufferTextureLayer(W.READ_FRAMEBUFFER, W.COLOR_ATTACHMENT0, _i.__webglTexture, pe, Et + zi) : W.framebufferTexture2D(W.READ_FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_2D, _i.__webglTexture, pe), Xi ? W.framebufferTextureLayer(W.DRAW_FRAMEBUFFER, W.COLOR_ATTACHMENT0, Oi.__webglTexture, je, Gn + zi) : W.framebufferTexture2D(W.DRAW_FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_2D, Oi.__webglTexture, je), pe !== 0 ? W.blitFramebuffer(Lt, wt, at, dt, Kt, En, at, dt, W.COLOR_BUFFER_BIT, W.NEAREST) : Xi ? W.copyTexSubImage3D(Dn, je, Kt, En, Gn + zi, Lt, wt, at, dt) : W.copyTexSubImage2D(Dn, je, Kt, En, Lt, wt, at, dt);
                    Be.bindFramebuffer(W.READ_FRAMEBUFFER, null), Be.bindFramebuffer(W.DRAW_FRAMEBUFFER, null);
                } else Xi ? k.isDataTexture || k.isData3DTexture ? W.texSubImage3D(Dn, je, Kt, En, Gn, at, dt, mt, Tn, Rt, Jt.data) : ce.isCompressedArrayTexture ? W.compressedTexSubImage3D(Dn, je, Kt, En, Gn, at, dt, mt, Tn, Jt.data) : W.texSubImage3D(Dn, je, Kt, En, Gn, at, dt, mt, Tn, Rt, Jt) : k.isDataTexture ? W.texSubImage2D(W.TEXTURE_2D, je, Kt, En, at, dt, Tn, Rt, Jt.data) : k.isCompressedTexture ? W.compressedTexSubImage2D(W.TEXTURE_2D, je, Kt, En, Jt.width, Jt.height, Tn, Jt.data) : W.texSubImage2D(W.TEXTURE_2D, je, Kt, En, at, dt, Tn, Rt, Jt);
                W.pixelStorei(W.UNPACK_ROW_LENGTH, ln), W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Ti), W.pixelStorei(W.UNPACK_SKIP_PIXELS, Wa), W.pixelStorei(W.UNPACK_SKIP_ROWS, zn), W.pixelStorei(W.UNPACK_SKIP_IMAGES, Za), je === 0 && ce.generateMipmaps && W.generateMipmap(Dn), Be.unbindTexture();
            }, this.copyTextureToTexture3D = function(k, ce, Ae = null, we = null, pe = 0) {
                return od('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(k, ce, Ae, we, pe);
            }, this.initRenderTarget = function(k) {
                Xe.get(k).__webglFramebuffer === void 0 && ot.setupRenderTarget(k);
            }, this.initTexture = function(k) {
                k.isCubeTexture ? ot.setTextureCube(k, 0) : k.isData3DTexture ? ot.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? ot.setTexture2DArray(k, 0) : ot.setTexture2D(k, 0), Be.unbindTexture();
            }, this.resetState = function() {
                O = 0, P = 0, F = null, Be.reset(), Ze.reset();
            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }));
        }
        get coordinateSystem() {
            return xr;
        }
        get outputColorSpace() {
            return this._outputColorSpace;
        }
        set outputColorSpace(e) {
            this._outputColorSpace = e;
            const t = this.getContext();
            t.drawingBufferColorSpace = Sn._getDrawingBufferColorSpace(e), t.unpackColorSpace = Sn._getUnpackColorSpace();
        }
    }
    const mO = Object.freeze(Object.defineProperty({
        __proto__: null,
        ACESFilmicToneMapping: MS,
        AddEquation: Fc,
        AddOperation: YE,
        AdditiveAnimationBlendMode: NS,
        AdditiveBlending: Jx,
        AgXToneMapping: JE,
        AlphaFormat: wS,
        AlwaysCompare: pT,
        AlwaysDepth: Ev,
        AlwaysStencilFunc: nS,
        AmbientLight: nb,
        AnimationAction: lA,
        AnimationClip: wf,
        AnimationLoader: LC,
        AnimationMixer: a3,
        AnimationObjectGroup: i3,
        AnimationUtils: CC,
        ArcCurve: CT,
        ArrayCamera: aA,
        ArrowHelper: A3,
        AttachedBindMode: tS,
        Audio: rA,
        AudioAnalyser: YC,
        AudioContext: ib,
        AudioListener: XC,
        AudioLoader: GC,
        AxesHelper: w3,
        BackSide: sa,
        BasicDepthPacking: aT,
        BasicShadowMap: wE,
        BatchedMesh: AT,
        Bone: Md,
        BooleanKeyframeTrack: Uf,
        Box2: h3,
        Box3: Ui,
        Box3Helper: E3,
        BoxGeometry: $c,
        BoxHelper: M3,
        BufferAttribute: vn,
        BufferGeometry: Dt,
        BufferGeometryLoader: iA,
        ByteType: ES,
        Cache: Xo,
        Camera: Ay,
        CameraHelper: b3,
        CanvasTexture: J2,
        CapsuleGeometry: Ly,
        CatmullRomCurve3: DT,
        CineonToneMapping: KE,
        CircleGeometry: Oy,
        ClampToEdgeWrapping: na,
        Clock: sb,
        Color: tt,
        ColorKeyframeTrack: JS,
        ColorManagement: Sn,
        CompressedArrayTexture: K2,
        CompressedCubeTexture: Q2,
        CompressedTexture: Ny,
        CompressedTextureLoader: OC,
        ConeGeometry: Fm,
        ConstantAlphaFactor: XE,
        ConstantColorFactor: VE,
        Controls: C3,
        CubeCamera: ST,
        CubeReflectionMapping: Bl,
        CubeRefractionMapping: jc,
        CubeTexture: Pm,
        CubeTextureLoader: zC,
        CubeUVReflectionMapping: wd,
        CubicBezierCurve: VS,
        CubicBezierCurve3: NT,
        CubicInterpolant: YT,
        CullFaceBack: Qx,
        CullFaceFront: AE,
        CullFaceFrontBack: oR,
        CullFaceNone: TE,
        Curve: Mr,
        CurvePath: LT,
        CustomBlending: RE,
        CustomToneMapping: QE,
        CylinderGeometry: Dd,
        Cylindrical: f3,
        Data3DTexture: Ey,
        DataArrayTexture: My,
        DataTexture: qo,
        DataTextureLoader: QT,
        DataUtils: S2,
        DecrementStencilOp: yR,
        DecrementWrapStencilOp: xR,
        DefaultLoadingManager: KT,
        DepthFormat: gd,
        DepthStencilFormat: vd,
        DepthTexture: Uy,
        DetachedBindMode: eT,
        DirectionalLight: jy,
        DirectionalLightHelper: S3,
        DiscreteInterpolant: WT,
        DodecahedronGeometry: zy,
        DoubleSide: ka,
        DstAlphaFactor: IE,
        DstColorFactor: HE,
        DynamicCopyUsage: zR,
        DynamicDrawUsage: CR,
        DynamicReadUsage: UR,
        EdgesGeometry: RT,
        EllipseCurve: By,
        EqualCompare: uT,
        EqualDepth: Av,
        EqualStencilFunc: ER,
        EquirectangularReflectionMapping: hd,
        EquirectangularRefractionMapping: Mm,
        Euler: $i,
        EventDispatcher: Qo,
        ExtrudeGeometry: Iy,
        FileLoader: bs,
        Float16BufferAttribute: R2,
        Float32BufferAttribute: nt,
        FloatType: ia,
        Fog: Ry,
        FogExp2: wy,
        FramebufferTexture: Z2,
        FrontSide: Wo,
        Frustum: Cd,
        FrustumArray: Dy,
        GLBufferAttribute: u3,
        GLSL1: IR,
        GLSL3: iS,
        GreaterCompare: fT,
        GreaterDepth: Rv,
        GreaterEqualCompare: dT,
        GreaterEqualDepth: wv,
        GreaterEqualStencilFunc: RR,
        GreaterStencilFunc: AR,
        GridHelper: _3,
        Group: Sr,
        HalfFloatType: Cf,
        HemisphereLight: JT,
        HemisphereLightHelper: y3,
        IcosahedronGeometry: Gm,
        ImageBitmapLoader: sA,
        ImageLoader: Um,
        ImageUtils: vT,
        IncrementStencilOp: vR,
        IncrementWrapStencilOp: _R,
        InstancedBufferAttribute: Tf,
        InstancedBufferGeometry: nA,
        InstancedInterleavedBuffer: c3,
        InstancedMesh: HS,
        Int16BufferAttribute: A2,
        Int32BufferAttribute: w2,
        Int8BufferAttribute: M2,
        IntType: gy,
        InterleavedBuffer: Hm,
        InterleavedBufferAttribute: Yc,
        Interpolant: Ud,
        InterpolateDiscrete: yd,
        InterpolateLinear: _d,
        InterpolateSmooth: mv,
        InterpolationSamplingMode: FR,
        InterpolationSamplingType: HR,
        InvertStencilOp: SR,
        KeepStencilOp: hf,
        KeyframeTrack: Tr,
        LOD: TT,
        LatheGeometry: Py,
        Layers: Sd,
        LessCompare: cT,
        LessDepth: Tv,
        LessEqualCompare: LS,
        LessEqualDepth: Ef,
        LessEqualStencilFunc: TR,
        LessStencilFunc: MR,
        Light: tu,
        LightProbe: tA,
        Line: Ko,
        Line3: d3,
        LineBasicMaterial: Vi,
        LineCurve: kS,
        LineCurve3: UT,
        LineDashedMaterial: XT,
        LineLoop: FS,
        LineSegments: Ya,
        LinearFilter: pi,
        LinearInterpolant: QS,
        LinearMipMapLinearFilter: fR,
        LinearMipMapNearestFilter: uR,
        LinearMipmapLinearFilter: Xa,
        LinearMipmapNearestFilter: rd,
        LinearSRGBColorSpace: qc,
        LinearToneMapping: WE,
        LinearTransfer: Tm,
        Loader: ki,
        LoaderUtils: Ol,
        LoadingManager: $S,
        LoopOnce: tT,
        LoopPingPong: iT,
        LoopRepeat: nT,
        MOUSE: uf,
        Material: Li,
        MaterialLoader: qy,
        MathUtils: yr,
        Matrix2: lb,
        Matrix3: Yt,
        Matrix4: pt,
        MaxEquation: UE,
        Mesh: ai,
        MeshBasicMaterial: ja,
        MeshDepthMaterial: WS,
        MeshDistanceMaterial: ZS,
        MeshLambertMaterial: YS,
        MeshMatcapMaterial: kT,
        MeshNormalMaterial: VT,
        MeshPhongMaterial: ud,
        MeshPhysicalMaterial: Er,
        MeshStandardMaterial: Xm,
        MeshToonMaterial: GT,
        MinEquation: NE,
        MirroredRepeatWrapping: dd,
        MixOperation: qE,
        MultiplyBlending: eS,
        MultiplyOperation: Bm,
        NearestFilter: cs,
        NearestMipMapLinearFilter: cR,
        NearestMipMapNearestFilter: lR,
        NearestMipmapLinearFilter: gf,
        NearestMipmapNearestFilter: my,
        NeutralToneMapping: $E,
        NeverCompare: lT,
        NeverDepth: Mv,
        NeverStencilFunc: bR,
        NoBlending: Ul,
        NoColorSpace: Dl,
        NoToneMapping: jo,
        NormalAnimationBlendMode: by,
        NormalBlending: Sf,
        NotEqualCompare: hT,
        NotEqualDepth: Cv,
        NotEqualStencilFunc: wR,
        NumberKeyframeTrack: Wc,
        Object3D: hn,
        ObjectLoader: HC,
        ObjectSpaceNormalMap: oT,
        OctahedronGeometry: Vm,
        OneFactor: OE,
        OneMinusConstantAlphaFactor: jE,
        OneMinusConstantColorFactor: kE,
        OneMinusDstAlphaFactor: PE,
        OneMinusDstColorFactor: FE,
        OneMinusSrcAlphaFactor: bv,
        OneMinusSrcColorFactor: BE,
        OrthographicCamera: Yo,
        PCFShadowMap: dy,
        PCFSoftShadowMap: hm,
        PMREMGenerator: fS,
        Path: ry,
        PerspectiveCamera: hi,
        Plane: Cl,
        PlaneGeometry: Nd,
        PlaneHelper: T3,
        PointLight: Lm,
        PointLightHelper: g3,
        Points: cd,
        PointsMaterial: kc,
        PolarGridHelper: x3,
        PolyhedronGeometry: eu,
        PositionalAudio: qC,
        PropertyBinding: fn,
        PropertyMixer: oA,
        QuadraticBezierCurve: XS,
        QuadraticBezierCurve3: jS,
        Quaternion: mi,
        QuaternionKeyframeTrack: Zc,
        QuaternionLinearInterpolant: ZT,
        RED_GREEN_RGTC2_Format: ey,
        RED_RGTC1_Format: DS,
        REVISION: zm,
        RGBADepthPacking: rT,
        RGBAFormat: Is,
        RGBAIntegerFormat: Sy,
        RGBA_ASTC_10x10_Format: Wv,
        RGBA_ASTC_10x5_Format: jv,
        RGBA_ASTC_10x6_Format: qv,
        RGBA_ASTC_10x8_Format: Yv,
        RGBA_ASTC_12x10_Format: Zv,
        RGBA_ASTC_12x12_Format: Kv,
        RGBA_ASTC_4x4_Format: Iv,
        RGBA_ASTC_5x4_Format: Pv,
        RGBA_ASTC_5x5_Format: Hv,
        RGBA_ASTC_6x5_Format: Fv,
        RGBA_ASTC_6x6_Format: Gv,
        RGBA_ASTC_8x5_Format: Vv,
        RGBA_ASTC_8x6_Format: kv,
        RGBA_ASTC_8x8_Format: Xv,
        RGBA_BPTC_Format: vm,
        RGBA_ETC2_EAC_Format: Bv,
        RGBA_PVRTC_2BPPV1_Format: Lv,
        RGBA_PVRTC_4BPPV1_Format: Uv,
        RGBA_S3TC_DXT1_Format: pm,
        RGBA_S3TC_DXT3_Format: mm,
        RGBA_S3TC_DXT5_Format: gm,
        RGBDepthPacking: dR,
        RGBFormat: RS,
        RGBIntegerFormat: hR,
        RGB_BPTC_SIGNED_Format: Qv,
        RGB_BPTC_UNSIGNED_Format: Jv,
        RGB_ETC1_Format: Ov,
        RGB_ETC2_Format: zv,
        RGB_PVRTC_2BPPV1_Format: Nv,
        RGB_PVRTC_4BPPV1_Format: Dv,
        RGB_S3TC_DXT1_Format: dm,
        RGDepthPacking: pR,
        RGFormat: CS,
        RGIntegerFormat: xy,
        RawShaderMaterial: FT,
        Ray: Df,
        Raycaster: cA,
        RectAreaLight: $T,
        RedFormat: _y,
        RedIntegerFormat: Im,
        ReinhardToneMapping: ZE,
        RenderTarget: zS,
        RenderTarget3D: r3,
        RepeatWrapping: Zo,
        ReplaceStencilOp: gR,
        ReverseSubtractEquation: DE,
        RingGeometry: Hy,
        SIGNED_RED_GREEN_RGTC2_Format: ty,
        SIGNED_RED_RGTC1_Format: $v,
        SRGBColorSpace: Bs,
        SRGBTransfer: Fn,
        Scene: IS,
        ShaderChunk: sn,
        ShaderLib: no,
        ShaderMaterial: ao,
        ShadowMaterial: HT,
        Shape: Mf,
        ShapeGeometry: Fy,
        ShapePath: R3,
        ShapeUtils: io,
        ShortType: TS,
        Skeleton: Rd,
        SkeletonHelper: m3,
        SkinnedMesh: Cy,
        Source: Vc,
        Sphere: us,
        SphereGeometry: Nf,
        Spherical: cS,
        SphericalHarmonics3: eA,
        SplineCurve: qS,
        SpotLight: Xy,
        SpotLightHelper: p3,
        Sprite: ET,
        SpriteMaterial: PS,
        SrcAlphaFactor: Sv,
        SrcAlphaSaturateFactor: GE,
        SrcColorFactor: zE,
        StaticCopyUsage: OR,
        StaticDrawUsage: Am,
        StaticReadUsage: NR,
        StereoCamera: VC,
        StreamCopyUsage: BR,
        StreamDrawUsage: DR,
        StreamReadUsage: LR,
        StringKeyframeTrack: Lf,
        SubtractEquation: CE,
        SubtractiveBlending: $x,
        TOUCH: ff,
        TangentSpaceNormalMap: Jc,
        TetrahedronGeometry: km,
        Texture: Qn,
        TextureLoader: eb,
        TextureUtils: O3,
        TimestampQuery: PR,
        TorusGeometry: Gy,
        TorusKnotGeometry: Vy,
        Triangle: ba,
        TriangleFanDrawMode: ny,
        TriangleStripDrawMode: US,
        TrianglesDrawMode: sT,
        TubeGeometry: ky,
        UVMapping: py,
        Uint16BufferAttribute: Ty,
        Uint32BufferAttribute: BS,
        Uint8BufferAttribute: E2,
        Uint8ClampedBufferAttribute: T2,
        Uniform: ob,
        UniformsGroup: l3,
        UniformsLib: ht,
        UniformsUtils: xT,
        UnsignedByteType: br,
        UnsignedInt248Type: md,
        UnsignedInt5999Type: AS,
        UnsignedIntType: Il,
        UnsignedShort4444Type: vy,
        UnsignedShort5551Type: yy,
        UnsignedShortType: pd,
        VSMShadowMap: to,
        Vector2: Ie,
        Vector3: Y,
        Vector4: gn,
        VectorKeyframeTrack: Kc,
        VideoFrameTexture: W2,
        VideoTexture: wT,
        WebGL3DRenderTarget: f2,
        WebGLArrayRenderTarget: u2,
        WebGLCoordinateSystem: xr,
        WebGLCubeRenderTarget: bT,
        WebGLRenderTarget: so,
        WebGLRenderer: vA,
        WebGLUtils: gA,
        WebGPUCoordinateSystem: wm,
        WebXRController: gv,
        WireframeGeometry: PT,
        WrapAroundEnding: Em,
        ZeroCurvatureEnding: vf,
        ZeroFactor: LE,
        ZeroSlopeEnding: yf,
        ZeroStencilOp: mR,
        createCanvasElement: gT
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var Ax = {
        exports: {}
    }, wl = {};
    var F1;
    function gO() {
        return F1 || (F1 = 1, wl.ConcurrentRoot = 1, wl.ContinuousEventPriority = 8, wl.DefaultEventPriority = 32, wl.DiscreteEventPriority = 2, wl.IdleEventPriority = 268435456, wl.LegacyRoot = 0, wl.NoEventPriority = 0), wl;
    }
    var G1;
    function vO() {
        return G1 || (G1 = 1, Ax.exports = gO()), Ax.exports;
    }
    var yv = vO(), wx = {
        exports: {}
    }, Rx = {}, Cx = {
        exports: {}
    }, Dx = {};
    var V1;
    function yO() {
        if (V1) return Dx;
        V1 = 1;
        var r = Ad();
        function e(y, _) {
            return y === _ && (y !== 0 || 1 / y === 1 / _) || y !== y && _ !== _;
        }
        var t = typeof Object.is == "function" ? Object.is : e, n = r.useState, i = r.useEffect, a = r.useLayoutEffect, l = r.useDebugValue;
        function f(y, _) {
            var x = _(), M = n({
                inst: {
                    value: x,
                    getSnapshot: _
                }
            }), R = M[0].inst, T = M[1];
            return a(function() {
                R.value = x, R.getSnapshot = _, d(R) && T({
                    inst: R
                });
            }, [
                y,
                x,
                _
            ]), i(function() {
                return d(R) && T({
                    inst: R
                }), y(function() {
                    d(R) && T({
                        inst: R
                    });
                });
            }, [
                y
            ]), l(x), x;
        }
        function d(y) {
            var _ = y.getSnapshot;
            y = y.value;
            try {
                var x = _();
                return !t(y, x);
            } catch  {
                return !0;
            }
        }
        function p(y, _) {
            return _();
        }
        var g = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? p : f;
        return Dx.useSyncExternalStore = r.useSyncExternalStore !== void 0 ? r.useSyncExternalStore : g, Dx;
    }
    var k1;
    function _O() {
        return k1 || (k1 = 1, Cx.exports = yO()), Cx.exports;
    }
    var X1;
    function xO() {
        if (X1) return Rx;
        X1 = 1;
        var r = Ad(), e = _O();
        function t(p, g) {
            return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
        }
        var n = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, a = r.useRef, l = r.useEffect, f = r.useMemo, d = r.useDebugValue;
        return Rx.useSyncExternalStoreWithSelector = function(p, g, y, _, x) {
            var M = a(null);
            if (M.current === null) {
                var R = {
                    hasValue: !1,
                    value: null
                };
                M.current = R;
            } else R = M.current;
            M = f(function() {
                function E(O) {
                    if (!C) {
                        if (C = !0, N = O, O = _(O), x !== void 0 && R.hasValue) {
                            var P = R.value;
                            if (x(P, O)) return D = P;
                        }
                        return D = O;
                    }
                    if (P = D, n(N, O)) return P;
                    var F = _(O);
                    return x !== void 0 && x(P, F) ? (N = O, P) : (N = O, D = F);
                }
                var C = !1, N, D, I = y === void 0 ? null : y;
                return [
                    function() {
                        return E(g());
                    },
                    I === null ? void 0 : function() {
                        return E(I());
                    }
                ];
            }, [
                g,
                y,
                _,
                x
            ]);
            var T = i(p, M[0], M[1]);
            return l(function() {
                R.hasValue = !0, R.value = T;
            }, [
                T
            ]), d(T), T;
        }, Rx;
    }
    var j1;
    function SO() {
        return j1 || (j1 = 1, wx.exports = xO()), wx.exports;
    }
    var bO = SO();
    const MO = hy(bO), q1 = (r)=>{
        let e;
        const t = new Set, n = (p, g)=>{
            const y = typeof p == "function" ? p(e) : p;
            if (!Object.is(y, e)) {
                const _ = e;
                e = g ?? (typeof y != "object" || y === null) ? y : Object.assign({}, e, y), t.forEach((x)=>x(e, _));
            }
        }, i = ()=>e, f = {
            setState: n,
            getState: i,
            getInitialState: ()=>d,
            subscribe: (p)=>(t.add(p), ()=>t.delete(p))
        }, d = e = r(n, i, f);
        return f;
    }, EO = (r)=>r ? q1(r) : q1, { useSyncExternalStoreWithSelector: TO } = MO, AO = (r)=>r;
    function wO(r, e = AO, t) {
        const n = TO(r.subscribe, r.getState, r.getInitialState, e, t);
        return EE.useDebugValue(n), n;
    }
    const Y1 = (r, e)=>{
        const t = EO(r), n = (i, a = e)=>wO(t, i, a);
        return Object.assign(n, t), n;
    }, RO = (r, e)=>r ? Y1(r, e) : Y1;
    var Nx = {
        exports: {}
    }, Ux = {
        exports: {}
    }, Lx = {
        exports: {}
    }, Ox = {};
    var W1;
    function CO() {
        return W1 || (W1 = 1, (function(r) {
            function e(H, K) {
                var Q = H.length;
                H.push(K);
                e: for(; 0 < Q;){
                    var fe = Q - 1 >>> 1, X = H[fe];
                    if (0 < i(X, K)) H[fe] = K, H[Q] = X, Q = fe;
                    else break e;
                }
            }
            function t(H) {
                return H.length === 0 ? null : H[0];
            }
            function n(H) {
                if (H.length === 0) return null;
                var K = H[0], Q = H.pop();
                if (Q !== K) {
                    H[0] = Q;
                    e: for(var fe = 0, X = H.length, $ = X >>> 1; fe < $;){
                        var me = 2 * (fe + 1) - 1, ve = H[me], J = me + 1, ue = H[J];
                        if (0 > i(ve, Q)) J < X && 0 > i(ue, ve) ? (H[fe] = ue, H[J] = Q, fe = J) : (H[fe] = ve, H[me] = Q, fe = me);
                        else if (J < X && 0 > i(ue, Q)) H[fe] = ue, H[J] = Q, fe = J;
                        else break e;
                    }
                }
                return K;
            }
            function i(H, K) {
                var Q = H.sortIndex - K.sortIndex;
                return Q !== 0 ? Q : H.id - K.id;
            }
            if (r.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
                var a = performance;
                r.unstable_now = function() {
                    return a.now();
                };
            } else {
                var l = Date, f = l.now();
                r.unstable_now = function() {
                    return l.now() - f;
                };
            }
            var d = [], p = [], g = 1, y = null, _ = 3, x = !1, M = !1, R = !1, T = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
            function N(H) {
                for(var K = t(p); K !== null;){
                    if (K.callback === null) n(p);
                    else if (K.startTime <= H) n(p), K.sortIndex = K.expirationTime, e(d, K);
                    else break;
                    K = t(p);
                }
            }
            function D(H) {
                if (R = !1, N(H), !M) if (t(d) !== null) M = !0, ge();
                else {
                    var K = t(p);
                    K !== null && _e(D, K.startTime - H);
                }
            }
            var I = !1, O = -1, P = 5, F = -1;
            function z() {
                return !(r.unstable_now() - F < P);
            }
            function L() {
                if (I) {
                    var H = r.unstable_now();
                    F = H;
                    var K = !0;
                    try {
                        e: {
                            M = !1, R && (R = !1, E(O), O = -1), x = !0;
                            var Q = _;
                            try {
                                t: {
                                    for(N(H), y = t(d); y !== null && !(y.expirationTime > H && z());){
                                        var fe = y.callback;
                                        if (typeof fe == "function") {
                                            y.callback = null, _ = y.priorityLevel;
                                            var X = fe(y.expirationTime <= H);
                                            if (H = r.unstable_now(), typeof X == "function") {
                                                y.callback = X, N(H), K = !0;
                                                break t;
                                            }
                                            y === t(d) && n(d), N(H);
                                        } else n(d);
                                        y = t(d);
                                    }
                                    if (y !== null) K = !0;
                                    else {
                                        var $ = t(p);
                                        $ !== null && _e(D, $.startTime - H), K = !1;
                                    }
                                }
                                break e;
                            } finally{
                                y = null, _ = Q, x = !1;
                            }
                            K = void 0;
                        }
                    } finally{
                        K ? q() : I = !1;
                    }
                }
            }
            var q;
            if (typeof C == "function") q = function() {
                C(L);
            };
            else if (typeof MessageChannel < "u") {
                var oe = new MessageChannel, se = oe.port2;
                oe.port1.onmessage = L, q = function() {
                    se.postMessage(null);
                };
            } else q = function() {
                T(L, 0);
            };
            function ge() {
                I || (I = !0, q());
            }
            function _e(H, K) {
                O = T(function() {
                    H(r.unstable_now());
                }, K);
            }
            r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(H) {
                H.callback = null;
            }, r.unstable_continueExecution = function() {
                M || x || (M = !0, ge());
            }, r.unstable_forceFrameRate = function(H) {
                0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < H ? Math.floor(1e3 / H) : 5;
            }, r.unstable_getCurrentPriorityLevel = function() {
                return _;
            }, r.unstable_getFirstCallbackNode = function() {
                return t(d);
            }, r.unstable_next = function(H) {
                switch(_){
                    case 1:
                    case 2:
                    case 3:
                        var K = 3;
                        break;
                    default:
                        K = _;
                }
                var Q = _;
                _ = K;
                try {
                    return H();
                } finally{
                    _ = Q;
                }
            }, r.unstable_pauseExecution = function() {}, r.unstable_requestPaint = function() {}, r.unstable_runWithPriority = function(H, K) {
                switch(H){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        H = 3;
                }
                var Q = _;
                _ = H;
                try {
                    return K();
                } finally{
                    _ = Q;
                }
            }, r.unstable_scheduleCallback = function(H, K, Q) {
                var fe = r.unstable_now();
                switch(typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? fe + Q : fe) : Q = fe, H){
                    case 1:
                        var X = -1;
                        break;
                    case 2:
                        X = 250;
                        break;
                    case 5:
                        X = 1073741823;
                        break;
                    case 4:
                        X = 1e4;
                        break;
                    default:
                        X = 5e3;
                }
                return X = Q + X, H = {
                    id: g++,
                    callback: K,
                    priorityLevel: H,
                    startTime: Q,
                    expirationTime: X,
                    sortIndex: -1
                }, Q > fe ? (H.sortIndex = Q, e(p, H), t(d) === null && H === t(p) && (R ? (E(O), O = -1) : R = !0, _e(D, Q - fe))) : (H.sortIndex = X, e(d, H), M || x || (M = !0, ge())), H;
            }, r.unstable_shouldYield = z, r.unstable_wrapCallback = function(H) {
                var K = _;
                return function() {
                    var Q = _;
                    _ = K;
                    try {
                        return H.apply(this, arguments);
                    } finally{
                        _ = Q;
                    }
                };
            };
        })(Ox)), Ox;
    }
    var Z1;
    function yA() {
        return Z1 || (Z1 = 1, Lx.exports = CO()), Lx.exports;
    }
    var K1;
    function DO() {
        return K1 || (K1 = 1, (function(r) {
            r.exports = function(e) {
                function t(c, u, v, b) {
                    return new cp(c, u, v, b);
                }
                function n() {}
                function i(c) {
                    var u = "https://react.dev/errors/" + c;
                    if (1 < arguments.length) {
                        u += "?args[]=" + encodeURIComponent(arguments[1]);
                        for(var v = 2; v < arguments.length; v++)u += "&args[]=" + encodeURIComponent(arguments[v]);
                    }
                    return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
                }
                function a(c) {
                    return c === null || typeof c != "object" ? null : (c = Hr && c[Hr] || c["@@iterator"], typeof c == "function" ? c : null);
                }
                function l(c) {
                    if (c == null) return null;
                    if (typeof c == "function") return c.$$typeof === dp ? null : c.displayName || c.name || null;
                    if (typeof c == "string") return c;
                    switch(c){
                        case Mo:
                            return "Fragment";
                        case la:
                            return "Portal";
                        case ih:
                            return "Profiler";
                        case Du:
                            return "StrictMode";
                        case sh:
                            return "Suspense";
                        case ac:
                            return "SuspenseList";
                    }
                    if (typeof c == "object") switch(c.$$typeof){
                        case Da:
                            return (c.displayName || "Context") + ".Provider";
                        case fp:
                            return (c._context.displayName || "Context") + ".Consumer";
                        case Uu:
                            var u = c.render;
                            return c = c.displayName, c || (c = u.displayName || u.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
                        case ah:
                            return u = c.displayName || null, u !== null ? u : l(c.type) || "Memo";
                        case ca:
                            u = c._payload, c = c._init;
                            try {
                                return l(c(u));
                            } catch  {}
                    }
                    return null;
                }
                function f(c) {
                    if (tr === void 0) try {
                        throw Error();
                    } catch (v) {
                        var u = v.stack.trim().match(/\n( *(at )?)/);
                        tr = u && u[1] || "", Fr = -1 < v.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < v.stack.indexOf("@") ? "@unknown:0:0" : "";
                    }
                    return `
` + tr + c + Fr;
                }
                function d(c, u) {
                    if (!c || nl) return "";
                    nl = !0;
                    var v = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        var b = {
                            DetermineComponentFrameRoot: function() {
                                try {
                                    if (u) {
                                        var ft = function() {
                                            throw Error();
                                        };
                                        if (Object.defineProperty(ft.prototype, "props", {
                                            set: function() {
                                                throw Error();
                                            }
                                        }), typeof Reflect == "object" && Reflect.construct) {
                                            try {
                                                Reflect.construct(ft, []);
                                            } catch (Xt) {
                                                var gt = Xt;
                                            }
                                            Reflect.construct(c, [], ft);
                                        } else {
                                            try {
                                                ft.call();
                                            } catch (Xt) {
                                                gt = Xt;
                                            }
                                            c.call(ft.prototype);
                                        }
                                    } else {
                                        try {
                                            throw Error();
                                        } catch (Xt) {
                                            gt = Xt;
                                        }
                                        (ft = c()) && typeof ft.catch == "function" && ft.catch(function() {});
                                    }
                                } catch (Xt) {
                                    if (Xt && gt && typeof Xt.stack == "string") return [
                                        Xt.stack,
                                        gt.stack
                                    ];
                                }
                                return [
                                    null,
                                    null
                                ];
                            }
                        };
                        b.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                        var w = Object.getOwnPropertyDescriptor(b.DetermineComponentFrameRoot, "name");
                        w && w.configurable && Object.defineProperty(b.DetermineComponentFrameRoot, "name", {
                            value: "DetermineComponentFrameRoot"
                        });
                        var U = b.DetermineComponentFrameRoot(), j = U[0], ne = U[1];
                        if (j && ne) {
                            var ye = j.split(`
`), Oe = ne.split(`
`);
                            for(w = b = 0; b < ye.length && !ye[b].includes("DetermineComponentFrameRoot");)b++;
                            for(; w < Oe.length && !Oe[w].includes("DetermineComponentFrameRoot");)w++;
                            if (b === ye.length || w === Oe.length) for(b = ye.length - 1, w = Oe.length - 1; 1 <= b && 0 <= w && ye[b] !== Oe[w];)w--;
                            for(; 1 <= b && 0 <= w; b--, w--)if (ye[b] !== Oe[w]) {
                                if (b !== 1 || w !== 1) do if (b--, w--, 0 > w || ye[b] !== Oe[w]) {
                                    var $e = `
` + ye[b].replace(" at new ", " at ");
                                    return c.displayName && $e.includes("<anonymous>") && ($e = $e.replace("<anonymous>", c.displayName)), $e;
                                }
                                while (1 <= b && 0 <= w);
                                break;
                            }
                        }
                    } finally{
                        nl = !1, Error.prepareStackTrace = v;
                    }
                    return (v = c ? c.displayName || c.name : "") ? f(v) : "";
                }
                function p(c) {
                    switch(c.tag){
                        case 26:
                        case 27:
                        case 5:
                            return f(c.type);
                        case 16:
                            return f("Lazy");
                        case 13:
                            return f("Suspense");
                        case 19:
                            return f("SuspenseList");
                        case 0:
                        case 15:
                            return c = d(c.type, !1), c;
                        case 11:
                            return c = d(c.type.render, !1), c;
                        case 1:
                            return c = d(c.type, !0), c;
                        default:
                            return "";
                    }
                }
                function g(c) {
                    try {
                        var u = "";
                        do u += p(c), c = c.return;
                        while (c);
                        return u;
                    } catch (v) {
                        return `
Error generating stack: ` + v.message + `
` + v.stack;
                    }
                }
                function y(c) {
                    var u = c, v = c;
                    if (c.alternate) for(; u.return;)u = u.return;
                    else {
                        c = u;
                        do u = c, (u.flags & 4098) !== 0 && (v = u.return), c = u.return;
                        while (c);
                    }
                    return u.tag === 3 ? v : null;
                }
                function _(c) {
                    if (y(c) !== c) throw Error(i(188));
                }
                function x(c) {
                    var u = c.alternate;
                    if (!u) {
                        if (u = y(c), u === null) throw Error(i(188));
                        return u !== c ? null : c;
                    }
                    for(var v = c, b = u;;){
                        var w = v.return;
                        if (w === null) break;
                        var U = w.alternate;
                        if (U === null) {
                            if (b = w.return, b !== null) {
                                v = b;
                                continue;
                            }
                            break;
                        }
                        if (w.child === U.child) {
                            for(U = w.child; U;){
                                if (U === v) return _(w), c;
                                if (U === b) return _(w), u;
                                U = U.sibling;
                            }
                            throw Error(i(188));
                        }
                        if (v.return !== b.return) v = w, b = U;
                        else {
                            for(var j = !1, ne = w.child; ne;){
                                if (ne === v) {
                                    j = !0, v = w, b = U;
                                    break;
                                }
                                if (ne === b) {
                                    j = !0, b = w, v = U;
                                    break;
                                }
                                ne = ne.sibling;
                            }
                            if (!j) {
                                for(ne = U.child; ne;){
                                    if (ne === v) {
                                        j = !0, v = U, b = w;
                                        break;
                                    }
                                    if (ne === b) {
                                        j = !0, b = U, v = w;
                                        break;
                                    }
                                    ne = ne.sibling;
                                }
                                if (!j) throw Error(i(189));
                            }
                        }
                        if (v.alternate !== b) throw Error(i(190));
                    }
                    if (v.tag !== 3) throw Error(i(188));
                    return v.stateNode.current === v ? c : u;
                }
                function M(c) {
                    var u = c.tag;
                    if (u === 5 || u === 26 || u === 27 || u === 6) return c;
                    for(c = c.child; c !== null;){
                        if (u = M(c), u !== null) return u;
                        c = c.sibling;
                    }
                    return null;
                }
                function R(c) {
                    var u = c.tag;
                    if (u === 5 || u === 26 || u === 27 || u === 6) return c;
                    for(c = c.child; c !== null;){
                        if (c.tag !== 4 && (u = R(c), u !== null)) return u;
                        c = c.sibling;
                    }
                    return null;
                }
                function T(c) {
                    return {
                        current: c
                    };
                }
                function E(c) {
                    0 > Xr || (c.current = li[Xr], li[Xr] = null, Xr--);
                }
                function C(c, u) {
                    Xr++, li[Xr] = c.current, c.current = u;
                }
                function N(c) {
                    return c >>>= 0, c === 0 ? 32 : 31 - (Qg(c) / Jg | 0) | 0;
                }
                function D(c) {
                    var u = c & 42;
                    if (u !== 0) return u;
                    switch(c & -c){
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                            return 64;
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return c & 4194176;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return c & 62914560;
                        case 67108864:
                            return 67108864;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 0;
                        default:
                            return c;
                    }
                }
                function I(c, u) {
                    var v = c.pendingLanes;
                    if (v === 0) return 0;
                    var b = 0, w = c.suspendedLanes, U = c.pingedLanes, j = c.warmLanes;
                    c = c.finishedLanes !== 0;
                    var ne = v & 134217727;
                    return ne !== 0 ? (v = ne & ~w, v !== 0 ? b = D(v) : (U &= ne, U !== 0 ? b = D(U) : c || (j = ne & ~j, j !== 0 && (b = D(j))))) : (ne = v & ~w, ne !== 0 ? b = D(ne) : U !== 0 ? b = D(U) : c || (j = v & ~j, j !== 0 && (b = D(j)))), b === 0 ? 0 : u !== 0 && u !== b && (u & w) === 0 && (w = b & -b, j = u & -u, w >= j || w === 32 && (j & 4194176) !== 0) ? u : b;
                }
                function O(c, u) {
                    return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & u) === 0;
                }
                function P(c, u) {
                    switch(c){
                        case 1:
                        case 2:
                        case 4:
                        case 8:
                            return u + 250;
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return u + 5e3;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return -1;
                        case 67108864:
                        case 134217728:
                        case 268435456:
                        case 536870912:
                        case 1073741824:
                            return -1;
                        default:
                            return -1;
                    }
                }
                function F() {
                    var c = ir;
                    return ir <<= 1, (ir & 4194176) === 0 && (ir = 128), c;
                }
                function z() {
                    var c = al;
                    return al <<= 1, (al & 62914560) === 0 && (al = 4194304), c;
                }
                function L(c) {
                    for(var u = [], v = 0; 31 > v; v++)u.push(c);
                    return u;
                }
                function q(c, u) {
                    c.pendingLanes |= u, u !== 268435456 && (c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0);
                }
                function oe(c, u, v, b, w, U) {
                    var j = c.pendingLanes;
                    c.pendingLanes = v, c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0, c.expiredLanes &= v, c.entangledLanes &= v, c.errorRecoveryDisabledLanes &= v, c.shellSuspendCounter = 0;
                    var ne = c.entanglements, ye = c.expirationTimes, Oe = c.hiddenUpdates;
                    for(v = j & ~v; 0 < v;){
                        var $e = 31 - ys(v), ft = 1 << $e;
                        ne[$e] = 0, ye[$e] = -1;
                        var gt = Oe[$e];
                        if (gt !== null) for(Oe[$e] = null, $e = 0; $e < gt.length; $e++){
                            var Xt = gt[$e];
                            Xt !== null && (Xt.lane &= -536870913);
                        }
                        v &= ~ft;
                    }
                    b !== 0 && se(c, b, 0), U !== 0 && w === 0 && c.tag !== 0 && (c.suspendedLanes |= U & ~(j & ~u));
                }
                function se(c, u, v) {
                    c.pendingLanes |= u, c.suspendedLanes &= ~u;
                    var b = 31 - ys(u);
                    c.entangledLanes |= u, c.entanglements[b] = c.entanglements[b] | 1073741824 | v & 4194218;
                }
                function ge(c, u) {
                    var v = c.entangledLanes |= u;
                    for(c = c.entanglements; v;){
                        var b = 31 - ys(v), w = 1 << b;
                        w & u | c[b] & u && (c[b] |= u), v &= ~w;
                    }
                }
                function _e(c) {
                    return c &= -c, 2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
                }
                function H(c) {
                    if (Ds && typeof Ds.onCommitFiberRoot == "function") try {
                        Ds.onCommitFiberRoot(ci, c, void 0, (c.current.flags & 128) === 128);
                    } catch  {}
                }
                function K(c) {
                    if (typeof t0 == "function" && Pi(c), Ds && typeof Ds.setStrictMode == "function") try {
                        Ds.setStrictMode(ci, c);
                    } catch  {}
                }
                function Q(c, u) {
                    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
                }
                function fe(c, u) {
                    if (typeof c == "object" && c !== null) {
                        var v = Up.get(c);
                        return v !== void 0 ? v : (u = {
                            value: c,
                            source: u,
                            stack: g(u)
                        }, Up.set(c, u), u);
                    }
                    return {
                        value: c,
                        source: u,
                        stack: g(u)
                    };
                }
                function X(c, u) {
                    rl[ol++] = pc, rl[ol++] = ll, ll = c, pc = u;
                }
                function $(c, u, v) {
                    Vs[ks++] = La, Vs[ks++] = Oa, Vs[ks++] = Do, Do = c;
                    var b = La;
                    c = Oa;
                    var w = 32 - ys(b) - 1;
                    b &= ~(1 << w), v += 1;
                    var U = 32 - ys(u) + w;
                    if (30 < U) {
                        var j = w - w % 5;
                        U = (b & (1 << j) - 1).toString(32), b >>= j, w -= j, La = 1 << 32 - ys(u) + w | v << w | b, Oa = U + c;
                    } else La = 1 << U | v << w | b, Oa = c;
                }
                function me(c) {
                    c.return !== null && (X(c, 1), $(c, 1, 0));
                }
                function ve(c) {
                    for(; c === ll;)ll = rl[--ol], rl[ol] = null, pc = rl[--ol], rl[ol] = null;
                    for(; c === Do;)Do = Vs[--ks], Vs[ks] = null, Oa = Vs[--ks], Vs[ks] = null, La = Vs[--ks], Vs[ks] = null;
                }
                function J(c, u) {
                    C(sr, u), C(mc, c), C(wi, null), c = gg(u), E(wi), C(wi, c);
                }
                function ue() {
                    E(wi), E(mc), E(sr);
                }
                function he(c) {
                    c.memoizedState !== null && C(cl, c);
                    var u = wi.current, v = cc(u, c.type);
                    u !== v && (C(mc, c), C(wi, v));
                }
                function De(c) {
                    mc.current === c && (E(wi), E(mc)), cl.current === c && (E(cl), gs ? Na._currentValue = To : Na._currentValue2 = To);
                }
                function Pe(c) {
                    var u = Error(i(418, ""));
                    throw Nt(fe(u, c)), Gu;
                }
                function _t(c, u) {
                    if (!Ki) throw Error(i(175));
                    Gg(c.stateNode, c.type, c.memoizedProps, u, c) || Pe(c);
                }
                function xt(c) {
                    for(Qi = c.return; Qi;)switch(Qi.tag){
                        case 3:
                        case 27:
                            Hi = !0;
                            return;
                        case 5:
                        case 13:
                            Hi = !1;
                            return;
                        default:
                            Qi = Qi.return;
                    }
                }
                function on(c) {
                    if (!Ki || c !== Qi) return !1;
                    if (!yn) return xt(c), yn = !0, !1;
                    var u = !1;
                    if (Bn ? c.tag !== 3 && c.tag !== 27 && (c.tag !== 5 || ph(c.type) && !qt(c.type, c.memoizedProps)) && (u = !0) : c.tag !== 3 && (c.tag !== 5 || ph(c.type) && !qt(c.type, c.memoizedProps)) && (u = !0), u && Ji && Pe(c), xt(c), c.tag === 13) {
                        if (!Ki) throw Error(i(316));
                        if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(i(317));
                        Ji = kg(c);
                    } else Ji = Qi ? Rp(c.stateNode) : null;
                    return !0;
                }
                function Vt() {
                    Ki && (Ji = Qi = null, yn = !1);
                }
                function Nt(c) {
                    ha === null ? ha = [
                        c
                    ] : ha.push(c);
                }
                function W() {
                    for(var c = ul, u = za = ul = 0; u < c;){
                        var v = da[u];
                        da[u++] = null;
                        var b = da[u];
                        da[u++] = null;
                        var w = da[u];
                        da[u++] = null;
                        var U = da[u];
                        if (da[u++] = null, b !== null && w !== null) {
                            var j = b.pending;
                            j === null ? w.next = w : (w.next = j.next, j.next = w), b.pending = w;
                        }
                        U !== 0 && Be(v, w, U);
                    }
                }
                function et(c, u, v, b) {
                    da[ul++] = c, da[ul++] = u, da[ul++] = v, da[ul++] = b, za |= b, c.lanes |= b, c = c.alternate, c !== null && (c.lanes |= b);
                }
                function Ye(c, u, v, b) {
                    return et(c, u, v, b), ut(c);
                }
                function We(c, u) {
                    return et(c, null, null, u), ut(c);
                }
                function Be(c, u, v) {
                    c.lanes |= v;
                    var b = c.alternate;
                    b !== null && (b.lanes |= v);
                    for(var w = !1, U = c.return; U !== null;)U.childLanes |= v, b = U.alternate, b !== null && (b.childLanes |= v), U.tag === 22 && (c = U.stateNode, c === null || c._visibility & 1 || (w = !0)), c = U, U = U.return;
                    w && u !== null && c.tag === 3 && (U = c.stateNode, w = 31 - ys(v), U = U.hiddenUpdates, c = U[w], c === null ? U[w] = [
                        u
                    ] : c.push(u), u.lane = v | 536870912);
                }
                function ut(c) {
                    if (50 < Ec) throw Ec = 0, Ch = null, Error(i(185));
                    for(var u = c.return; u !== null;)c = u, u = c.return;
                    return c.tag === 3 ? c.stateNode : null;
                }
                function Xe(c) {
                    c !== jr && c.next === null && (jr === null ? Vu = jr = c : jr = jr.next = c), Vn = !0, fl || (fl = !0, Ue(It));
                }
                function ot(c, u) {
                    if (!Lp && Vn) {
                        Lp = !0;
                        do for(var v = !1, b = Vu; b !== null;){
                            if (c !== 0) {
                                var w = b.pendingLanes;
                                if (w === 0) var U = 0;
                                else {
                                    var j = b.suspendedLanes, ne = b.pingedLanes;
                                    U = (1 << 31 - ys(42 | c) + 1) - 1, U &= w & ~(j & ~ne), U = U & 201326677 ? U & 201326677 | 1 : U ? U | 2 : 0;
                                }
                                U !== 0 && (v = !0, Se(b, U));
                            } else U = cn, U = I(b, b === Rn ? U : 0), (U & 3) === 0 || O(b, U) || (v = !0, Se(b, U));
                            b = b.next;
                        }
                        while (v);
                        Lp = !1;
                    }
                }
                function It() {
                    Vn = fl = !1;
                    var c = 0;
                    gc !== 0 && (xg() && (c = gc), gc = 0);
                    for(var u = fa(), v = null, b = Vu; b !== null;){
                        var w = b.next, U = Z(b, u);
                        U === 0 ? (b.next = null, v === null ? Vu = w : v.next = w, w === null && (jr = v)) : (v = b, (c !== 0 || (U & 3) !== 0) && (Vn = !0)), b = w;
                    }
                    ot(c);
                }
                function Z(c, u) {
                    for(var v = c.suspendedLanes, b = c.pingedLanes, w = c.expirationTimes, U = c.pendingLanes & -62914561; 0 < U;){
                        var j = 31 - ys(U), ne = 1 << j, ye = w[j];
                        ye === -1 ? ((ne & v) === 0 || (ne & b) !== 0) && (w[j] = P(ne, u)) : ye <= u && (c.expiredLanes |= ne), U &= ~ne;
                    }
                    if (u = Rn, v = cn, v = I(c, c === u ? v : 0), b = c.callbackNode, v === 0 || c === u && On === 2 || c.cancelPendingCommit !== null) return b !== null && b !== null && yh(b), c.callbackNode = null, c.callbackPriority = 0;
                    if ((v & 3) === 0 || O(c, v)) {
                        if (u = v & -v, u === c.callbackPriority) return u;
                        switch(b !== null && yh(b), _e(v)){
                            case 2:
                            case 8:
                                v = e0;
                                break;
                            case 32:
                                v = Sh;
                                break;
                            case 268435456:
                                v = r_;
                                break;
                            default:
                                v = Sh;
                        }
                        return b = G.bind(null, c), v = Fu(v, b), c.callbackPriority = u, c.callbackNode = v, u;
                    }
                    return b !== null && b !== null && yh(b), c.callbackPriority = 2, c.callbackNode = null, 2;
                }
                function G(c, u) {
                    var v = c.callbackNode;
                    if (Ca() && c.callbackNode !== v) return null;
                    var b = cn;
                    return b = I(c, c === Rn ? b : 0), b === 0 ? null : (yo(c, b, u), Z(c, fa()), c.callbackNode != null && c.callbackNode === v ? G.bind(null, c) : null);
                }
                function Se(c, u) {
                    if (Ca()) return null;
                    yo(c, u, !0);
                }
                function Ue(c) {
                    yp ? kr(function() {
                        (xn & 6) !== 0 ? Fu(xh, c) : c();
                    }) : Fu(xh, c);
                }
                function Le() {
                    return gc === 0 && (gc = F()), gc;
                }
                function Ne(c, u) {
                    if (vc === null) {
                        var v = vc = [];
                        hl = 0, Xs = Le(), dl = {
                            status: "pending",
                            value: void 0,
                            then: function(b) {
                                v.push(b);
                            }
                        };
                    }
                    return hl++, u.then(lt, lt), u;
                }
                function lt() {
                    if (--hl === 0 && vc !== null) {
                        dl !== null && (dl.status = "fulfilled");
                        var c = vc;
                        vc = null, Xs = 0, dl = null;
                        for(var u = 0; u < c.length; u++)(0, c[u])();
                    }
                }
                function it(c, u) {
                    var v = [], b = {
                        status: "pending",
                        value: null,
                        reason: null,
                        then: function(w) {
                            v.push(w);
                        }
                    };
                    return c.then(function() {
                        b.status = "fulfilled", b.value = u;
                        for(var w = 0; w < v.length; w++)(0, v[w])(u);
                    }, function(w) {
                        for(b.status = "rejected", b.reason = w, w = 0; w < v.length; w++)(0, v[w])(void 0);
                    }), b;
                }
                function vt(c) {
                    c.updateQueue = {
                        baseState: c.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            lanes: 0,
                            hiddenCallbacks: null
                        },
                        callbacks: null
                    };
                }
                function yt(c, u) {
                    c = c.updateQueue, u.updateQueue === c && (u.updateQueue = {
                        baseState: c.baseState,
                        firstBaseUpdate: c.firstBaseUpdate,
                        lastBaseUpdate: c.lastBaseUpdate,
                        shared: c.shared,
                        callbacks: null
                    });
                }
                function He(c) {
                    return {
                        lane: c,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    };
                }
                function st(c, u, v) {
                    var b = c.updateQueue;
                    if (b === null) return null;
                    if (b = b.shared, (xn & 2) !== 0) {
                        var w = b.pending;
                        return w === null ? u.next = u : (u.next = w.next, w.next = u), b.pending = u, u = ut(c), Be(c, null, v), u;
                    }
                    return et(c, b, u, v), ut(c);
                }
                function St(c, u, v) {
                    if (u = u.updateQueue, u !== null && (u = u.shared, (v & 4194176) !== 0)) {
                        var b = u.lanes;
                        b &= c.pendingLanes, v |= b, u.lanes = v, ge(c, v);
                    }
                }
                function ie(c, u) {
                    var v = c.updateQueue, b = c.alternate;
                    if (b !== null && (b = b.updateQueue, v === b)) {
                        var w = null, U = null;
                        if (v = v.firstBaseUpdate, v !== null) {
                            do {
                                var j = {
                                    lane: v.lane,
                                    tag: v.tag,
                                    payload: v.payload,
                                    callback: null,
                                    next: null
                                };
                                U === null ? w = U = j : U = U.next = j, v = v.next;
                            }while (v !== null);
                            U === null ? w = U = u : U = U.next = u;
                        } else w = U = u;
                        v = {
                            baseState: b.baseState,
                            firstBaseUpdate: w,
                            lastBaseUpdate: U,
                            shared: b.shared,
                            callbacks: b.callbacks
                        }, c.updateQueue = v;
                        return;
                    }
                    c = v.lastBaseUpdate, c === null ? v.firstBaseUpdate = u : c.next = u, v.lastBaseUpdate = u;
                }
                function xe() {
                    if (pl) {
                        var c = dl;
                        if (c !== null) throw c;
                    }
                }
                function Ze(c, u, v, b) {
                    pl = !1;
                    var w = c.updateQueue;
                    qr = !1;
                    var U = w.firstBaseUpdate, j = w.lastBaseUpdate, ne = w.shared.pending;
                    if (ne !== null) {
                        w.shared.pending = null;
                        var ye = ne, Oe = ye.next;
                        ye.next = null, j === null ? U = Oe : j.next = Oe, j = ye;
                        var $e = c.alternate;
                        $e !== null && ($e = $e.updateQueue, ne = $e.lastBaseUpdate, ne !== j && (ne === null ? $e.firstBaseUpdate = Oe : ne.next = Oe, $e.lastBaseUpdate = ye));
                    }
                    if (U !== null) {
                        var ft = w.baseState;
                        j = 0, $e = Oe = ye = null, ne = U;
                        do {
                            var gt = ne.lane & -536870913, Xt = gt !== ne.lane;
                            if (Xt ? (cn & gt) === gt : (b & gt) === gt) {
                                gt !== 0 && gt === Xs && (pl = !0), $e !== null && ($e = $e.next = {
                                    lane: 0,
                                    tag: ne.tag,
                                    payload: ne.payload,
                                    callback: null,
                                    next: null
                                });
                                e: {
                                    var Js = c, Ho = ne;
                                    gt = u;
                                    var Fo = v;
                                    switch(Ho.tag){
                                        case 1:
                                            if (Js = Ho.payload, typeof Js == "function") {
                                                ft = Js.call(Fo, ft, gt);
                                                break e;
                                            }
                                            ft = Js;
                                            break e;
                                        case 3:
                                            Js.flags = Js.flags & -65537 | 128;
                                        case 0:
                                            if (Js = Ho.payload, gt = typeof Js == "function" ? Js.call(Fo, ft, gt) : Js, gt == null) break e;
                                            ft = nh({}, ft, gt);
                                            break e;
                                        case 2:
                                            qr = !0;
                                    }
                                }
                                gt = ne.callback, gt !== null && (c.flags |= 64, Xt && (c.flags |= 8192), Xt = w.callbacks, Xt === null ? w.callbacks = [
                                    gt
                                ] : Xt.push(gt));
                            } else Xt = {
                                lane: gt,
                                tag: ne.tag,
                                payload: ne.payload,
                                callback: ne.callback,
                                next: null
                            }, $e === null ? (Oe = $e = Xt, ye = ft) : $e = $e.next = Xt, j |= gt;
                            if (ne = ne.next, ne === null) {
                                if (ne = w.shared.pending, ne === null) break;
                                Xt = ne, ne = Xt.next, Xt.next = null, w.lastBaseUpdate = Xt, w.shared.pending = null;
                            }
                        }while (!0);
                        $e === null && (ye = ft), w.baseState = ye, w.firstBaseUpdate = Oe, w.lastBaseUpdate = $e, U === null && (w.shared.lanes = 0), Ks |= j, c.lanes = j, c.memoizedState = ft;
                    }
                }
                function te(c, u) {
                    if (typeof c != "function") throw Error(i(191, c));
                    c.call(u);
                }
                function Qe(c, u) {
                    var v = c.callbacks;
                    if (v !== null) for(c.callbacks = null, c = 0; c < v.length; c++)te(v[c], u);
                }
                function Ve(c, u) {
                    if (Ns(c, u)) return !0;
                    if (typeof c != "object" || c === null || typeof u != "object" || u === null) return !1;
                    var v = Object.keys(c), b = Object.keys(u);
                    if (v.length !== b.length) return !1;
                    for(b = 0; b < v.length; b++){
                        var w = v[b];
                        if (!ar.call(u, w) || !Ns(c[w], u[w])) return !1;
                    }
                    return !0;
                }
                function rt(c) {
                    return c = c.status, c === "fulfilled" || c === "rejected";
                }
                function Ke() {}
                function Fe(c, u, v) {
                    switch(v = c[v], v === void 0 ? c.push(u) : v !== u && (u.then(Ke, Ke), u = v), u.status){
                        case "fulfilled":
                            return u.value;
                        case "rejected":
                            throw c = u.reason, c === yc ? Error(i(483)) : c;
                        default:
                            if (typeof u.status == "string") u.then(Ke, Ke);
                            else {
                                if (c = Rn, c !== null && 100 < c.shellSuspendCounter) throw Error(i(482));
                                c = u, c.status = "pending", c.then(function(b) {
                                    if (u.status === "pending") {
                                        var w = u;
                                        w.status = "fulfilled", w.value = b;
                                    }
                                }, function(b) {
                                    if (u.status === "pending") {
                                        var w = u;
                                        w.status = "rejected", w.reason = b;
                                    }
                                });
                            }
                            switch(u.status){
                                case "fulfilled":
                                    return u.value;
                                case "rejected":
                                    throw c = u.reason, c === yc ? Error(i(483)) : c;
                            }
                            throw No = u, yc;
                    }
                }
                function ct() {
                    if (No === null) throw Error(i(459));
                    var c = No;
                    return No = null, c;
                }
                function Mt(c) {
                    var u = Lo;
                    return Lo += 1, Uo === null && (Uo = []), Fe(Uo, c, u);
                }
                function tn(c, u) {
                    u = u.props.ref, c.ref = u !== void 0 ? u : null;
                }
                function Zt(c, u) {
                    throw u.$$typeof === $y ? Error(i(525)) : (c = Object.prototype.toString.call(u), Error(i(31, c === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : c)));
                }
                function gi(c) {
                    var u = c._init;
                    return u(c._payload);
                }
                function Zn(c) {
                    function u(Ee, re) {
                        if (c) {
                            var Ce = Ee.deletions;
                            Ce === null ? (Ee.deletions = [
                                re
                            ], Ee.flags |= 16) : Ce.push(re);
                        }
                    }
                    function v(Ee, re) {
                        if (!c) return null;
                        for(; re !== null;)u(Ee, re), re = re.sibling;
                        return null;
                    }
                    function b(Ee) {
                        for(var re = new Map; Ee !== null;)Ee.key !== null ? re.set(Ee.key, Ee) : re.set(Ee.index, Ee), Ee = Ee.sibling;
                        return re;
                    }
                    function w(Ee, re) {
                        return Ee = oa(Ee, re), Ee.index = 0, Ee.sibling = null, Ee;
                    }
                    function U(Ee, re, Ce) {
                        return Ee.index = Ce, c ? (Ce = Ee.alternate, Ce !== null ? (Ce = Ce.index, Ce < re ? (Ee.flags |= 33554434, re) : Ce) : (Ee.flags |= 33554434, re)) : (Ee.flags |= 1048576, re);
                    }
                    function j(Ee) {
                        return c && Ee.alternate === null && (Ee.flags |= 33554434), Ee;
                    }
                    function ne(Ee, re, Ce, Je) {
                        return re === null || re.tag !== 6 ? (re = eh(Ce, Ee.mode, Je), re.return = Ee, re) : (re = w(re, Ce), re.return = Ee, re);
                    }
                    function ye(Ee, re, Ce, Je) {
                        var Tt = Ce.type;
                        return Tt === Mo ? $e(Ee, re, Ce.props.children, Je, Ce.key) : re !== null && (re.elementType === Tt || typeof Tt == "object" && Tt !== null && Tt.$$typeof === ca && gi(Tt) === re.type) ? (re = w(re, Ce.props), tn(re, Ce), re.return = Ee, re) : (re = er(Ce.type, Ce.key, Ce.props, null, Ee.mode, Je), tn(re, Ce), re.return = Ee, re);
                    }
                    function Oe(Ee, re, Ce, Je) {
                        return re === null || re.tag !== 4 || re.stateNode.containerInfo !== Ce.containerInfo || re.stateNode.implementation !== Ce.implementation ? (re = up(Ce, Ee.mode, Je), re.return = Ee, re) : (re = w(re, Ce.children || []), re.return = Ee, re);
                    }
                    function $e(Ee, re, Ce, Je, Tt) {
                        return re === null || re.tag !== 7 ? (re = ti(Ce, Ee.mode, Je, Tt), re.return = Ee, re) : (re = w(re, Ce), re.return = Ee, re);
                    }
                    function ft(Ee, re, Ce) {
                        if (typeof re == "string" && re !== "" || typeof re == "number" || typeof re == "bigint") return re = eh("" + re, Ee.mode, Ce), re.return = Ee, re;
                        if (typeof re == "object" && re !== null) {
                            switch(re.$$typeof){
                                case Cu:
                                    return Ce = er(re.type, re.key, re.props, null, Ee.mode, Ce), tn(Ce, re), Ce.return = Ee, Ce;
                                case la:
                                    return re = up(re, Ee.mode, Ce), re.return = Ee, re;
                                case ca:
                                    var Je = re._init;
                                    return re = Je(re._payload), ft(Ee, re, Ce);
                            }
                            if (rc(re) || a(re)) return re = ti(re, Ee.mode, Ce, null), re.return = Ee, re;
                            if (typeof re.then == "function") return ft(Ee, Mt(re), Ce);
                            if (re.$$typeof === Da) return ft(Ee, pu(Ee, re), Ce);
                            Zt(Ee, re);
                        }
                        return null;
                    }
                    function gt(Ee, re, Ce, Je) {
                        var Tt = re !== null ? re.key : null;
                        if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint") return Tt !== null ? null : ne(Ee, re, "" + Ce, Je);
                        if (typeof Ce == "object" && Ce !== null) {
                            switch(Ce.$$typeof){
                                case Cu:
                                    return Ce.key === Tt ? ye(Ee, re, Ce, Je) : null;
                                case la:
                                    return Ce.key === Tt ? Oe(Ee, re, Ce, Je) : null;
                                case ca:
                                    return Tt = Ce._init, Ce = Tt(Ce._payload), gt(Ee, re, Ce, Je);
                            }
                            if (rc(Ce) || a(Ce)) return Tt !== null ? null : $e(Ee, re, Ce, Je, null);
                            if (typeof Ce.then == "function") return gt(Ee, re, Mt(Ce), Je);
                            if (Ce.$$typeof === Da) return gt(Ee, re, pu(Ee, Ce), Je);
                            Zt(Ee, Ce);
                        }
                        return null;
                    }
                    function Xt(Ee, re, Ce, Je, Tt) {
                        if (typeof Je == "string" && Je !== "" || typeof Je == "number" || typeof Je == "bigint") return Ee = Ee.get(Ce) || null, ne(re, Ee, "" + Je, Tt);
                        if (typeof Je == "object" && Je !== null) {
                            switch(Je.$$typeof){
                                case Cu:
                                    return Ee = Ee.get(Je.key === null ? Ce : Je.key) || null, ye(re, Ee, Je, Tt);
                                case la:
                                    return Ee = Ee.get(Je.key === null ? Ce : Je.key) || null, Oe(re, Ee, Je, Tt);
                                case ca:
                                    var Wn = Je._init;
                                    return Je = Wn(Je._payload), Xt(Ee, re, Ce, Je, Tt);
                            }
                            if (rc(Je) || a(Je)) return Ee = Ee.get(Ce) || null, $e(re, Ee, Je, Tt, null);
                            if (typeof Je.then == "function") return Xt(Ee, re, Ce, Mt(Je), Tt);
                            if (Je.$$typeof === Da) return Xt(Ee, re, Ce, pu(re, Je), Tt);
                            Zt(re, Je);
                        }
                        return null;
                    }
                    function Js(Ee, re, Ce, Je) {
                        for(var Tt = null, Wn = null, Ft = re, Mn = re = 0, ui = null; Ft !== null && Mn < Ce.length; Mn++){
                            Ft.index > Mn ? (ui = Ft, Ft = null) : ui = Ft.sibling;
                            var rn = gt(Ee, Ft, Ce[Mn], Je);
                            if (rn === null) {
                                Ft === null && (Ft = ui);
                                break;
                            }
                            c && Ft && rn.alternate === null && u(Ee, Ft), re = U(rn, re, Mn), Wn === null ? Tt = rn : Wn.sibling = rn, Wn = rn, Ft = ui;
                        }
                        if (Mn === Ce.length) return v(Ee, Ft), yn && X(Ee, Mn), Tt;
                        if (Ft === null) {
                            for(; Mn < Ce.length; Mn++)Ft = ft(Ee, Ce[Mn], Je), Ft !== null && (re = U(Ft, re, Mn), Wn === null ? Tt = Ft : Wn.sibling = Ft, Wn = Ft);
                            return yn && X(Ee, Mn), Tt;
                        }
                        for(Ft = b(Ft); Mn < Ce.length; Mn++)ui = Xt(Ft, Ee, Mn, Ce[Mn], Je), ui !== null && (c && ui.alternate !== null && Ft.delete(ui.key === null ? Mn : ui.key), re = U(ui, re, Mn), Wn === null ? Tt = ui : Wn.sibling = ui, Wn = ui);
                        return c && Ft.forEach(function(dr) {
                            return u(Ee, dr);
                        }), yn && X(Ee, Mn), Tt;
                    }
                    function Ho(Ee, re, Ce, Je) {
                        if (Ce == null) throw Error(i(151));
                        for(var Tt = null, Wn = null, Ft = re, Mn = re = 0, ui = null, rn = Ce.next(); Ft !== null && !rn.done; Mn++, rn = Ce.next()){
                            Ft.index > Mn ? (ui = Ft, Ft = null) : ui = Ft.sibling;
                            var dr = gt(Ee, Ft, rn.value, Je);
                            if (dr === null) {
                                Ft === null && (Ft = ui);
                                break;
                            }
                            c && Ft && dr.alternate === null && u(Ee, Ft), re = U(dr, re, Mn), Wn === null ? Tt = dr : Wn.sibling = dr, Wn = dr, Ft = ui;
                        }
                        if (rn.done) return v(Ee, Ft), yn && X(Ee, Mn), Tt;
                        if (Ft === null) {
                            for(; !rn.done; Mn++, rn = Ce.next())rn = ft(Ee, rn.value, Je), rn !== null && (re = U(rn, re, Mn), Wn === null ? Tt = rn : Wn.sibling = rn, Wn = rn);
                            return yn && X(Ee, Mn), Tt;
                        }
                        for(Ft = b(Ft); !rn.done; Mn++, rn = Ce.next())rn = Xt(Ft, Ee, Mn, rn.value, Je), rn !== null && (c && rn.alternate !== null && Ft.delete(rn.key === null ? Mn : rn.key), re = U(rn, re, Mn), Wn === null ? Tt = rn : Wn.sibling = rn, Wn = rn);
                        return c && Ft.forEach(function(Dh) {
                            return u(Ee, Dh);
                        }), yn && X(Ee, Mn), Tt;
                    }
                    function Fo(Ee, re, Ce, Je) {
                        if (typeof Ce == "object" && Ce !== null && Ce.type === Mo && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
                            switch(Ce.$$typeof){
                                case Cu:
                                    e: {
                                        for(var Tt = Ce.key; re !== null;){
                                            if (re.key === Tt) {
                                                if (Tt = Ce.type, Tt === Mo) {
                                                    if (re.tag === 7) {
                                                        v(Ee, re.sibling), Je = w(re, Ce.props.children), Je.return = Ee, Ee = Je;
                                                        break e;
                                                    }
                                                } else if (re.elementType === Tt || typeof Tt == "object" && Tt !== null && Tt.$$typeof === ca && gi(Tt) === re.type) {
                                                    v(Ee, re.sibling), Je = w(re, Ce.props), tn(Je, Ce), Je.return = Ee, Ee = Je;
                                                    break e;
                                                }
                                                v(Ee, re);
                                                break;
                                            } else u(Ee, re);
                                            re = re.sibling;
                                        }
                                        Ce.type === Mo ? (Je = ti(Ce.props.children, Ee.mode, Je, Ce.key), Je.return = Ee, Ee = Je) : (Je = er(Ce.type, Ce.key, Ce.props, null, Ee.mode, Je), tn(Je, Ce), Je.return = Ee, Ee = Je);
                                    }
                                    return j(Ee);
                                case la:
                                    e: {
                                        for(Tt = Ce.key; re !== null;){
                                            if (re.key === Tt) if (re.tag === 4 && re.stateNode.containerInfo === Ce.containerInfo && re.stateNode.implementation === Ce.implementation) {
                                                v(Ee, re.sibling), Je = w(re, Ce.children || []), Je.return = Ee, Ee = Je;
                                                break e;
                                            } else {
                                                v(Ee, re);
                                                break;
                                            }
                                            else u(Ee, re);
                                            re = re.sibling;
                                        }
                                        Je = up(Ce, Ee.mode, Je), Je.return = Ee, Ee = Je;
                                    }
                                    return j(Ee);
                                case ca:
                                    return Tt = Ce._init, Ce = Tt(Ce._payload), Fo(Ee, re, Ce, Je);
                            }
                            if (rc(Ce)) return Js(Ee, re, Ce, Je);
                            if (a(Ce)) {
                                if (Tt = a(Ce), typeof Tt != "function") throw Error(i(150));
                                return Ce = Tt.call(Ce), Ho(Ee, re, Ce, Je);
                            }
                            if (typeof Ce.then == "function") return Fo(Ee, re, Mt(Ce), Je);
                            if (Ce.$$typeof === Da) return Fo(Ee, re, pu(Ee, Ce), Je);
                            Zt(Ee, Ce);
                        }
                        return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint" ? (Ce = "" + Ce, re !== null && re.tag === 6 ? (v(Ee, re.sibling), Je = w(re, Ce), Je.return = Ee, Ee = Je) : (v(Ee, re), Je = eh(Ce, Ee.mode, Je), Je.return = Ee, Ee = Je), j(Ee)) : v(Ee, re);
                    }
                    return function(Ee, re, Ce, Je) {
                        try {
                            Lo = 0;
                            var Tt = Fo(Ee, re, Ce, Je);
                            return Uo = null, Tt;
                        } catch (Ft) {
                            if (Ft === yc) throw Ft;
                            var Wn = t(29, Ft, null, Ee.mode);
                            return Wn.lanes = Je, Wn.return = Ee, Wn;
                        } finally{}
                    };
                }
                function vi(c, u) {
                    c = rs, C(_c, c), C(kn, u), rs = c | u.baseLanes;
                }
                function Ei() {
                    C(_c, rs), C(kn, kn.current);
                }
                function ns() {
                    rs = _c.current, E(kn), E(_c);
                }
                function Ms(c) {
                    var u = c.alternate;
                    C(Ri, Ri.current & 1), C(js, c), In === null && (u === null || kn.current !== null || u.memoizedState !== null) && (In = c);
                }
                function nu(c) {
                    if (c.tag === 22) {
                        if (C(Ri, Ri.current), C(js, c), In === null) {
                            var u = c.alternate;
                            u !== null && u.memoizedState !== null && (In = c);
                        }
                    } else Ma();
                }
                function Ma() {
                    C(Ri, Ri.current), C(js, js.current);
                }
                function fs(c) {
                    E(js), In === c && (In = null), E(Ri);
                }
                function Ea(c) {
                    for(var u = c; u !== null;){
                        if (u.tag === 13) {
                            var v = u.memoizedState;
                            if (v !== null && (v = v.dehydrated, v === null || fh(v) || hh(v))) return u;
                        } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                            if ((u.flags & 128) !== 0) return u;
                        } else if (u.child !== null) {
                            u.child.return = u, u = u.child;
                            continue;
                        }
                        if (u === c) break;
                        for(; u.sibling === null;){
                            if (u.return === null || u.return === c) return null;
                            u = u.return;
                        }
                        u.sibling.return = u.return, u = u.sibling;
                    }
                    return null;
                }
                function Un() {
                    throw Error(i(321));
                }
                function Ta(c, u) {
                    if (u === null) return !1;
                    for(var v = 0; v < u.length && v < c.length; v++)if (!Ns(c[v], u[v])) return !1;
                    return !0;
                }
                function Aa(c, u, v, b, w, U) {
                    return Yr = U, $t = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, Ht.H = c === null || c.memoizedState === null ? Bo : _s, zo = !1, U = v(b, w), zo = !1, ml && (U = Ar(u, v, b, w)), ro(c), U;
                }
                function ro(c) {
                    Ht.H = ni;
                    var u = Ut !== null && Ut.next !== null;
                    if (Yr = 0, _n = Ut = $t = null, pa = !1, gl = 0, Fi = null, u) throw Error(i(300));
                    c === null || Pn || (c = c.dependencies, c !== null && du(c) && (Pn = !0));
                }
                function Ar(c, u, v, b) {
                    $t = c;
                    var w = 0;
                    do {
                        if (ml && (Fi = null), gl = 0, ml = !1, 25 <= w) throw Error(i(301));
                        if (w += 1, _n = Ut = null, c.updateQueue != null) {
                            var U = c.updateQueue;
                            U.lastEffect = null, U.events = null, U.stores = null, U.memoCache != null && (U.memoCache.index = 0);
                        }
                        Ht.H = qs, U = u(v, b);
                    }while (ml);
                    return U;
                }
                function yi() {
                    var c = Ht.H, u = c.useState()[0];
                    return u = typeof u.then == "function" ? Ae(u) : u, c = c.useState()[0], (Ut !== null ? Ut.memoizedState : null) !== c && ($t.flags |= 1024), u;
                }
                function Pl() {
                    var c = bh !== 0;
                    return bh = 0, c;
                }
                function Hl(c, u, v) {
                    u.updateQueue = c.updateQueue, u.flags &= -2053, c.lanes &= ~v;
                }
                function wa(c) {
                    if (pa) {
                        for(c = c.memoizedState; c !== null;){
                            var u = c.queue;
                            u !== null && (u.pending = null), c = c.next;
                        }
                        pa = !1;
                    }
                    Yr = 0, _n = Ut = $t = null, ml = !1, gl = bh = 0, Fi = null;
                }
                function k() {
                    var c = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return _n === null ? $t.memoizedState = _n = c : _n = _n.next = c, _n;
                }
                function ce() {
                    if (Ut === null) {
                        var c = $t.alternate;
                        c = c !== null ? c.memoizedState : null;
                    } else c = Ut.next;
                    var u = _n === null ? $t.memoizedState : _n.next;
                    if (u !== null) _n = u, Ut = c;
                    else {
                        if (c === null) throw $t.alternate === null ? Error(i(467)) : Error(i(310));
                        Ut = c, c = {
                            memoizedState: Ut.memoizedState,
                            baseState: Ut.baseState,
                            baseQueue: Ut.baseQueue,
                            queue: Ut.queue,
                            next: null
                        }, _n === null ? $t.memoizedState = _n = c : _n = _n.next = c;
                    }
                    return _n;
                }
                function Ae(c) {
                    var u = gl;
                    return gl += 1, Fi === null && (Fi = []), c = Fe(Fi, c, u), u = $t, (_n === null ? u.memoizedState : _n.next) === null && (u = u.alternate, Ht.H = u === null || u.memoizedState === null ? Bo : _s), c;
                }
                function we(c) {
                    if (c !== null && typeof c == "object") {
                        if (typeof c.then == "function") return Ae(c);
                        if (c.$$typeof === Da) return qi(c);
                    }
                    throw Error(i(438, String(c)));
                }
                function pe(c) {
                    var u = null, v = $t.updateQueue;
                    if (v !== null && (u = v.memoCache), u == null) {
                        var b = $t.alternate;
                        b !== null && (b = b.updateQueue, b !== null && (b = b.memoCache, b != null && (u = {
                            data: b.data.map(function(w) {
                                return w.slice();
                            }),
                            index: 0
                        })));
                    }
                    if (u == null && (u = {
                        data: [],
                        index: 0
                    }), v === null && (v = Mh(), $t.updateQueue = v), v.memoCache = u, v = u.data[u.index], v === void 0) for(v = u.data[u.index] = Array(c), b = 0; b < c; b++)v[b] = mg;
                    return u.index++, v;
                }
                function je(c, u) {
                    return typeof u == "function" ? u(c) : u;
                }
                function at(c) {
                    var u = ce();
                    return dt(u, Ut, c);
                }
                function dt(c, u, v) {
                    var b = c.queue;
                    if (b === null) throw Error(i(311));
                    b.lastRenderedReducer = v;
                    var w = c.baseQueue, U = b.pending;
                    if (U !== null) {
                        if (w !== null) {
                            var j = w.next;
                            w.next = U.next, U.next = j;
                        }
                        u.baseQueue = w = U, b.pending = null;
                    }
                    if (U = c.baseState, w === null) c.memoizedState = U;
                    else {
                        u = w.next;
                        var ne = j = null, ye = null, Oe = u, $e = !1;
                        do {
                            var ft = Oe.lane & -536870913;
                            if (ft !== Oe.lane ? (cn & ft) === ft : (Yr & ft) === ft) {
                                var gt = Oe.revertLane;
                                if (gt === 0) ye !== null && (ye = ye.next = {
                                    lane: 0,
                                    revertLane: 0,
                                    action: Oe.action,
                                    hasEagerState: Oe.hasEagerState,
                                    eagerState: Oe.eagerState,
                                    next: null
                                }), ft === Xs && ($e = !0);
                                else if ((Yr & gt) === gt) {
                                    Oe = Oe.next, gt === Xs && ($e = !0);
                                    continue;
                                } else ft = {
                                    lane: 0,
                                    revertLane: Oe.revertLane,
                                    action: Oe.action,
                                    hasEagerState: Oe.hasEagerState,
                                    eagerState: Oe.eagerState,
                                    next: null
                                }, ye === null ? (ne = ye = ft, j = U) : ye = ye.next = ft, $t.lanes |= gt, Ks |= gt;
                                ft = Oe.action, zo && v(U, ft), U = Oe.hasEagerState ? Oe.eagerState : v(U, ft);
                            } else gt = {
                                lane: ft,
                                revertLane: Oe.revertLane,
                                action: Oe.action,
                                hasEagerState: Oe.hasEagerState,
                                eagerState: Oe.eagerState,
                                next: null
                            }, ye === null ? (ne = ye = gt, j = U) : ye = ye.next = gt, $t.lanes |= ft, Ks |= ft;
                            Oe = Oe.next;
                        }while (Oe !== null && Oe !== u);
                        if (ye === null ? j = U : ye.next = ne, !Ns(U, c.memoizedState) && (Pn = !0, $e && (v = dl, v !== null))) throw v;
                        c.memoizedState = U, c.baseState = j, c.baseQueue = ye, b.lastRenderedState = U;
                    }
                    return w === null && (b.lanes = 0), [
                        c.memoizedState,
                        b.dispatch
                    ];
                }
                function mt(c) {
                    var u = ce(), v = u.queue;
                    if (v === null) throw Error(i(311));
                    v.lastRenderedReducer = c;
                    var b = v.dispatch, w = v.pending, U = u.memoizedState;
                    if (w !== null) {
                        v.pending = null;
                        var j = w = w.next;
                        do U = c(U, j.action), j = j.next;
                        while (j !== w);
                        Ns(U, u.memoizedState) || (Pn = !0), u.memoizedState = U, u.baseQueue === null && (u.baseState = U), v.lastRenderedState = U;
                    }
                    return [
                        U,
                        b
                    ];
                }
                function Lt(c, u, v) {
                    var b = $t, w = ce(), U = yn;
                    if (U) {
                        if (v === void 0) throw Error(i(407));
                        v = v();
                    } else v = u();
                    var j = !Ns((Ut || w).memoizedState, v);
                    if (j && (w.memoizedState = v, Pn = !0), w = w.queue, zd(Kt.bind(null, b, w, c), [
                        c
                    ]), w.getSnapshot !== u || j || _n !== null && _n.memoizedState.tag & 1) {
                        if (b.flags |= 2048, hs(9, Et.bind(null, b, w, v, u), {
                            destroy: void 0
                        }, null), Rn === null) throw Error(i(349));
                        U || (Yr & 60) !== 0 || wt(b, u, v);
                    }
                    return v;
                }
                function wt(c, u, v) {
                    c.flags |= 16384, c = {
                        getSnapshot: u,
                        value: v
                    }, u = $t.updateQueue, u === null ? (u = Mh(), $t.updateQueue = u, u.stores = [
                        c
                    ]) : (v = u.stores, v === null ? u.stores = [
                        c
                    ] : v.push(c));
                }
                function Et(c, u, v, b) {
                    u.value = v, u.getSnapshot = b, En(u) && Gn(c);
                }
                function Kt(c, u, v) {
                    return v(function() {
                        En(u) && Gn(c);
                    });
                }
                function En(c) {
                    var u = c.getSnapshot;
                    c = c.value;
                    try {
                        var v = u();
                        return !Ns(c, v);
                    } catch  {
                        return !0;
                    }
                }
                function Gn(c) {
                    var u = We(c, 2);
                    u !== null && Ii(u, c, 2);
                }
                function Jt(c) {
                    var u = k();
                    if (typeof c == "function") {
                        var v = c;
                        if (c = v(), zo) {
                            K(!0);
                            try {
                                v();
                            } finally{
                                K(!1);
                            }
                        }
                    }
                    return u.memoizedState = u.baseState = c, u.queue = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: je,
                        lastRenderedState: c
                    }, u;
                }
                function Tn(c, u, v, b) {
                    return c.baseState = v, dt(c, Ut, typeof b == "function" ? b : je);
                }
                function Rt(c, u, v, b, w) {
                    if (lu(c)) throw Error(i(485));
                    if (c = u.action, c !== null) {
                        var U = {
                            payload: w,
                            action: c,
                            next: null,
                            isTransition: !0,
                            status: "pending",
                            value: null,
                            reason: null,
                            listeners: [],
                            then: function(j) {
                                U.listeners.push(j);
                            }
                        };
                        Ht.T !== null ? v(!0) : U.isTransition = !1, b(U), v = u.pending, v === null ? (U.next = u.pending = U, Dn(u, U)) : (U.next = v.next, u.pending = v.next = U);
                    }
                }
                function Dn(c, u) {
                    var v = u.action, b = u.payload, w = c.state;
                    if (u.isTransition) {
                        var U = Ht.T, j = {};
                        Ht.T = j;
                        try {
                            var ne = v(w, b), ye = Ht.S;
                            ye !== null && ye(j, ne), ln(c, u, ne);
                        } catch (Oe) {
                            Wa(c, u, Oe);
                        } finally{
                            Ht.T = U;
                        }
                    } else try {
                        U = v(w, b), ln(c, u, U);
                    } catch (Oe) {
                        Wa(c, u, Oe);
                    }
                }
                function ln(c, u, v) {
                    v !== null && typeof v == "object" && typeof v.then == "function" ? v.then(function(b) {
                        Ti(c, u, b);
                    }, function(b) {
                        return Wa(c, u, b);
                    }) : Ti(c, u, v);
                }
                function Ti(c, u, v) {
                    u.status = "fulfilled", u.value = v, zn(u), c.state = v, u = c.pending, u !== null && (v = u.next, v === u ? c.pending = null : (v = v.next, u.next = v, Dn(c, v)));
                }
                function Wa(c, u, v) {
                    var b = c.pending;
                    if (c.pending = null, b !== null) {
                        b = b.next;
                        do u.status = "rejected", u.reason = v, zn(u), u = u.next;
                        while (u !== b);
                    }
                    c.action = null;
                }
                function zn(c) {
                    c = c.listeners;
                    for(var u = 0; u < c.length; u++)(0, c[u])();
                }
                function Za(c, u) {
                    return u;
                }
                function Ln(c, u) {
                    if (yn) {
                        var v = Rn.formState;
                        if (v !== null) {
                            e: {
                                var b = $t;
                                if (yn) {
                                    if (Ji) {
                                        var w = wp(Ji, Hi);
                                        if (w) {
                                            Ji = Rp(w), b = Ig(w);
                                            break e;
                                        }
                                    }
                                    Pe(b);
                                }
                                b = !1;
                            }
                            b && (u = v[0]);
                        }
                    }
                    v = k(), v.memoizedState = v.baseState = u, b = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Za,
                        lastRenderedState: u
                    }, v.queue = b, v = Hd.bind(null, $t, b), b.dispatch = v, b = Jt(!1);
                    var U = Vl.bind(null, $t, !1, b.queue);
                    return b = k(), w = {
                        state: u,
                        dispatch: null,
                        action: c,
                        pending: null
                    }, b.queue = w, v = Rt.bind(null, $t, w, U, v), w.dispatch = v, b.memoizedState = c, [
                        u,
                        v,
                        !1
                    ];
                }
                function Xi(c) {
                    var u = ce();
                    return _i(u, Ut, c);
                }
                function _i(c, u, v) {
                    u = dt(c, u, Za)[0], c = at(je)[0], u = typeof u == "object" && u !== null && typeof u.then == "function" ? Ae(u) : u;
                    var b = ce(), w = b.queue, U = w.dispatch;
                    return v !== b.memoizedState && ($t.flags |= 2048, hs(9, Oi.bind(null, w, v), {
                        destroy: void 0
                    }, null)), [
                        u,
                        U,
                        c
                    ];
                }
                function Oi(c, u) {
                    c.action = u;
                }
                function zi(c) {
                    var u = ce(), v = Ut;
                    if (v !== null) return _i(u, v, c);
                    ce(), u = u.memoizedState, v = ce();
                    var b = v.queue.dispatch;
                    return v.memoizedState = c, [
                        u,
                        b,
                        !1
                    ];
                }
                function hs(c, u, v, b) {
                    return c = {
                        tag: c,
                        create: u,
                        inst: v,
                        deps: b,
                        next: null
                    }, u = $t.updateQueue, u === null && (u = Mh(), $t.updateQueue = u), v = u.lastEffect, v === null ? u.lastEffect = c.next = c : (b = v.next, v.next = c, c.next = b, u.lastEffect = c), c;
                }
                function Ka() {
                    return ce().memoizedState;
                }
                function iu(c, u, v, b) {
                    var w = k();
                    $t.flags |= c, w.memoizedState = hs(1 | u, v, {
                        destroy: void 0
                    }, b === void 0 ? null : b);
                }
                function su(c, u, v, b) {
                    var w = ce();
                    b = b === void 0 ? null : b;
                    var U = w.memoizedState.inst;
                    Ut !== null && b !== null && Ta(b, Ut.memoizedState.deps) ? w.memoizedState = hs(u, v, U, b) : ($t.flags |= c, w.memoizedState = hs(1 | u, v, U, b));
                }
                function Of(c, u) {
                    iu(8390656, 8, c, u);
                }
                function zd(c, u) {
                    su(2048, 8, c, u);
                }
                function Ym(c, u) {
                    return su(4, 2, c, u);
                }
                function au(c, u) {
                    return su(4, 4, c, u);
                }
                function zf(c, u) {
                    if (typeof u == "function") {
                        c = c();
                        var v = u(c);
                        return function() {
                            typeof v == "function" ? v() : u(null);
                        };
                    }
                    if (u != null) return c = c(), u.current = c, function() {
                        u.current = null;
                    };
                }
                function Bf(c, u, v) {
                    v = v != null ? v.concat([
                        c
                    ]) : null, su(4, 4, zf.bind(null, u, c), v);
                }
                function oo() {}
                function Jo(c, u) {
                    var v = ce();
                    u = u === void 0 ? null : u;
                    var b = v.memoizedState;
                    return u !== null && Ta(u, b[1]) ? b[0] : (v.memoizedState = [
                        c,
                        u
                    ], c);
                }
                function Bd(c, u) {
                    var v = ce();
                    u = u === void 0 ? null : u;
                    var b = v.memoizedState;
                    if (u !== null && Ta(u, b[1])) return b[0];
                    if (b = c(), zo) {
                        K(!0);
                        try {
                            c();
                        } finally{
                            K(!1);
                        }
                    }
                    return v.memoizedState = [
                        b,
                        u
                    ], b;
                }
                function ru(c, u, v) {
                    return v === void 0 || (Yr & 1073741824) !== 0 ? c.memoizedState = u : (c.memoizedState = v, c = sp(), $t.lanes |= c, Ks |= c, v);
                }
                function Id(c, u, v, b) {
                    return Ns(v, u) ? v : kn.current !== null ? (c = ru(c, v, b), Ns(c, u) || (Pn = !0), c) : (Yr & 42) === 0 ? (Pn = !0, c.memoizedState = v) : (c = sp(), $t.lanes |= c, Ks |= c, u);
                }
                function Fl(c, u, v, b, w) {
                    var U = Vr();
                    ss(U !== 0 && 8 > U ? U : 8);
                    var j = Ht.T, ne = {};
                    Ht.T = ne, Vl(c, !1, u, v);
                    try {
                        var ye = w(), Oe = Ht.S;
                        if (Oe !== null && Oe(ne, ye), ye !== null && typeof ye == "object" && typeof ye.then == "function") {
                            var $e = it(ye, b);
                            lo(c, u, $e, ri(c));
                        } else lo(c, u, b, ri(c));
                    } catch (ft) {
                        lo(c, u, {
                            then: function() {},
                            status: "rejected",
                            reason: ft
                        }, ri());
                    } finally{
                        ss(U), Ht.T = j;
                    }
                }
                function Qa(c) {
                    var u = c.memoizedState;
                    if (u !== null) return u;
                    u = {
                        memoizedState: To,
                        baseState: To,
                        baseQueue: null,
                        queue: {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: je,
                            lastRenderedState: To
                        },
                        next: null
                    };
                    var v = {};
                    return u.next = {
                        memoizedState: v,
                        baseState: v,
                        baseQueue: null,
                        queue: {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: je,
                            lastRenderedState: v
                        },
                        next: null
                    }, c.memoizedState = u, c = c.alternate, c !== null && (c.memoizedState = u), u;
                }
                function ou() {
                    return qi(Na);
                }
                function Gl() {
                    return ce().memoizedState;
                }
                function wr() {
                    return ce().memoizedState;
                }
                function Pd(c) {
                    for(var u = c.return; u !== null;){
                        switch(u.tag){
                            case 24:
                            case 3:
                                var v = ri();
                                c = He(v);
                                var b = st(u, c, v);
                                b !== null && (Ii(b, u, v), St(b, u, v)), u = {
                                    cache: ho()
                                }, c.payload = u;
                                return;
                        }
                        u = u.return;
                    }
                }
                function If(c, u, v) {
                    var b = ri();
                    v = {
                        lane: b,
                        revertLane: 0,
                        action: v,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    }, lu(c) ? ds(u, v) : (v = Ye(c, u, v, b), v !== null && (Ii(v, c, b), co(v, u, b)));
                }
                function Hd(c, u, v) {
                    var b = ri();
                    lo(c, u, v, b);
                }
                function lo(c, u, v, b) {
                    var w = {
                        lane: b,
                        revertLane: 0,
                        action: v,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    };
                    if (lu(c)) ds(u, w);
                    else {
                        var U = c.alternate;
                        if (c.lanes === 0 && (U === null || U.lanes === 0) && (U = u.lastRenderedReducer, U !== null)) try {
                            var j = u.lastRenderedState, ne = U(j, v);
                            if (w.hasEagerState = !0, w.eagerState = ne, Ns(ne, j)) return et(c, u, w, 0), Rn === null && W(), !1;
                        } catch  {} finally{}
                        if (v = Ye(c, u, w, b), v !== null) return Ii(v, c, b), co(v, u, b), !0;
                    }
                    return !1;
                }
                function Vl(c, u, v, b) {
                    if (b = {
                        lane: 2,
                        revertLane: Le(),
                        action: b,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    }, lu(c)) {
                        if (u) throw Error(i(479));
                    } else u = Ye(c, v, b, 2), u !== null && Ii(u, c, 2);
                }
                function lu(c) {
                    var u = c.alternate;
                    return c === $t || u !== null && u === $t;
                }
                function ds(c, u) {
                    ml = pa = !0;
                    var v = c.pending;
                    v === null ? u.next = u : (u.next = v.next, v.next = u), c.pending = u;
                }
                function co(c, u, v) {
                    if ((v & 4194176) !== 0) {
                        var b = u.lanes;
                        b &= c.pendingLanes, v |= b, u.lanes = v, ge(c, v);
                    }
                }
                function kl(c, u, v, b) {
                    u = c.memoizedState, v = v(b, u), v = v == null ? u : nh({}, u, v), c.memoizedState = v, c.lanes === 0 && (c.updateQueue.baseState = v);
                }
                function Xl(c, u, v, b, w, U, j) {
                    return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(b, U, j) : u.prototype && u.prototype.isPureReactComponent ? !Ve(v, b) || !Ve(w, U) : !0;
                }
                function Wm(c, u, v, b) {
                    c = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(v, b), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(v, b), u.state !== c && or.enqueueReplaceState(u, u.state, null);
                }
                function Rr(c, u) {
                    var v = u;
                    if ("ref" in u) {
                        v = {};
                        for(var b in u)b !== "ref" && (v[b] = u[b]);
                    }
                    if (c = c.defaultProps) {
                        v === u && (v = nh({}, v));
                        for(var w in c)v[w] === void 0 && (v[w] = c[w]);
                    }
                    return v;
                }
                function jl(c, u) {
                    try {
                        var v = c.onUncaughtError;
                        v(u.value, {
                            componentStack: u.stack
                        });
                    } catch (b) {
                        setTimeout(function() {
                            throw b;
                        });
                    }
                }
                function ql(c, u, v) {
                    try {
                        var b = c.onCaughtError;
                        b(v.value, {
                            componentStack: v.stack,
                            errorBoundary: u.tag === 1 ? u.stateNode : null
                        });
                    } catch (w) {
                        setTimeout(function() {
                            throw w;
                        });
                    }
                }
                function Yl(c, u, v) {
                    return v = He(v), v.tag = 3, v.payload = {
                        element: null
                    }, v.callback = function() {
                        jl(c, u);
                    }, v;
                }
                function Fd(c) {
                    return c = He(c), c.tag = 3, c;
                }
                function Zm(c, u, v, b) {
                    var w = v.type.getDerivedStateFromError;
                    if (typeof w == "function") {
                        var U = b.value;
                        c.payload = function() {
                            return w(U);
                        }, c.callback = function() {
                            ql(u, v, b);
                        };
                    }
                    var j = v.stateNode;
                    j !== null && typeof j.componentDidCatch == "function" && (c.callback = function() {
                        ql(u, v, b), typeof w != "function" && (Io === null ? Io = new Set([
                            this
                        ]) : Io.add(this));
                        var ne = b.stack;
                        this.componentDidCatch(b.value, {
                            componentStack: ne !== null ? ne : ""
                        });
                    });
                }
                function Zy(c, u, v, b, w) {
                    if (v.flags |= 32768, b !== null && typeof b == "object" && typeof b.then == "function") {
                        if (u = v.alternate, u !== null && hu(u, v, w, !0), v = js.current, v !== null) {
                            switch(v.tag){
                                case 13:
                                    return In === null ? Br() : v.alternate === null && Hn === 0 && (Hn = 3), v.flags &= -257, v.flags |= 65536, v.lanes = w, b === Xu ? v.flags |= 16384 : (u = v.updateQueue, u === null ? v.updateQueue = new Set([
                                        b
                                    ]) : u.add(b), tl(c, b, w)), !1;
                                case 22:
                                    return v.flags |= 65536, b === Xu ? v.flags |= 16384 : (u = v.updateQueue, u === null ? (u = {
                                        transitions: null,
                                        markerInstances: null,
                                        retryQueue: new Set([
                                            b
                                        ])
                                    }, v.updateQueue = u) : (v = u.retryQueue, v === null ? u.retryQueue = new Set([
                                        b
                                    ]) : v.add(b)), tl(c, b, w)), !1;
                            }
                            throw Error(i(435, v.tag));
                        }
                        return tl(c, b, w), Br(), !1;
                    }
                    if (yn) return u = js.current, u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256), u.flags |= 65536, u.lanes = w, b !== Gu && (c = Error(i(422), {
                        cause: b
                    }), Nt(fe(c, v)))) : (b !== Gu && (u = Error(i(423), {
                        cause: b
                    }), Nt(fe(u, v))), c = c.current.alternate, c.flags |= 65536, w &= -w, c.lanes |= w, b = fe(b, v), w = Yl(c.stateNode, b, w), ie(c, w), Hn !== 4 && (Hn = 2)), !1;
                    var U = Error(i(520), {
                        cause: b
                    });
                    if (U = fe(U, v), yl === null ? yl = [
                        U
                    ] : yl.push(U), Hn !== 4 && (Hn = 2), u === null) return !0;
                    b = fe(b, v), v = u;
                    do {
                        switch(v.tag){
                            case 3:
                                return v.flags |= 65536, c = w & -w, v.lanes |= c, c = Yl(v.stateNode, b, c), ie(v, c), !1;
                            case 1:
                                if (u = v.type, U = v.stateNode, (v.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || U !== null && typeof U.componentDidCatch == "function" && (Io === null || !Io.has(U)))) return v.flags |= 65536, w &= -w, v.lanes |= w, w = Fd(w), Zm(w, c, v, b), ie(v, w), !1;
                        }
                        v = v.return;
                    }while (v !== null);
                    return !1;
                }
                function ji(c, u, v, b) {
                    u.child = c === null ? rr(u, null, v, b) : Oo(u, c.child, v, b);
                }
                function Pf(c, u, v, b, w) {
                    v = v.render;
                    var U = u.ref;
                    if ("ref" in b) {
                        var j = {};
                        for(var ne in b)ne !== "ref" && (j[ne] = b[ne]);
                    } else j = b;
                    return fo(u), b = Aa(c, u, v, j, U, w), ne = Pl(), c !== null && !Pn ? (Hl(c, u, w), Cr(c, u, w)) : (yn && ne && me(u), u.flags |= 1, ji(c, u, b, w), u.child);
                }
                function Km(c, u, v, b, w) {
                    if (c === null) {
                        var U = v.type;
                        return typeof U == "function" && !Tu(U) && U.defaultProps === void 0 && v.compare === null ? (u.tag = 15, u.type = U, Qm(c, u, U, b, w)) : (c = er(v.type, null, b, u, u.mode, w), c.ref = u.ref, c.return = u, u.child = c);
                    }
                    if (U = c.child, !jd(c, w)) {
                        var j = U.memoizedProps;
                        if (v = v.compare, v = v !== null ? v : Ve, v(j, b) && c.ref === u.ref) return Cr(c, u, w);
                    }
                    return u.flags |= 1, c = oa(U, b), c.ref = u.ref, c.return = u, u.child = c;
                }
                function Qm(c, u, v, b, w) {
                    if (c !== null) {
                        var U = c.memoizedProps;
                        if (Ve(U, b) && c.ref === u.ref) if (Pn = !1, u.pendingProps = b = U, jd(c, w)) (c.flags & 131072) !== 0 && (Pn = !0);
                        else return u.lanes = c.lanes, Cr(c, u, w);
                    }
                    return Hf(c, u, v, b, w);
                }
                function Jm(c, u, v) {
                    var b = u.pendingProps, w = b.children, U = (u.stateNode._pendingVisibility & 2) !== 0, j = c !== null ? c.memoizedState : null;
                    if (cu(c, u), b.mode === "hidden" || U) {
                        if ((u.flags & 128) !== 0) {
                            if (b = j !== null ? j.baseLanes | v : v, c !== null) {
                                for(w = u.child = c.child, U = 0; w !== null;)U = U | w.lanes | w.childLanes, w = w.sibling;
                                u.childLanes = U & ~b;
                            } else u.childLanes = 0, u.child = null;
                            return $m(c, u, b, v);
                        }
                        if ((v & 536870912) !== 0) u.memoizedState = {
                            baseLanes: 0,
                            cachePool: null
                        }, c !== null && Gf(u, j !== null ? j.cachePool : null), j !== null ? vi(u, j) : Ei(), nu(u);
                        else return u.lanes = u.childLanes = 536870912, $m(c, u, j !== null ? j.baseLanes | v : v, v);
                    } else j !== null ? (Gf(u, j.cachePool), vi(u, j), Ma(), u.memoizedState = null) : (c !== null && Gf(u, null), Ei(), Ma());
                    return ji(c, u, w, v), u.child;
                }
                function $m(c, u, v, b) {
                    var w = Yd();
                    return w = w === null ? null : {
                        parent: gs ? Xn._currentValue : Xn._currentValue2,
                        pool: w
                    }, u.memoizedState = {
                        baseLanes: v,
                        cachePool: w
                    }, c !== null && Gf(u, null), Ei(), nu(u), c !== null && hu(c, u, b, !0), null;
                }
                function cu(c, u) {
                    var v = u.ref;
                    if (v === null) c !== null && c.ref !== null && (u.flags |= 2097664);
                    else {
                        if (typeof v != "function" && typeof v != "object") throw Error(i(284));
                        (c === null || c.ref !== v) && (u.flags |= 2097664);
                    }
                }
                function Hf(c, u, v, b, w) {
                    return fo(u), v = Aa(c, u, v, b, void 0, w), b = Pl(), c !== null && !Pn ? (Hl(c, u, w), Cr(c, u, w)) : (yn && b && me(u), u.flags |= 1, ji(c, u, v, w), u.child);
                }
                function eg(c, u, v, b, w, U) {
                    return fo(u), u.updateQueue = null, v = Ar(u, b, v, w), ro(c), b = Pl(), c !== null && !Pn ? (Hl(c, u, U), Cr(c, u, U)) : (yn && b && me(u), u.flags |= 1, ji(c, u, v, U), u.child);
                }
                function tg(c, u, v, b, w) {
                    if (fo(u), u.stateNode === null) {
                        var U = Co, j = v.contextType;
                        typeof j == "object" && j !== null && (U = qi(j)), U = new v(b, U), u.memoizedState = U.state !== null && U.state !== void 0 ? U.state : null, U.updater = or, u.stateNode = U, U._reactInternals = u, U = u.stateNode, U.props = b, U.state = u.memoizedState, U.refs = {}, vt(u), j = v.contextType, U.context = typeof j == "object" && j !== null ? qi(j) : Co, U.state = u.memoizedState, j = v.getDerivedStateFromProps, typeof j == "function" && (kl(u, v, j, b), U.state = u.memoizedState), typeof v.getDerivedStateFromProps == "function" || typeof U.getSnapshotBeforeUpdate == "function" || typeof U.UNSAFE_componentWillMount != "function" && typeof U.componentWillMount != "function" || (j = U.state, typeof U.componentWillMount == "function" && U.componentWillMount(), typeof U.UNSAFE_componentWillMount == "function" && U.UNSAFE_componentWillMount(), j !== U.state && or.enqueueReplaceState(U, U.state, null), Ze(u, b, U, w), xe(), U.state = u.memoizedState), typeof U.componentDidMount == "function" && (u.flags |= 4194308), b = !0;
                    } else if (c === null) {
                        U = u.stateNode;
                        var ne = u.memoizedProps, ye = Rr(v, ne);
                        U.props = ye;
                        var Oe = U.context, $e = v.contextType;
                        j = Co, typeof $e == "object" && $e !== null && (j = qi($e));
                        var ft = v.getDerivedStateFromProps;
                        $e = typeof ft == "function" || typeof U.getSnapshotBeforeUpdate == "function", ne = u.pendingProps !== ne, $e || typeof U.UNSAFE_componentWillReceiveProps != "function" && typeof U.componentWillReceiveProps != "function" || (ne || Oe !== j) && Wm(u, U, b, j), qr = !1;
                        var gt = u.memoizedState;
                        U.state = gt, Ze(u, b, U, w), xe(), Oe = u.memoizedState, ne || gt !== Oe || qr ? (typeof ft == "function" && (kl(u, v, ft, b), Oe = u.memoizedState), (ye = qr || Xl(u, v, ye, b, gt, Oe, j)) ? ($e || typeof U.UNSAFE_componentWillMount != "function" && typeof U.componentWillMount != "function" || (typeof U.componentWillMount == "function" && U.componentWillMount(), typeof U.UNSAFE_componentWillMount == "function" && U.UNSAFE_componentWillMount()), typeof U.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof U.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = b, u.memoizedState = Oe), U.props = b, U.state = Oe, U.context = j, b = ye) : (typeof U.componentDidMount == "function" && (u.flags |= 4194308), b = !1);
                    } else {
                        U = u.stateNode, yt(c, u), j = u.memoizedProps, $e = Rr(v, j), U.props = $e, ft = u.pendingProps, gt = U.context, Oe = v.contextType, ye = Co, typeof Oe == "object" && Oe !== null && (ye = qi(Oe)), ne = v.getDerivedStateFromProps, (Oe = typeof ne == "function" || typeof U.getSnapshotBeforeUpdate == "function") || typeof U.UNSAFE_componentWillReceiveProps != "function" && typeof U.componentWillReceiveProps != "function" || (j !== ft || gt !== ye) && Wm(u, U, b, ye), qr = !1, gt = u.memoizedState, U.state = gt, Ze(u, b, U, w), xe();
                        var Xt = u.memoizedState;
                        j !== ft || gt !== Xt || qr || c !== null && c.dependencies !== null && du(c.dependencies) ? (typeof ne == "function" && (kl(u, v, ne, b), Xt = u.memoizedState), ($e = qr || Xl(u, v, $e, b, gt, Xt, ye) || c !== null && c.dependencies !== null && du(c.dependencies)) ? (Oe || typeof U.UNSAFE_componentWillUpdate != "function" && typeof U.componentWillUpdate != "function" || (typeof U.componentWillUpdate == "function" && U.componentWillUpdate(b, Xt, ye), typeof U.UNSAFE_componentWillUpdate == "function" && U.UNSAFE_componentWillUpdate(b, Xt, ye)), typeof U.componentDidUpdate == "function" && (u.flags |= 4), typeof U.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof U.componentDidUpdate != "function" || j === c.memoizedProps && gt === c.memoizedState || (u.flags |= 4), typeof U.getSnapshotBeforeUpdate != "function" || j === c.memoizedProps && gt === c.memoizedState || (u.flags |= 1024), u.memoizedProps = b, u.memoizedState = Xt), U.props = b, U.state = Xt, U.context = ye, b = $e) : (typeof U.componentDidUpdate != "function" || j === c.memoizedProps && gt === c.memoizedState || (u.flags |= 4), typeof U.getSnapshotBeforeUpdate != "function" || j === c.memoizedProps && gt === c.memoizedState || (u.flags |= 1024), b = !1);
                    }
                    return U = b, cu(c, u), b = (u.flags & 128) !== 0, U || b ? (U = u.stateNode, v = b && typeof v.getDerivedStateFromError != "function" ? null : U.render(), u.flags |= 1, c !== null && b ? (u.child = Oo(u, c.child, null, w), u.child = Oo(u, null, v, w)) : ji(c, u, v, w), u.memoizedState = U.state, c = u.child) : c = Cr(c, u, w), c;
                }
                function ng(c, u, v, b) {
                    return Vt(), u.flags |= 256, ji(c, u, v, b), u.child;
                }
                function Gd(c) {
                    return {
                        baseLanes: c,
                        cachePool: Wd()
                    };
                }
                function uu(c, u, v) {
                    return c = c !== null ? c.childLanes & ~v : 0, u && (c |= Qs), c;
                }
                function ig(c, u, v) {
                    var b = u.pendingProps, w = !1, U = (u.flags & 128) !== 0, j;
                    if ((j = U) || (j = c !== null && c.memoizedState === null ? !1 : (Ri.current & 2) !== 0), j && (w = !0, u.flags &= -129), j = (u.flags & 32) !== 0, u.flags &= -33, c === null) {
                        if (yn) {
                            if (w ? Ms(u) : Ma(), yn) {
                                var ne = Ji, ye;
                                (ye = ne) && (ne = Fg(ne, Hi), ne !== null ? (u.memoizedState = {
                                    dehydrated: ne,
                                    treeContext: Do !== null ? {
                                        id: La,
                                        overflow: Oa
                                    } : null,
                                    retryLane: 536870912
                                }, ye = t(18, null, null, 0), ye.stateNode = ne, ye.return = u, u.child = ye, Qi = u, Ji = null, ye = !0) : ye = !1), ye || Pe(u);
                            }
                            if (ne = u.memoizedState, ne !== null && (ne = ne.dehydrated, ne !== null)) return hh(ne) ? u.lanes = 16 : u.lanes = 536870912, null;
                            fs(u);
                        }
                        return ne = b.children, b = b.fallback, w ? (Ma(), w = u.mode, ne = kd({
                            mode: "hidden",
                            children: ne
                        }, w), b = ti(b, w, v, null), ne.return = u, b.return = u, ne.sibling = b, u.child = ne, w = u.child, w.memoizedState = Gd(v), w.childLanes = uu(c, j, v), u.memoizedState = Ah, b) : (Ms(u), Vd(u, ne));
                    }
                    if (ye = c.memoizedState, ye !== null && (ne = ye.dehydrated, ne !== null)) {
                        if (U) u.flags & 256 ? (Ms(u), u.flags &= -257, u = Ff(c, u, v)) : u.memoizedState !== null ? (Ma(), u.child = c.child, u.flags |= 128, u = null) : (Ma(), w = b.fallback, ne = u.mode, b = kd({
                            mode: "visible",
                            children: b.children
                        }, ne), w = ti(w, ne, v, null), w.flags |= 2, b.return = u, w.return = u, b.sibling = w, u.child = b, Oo(u, c.child, null, v), b = u.child, b.memoizedState = Gd(v), b.childLanes = uu(c, j, v), u.memoizedState = Ah, u = w);
                        else if (Ms(u), hh(ne)) j = zg(ne).digest, b = Error(i(419)), b.stack = "", b.digest = j, Nt({
                            value: b,
                            source: null,
                            stack: null
                        }), u = Ff(c, u, v);
                        else if (Pn || hu(c, u, v, !1), j = (v & c.childLanes) !== 0, Pn || j) {
                            if (j = Rn, j !== null) {
                                if (b = v & -v, (b & 42) !== 0) b = 1;
                                else switch(b){
                                    case 2:
                                        b = 1;
                                        break;
                                    case 8:
                                        b = 4;
                                        break;
                                    case 32:
                                        b = 16;
                                        break;
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                        b = 64;
                                        break;
                                    case 268435456:
                                        b = 134217728;
                                        break;
                                    default:
                                        b = 0;
                                }
                                if (b = (b & (j.suspendedLanes | v)) !== 0 ? 0 : b, b !== 0 && b !== ye.retryLane) throw ye.retryLane = b, We(c, b), Ii(j, c, b), Th;
                            }
                            fh(ne) || Br(), u = Ff(c, u, v);
                        } else fh(ne) ? (u.flags |= 128, u.child = c.child, u = Ir.bind(null, c), Bg(ne, u), u = null) : (c = ye.treeContext, Ki && (Ji = Hg(ne), Qi = u, yn = !0, ha = null, Hi = !1, c !== null && (Vs[ks++] = La, Vs[ks++] = Oa, Vs[ks++] = Do, La = c.id, Oa = c.overflow, Do = u)), u = Vd(u, b.children), u.flags |= 4096);
                        return u;
                    }
                    return w ? (Ma(), w = b.fallback, ne = u.mode, ye = c.child, U = ye.sibling, b = oa(ye, {
                        mode: "hidden",
                        children: b.children
                    }), b.subtreeFlags = ye.subtreeFlags & 31457280, U !== null ? w = oa(U, w) : (w = ti(w, ne, v, null), w.flags |= 2), w.return = u, b.return = u, b.sibling = w, u.child = b, b = w, w = u.child, ne = c.child.memoizedState, ne === null ? ne = Gd(v) : (ye = ne.cachePool, ye !== null ? (U = gs ? Xn._currentValue : Xn._currentValue2, ye = ye.parent !== U ? {
                        parent: U,
                        pool: U
                    } : ye) : ye = Wd(), ne = {
                        baseLanes: ne.baseLanes | v,
                        cachePool: ye
                    }), w.memoizedState = ne, w.childLanes = uu(c, j, v), u.memoizedState = Ah, b) : (Ms(u), v = c.child, c = v.sibling, v = oa(v, {
                        mode: "visible",
                        children: b.children
                    }), v.return = u, v.sibling = null, c !== null && (j = u.deletions, j === null ? (u.deletions = [
                        c
                    ], u.flags |= 16) : j.push(c)), u.child = v, u.memoizedState = null, v);
                }
                function Vd(c, u) {
                    return u = kd({
                        mode: "visible",
                        children: u
                    }, c.mode), u.return = c, c.child = u;
                }
                function kd(c, u) {
                    return wu(c, u, 0, null);
                }
                function Ff(c, u, v) {
                    return Oo(u, c.child, null, v), c = Vd(u, u.pendingProps.children), c.flags |= 2, u.memoizedState = null, c;
                }
                function sg(c, u, v) {
                    c.lanes |= u;
                    var b = c.alternate;
                    b !== null && (b.lanes |= u), fu(c.return, u, v);
                }
                function Xd(c, u, v, b, w) {
                    var U = c.memoizedState;
                    U === null ? c.memoizedState = {
                        isBackwards: u,
                        rendering: null,
                        renderingStartTime: 0,
                        last: b,
                        tail: v,
                        tailMode: w
                    } : (U.isBackwards = u, U.rendering = null, U.renderingStartTime = 0, U.last = b, U.tail = v, U.tailMode = w);
                }
                function ag(c, u, v) {
                    var b = u.pendingProps, w = b.revealOrder, U = b.tail;
                    if (ji(c, u, b.children, v), b = Ri.current, (b & 2) !== 0) b = b & 1 | 2, u.flags |= 128;
                    else {
                        if (c !== null && (c.flags & 128) !== 0) e: for(c = u.child; c !== null;){
                            if (c.tag === 13) c.memoizedState !== null && sg(c, v, u);
                            else if (c.tag === 19) sg(c, v, u);
                            else if (c.child !== null) {
                                c.child.return = c, c = c.child;
                                continue;
                            }
                            if (c === u) break e;
                            for(; c.sibling === null;){
                                if (c.return === null || c.return === u) break e;
                                c = c.return;
                            }
                            c.sibling.return = c.return, c = c.sibling;
                        }
                        b &= 1;
                    }
                    switch(C(Ri, b), w){
                        case "forwards":
                            for(v = u.child, w = null; v !== null;)c = v.alternate, c !== null && Ea(c) === null && (w = v), v = v.sibling;
                            v = w, v === null ? (w = u.child, u.child = null) : (w = v.sibling, v.sibling = null), Xd(u, !1, w, v, U);
                            break;
                        case "backwards":
                            for(v = null, w = u.child, u.child = null; w !== null;){
                                if (c = w.alternate, c !== null && Ea(c) === null) {
                                    u.child = w;
                                    break;
                                }
                                c = w.sibling, w.sibling = v, v = w, w = c;
                            }
                            Xd(u, !0, v, null, U);
                            break;
                        case "together":
                            Xd(u, !1, null, null, void 0);
                            break;
                        default:
                            u.memoizedState = null;
                    }
                    return u.child;
                }
                function Cr(c, u, v) {
                    if (c !== null && (u.dependencies = c.dependencies), Ks |= u.lanes, (v & u.childLanes) === 0) if (c !== null) {
                        if (hu(c, u, v, !1), (v & u.childLanes) === 0) return null;
                    } else return null;
                    if (c !== null && u.child !== c.child) throw Error(i(153));
                    if (u.child !== null) {
                        for(c = u.child, v = oa(c, c.pendingProps), u.child = v, v.return = u; c.sibling !== null;)c = c.sibling, v = v.sibling = oa(c, c.pendingProps), v.return = u;
                        v.sibling = null;
                    }
                    return u.child;
                }
                function jd(c, u) {
                    return (c.lanes & u) !== 0 ? !0 : (c = c.dependencies, !!(c !== null && du(c)));
                }
                function Ky(c, u, v) {
                    switch(u.tag){
                        case 3:
                            J(u, u.stateNode.containerInfo), uo(u, Xn, c.memoizedState.cache), Vt();
                            break;
                        case 27:
                        case 5:
                            he(u);
                            break;
                        case 4:
                            J(u, u.stateNode.containerInfo);
                            break;
                        case 10:
                            uo(u, u.type, u.memoizedProps.value);
                            break;
                        case 13:
                            var b = u.memoizedState;
                            if (b !== null) return b.dehydrated !== null ? (Ms(u), u.flags |= 128, null) : (v & u.child.childLanes) !== 0 ? ig(c, u, v) : (Ms(u), c = Cr(c, u, v), c !== null ? c.sibling : null);
                            Ms(u);
                            break;
                        case 19:
                            var w = (c.flags & 128) !== 0;
                            if (b = (v & u.childLanes) !== 0, b || (hu(c, u, v, !1), b = (v & u.childLanes) !== 0), w) {
                                if (b) return ag(c, u, v);
                                u.flags |= 128;
                            }
                            if (w = u.memoizedState, w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), C(Ri, Ri.current), b) break;
                            return null;
                        case 22:
                        case 23:
                            return u.lanes = 0, Jm(c, u, v);
                        case 24:
                            uo(u, Xn, c.memoizedState.cache);
                    }
                    return Cr(c, u, v);
                }
                function rg(c, u, v) {
                    if (c !== null) if (c.memoizedProps !== u.pendingProps) Pn = !0;
                    else {
                        if (!jd(c, v) && (u.flags & 128) === 0) return Pn = !1, Ky(c, u, v);
                        Pn = (c.flags & 131072) !== 0;
                    }
                    else Pn = !1, yn && (u.flags & 1048576) !== 0 && $(u, pc, u.index);
                    switch(u.lanes = 0, u.tag){
                        case 16:
                            e: {
                                c = u.pendingProps;
                                var b = u.elementType, w = b._init;
                                if (b = w(b._payload), u.type = b, typeof b == "function") Tu(b) ? (c = Rr(b, c), u.tag = 1, u = tg(null, u, b, c, v)) : (u.tag = 0, u = Hf(null, u, b, c, v));
                                else {
                                    if (b != null) {
                                        if (w = b.$$typeof, w === Uu) {
                                            u.tag = 11, u = Pf(null, u, b, c, v);
                                            break e;
                                        } else if (w === ah) {
                                            u.tag = 14, u = Km(null, u, b, c, v);
                                            break e;
                                        }
                                    }
                                    throw u = l(b) || b, Error(i(306, u, ""));
                                }
                            }
                            return u;
                        case 0:
                            return Hf(c, u, u.type, u.pendingProps, v);
                        case 1:
                            return b = u.type, w = Rr(b, u.pendingProps), tg(c, u, b, w, v);
                        case 3:
                            e: {
                                if (J(u, u.stateNode.containerInfo), c === null) throw Error(i(387));
                                var U = u.pendingProps;
                                w = u.memoizedState, b = w.element, yt(c, u), Ze(u, U, null, v);
                                var j = u.memoizedState;
                                if (U = j.cache, uo(u, Xn, U), U !== w.cache && $o(u, [
                                    Xn
                                ], v, !0), xe(), U = j.element, Ki && w.isDehydrated) if (w = {
                                    element: U,
                                    isDehydrated: !1,
                                    cache: j.cache
                                }, u.updateQueue.baseState = w, u.memoizedState = w, u.flags & 256) {
                                    u = ng(c, u, U, v);
                                    break e;
                                } else if (U !== b) {
                                    b = fe(Error(i(424)), u), Nt(b), u = ng(c, u, U, v);
                                    break e;
                                } else for(Ki && (Ji = Pg(u.stateNode.containerInfo), Qi = u, yn = !0, ha = null, Hi = !0), v = rr(u, null, U, v), u.child = v; v;)v.flags = v.flags & -3 | 4096, v = v.sibling;
                                else {
                                    if (Vt(), U === b) {
                                        u = Cr(c, u, v);
                                        break e;
                                    }
                                    ji(c, u, U, v);
                                }
                                u = u.child;
                            }
                            return u;
                        case 26:
                            if (Gs) return cu(c, u), c === null ? (v = Np(u.type, null, u.pendingProps, null)) ? u.memoizedState = v : yn || (u.stateNode = vh(u.type, u.pendingProps, sr.current, u)) : u.memoizedState = Np(u.type, c.memoizedProps, u.pendingProps, c.memoizedState), null;
                        case 27:
                            if (Bn) return he(u), c === null && Bn && yn && (b = u.stateNode = Ua(u.type, u.pendingProps, sr.current, wi.current, !1), Qi = u, Hi = !0, Ji = dh(b)), b = u.pendingProps.children, c !== null || yn ? ji(c, u, b, v) : u.child = Oo(u, null, b, v), cu(c, u), u.child;
                        case 5:
                            return c === null && yn && (mh(u.type, u.pendingProps, wi.current), (w = b = Ji) && (b = i_(b, u.type, u.pendingProps, Hi), b !== null ? (u.stateNode = b, Qi = u, Ji = dh(b), Hi = !1, w = !0) : w = !1), w || Pe(u)), he(u), w = u.type, U = u.pendingProps, j = c !== null ? c.memoizedProps : null, b = U.children, qt(w, U) ? b = null : j !== null && qt(w, j) && (u.flags |= 32), u.memoizedState !== null && (w = Aa(c, u, yi, null, null, v), gs ? Na._currentValue = w : Na._currentValue2 = w), cu(c, u), ji(c, u, b, v), u.child;
                        case 6:
                            return c === null && yn && (jg(u.pendingProps, wi.current), (c = v = Ji) && (v = Cp(v, u.pendingProps, Hi), v !== null ? (u.stateNode = v, Qi = u, Ji = null, c = !0) : c = !1), c || Pe(u)), null;
                        case 13:
                            return ig(c, u, v);
                        case 4:
                            return J(u, u.stateNode.containerInfo), b = u.pendingProps, c === null ? u.child = Oo(u, null, b, v) : ji(c, u, b, v), u.child;
                        case 11:
                            return Pf(c, u, u.type, u.pendingProps, v);
                        case 7:
                            return ji(c, u, u.pendingProps, v), u.child;
                        case 8:
                            return ji(c, u, u.pendingProps.children, v), u.child;
                        case 12:
                            return ji(c, u, u.pendingProps.children, v), u.child;
                        case 10:
                            return b = u.pendingProps, uo(u, u.type, b.value), ji(c, u, b.children, v), u.child;
                        case 9:
                            return w = u.type._context, b = u.pendingProps.children, fo(u), w = qi(w), b = b(w), u.flags |= 1, ji(c, u, b, v), u.child;
                        case 14:
                            return Km(c, u, u.type, u.pendingProps, v);
                        case 15:
                            return Qm(c, u, u.type, u.pendingProps, v);
                        case 19:
                            return ag(c, u, v);
                        case 22:
                            return Jm(c, u, v);
                        case 24:
                            return fo(u), b = qi(Xn), c === null ? (w = Yd(), w === null && (w = Rn, U = ho(), w.pooledCache = U, U.refCount++, U !== null && (w.pooledCacheLanes |= v), w = U), u.memoizedState = {
                                parent: b,
                                cache: w
                            }, vt(u), uo(u, Xn, w)) : ((c.lanes & v) !== 0 && (yt(c, u), Ze(u, null, null, v), xe()), w = c.memoizedState, U = u.memoizedState, w.parent !== b ? (w = {
                                parent: b,
                                cache: b
                            }, u.memoizedState = w, u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = w), uo(u, Xn, b)) : (b = U.cache, uo(u, Xn, b), b !== w.cache && $o(u, [
                                Xn
                            ], v, !0))), ji(c, u, u.pendingProps.children, v), u.child;
                        case 29:
                            throw u.pendingProps;
                    }
                    throw Error(i(156, u.tag));
                }
                function uo(c, u, v) {
                    gs ? (C(Wr, u._currentValue), u._currentValue = v) : (C(Wr, u._currentValue2), u._currentValue2 = v);
                }
                function Dr(c) {
                    var u = Wr.current;
                    gs ? c._currentValue = u : c._currentValue2 = u, E(Wr);
                }
                function fu(c, u, v) {
                    for(; c !== null;){
                        var b = c.alternate;
                        if ((c.childLanes & u) !== u ? (c.childLanes |= u, b !== null && (b.childLanes |= u)) : b !== null && (b.childLanes & u) !== u && (b.childLanes |= u), c === v) break;
                        c = c.return;
                    }
                }
                function $o(c, u, v, b) {
                    var w = c.child;
                    for(w !== null && (w.return = c); w !== null;){
                        var U = w.dependencies;
                        if (U !== null) {
                            var j = w.child;
                            U = U.firstContext;
                            e: for(; U !== null;){
                                var ne = U;
                                U = w;
                                for(var ye = 0; ye < u.length; ye++)if (ne.context === u[ye]) {
                                    U.lanes |= v, ne = U.alternate, ne !== null && (ne.lanes |= v), fu(U.return, v, c), b || (j = null);
                                    break e;
                                }
                                U = ne.next;
                            }
                        } else if (w.tag === 18) {
                            if (j = w.return, j === null) throw Error(i(341));
                            j.lanes |= v, U = j.alternate, U !== null && (U.lanes |= v), fu(j, v, c), j = null;
                        } else j = w.child;
                        if (j !== null) j.return = w;
                        else for(j = w; j !== null;){
                            if (j === c) {
                                j = null;
                                break;
                            }
                            if (w = j.sibling, w !== null) {
                                w.return = j.return, j = w;
                                break;
                            }
                            j = j.return;
                        }
                        w = j;
                    }
                }
                function hu(c, u, v, b) {
                    c = null;
                    for(var w = u, U = !1; w !== null;){
                        if (!U) {
                            if ((w.flags & 524288) !== 0) U = !0;
                            else if ((w.flags & 262144) !== 0) break;
                        }
                        if (w.tag === 10) {
                            var j = w.alternate;
                            if (j === null) throw Error(i(387));
                            if (j = j.memoizedProps, j !== null) {
                                var ne = w.type;
                                Ns(w.pendingProps.value, j.value) || (c !== null ? c.push(ne) : c = [
                                    ne
                                ]);
                            }
                        } else if (w === cl.current) {
                            if (j = w.alternate, j === null) throw Error(i(387));
                            j.memoizedState.memoizedState !== w.memoizedState.memoizedState && (c !== null ? c.push(Na) : c = [
                                Na
                            ]);
                        }
                        w = w.return;
                    }
                    c !== null && $o(u, c, v, b), u.flags |= 262144;
                }
                function du(c) {
                    for(c = c.firstContext; c !== null;){
                        var u = c.context;
                        if (!Ns(gs ? u._currentValue : u._currentValue2, c.memoizedValue)) return !0;
                        c = c.next;
                    }
                    return !1;
                }
                function fo(c) {
                    Ia = c, Ys = null, c = c.dependencies, c !== null && (c.firstContext = null);
                }
                function qi(c) {
                    return qd(Ia, c);
                }
                function pu(c, u) {
                    return Ia === null && fo(c), qd(c, u);
                }
                function qd(c, u) {
                    var v = gs ? u._currentValue : u._currentValue2;
                    if (u = {
                        context: u,
                        memoizedValue: v,
                        next: null
                    }, Ys === null) {
                        if (c === null) throw Error(i(308));
                        Ys = u, c.dependencies = {
                            lanes: 0,
                            firstContext: u
                        }, c.flags |= 524288;
                    } else Ys = Ys.next = u;
                    return v;
                }
                function ho() {
                    return {
                        controller: new xc,
                        data: new Map,
                        refCount: 0
                    };
                }
                function mu(c) {
                    c.refCount--, c.refCount === 0 && n0(i0, function() {
                        c.controller.abort();
                    });
                }
                function Yd() {
                    var c = lr.current;
                    return c !== null ? c : Rn.pooledCache;
                }
                function Gf(c, u) {
                    u === null ? C(lr, lr.current) : C(lr, u.pool);
                }
                function Wd() {
                    var c = Yd();
                    return c === null ? null : {
                        parent: gs ? Xn._currentValue : Xn._currentValue2,
                        pool: c
                    };
                }
                function Es(c) {
                    c.flags |= 4;
                }
                function Wl(c, u) {
                    if (c !== null && c.child === u.child) return !1;
                    if ((u.flags & 16) !== 0) return !0;
                    for(c = u.child; c !== null;){
                        if ((c.flags & 13878) !== 0 || (c.subtreeFlags & 13878) !== 0) return !0;
                        c = c.sibling;
                    }
                    return !1;
                }
                function el(c, u, v, b) {
                    if (Ai) for(v = u.child; v !== null;){
                        if (v.tag === 5 || v.tag === 6) Ou(c, v.stateNode);
                        else if (!(v.tag === 4 || Bn && v.tag === 27) && v.child !== null) {
                            v.child.return = v, v = v.child;
                            continue;
                        }
                        if (v === u) break;
                        for(; v.sibling === null;){
                            if (v.return === null || v.return === u) return;
                            v = v.return;
                        }
                        v.sibling.return = v.return, v = v.sibling;
                    }
                    else if (ua) for(var w = u.child; w !== null;){
                        if (w.tag === 5) {
                            var U = w.stateNode;
                            v && b && (U = Tp(U, w.type, w.memoizedProps)), Ou(c, U);
                        } else if (w.tag === 6) U = w.stateNode, v && b && (U = Ap(U, w.memoizedProps)), Ou(c, U);
                        else if (w.tag !== 4) {
                            if (w.tag === 22 && w.memoizedState !== null) U = w.child, U !== null && (U.return = w), el(c, w, !0, !0);
                            else if (w.child !== null) {
                                w.child.return = w, w = w.child;
                                continue;
                            }
                        }
                        if (w === u) break;
                        for(; w.sibling === null;){
                            if (w.return === null || w.return === u) return;
                            w = w.return;
                        }
                        w.sibling.return = w.return, w = w.sibling;
                    }
                }
                function og(c, u, v, b) {
                    if (ua) for(var w = u.child; w !== null;){
                        if (w.tag === 5) {
                            var U = w.stateNode;
                            v && b && (U = Tp(U, w.type, w.memoizedProps)), Ep(c, U);
                        } else if (w.tag === 6) U = w.stateNode, v && b && (U = Ap(U, w.memoizedProps)), Ep(c, U);
                        else if (w.tag !== 4) {
                            if (w.tag === 22 && w.memoizedState !== null) U = w.child, U !== null && (U.return = w), og(c, w, !(w.memoizedProps !== null && w.memoizedProps.mode === "manual"), !0);
                            else if (w.child !== null) {
                                w.child.return = w, w = w.child;
                                continue;
                            }
                        }
                        if (w === u) break;
                        for(; w.sibling === null;){
                            if (w.return === null || w.return === u) return;
                            w = w.return;
                        }
                        w.sibling.return = w.return, w = w.sibling;
                    }
                }
                function gu(c, u) {
                    if (ua && Wl(c, u)) {
                        c = u.stateNode;
                        var v = c.containerInfo, b = zu();
                        og(b, u, !1, !1), c.pendingChildren = b, Es(u), uh(v, b);
                    }
                }
                function Vf(c, u, v, b) {
                    if (Ai) c.memoizedProps !== b && Es(u);
                    else if (ua) {
                        var w = c.stateNode, U = c.memoizedProps;
                        if ((c = Wl(c, u)) || U !== b) {
                            var j = wi.current;
                            U = fc(w, v, U, b, !c, null), U === w ? u.stateNode = w : (Gr(U, v, b, j) && Es(u), u.stateNode = U, c ? el(U, u, !1, !1) : Es(u));
                        } else u.stateNode = w;
                    }
                }
                function kf(c, u, v) {
                    if (gp(u, v)) {
                        if (c.flags |= 16777216, !lh(u, v)) if (_o()) c.flags |= 8192;
                        else throw No = Xu, ku;
                    } else c.flags &= -16777217;
                }
                function Xf(c, u) {
                    if (Wg(u)) {
                        if (c.flags |= 16777216, !sl(u)) if (_o()) c.flags |= 8192;
                        else throw No = Xu, ku;
                    } else c.flags &= -16777217;
                }
                function Zl(c, u) {
                    u !== null && (c.flags |= 4), c.flags & 16384 && (u = c.tag !== 22 ? z() : 536870912, c.lanes |= u, fr |= u);
                }
                function Kl(c, u) {
                    if (!yn) switch(c.tailMode){
                        case "hidden":
                            u = c.tail;
                            for(var v = null; u !== null;)u.alternate !== null && (v = u), u = u.sibling;
                            v === null ? c.tail = null : v.sibling = null;
                            break;
                        case "collapsed":
                            v = c.tail;
                            for(var b = null; v !== null;)v.alternate !== null && (b = v), v = v.sibling;
                            b === null ? u || c.tail === null ? c.tail = null : c.tail.sibling = null : b.sibling = null;
                    }
                }
                function Kn(c) {
                    var u = c.alternate !== null && c.alternate.child === c.child, v = 0, b = 0;
                    if (u) for(var w = c.child; w !== null;)v |= w.lanes | w.childLanes, b |= w.subtreeFlags & 31457280, b |= w.flags & 31457280, w.return = c, w = w.sibling;
                    else for(w = c.child; w !== null;)v |= w.lanes | w.childLanes, b |= w.subtreeFlags, b |= w.flags, w.return = c, w = w.sibling;
                    return c.subtreeFlags |= b, c.childLanes = v, u;
                }
                function lg(c, u, v) {
                    var b = u.pendingProps;
                    switch(ve(u), u.tag){
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Kn(u), null;
                        case 1:
                            return Kn(u), null;
                        case 3:
                            return v = u.stateNode, b = null, c !== null && (b = c.memoizedState.cache), u.memoizedState.cache !== b && (u.flags |= 2048), Dr(Xn), ue(), v.pendingContext && (v.context = v.pendingContext, v.pendingContext = null), (c === null || c.child === null) && (on(u) ? Es(u) : c === null || c.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024, ha !== null && (Mu(ha), ha = null))), gu(c, u), Kn(u), null;
                        case 26:
                            if (Gs) {
                                v = u.type;
                                var w = u.memoizedState;
                                return c === null ? (Es(u), w !== null ? (Kn(u), Xf(u, w)) : (Kn(u), kf(u, v, b))) : w ? w !== c.memoizedState ? (Es(u), Kn(u), Xf(u, w)) : (Kn(u), u.flags &= -16777217) : (Ai ? c.memoizedProps !== b && Es(u) : Vf(c, u, v, b), Kn(u), kf(u, v, b)), null;
                            }
                        case 27:
                            if (Bn) {
                                if (De(u), v = sr.current, w = u.type, c !== null && u.stateNode != null) Ai ? c.memoizedProps !== b && Es(u) : Vf(c, u, w, b);
                                else {
                                    if (!b) {
                                        if (u.stateNode === null) throw Error(i(166));
                                        return Kn(u), null;
                                    }
                                    c = wi.current, on(u) ? _t(u, c) : (c = Ua(w, b, v, c, !0), u.stateNode = c, Es(u));
                                }
                                return Kn(u), null;
                            }
                        case 5:
                            if (De(u), v = u.type, c !== null && u.stateNode != null) Vf(c, u, v, b);
                            else {
                                if (!b) {
                                    if (u.stateNode === null) throw Error(i(166));
                                    return Kn(u), null;
                                }
                                c = wi.current, on(u) ? _t(u, c) : (w = mp(v, b, sr.current, c, u), el(w, u, !1, !1), u.stateNode = w, Gr(w, v, b, c) && Es(u));
                            }
                            return Kn(u), kf(u, u.type, u.pendingProps), null;
                        case 6:
                            if (c && u.stateNode != null) v = c.memoizedProps, Ai ? v !== b && Es(u) : ua && (v !== b ? (u.stateNode = Nn(b, sr.current, wi.current, u), Es(u)) : u.stateNode = c.stateNode);
                            else {
                                if (typeof b != "string" && u.stateNode === null) throw Error(i(166));
                                if (c = sr.current, v = wi.current, on(u)) {
                                    if (!Ki) throw Error(i(176));
                                    if (c = u.stateNode, v = u.memoizedProps, b = null, w = Qi, w !== null) switch(w.tag){
                                        case 27:
                                        case 5:
                                            b = w.memoizedProps;
                                    }
                                    Dp(c, v, u, b) || Pe(u);
                                } else u.stateNode = Nn(b, c, v, u);
                            }
                            return Kn(u), null;
                        case 13:
                            if (b = u.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                                if (w = on(u), b !== null && b.dehydrated !== null) {
                                    if (c === null) {
                                        if (!w) throw Error(i(318));
                                        if (!Ki) throw Error(i(344));
                                        if (w = u.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(i(317));
                                        Vg(w, u);
                                    } else Vt(), (u.flags & 128) === 0 && (u.memoizedState = null), u.flags |= 4;
                                    Kn(u), w = !1;
                                } else ha !== null && (Mu(ha), ha = null), w = !0;
                                if (!w) return u.flags & 256 ? (fs(u), u) : (fs(u), null);
                            }
                            if (fs(u), (u.flags & 128) !== 0) return u.lanes = v, u;
                            if (v = b !== null, c = c !== null && c.memoizedState !== null, v) {
                                b = u.child, w = null, b.alternate !== null && b.alternate.memoizedState !== null && b.alternate.memoizedState.cachePool !== null && (w = b.alternate.memoizedState.cachePool.pool);
                                var U = null;
                                b.memoizedState !== null && b.memoizedState.cachePool !== null && (U = b.memoizedState.cachePool.pool), U !== w && (b.flags |= 2048);
                            }
                            return v !== c && v && (u.child.flags |= 8192), Zl(u, u.updateQueue), Kn(u), null;
                        case 4:
                            return ue(), gu(c, u), c === null && oi(u.stateNode.containerInfo), Kn(u), null;
                        case 10:
                            return Dr(u.type), Kn(u), null;
                        case 19:
                            if (E(Ri), w = u.memoizedState, w === null) return Kn(u), null;
                            if (b = (u.flags & 128) !== 0, U = w.rendering, U === null) if (b) Kl(w, !1);
                            else {
                                if (Hn !== 0 || c !== null && (c.flags & 128) !== 0) for(c = u.child; c !== null;){
                                    if (U = Ea(c), U !== null) {
                                        for(u.flags |= 128, Kl(w, !1), c = U.updateQueue, u.updateQueue = c, Zl(u, c), u.subtreeFlags = 0, c = v, v = u.child; v !== null;)Au(v, c), v = v.sibling;
                                        return C(Ri, Ri.current & 1 | 2), u.child;
                                    }
                                    c = c.sibling;
                                }
                                w.tail !== null && fa() > Mc && (u.flags |= 128, b = !0, Kl(w, !1), u.lanes = 4194304);
                            }
                            else {
                                if (!b) if (c = Ea(U), c !== null) {
                                    if (u.flags |= 128, b = !0, c = c.updateQueue, u.updateQueue = c, Zl(u, c), Kl(w, !0), w.tail === null && w.tailMode === "hidden" && !U.alternate && !yn) return Kn(u), null;
                                } else 2 * fa() - w.renderingStartTime > Mc && v !== 536870912 && (u.flags |= 128, b = !0, Kl(w, !1), u.lanes = 4194304);
                                w.isBackwards ? (U.sibling = u.child, u.child = U) : (c = w.last, c !== null ? c.sibling = U : u.child = U, w.last = U);
                            }
                            return w.tail !== null ? (u = w.tail, w.rendering = u, w.tail = u.sibling, w.renderingStartTime = fa(), u.sibling = null, c = Ri.current, C(Ri, b ? c & 1 | 2 : c & 1), u) : (Kn(u), null);
                        case 22:
                        case 23:
                            return fs(u), ns(), b = u.memoizedState !== null, c !== null ? c.memoizedState !== null !== b && (u.flags |= 8192) : b && (u.flags |= 8192), b ? (v & 536870912) !== 0 && (u.flags & 128) === 0 && (Kn(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : Kn(u), v = u.updateQueue, v !== null && Zl(u, v.retryQueue), v = null, c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (v = c.memoizedState.cachePool.pool), b = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (b = u.memoizedState.cachePool.pool), b !== v && (u.flags |= 2048), c !== null && E(lr), null;
                        case 24:
                            return v = null, c !== null && (v = c.memoizedState.cache), u.memoizedState.cache !== v && (u.flags |= 2048), Dr(Xn), Kn(u), null;
                        case 25:
                            return null;
                    }
                    throw Error(i(156, u.tag));
                }
                function Qy(c, u) {
                    switch(ve(u), u.tag){
                        case 1:
                            return c = u.flags, c & 65536 ? (u.flags = c & -65537 | 128, u) : null;
                        case 3:
                            return Dr(Xn), ue(), c = u.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (u.flags = c & -65537 | 128, u) : null;
                        case 26:
                        case 27:
                        case 5:
                            return De(u), null;
                        case 13:
                            if (fs(u), c = u.memoizedState, c !== null && c.dehydrated !== null) {
                                if (u.alternate === null) throw Error(i(340));
                                Vt();
                            }
                            return c = u.flags, c & 65536 ? (u.flags = c & -65537 | 128, u) : null;
                        case 19:
                            return E(Ri), null;
                        case 4:
                            return ue(), null;
                        case 10:
                            return Dr(u.type), null;
                        case 22:
                        case 23:
                            return fs(u), ns(), c !== null && E(lr), c = u.flags, c & 65536 ? (u.flags = c & -65537 | 128, u) : null;
                        case 24:
                            return Dr(Xn), null;
                        case 25:
                            return null;
                        default:
                            return null;
                    }
                }
                function cg(c, u) {
                    switch(ve(u), u.tag){
                        case 3:
                            Dr(Xn), ue();
                            break;
                        case 26:
                        case 27:
                        case 5:
                            De(u);
                            break;
                        case 4:
                            ue();
                            break;
                        case 13:
                            fs(u);
                            break;
                        case 19:
                            E(Ri);
                            break;
                        case 10:
                            Dr(u.type);
                            break;
                        case 22:
                        case 23:
                            fs(u), ns(), c !== null && E(lr);
                            break;
                        case 24:
                            Dr(Xn);
                    }
                }
                function vu(c, u) {
                    try {
                        var v = u.updateQueue, b = v !== null ? v.lastEffect : null;
                        if (b !== null) {
                            var w = b.next;
                            v = w;
                            do {
                                if ((v.tag & c) === c) {
                                    b = void 0;
                                    var U = v.create, j = v.inst;
                                    b = U(), j.destroy = b;
                                }
                                v = v.next;
                            }while (v !== w);
                        }
                    } catch (ne) {
                        An(u, u.return, ne);
                    }
                }
                function po(c, u, v) {
                    try {
                        var b = u.updateQueue, w = b !== null ? b.lastEffect : null;
                        if (w !== null) {
                            var U = w.next;
                            b = U;
                            do {
                                if ((b.tag & c) === c) {
                                    var j = b.inst, ne = j.destroy;
                                    if (ne !== void 0) {
                                        j.destroy = void 0, w = u;
                                        var ye = v;
                                        try {
                                            ne();
                                        } catch (Oe) {
                                            An(w, ye, Oe);
                                        }
                                    }
                                }
                                b = b.next;
                            }while (b !== U);
                        }
                    } catch (Oe) {
                        An(u, u.return, Oe);
                    }
                }
                function ug(c) {
                    var u = c.updateQueue;
                    if (u !== null) {
                        var v = c.stateNode;
                        try {
                            Qe(u, v);
                        } catch (b) {
                            An(c, c.return, b);
                        }
                    }
                }
                function Ts(c, u, v) {
                    v.props = Rr(c.type, c.memoizedProps), v.state = c.memoizedState;
                    try {
                        v.componentWillUnmount();
                    } catch (b) {
                        An(c, u, b);
                    }
                }
                function Ra(c, u) {
                    try {
                        var v = c.ref;
                        if (v !== null) {
                            var b = c.stateNode;
                            switch(c.tag){
                                case 26:
                                case 27:
                                case 5:
                                    var w = lc(b);
                                    break;
                                default:
                                    w = b;
                            }
                            typeof v == "function" ? c.refCleanup = v(w) : v.current = w;
                        }
                    } catch (U) {
                        An(c, u, U);
                    }
                }
                function As(c, u) {
                    var v = c.ref, b = c.refCleanup;
                    if (v !== null) if (typeof b == "function") try {
                        b();
                    } catch (w) {
                        An(c, u, w);
                    } finally{
                        c.refCleanup = null, c = c.alternate, c != null && (c.refCleanup = null);
                    }
                    else if (typeof v == "function") try {
                        v(null);
                    } catch (w) {
                        An(c, u, w);
                    }
                    else v.current = null;
                }
                function Zd(c) {
                    var u = c.type, v = c.memoizedProps, b = c.stateNode;
                    try {
                        t_(b, u, v, c);
                    } catch (w) {
                        An(c, c.return, w);
                    }
                }
                function Kd(c, u, v) {
                    try {
                        wg(c.stateNode, c.type, v, u, c);
                    } catch (b) {
                        An(c, c.return, b);
                    }
                }
                function Qd(c) {
                    return c.tag === 5 || c.tag === 3 || (Gs ? c.tag === 26 : !1) || (Bn ? c.tag === 27 : !1) || c.tag === 4;
                }
                function yu(c) {
                    e: for(;;){
                        for(; c.sibling === null;){
                            if (c.return === null || Qd(c.return)) return null;
                            c = c.return;
                        }
                        for(c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && (!Bn || c.tag !== 27) && c.tag !== 18;){
                            if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
                            c.child.return = c, c = c.child;
                        }
                        if (!(c.flags & 2)) return c.stateNode;
                    }
                }
                function Jd(c, u, v) {
                    var b = c.tag;
                    if (b === 5 || b === 6) c = c.stateNode, u ? Cg(v, c, u) : Sp(v, c);
                    else if (!(b === 4 || Bn && b === 27) && (c = c.child, c !== null)) for(Jd(c, u, v), c = c.sibling; c !== null;)Jd(c, u, v), c = c.sibling;
                }
                function Nr(c, u, v) {
                    var b = c.tag;
                    if (b === 5 || b === 6) c = c.stateNode, u ? Rg(v, c, u) : Tg(v, c);
                    else if (!(b === 4 || Bn && b === 27) && (c = c.child, c !== null)) for(Nr(c, u, v), c = c.sibling; c !== null;)Nr(c, u, v), c = c.sibling;
                }
                function jf(c, u, v) {
                    c = c.containerInfo;
                    try {
                        hc(c, v);
                    } catch (b) {
                        An(u, u.return, b);
                    }
                }
                function _u(c, u) {
                    for(rh(c.containerInfo), kt = u; kt !== null;)if (c = kt, u = c.child, (c.subtreeFlags & 1028) !== 0 && u !== null) u.return = c, kt = u;
                    else for(; kt !== null;){
                        c = kt;
                        var v = c.alternate;
                        switch(u = c.flags, c.tag){
                            case 0:
                                break;
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if ((u & 1024) !== 0 && v !== null) {
                                    u = void 0;
                                    var b = c, w = v.memoizedProps;
                                    v = v.memoizedState;
                                    var U = b.stateNode;
                                    try {
                                        var j = Rr(b.type, w, b.elementType === b.type);
                                        u = U.getSnapshotBeforeUpdate(j, v), U.__reactInternalSnapshotBeforeUpdate = u;
                                    } catch (ne) {
                                        An(b, b.return, ne);
                                    }
                                }
                                break;
                            case 3:
                                (u & 1024) !== 0 && Ai && Og(c.stateNode.containerInfo);
                                break;
                            case 5:
                            case 26:
                            case 27:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                if ((u & 1024) !== 0) throw Error(i(163));
                        }
                        if (u = c.sibling, u !== null) {
                            u.return = c.return, kt = u;
                            break;
                        }
                        kt = c.return;
                    }
                    return j = an, an = !1, j;
                }
                function qf(c, u, v) {
                    var b = v.flags;
                    switch(v.tag){
                        case 0:
                        case 11:
                        case 15:
                            Lr(c, v), b & 4 && vu(5, v);
                            break;
                        case 1:
                            if (Lr(c, v), b & 4) if (c = v.stateNode, u === null) try {
                                c.componentDidMount();
                            } catch (ne) {
                                An(v, v.return, ne);
                            }
                            else {
                                var w = Rr(v.type, u.memoizedProps);
                                u = u.memoizedState;
                                try {
                                    c.componentDidUpdate(w, u, c.__reactInternalSnapshotBeforeUpdate);
                                } catch (ne) {
                                    An(v, v.return, ne);
                                }
                            }
                            b & 64 && ug(v), b & 512 && Ra(v, v.return);
                            break;
                        case 3:
                            if (Lr(c, v), b & 64 && (b = v.updateQueue, b !== null)) {
                                if (c = null, v.child !== null) switch(v.child.tag){
                                    case 27:
                                    case 5:
                                        c = lc(v.child.stateNode);
                                        break;
                                    case 1:
                                        c = v.child.stateNode;
                                }
                                try {
                                    Qe(b, c);
                                } catch (ne) {
                                    An(v, v.return, ne);
                                }
                            }
                            break;
                        case 26:
                            if (Gs) {
                                Lr(c, v), b & 512 && Ra(v, v.return);
                                break;
                            }
                        case 27:
                        case 5:
                            Lr(c, v), u === null && b & 4 && Zd(v), b & 512 && Ra(v, v.return);
                            break;
                        case 12:
                            Lr(c, v);
                            break;
                        case 13:
                            Lr(c, v), b & 4 && Yf(c, v);
                            break;
                        case 22:
                            if (w = v.memoizedState !== null || cr, !w) {
                                u = u !== null && u.memoizedState !== null || ii;
                                var U = cr, j = ii;
                                cr = w, (ii = u) && !j ? Or(c, v, (v.subtreeFlags & 8772) !== 0) : Lr(c, v), cr = U, ii = j;
                            }
                            b & 512 && (v.memoizedProps.mode === "manual" ? Ra(v, v.return) : As(v, v.return));
                            break;
                        default:
                            Lr(c, v);
                    }
                }
                function $d(c) {
                    var u = c.alternate;
                    u !== null && (c.alternate = null, $d(u)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (u = c.stateNode, u !== null && e_(u)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
                }
                function Yi(c, u, v) {
                    for(v = v.child; v !== null;)mo(c, u, v), v = v.sibling;
                }
                function mo(c, u, v) {
                    if (Ds && typeof Ds.onCommitFiberUnmount == "function") try {
                        Ds.onCommitFiberUnmount(ci, v);
                    } catch  {}
                    switch(v.tag){
                        case 26:
                            if (Gs) {
                                ii || As(v, u), Yi(c, u, v), v.memoizedState ? il(v.memoizedState) : v.stateNode && dc(v.stateNode);
                                break;
                            }
                        case 27:
                            if (Bn) {
                                ii || As(v, u);
                                var b = Ct, w = Qt;
                                Ct = v.stateNode, Yi(c, u, v), Ro(v.stateNode), Ct = b, Qt = w;
                                break;
                            }
                        case 5:
                            ii || As(v, u);
                        case 6:
                            if (Ai) {
                                if (b = Ct, w = Qt, Ct = null, Yi(c, u, v), Ct = b, Qt = w, Ct !== null) if (Qt) try {
                                    Dg(Ct, v.stateNode);
                                } catch (U) {
                                    An(v, u, U);
                                }
                                else try {
                                    bp(Ct, v.stateNode);
                                } catch (U) {
                                    An(v, u, U);
                                }
                            } else Yi(c, u, v);
                            break;
                        case 18:
                            Ai && Ct !== null && (Qt ? Bu(Ct, v.stateNode) : Xg(Ct, v.stateNode));
                            break;
                        case 4:
                            Ai ? (b = Ct, w = Qt, Ct = v.stateNode.containerInfo, Qt = !0, Yi(c, u, v), Ct = b, Qt = w) : (ua && jf(v.stateNode, v, zu()), Yi(c, u, v));
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            ii || po(2, v, u), ii || po(4, v, u), Yi(c, u, v);
                            break;
                        case 1:
                            ii || (As(v, u), b = v.stateNode, typeof b.componentWillUnmount == "function" && Ts(v, u, b)), Yi(c, u, v);
                            break;
                        case 21:
                            Yi(c, u, v);
                            break;
                        case 22:
                            ii || As(v, u), ii = (b = ii) || v.memoizedState !== null, Yi(c, u, v), ii = b;
                            break;
                        default:
                            Yi(c, u, v);
                    }
                }
                function Yf(c, u) {
                    if (Ki && u.memoizedState === null && (c = u.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null)))) try {
                        a_(c);
                    } catch (v) {
                        An(u, u.return, v);
                    }
                }
                function fg(c) {
                    switch(c.tag){
                        case 13:
                        case 19:
                            var u = c.stateNode;
                            return u === null && (u = c.stateNode = new wn), u;
                        case 22:
                            return c = c.stateNode, u = c._retryCache, u === null && (u = c._retryCache = new wn), u;
                        default:
                            throw Error(i(435, c.tag));
                    }
                }
                function Ur(c, u) {
                    var v = fg(c);
                    u.forEach(function(b) {
                        var w = bo.bind(null, c, b);
                        v.has(b) || (v.add(b), b.then(w, w));
                    });
                }
                function ps(c, u) {
                    var v = u.deletions;
                    if (v !== null) for(var b = 0; b < v.length; b++){
                        var w = v[b], U = c, j = u;
                        if (Ai) {
                            var ne = j;
                            e: for(; ne !== null;){
                                switch(ne.tag){
                                    case 27:
                                    case 5:
                                        Ct = ne.stateNode, Qt = !1;
                                        break e;
                                    case 3:
                                        Ct = ne.stateNode.containerInfo, Qt = !0;
                                        break e;
                                    case 4:
                                        Ct = ne.stateNode.containerInfo, Qt = !0;
                                        break e;
                                }
                                ne = ne.return;
                            }
                            if (Ct === null) throw Error(i(160));
                            mo(U, j, w), Ct = null, Qt = !1;
                        } else mo(U, j, w);
                        U = w.alternate, U !== null && (U.return = null), w.return = null;
                    }
                    if (u.subtreeFlags & 13878) for(u = u.child; u !== null;)ep(u, c), u = u.sibling;
                }
                function ep(c, u) {
                    var v = c.alternate, b = c.flags;
                    switch(c.tag){
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            ps(u, c), ws(c), b & 4 && (po(3, c, c.return), vu(3, c), po(5, c, c.return));
                            break;
                        case 1:
                            ps(u, c), ws(c), b & 512 && (ii || v === null || As(v, v.return)), b & 64 && cr && (c = c.updateQueue, c !== null && (b = c.callbacks, b !== null && (v = c.shared.hiddenCallbacks, c.shared.hiddenCallbacks = v === null ? b : v.concat(b))));
                            break;
                        case 26:
                            if (Gs) {
                                var w = $n;
                                ps(u, c), ws(c), b & 512 && (ii || v === null || As(v, v.return)), b & 4 && (b = v !== null ? v.memoizedState : null, u = c.memoizedState, v === null ? u === null ? c.stateNode === null ? c.stateNode = Pu(w, c.type, c.memoizedProps, c) : Hu(w, c.type, c.stateNode) : c.stateNode = qg(w, u, c.memoizedProps) : b !== u ? (b === null ? v.stateNode !== null && dc(v.stateNode) : il(b), u === null ? Hu(w, c.type, c.stateNode) : qg(w, u, c.memoizedProps)) : u === null && c.stateNode !== null && Kd(c, c.memoizedProps, v.memoizedProps));
                                break;
                            }
                        case 27:
                            if (Bn && b & 4 && c.alternate === null) {
                                w = c.stateNode;
                                var U = c.memoizedProps;
                                try {
                                    wo(w), Kg(c.type, U, w, c);
                                } catch ($e) {
                                    An(c, c.return, $e);
                                }
                            }
                        case 5:
                            if (ps(u, c), ws(c), b & 512 && (ii || v === null || As(v, v.return)), Ai) {
                                if (c.flags & 32) {
                                    u = c.stateNode;
                                    try {
                                        Mp(u);
                                    } catch ($e) {
                                        An(c, c.return, $e);
                                    }
                                }
                                b & 4 && c.stateNode != null && (u = c.memoizedProps, Kd(c, u, v !== null ? v.memoizedProps : u)), b & 1024 && (zp = !0);
                            }
                            break;
                        case 6:
                            if (ps(u, c), ws(c), b & 4 && Ai) {
                                if (c.stateNode === null) throw Error(i(162));
                                b = c.memoizedProps, v = v !== null ? v.memoizedProps : b, u = c.stateNode;
                                try {
                                    Ag(u, v, b);
                                } catch ($e) {
                                    An(c, c.return, $e);
                                }
                            }
                            break;
                        case 3:
                            if (Gs ? (Yg(), w = $n, $n = gh(u.containerInfo), ps(u, c), $n = w) : ps(u, c), ws(c), b & 4) {
                                if (Ai && Ki && v !== null && v.memoizedState.isDehydrated) try {
                                    s_(u.containerInfo);
                                } catch ($e) {
                                    An(c, c.return, $e);
                                }
                                if (ua) {
                                    b = u.containerInfo, v = u.pendingChildren;
                                    try {
                                        hc(b, v);
                                    } catch ($e) {
                                        An(c, c.return, $e);
                                    }
                                }
                            }
                            zp && (zp = !1, hg(c));
                            break;
                        case 4:
                            Gs ? (v = $n, $n = gh(c.stateNode.containerInfo), ps(u, c), ws(c), $n = v) : (ps(u, c), ws(c)), b & 4 && ua && jf(c.stateNode, c, c.stateNode.pendingChildren);
                            break;
                        case 12:
                            ps(u, c), ws(c);
                            break;
                        case 13:
                            ps(u, c), ws(c), c.child.flags & 8192 && c.memoizedState !== null != (v !== null && v.memoizedState !== null) && (xs = fa()), b & 4 && (b = c.updateQueue, b !== null && (c.updateQueue = null, Ur(c, b)));
                            break;
                        case 22:
                            b & 512 && (ii || v === null || As(v, v.return)), w = c.memoizedState !== null;
                            var j = v !== null && v.memoizedState !== null, ne = cr, ye = ii;
                            if (cr = ne || w, ii = ye || j, ps(u, c), ii = ye, cr = ne, ws(c), u = c.stateNode, u._current = c, u._visibility &= -3, u._visibility |= u._pendingVisibility & 2, b & 8192 && (u._visibility = w ? u._visibility & -2 : u._visibility | 1, w && (u = cr || ii, v === null || j || u || Ql(c)), Ai && (c.memoizedProps === null || c.memoizedProps.mode !== "manual"))) {
                                e: if (v = null, Ai) for(u = c;;){
                                    if (u.tag === 5 || Gs && u.tag === 26 || Bn && u.tag === 27) {
                                        if (v === null) {
                                            j = v = u;
                                            try {
                                                U = j.stateNode, w ? Ng(U) : Lg(j.stateNode, j.memoizedProps);
                                            } catch ($e) {
                                                An(j, j.return, $e);
                                            }
                                        }
                                    } else if (u.tag === 6) {
                                        if (v === null) {
                                            j = u;
                                            try {
                                                var Oe = j.stateNode;
                                                w ? Ug(Oe) : n_(Oe, j.memoizedProps);
                                            } catch ($e) {
                                                An(j, j.return, $e);
                                            }
                                        }
                                    } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === c) && u.child !== null) {
                                        u.child.return = u, u = u.child;
                                        continue;
                                    }
                                    if (u === c) break e;
                                    for(; u.sibling === null;){
                                        if (u.return === null || u.return === c) break e;
                                        v === u && (v = null), u = u.return;
                                    }
                                    v === u && (v = null), u.sibling.return = u.return, u = u.sibling;
                                }
                            }
                            b & 4 && (b = c.updateQueue, b !== null && (v = b.retryQueue, v !== null && (b.retryQueue = null, Ur(c, v))));
                            break;
                        case 19:
                            ps(u, c), ws(c), b & 4 && (b = c.updateQueue, b !== null && (c.updateQueue = null, Ur(c, b)));
                            break;
                        case 21:
                            break;
                        default:
                            ps(u, c), ws(c);
                    }
                }
                function ws(c) {
                    var u = c.flags;
                    if (u & 2) {
                        try {
                            if (Ai && (!Bn || c.tag !== 27)) {
                                e: {
                                    for(var v = c.return; v !== null;){
                                        if (Qd(v)) {
                                            var b = v;
                                            break e;
                                        }
                                        v = v.return;
                                    }
                                    throw Error(i(160));
                                }
                                switch(b.tag){
                                    case 27:
                                        if (Bn) {
                                            var w = b.stateNode, U = yu(c);
                                            Nr(c, U, w);
                                            break;
                                        }
                                    case 5:
                                        var j = b.stateNode;
                                        b.flags & 32 && (Mp(j), b.flags &= -33);
                                        var ne = yu(c);
                                        Nr(c, ne, j);
                                        break;
                                    case 3:
                                    case 4:
                                        var ye = b.stateNode.containerInfo, Oe = yu(c);
                                        Jd(c, Oe, ye);
                                        break;
                                    default:
                                        throw Error(i(161));
                                }
                            }
                        } catch ($e) {
                            An(c, c.return, $e);
                        }
                        c.flags &= -3;
                    }
                    u & 4096 && (c.flags &= -4097);
                }
                function hg(c) {
                    if (c.subtreeFlags & 1024) for(c = c.child; c !== null;){
                        var u = c;
                        hg(u), u.tag === 5 && u.flags & 1024 && ch(u.stateNode), c = c.sibling;
                    }
                }
                function Lr(c, u) {
                    if (u.subtreeFlags & 8772) for(u = u.child; u !== null;)qf(c, u.alternate, u), u = u.sibling;
                }
                function Ql(c) {
                    for(c = c.child; c !== null;){
                        var u = c;
                        switch(u.tag){
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                po(4, u, u.return), Ql(u);
                                break;
                            case 1:
                                As(u, u.return);
                                var v = u.stateNode;
                                typeof v.componentWillUnmount == "function" && Ts(u, u.return, v), Ql(u);
                                break;
                            case 26:
                            case 27:
                            case 5:
                                As(u, u.return), Ql(u);
                                break;
                            case 22:
                                As(u, u.return), u.memoizedState === null && Ql(u);
                                break;
                            default:
                                Ql(u);
                        }
                        c = c.sibling;
                    }
                }
                function Or(c, u, v) {
                    for(v = v && (u.subtreeFlags & 8772) !== 0, u = u.child; u !== null;){
                        var b = u.alternate, w = c, U = u, j = U.flags;
                        switch(U.tag){
                            case 0:
                            case 11:
                            case 15:
                                Or(w, U, v), vu(4, U);
                                break;
                            case 1:
                                if (Or(w, U, v), b = U, w = b.stateNode, typeof w.componentDidMount == "function") try {
                                    w.componentDidMount();
                                } catch (Oe) {
                                    An(b, b.return, Oe);
                                }
                                if (b = U, w = b.updateQueue, w !== null) {
                                    var ne = b.stateNode;
                                    try {
                                        var ye = w.shared.hiddenCallbacks;
                                        if (ye !== null) for(w.shared.hiddenCallbacks = null, w = 0; w < ye.length; w++)te(ye[w], ne);
                                    } catch (Oe) {
                                        An(b, b.return, Oe);
                                    }
                                }
                                v && j & 64 && ug(U), Ra(U, U.return);
                                break;
                            case 26:
                            case 27:
                            case 5:
                                Or(w, U, v), v && b === null && j & 4 && Zd(U), Ra(U, U.return);
                                break;
                            case 12:
                                Or(w, U, v);
                                break;
                            case 13:
                                Or(w, U, v), v && j & 4 && Yf(w, U);
                                break;
                            case 22:
                                U.memoizedState === null && Or(w, U, v), Ra(U, U.return);
                                break;
                            default:
                                Or(w, U, v);
                        }
                        u = u.sibling;
                    }
                }
                function Wf(c, u) {
                    var v = null;
                    c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (v = c.memoizedState.cachePool.pool), c = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (c = u.memoizedState.cachePool.pool), c !== v && (c != null && c.refCount++, v != null && mu(v));
                }
                function xu(c, u) {
                    c = null, u.alternate !== null && (c = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== c && (u.refCount++, c != null && mu(c));
                }
                function Bi(c, u, v, b) {
                    if (u.subtreeFlags & 10256) for(u = u.child; u !== null;)tp(c, u, v, b), u = u.sibling;
                }
                function tp(c, u, v, b) {
                    var w = u.flags;
                    switch(u.tag){
                        case 0:
                        case 11:
                        case 15:
                            Bi(c, u, v, b), w & 2048 && vu(9, u);
                            break;
                        case 3:
                            Bi(c, u, v, b), w & 2048 && (c = null, u.alternate !== null && (c = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== c && (u.refCount++, c != null && mu(c)));
                            break;
                        case 12:
                            if (w & 2048) {
                                Bi(c, u, v, b), c = u.stateNode;
                                try {
                                    var U = u.memoizedProps, j = U.id, ne = U.onPostCommit;
                                    typeof ne == "function" && ne(j, u.alternate === null ? "mount" : "update", c.passiveEffectDuration, -0);
                                } catch (ye) {
                                    An(u, u.return, ye);
                                }
                            } else Bi(c, u, v, b);
                            break;
                        case 23:
                            break;
                        case 22:
                            U = u.stateNode, u.memoizedState !== null ? U._visibility & 4 ? Bi(c, u, v, b) : is(c, u) : U._visibility & 4 ? Bi(c, u, v, b) : (U._visibility |= 4, Wi(c, u, v, b, (u.subtreeFlags & 10256) !== 0)), w & 2048 && Wf(u.alternate, u);
                            break;
                        case 24:
                            Bi(c, u, v, b), w & 2048 && xu(u.alternate, u);
                            break;
                        default:
                            Bi(c, u, v, b);
                    }
                }
                function Wi(c, u, v, b, w) {
                    for(w = w && (u.subtreeFlags & 10256) !== 0, u = u.child; u !== null;){
                        var U = c, j = u, ne = v, ye = b, Oe = j.flags;
                        switch(j.tag){
                            case 0:
                            case 11:
                            case 15:
                                Wi(U, j, ne, ye, w), vu(8, j);
                                break;
                            case 23:
                                break;
                            case 22:
                                var $e = j.stateNode;
                                j.memoizedState !== null ? $e._visibility & 4 ? Wi(U, j, ne, ye, w) : is(U, j) : ($e._visibility |= 4, Wi(U, j, ne, ye, w)), w && Oe & 2048 && Wf(j.alternate, j);
                                break;
                            case 24:
                                Wi(U, j, ne, ye, w), w && Oe & 2048 && xu(j.alternate, j);
                                break;
                            default:
                                Wi(U, j, ne, ye, w);
                        }
                        u = u.sibling;
                    }
                }
                function is(c, u) {
                    if (u.subtreeFlags & 10256) for(u = u.child; u !== null;){
                        var v = c, b = u, w = b.flags;
                        switch(b.tag){
                            case 22:
                                is(v, b), w & 2048 && Wf(b.alternate, b);
                                break;
                            case 24:
                                is(v, b), w & 2048 && xu(b.alternate, b);
                                break;
                            default:
                                is(v, b);
                        }
                        u = u.sibling;
                    }
                }
                function aa(c) {
                    if (c.subtreeFlags & Ws) for(c = c.child; c !== null;)Zf(c), c = c.sibling;
                }
                function Zf(c) {
                    switch(c.tag){
                        case 26:
                            aa(c), c.flags & Ws && (c.memoizedState !== null ? Zg($n, c.memoizedState, c.memoizedProps) : vs(c.type, c.memoizedProps));
                            break;
                        case 5:
                            aa(c), c.flags & Ws && vs(c.type, c.memoizedProps);
                            break;
                        case 3:
                        case 4:
                            if (Gs) {
                                var u = $n;
                                $n = gh(c.stateNode.containerInfo), aa(c), $n = u;
                            } else aa(c);
                            break;
                        case 22:
                            c.memoizedState === null && (u = c.alternate, u !== null && u.memoizedState !== null ? (u = Ws, Ws = 16777216, aa(c), Ws = u) : aa(c));
                            break;
                        default:
                            aa(c);
                    }
                }
                function Su(c) {
                    var u = c.alternate;
                    if (u !== null && (c = u.child, c !== null)) {
                        u.child = null;
                        do u = c.sibling, c.sibling = null, c = u;
                        while (c !== null);
                    }
                }
                function go(c) {
                    var u = c.deletions;
                    if ((c.flags & 16) !== 0) {
                        if (u !== null) for(var v = 0; v < u.length; v++){
                            var b = u[v];
                            kt = b, np(b, c);
                        }
                        Su(c);
                    }
                    if (c.subtreeFlags & 10256) for(c = c.child; c !== null;)Kf(c), c = c.sibling;
                }
                function Kf(c) {
                    switch(c.tag){
                        case 0:
                        case 11:
                        case 15:
                            go(c), c.flags & 2048 && po(9, c, c.return);
                            break;
                        case 3:
                            go(c);
                            break;
                        case 12:
                            go(c);
                            break;
                        case 22:
                            var u = c.stateNode;
                            c.memoizedState !== null && u._visibility & 4 && (c.return === null || c.return.tag !== 13) ? (u._visibility &= -5, zr(c)) : go(c);
                            break;
                        default:
                            go(c);
                    }
                }
                function zr(c) {
                    var u = c.deletions;
                    if ((c.flags & 16) !== 0) {
                        if (u !== null) for(var v = 0; v < u.length; v++){
                            var b = u[v];
                            kt = b, np(b, c);
                        }
                        Su(c);
                    }
                    for(c = c.child; c !== null;){
                        switch(u = c, u.tag){
                            case 0:
                            case 11:
                            case 15:
                                po(8, u, u.return), zr(u);
                                break;
                            case 22:
                                v = u.stateNode, v._visibility & 4 && (v._visibility &= -5, zr(u));
                                break;
                            default:
                                zr(u);
                        }
                        c = c.sibling;
                    }
                }
                function np(c, u) {
                    for(; kt !== null;){
                        var v = kt;
                        switch(v.tag){
                            case 0:
                            case 11:
                            case 15:
                                po(8, v, u);
                                break;
                            case 23:
                            case 22:
                                if (v.memoizedState !== null && v.memoizedState.cachePool !== null) {
                                    var b = v.memoizedState.cachePool.pool;
                                    b != null && b.refCount++;
                                }
                                break;
                            case 24:
                                mu(v.memoizedState.cache);
                        }
                        if (b = v.child, b !== null) b.return = v, kt = b;
                        else e: for(v = c; kt !== null;){
                            b = kt;
                            var w = b.sibling, U = b.return;
                            if ($d(b), b === v) {
                                kt = null;
                                break e;
                            }
                            if (w !== null) {
                                w.return = U, kt = w;
                                break e;
                            }
                            kt = U;
                        }
                    }
                }
                function Jl(c) {
                    var u = yg(c);
                    if (u != null) {
                        if (typeof u.memoizedProps["data-testname"] != "string") throw Error(i(364));
                        return u;
                    }
                    if (c = _p(c), c === null) throw Error(i(362));
                    return c.stateNode.current;
                }
                function vo(c, u) {
                    var v = c.tag;
                    switch(u.$$typeof){
                        case bc:
                            if (c.type === u.value) return !0;
                            break;
                        case ma:
                            e: {
                                for(u = u.value, c = [
                                    c,
                                    0
                                ], v = 0; v < c.length;){
                                    var b = c[v++], w = b.tag, U = c[v++], j = u[U];
                                    if (w !== 5 && w !== 26 && w !== 27 || !uc(b)) {
                                        for(; j != null && vo(b, j);)U++, j = u[U];
                                        if (U === u.length) {
                                            u = !0;
                                            break e;
                                        } else for(b = b.child; b !== null;)c.push(b, U), b = b.sibling;
                                    }
                                }
                                u = !1;
                            }
                            return u;
                        case Yn:
                            if ((v === 5 || v === 26 || v === 27) && bg(c.stateNode, u.value)) return !0;
                            break;
                        case ur:
                            if ((v === 5 || v === 6 || v === 26 || v === 27) && (c = Sg(c), c !== null && 0 <= c.indexOf(u.value))) return !0;
                            break;
                        case Pa:
                            if ((v === 5 || v === 26 || v === 27) && (c = c.memoizedProps["data-testname"], typeof c == "string" && c.toLowerCase() === u.value.toLowerCase())) return !0;
                            break;
                        default:
                            throw Error(i(365));
                    }
                    return !1;
                }
                function ip(c) {
                    switch(c.$$typeof){
                        case bc:
                            return "<" + (l(c.value) || "Unknown") + ">";
                        case ma:
                            return ":has(" + (ip(c) || "") + ")";
                        case Yn:
                            return '[role="' + c.value + '"]';
                        case ur:
                            return '"' + c.value + '"';
                        case Pa:
                            return '[data-testname="' + c.value + '"]';
                        default:
                            throw Error(i(365));
                    }
                }
                function Rs(c, u) {
                    var v = [];
                    c = [
                        c,
                        0
                    ];
                    for(var b = 0; b < c.length;){
                        var w = c[b++], U = w.tag, j = c[b++], ne = u[j];
                        if (U !== 5 && U !== 26 && U !== 27 || !uc(w)) {
                            for(; ne != null && vo(w, ne);)j++, ne = u[j];
                            if (j === u.length) v.push(w);
                            else for(w = w.child; w !== null;)c.push(w, j), w = w.sibling;
                        }
                    }
                    return v;
                }
                function bu(c, u) {
                    if (!Ao) throw Error(i(363));
                    c = Jl(c), c = Rs(c, u), u = [], c = Array.from(c);
                    for(var v = 0; v < c.length;){
                        var b = c[v++], w = b.tag;
                        if (w === 5 || w === 26 || w === 27) uc(b) || u.push(b.stateNode);
                        else for(b = b.child; b !== null;)c.push(b), b = b.sibling;
                    }
                    return u;
                }
                function ri() {
                    if ((xn & 2) !== 0 && cn !== 0) return cn & -cn;
                    if (Ht.T !== null) {
                        var c = Xs;
                        return c !== 0 ? c : Le();
                    }
                    return _g();
                }
                function sp() {
                    Qs === 0 && (Qs = (cn & 536870912) === 0 || yn ? F() : 536870912);
                    var c = js.current;
                    return c !== null && (c.flags |= 32), Qs;
                }
                function Ii(c, u, v) {
                    (c === Rn && On === 2 || c.cancelPendingCommit !== null) && (Zi(c, 0), Cs(c, cn, Qs, !1)), q(c, v), ((xn & 2) === 0 || c !== Rn) && (c === Rn && ((xn & 2) === 0 && (Zr |= v), Hn === 4 && Cs(c, cn, Qs, !1)), Xe(c));
                }
                function yo(c, u, v) {
                    if ((xn & 6) !== 0) throw Error(i(327));
                    var b = !v && (u & 60) === 0 && (u & c.expiredLanes) === 0 || O(c, u), w = b ? rp(c, u) : Jf(c, u, !0), U = b;
                    do {
                        if (w === 0) {
                            Zs && !b && Cs(c, u, 0, !1);
                            break;
                        } else if (w === 6) Cs(c, u, 0, !va);
                        else {
                            if (v = c.current.alternate, U && !$l(v)) {
                                w = Jf(c, u, !1), U = !1;
                                continue;
                            }
                            if (w === 2) {
                                if (U = u, c.errorRecoveryDisabledLanes & U) var j = 0;
                                else j = c.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
                                if (j !== 0) {
                                    u = j;
                                    e: {
                                        var ne = c;
                                        w = yl;
                                        var ye = Ki && ne.current.memoizedState.isDehydrated;
                                        if (ye && (Zi(ne, j).flags |= 256), j = Jf(ne, j, !1), j !== 2) {
                                            if (Ci && !ye) {
                                                ne.errorRecoveryDisabledLanes |= U, Zr |= U, w = 4;
                                                break e;
                                            }
                                            U = si, si = w, U !== null && Mu(U);
                                        }
                                        w = j;
                                    }
                                    if (U = !1, w !== 2) continue;
                                }
                            }
                            if (w === 1) {
                                Zi(c, 0), Cs(c, u, 0, !0);
                                break;
                            }
                            e: {
                                switch(b = c, w){
                                    case 0:
                                    case 1:
                                        throw Error(i(345));
                                    case 4:
                                        if ((u & 4194176) === u) {
                                            Cs(b, u, Qs, !va);
                                            break e;
                                        }
                                        break;
                                    case 2:
                                        si = null;
                                        break;
                                    case 3:
                                    case 5:
                                        break;
                                    default:
                                        throw Error(i(329));
                                }
                                if (b.finishedWork = v, b.finishedLanes = u, (u & 62914560) === u && (U = xs + 300 - fa(), 10 < U)) {
                                    if (Cs(b, u, Qs, !va), I(b, 0) !== 0) break e;
                                    b.timeoutHandle = Si(Qf.bind(null, b, v, si, qu, wh, u, Qs, Zr, fr, va, 2, -0, 0), U);
                                    break e;
                                }
                                Qf(b, v, si, qu, wh, u, Qs, Zr, fr, va, 0, -0, 0);
                            }
                        }
                        break;
                    }while (!0);
                    Xe(c);
                }
                function Mu(c) {
                    si === null ? si = c : si.push.apply(si, c);
                }
                function Qf(c, u, v, b, w, U, j, ne, ye, Oe, $e, ft, gt) {
                    var Xt = u.subtreeFlags;
                    if ((Xt & 8192 || (Xt & 16785408) === 16785408) && (vp(), Zf(u), u = bi(), u !== null)) {
                        c.cancelPendingCommit = u(xo.bind(null, c, v, b, w, j, ne, ye, 1, ft, gt)), Cs(c, U, j, !Oe);
                        return;
                    }
                    xo(c, v, b, w, j, ne, ye, $e, ft, gt);
                }
                function $l(c) {
                    for(var u = c;;){
                        var v = u.tag;
                        if ((v === 0 || v === 11 || v === 15) && u.flags & 16384 && (v = u.updateQueue, v !== null && (v = v.stores, v !== null))) for(var b = 0; b < v.length; b++){
                            var w = v[b], U = w.getSnapshot;
                            w = w.value;
                            try {
                                if (!Ns(U(), w)) return !1;
                            } catch  {
                                return !1;
                            }
                        }
                        if (v = u.child, u.subtreeFlags & 16384 && v !== null) v.return = u, u = v;
                        else {
                            if (u === c) break;
                            for(; u.sibling === null;){
                                if (u.return === null || u.return === c) return !0;
                                u = u.return;
                            }
                            u.sibling.return = u.return, u = u.sibling;
                        }
                    }
                    return !0;
                }
                function Cs(c, u, v, b) {
                    u &= ~ju, u &= ~Zr, c.suspendedLanes |= u, c.pingedLanes &= ~u, b && (c.warmLanes |= u), b = c.expirationTimes;
                    for(var w = u; 0 < w;){
                        var U = 31 - ys(w), j = 1 << U;
                        b[U] = -1, w &= ~j;
                    }
                    v !== 0 && se(c, v, u);
                }
                function Eu() {
                    return (xn & 6) === 0 ? (ot(0), !1) : !0;
                }
                function ec() {
                    if (Ot !== null) {
                        if (On === 0) var c = Ot.return;
                        else c = Ot, Ys = Ia = null, wa(c), Uo = null, Lo = 0, c = Ot;
                        for(; c !== null;)cg(c.alternate, c), c = c.return;
                        Ot = null;
                    }
                }
                function Zi(c, u) {
                    c.finishedWork = null, c.finishedLanes = 0;
                    var v = c.timeoutHandle;
                    v !== Eo && (c.timeoutHandle = Eo, oh(v)), v = c.cancelPendingCommit, v !== null && (c.cancelPendingCommit = null, v()), ec(), Rn = c, Ot = v = oa(c.current, null), cn = u, On = 0, as = null, va = !1, Zs = O(c, u), Ci = !1, fr = Qs = ju = Zr = Ks = Hn = 0, si = yl = null, wh = !1, (u & 8) !== 0 && (u |= u & 32);
                    var b = c.entangledLanes;
                    if (b !== 0) for(c = c.entanglements, b &= u; 0 < b;){
                        var w = 31 - ys(b), U = 1 << w;
                        u |= c[w], b &= ~U;
                    }
                    return rs = u, W(), v;
                }
                function Ps(c, u) {
                    $t = null, Ht.H = ni, u === yc ? (u = ct(), On = 3) : u === ku ? (u = ct(), On = 4) : On = u === Th ? 8 : u !== null && typeof u == "object" && typeof u.then == "function" ? 6 : 1, as = u, Ot === null && (Hn = 1, jl(c, fe(u, c.current)));
                }
                function _o() {
                    var c = js.current;
                    return c === null ? !0 : (cn & 4194176) === cn ? In === null : (cn & 62914560) === cn || (cn & 536870912) !== 0 ? c === In : !1;
                }
                function Ja() {
                    var c = Ht.H;
                    return Ht.H = ni, c === null ? ni : c;
                }
                function $a() {
                    var c = Ht.A;
                    return Ht.A = Sc, c;
                }
                function Br() {
                    Hn = 4, va || (cn & 4194176) !== cn && js.current !== null || (Zs = !0), (Ks & 134217727) === 0 && (Zr & 134217727) === 0 || Rn === null || Cs(Rn, cn, Qs, !1);
                }
                function Jf(c, u, v) {
                    var b = xn;
                    xn |= 2;
                    var w = Ja(), U = $a();
                    (Rn !== c || cn !== u) && (qu = null, Zi(c, u)), u = !1;
                    var j = Hn;
                    e: do try {
                        if (On !== 0 && Ot !== null) {
                            var ne = Ot, ye = as;
                            switch(On){
                                case 8:
                                    ec(), j = 6;
                                    break e;
                                case 3:
                                case 2:
                                case 6:
                                    js.current === null && (u = !0);
                                    var Oe = On;
                                    if (On = 0, as = null, ra(c, ne, ye, Oe), v && Zs) {
                                        j = 0;
                                        break e;
                                    }
                                    break;
                                default:
                                    Oe = On, On = 0, as = null, ra(c, ne, ye, Oe);
                            }
                        }
                        ap(), j = Hn;
                        break;
                    } catch ($e) {
                        Ps(c, $e);
                    }
                    while (!0);
                    return u && c.shellSuspendCounter++, Ys = Ia = null, xn = b, Ht.H = w, Ht.A = U, Ot === null && (Rn = null, cn = 0, W()), j;
                }
                function ap() {
                    for(; Ot !== null;)Jn(Ot);
                }
                function rp(c, u) {
                    var v = xn;
                    xn |= 2;
                    var b = Ja(), w = $a();
                    Rn !== c || cn !== u ? (qu = null, Mc = fa() + 500, Zi(c, u)) : Zs = O(c, u);
                    e: do try {
                        if (On !== 0 && Ot !== null) {
                            u = Ot;
                            var U = as;
                            t: switch(On){
                                case 1:
                                    On = 0, as = null, ra(c, u, U, 1);
                                    break;
                                case 2:
                                    if (rt(U)) {
                                        On = 0, as = null, bn(u);
                                        break;
                                    }
                                    u = function() {
                                        On === 2 && Rn === c && (On = 7), Xe(c);
                                    }, U.then(u, u);
                                    break e;
                                case 3:
                                    On = 7;
                                    break e;
                                case 4:
                                    On = 5;
                                    break e;
                                case 7:
                                    rt(U) ? (On = 0, as = null, bn(u)) : (On = 0, as = null, ra(c, u, U, 7));
                                    break;
                                case 5:
                                    var j = null;
                                    switch(Ot.tag){
                                        case 26:
                                            j = Ot.memoizedState;
                                        case 5:
                                        case 27:
                                            var ne = Ot, ye = ne.type, Oe = ne.pendingProps;
                                            if (j ? sl(j) : lh(ye, Oe)) {
                                                On = 0, as = null;
                                                var $e = ne.sibling;
                                                if ($e !== null) Ot = $e;
                                                else {
                                                    var ft = ne.return;
                                                    ft !== null ? (Ot = ft, Hs(ft)) : Ot = null;
                                                }
                                                break t;
                                            }
                                    }
                                    On = 0, as = null, ra(c, u, U, 5);
                                    break;
                                case 6:
                                    On = 0, as = null, ra(c, u, U, 6);
                                    break;
                                case 8:
                                    ec(), Hn = 6;
                                    break e;
                                default:
                                    throw Error(i(462));
                            }
                        }
                        ms();
                        break;
                    } catch (gt) {
                        Ps(c, gt);
                    }
                    while (!0);
                    return Ys = Ia = null, Ht.H = b, Ht.A = w, xn = v, Ot !== null ? 0 : (Rn = null, cn = 0, W(), Hn);
                }
                function ms() {
                    for(; Ot !== null && !$g();)Jn(Ot);
                }
                function Jn(c) {
                    var u = rg(c.alternate, c, rs);
                    c.memoizedProps = c.pendingProps, u === null ? Hs(c) : Ot = u;
                }
                function bn(c) {
                    var u = c, v = u.alternate;
                    switch(u.tag){
                        case 15:
                        case 0:
                            u = eg(v, u, u.pendingProps, u.type, void 0, cn);
                            break;
                        case 11:
                            u = eg(v, u, u.pendingProps, u.type.render, u.ref, cn);
                            break;
                        case 5:
                            wa(u);
                        default:
                            cg(v, u), u = Ot = Au(u, rs), u = rg(v, u, rs);
                    }
                    c.memoizedProps = c.pendingProps, u === null ? Hs(c) : Ot = u;
                }
                function ra(c, u, v, b) {
                    Ys = Ia = null, wa(u), Uo = null, Lo = 0;
                    var w = u.return;
                    try {
                        if (Zy(c, w, u, v, cn)) {
                            Hn = 1, jl(c, fe(v, c.current)), Ot = null;
                            return;
                        }
                    } catch (U) {
                        if (w !== null) throw Ot = w, U;
                        Hn = 1, jl(c, fe(v, c.current)), Ot = null;
                        return;
                    }
                    u.flags & 32768 ? (yn || b === 1 ? c = !0 : Zs || (cn & 536870912) !== 0 ? c = !1 : (va = c = !0, (b === 2 || b === 3 || b === 6) && (b = js.current, b !== null && b.tag === 13 && (b.flags |= 16384))), $f(u, c)) : Hs(u);
                }
                function Hs(c) {
                    var u = c;
                    do {
                        if ((u.flags & 32768) !== 0) {
                            $f(u, va);
                            return;
                        }
                        c = u.return;
                        var v = lg(u.alternate, u, rs);
                        if (v !== null) {
                            Ot = v;
                            return;
                        }
                        if (u = u.sibling, u !== null) {
                            Ot = u;
                            return;
                        }
                        Ot = u = c;
                    }while (u !== null);
                    Hn === 0 && (Hn = 5);
                }
                function $f(c, u) {
                    do {
                        var v = Qy(c.alternate, c);
                        if (v !== null) {
                            v.flags &= 32767, Ot = v;
                            return;
                        }
                        if (v = c.return, v !== null && (v.flags |= 32768, v.subtreeFlags = 0, v.deletions = null), !u && (c = c.sibling, c !== null)) {
                            Ot = c;
                            return;
                        }
                        Ot = c = v;
                    }while (c !== null);
                    Hn = 6, Ot = null;
                }
                function xo(c, u, v, b, w, U, j, ne, ye, Oe) {
                    var $e = Ht.T, ft = Vr();
                    try {
                        ss(2), Ht.T = null, dg(c, u, v, b, ft, w, U, j, ne, ye, Oe);
                    } finally{
                        Ht.T = $e, ss(ft);
                    }
                }
                function dg(c, u, v, b, w, U, j, ne) {
                    do Ca();
                    while (hr !== null);
                    if ((xn & 6) !== 0) throw Error(i(327));
                    var ye = c.finishedWork;
                    if (b = c.finishedLanes, ye === null) return null;
                    if (c.finishedWork = null, c.finishedLanes = 0, ye === c.current) throw Error(i(177));
                    c.callbackNode = null, c.callbackPriority = 0, c.cancelPendingCommit = null;
                    var Oe = ye.lanes | ye.childLanes;
                    if (Oe |= za, oe(c, b, Oe, U, j, ne), c === Rn && (Ot = Rn = null, cn = 0), (ye.subtreeFlags & 10256) === 0 && (ye.flags & 10256) === 0 || Ha || (Ha = !0, Po = Oe, Rh = v, Pr(Sh, function() {
                        return Ca(), null;
                    })), v = (ye.flags & 15990) !== 0, (ye.subtreeFlags & 15990) !== 0 || v ? (v = Ht.T, Ht.T = null, U = Vr(), ss(2), j = xn, xn |= 4, _u(c, ye), ep(ye, c), vg(c.containerInfo), c.current = ye, qf(c, ye.alternate, ye), _h(), xn = j, ss(U), Ht.T = v) : c.current = ye, Ha ? (Ha = !1, hr = c, _l = b) : op(c, Oe), Oe = c.pendingLanes, Oe === 0 && (Io = null), H(ye.stateNode), Xe(c), u !== null) for(w = c.onRecoverableError, ye = 0; ye < u.length; ye++)Oe = u[ye], w(Oe.value, {
                        componentStack: Oe.stack
                    });
                    return (_l & 3) !== 0 && Ca(), Oe = c.pendingLanes, (b & 4194218) !== 0 && (Oe & 42) !== 0 ? c === Ch ? Ec++ : (Ec = 0, Ch = c) : Ec = 0, ot(0), null;
                }
                function op(c, u) {
                    (c.pooledCacheLanes &= u) === 0 && (u = c.pooledCache, u != null && (c.pooledCache = null, mu(u)));
                }
                function Ca() {
                    if (hr !== null) {
                        var c = hr, u = Po;
                        Po = 0;
                        var v = _e(_l), b = 32 > v ? 32 : v;
                        v = Ht.T;
                        var w = Vr();
                        try {
                            if (ss(b), Ht.T = null, hr === null) var U = !1;
                            else {
                                b = Rh, Rh = null;
                                var j = hr, ne = _l;
                                if (hr = null, _l = 0, (xn & 6) !== 0) throw Error(i(331));
                                var ye = xn;
                                if (xn |= 4, Kf(j.current), tp(j, j.current, ne, b), xn = ye, ot(0, !1), Ds && typeof Ds.onPostCommitFiberRoot == "function") try {
                                    Ds.onPostCommitFiberRoot(ci, j);
                                } catch  {}
                                U = !0;
                            }
                            return U;
                        } finally{
                            ss(w), Ht.T = v, op(c, u);
                        }
                    }
                    return !1;
                }
                function tc(c, u, v) {
                    u = fe(v, u), u = Yl(c.stateNode, u, 2), c = st(c, u, 2), c !== null && (q(c, 2), Xe(c));
                }
                function An(c, u, v) {
                    if (c.tag === 3) tc(c, c, v);
                    else for(; u !== null;){
                        if (u.tag === 3) {
                            tc(u, c, v);
                            break;
                        } else if (u.tag === 1) {
                            var b = u.stateNode;
                            if (typeof u.type.getDerivedStateFromError == "function" || typeof b.componentDidCatch == "function" && (Io === null || !Io.has(b))) {
                                c = fe(v, c), v = Fd(2), b = st(u, v, 2), b !== null && (Zm(v, b, u, c), q(b, 2), Xe(b));
                                break;
                            }
                        }
                        u = u.return;
                    }
                }
                function tl(c, u, v) {
                    var b = c.pingCache;
                    if (b === null) {
                        b = c.pingCache = new ga;
                        var w = new Set;
                        b.set(u, w);
                    } else w = b.get(u), w === void 0 && (w = new Set, b.set(u, w));
                    w.has(v) || (Ci = !0, w.add(v), c = lp.bind(null, c, u, v), u.then(c, c));
                }
                function lp(c, u, v) {
                    var b = c.pingCache;
                    b !== null && b.delete(u), c.pingedLanes |= c.suspendedLanes & v, c.warmLanes &= ~v, Rn === c && (cn & v) === v && (Hn === 4 || Hn === 3 && (cn & 62914560) === cn && 300 > fa() - xs ? (xn & 2) === 0 && Zi(c, 0) : ju |= v, fr === cn && (fr = 0)), Xe(c);
                }
                function So(c, u) {
                    u === 0 && (u = z()), c = We(c, u), c !== null && (q(c, u), Xe(c));
                }
                function Ir(c) {
                    var u = c.memoizedState, v = 0;
                    u !== null && (v = u.retryLane), So(c, v);
                }
                function bo(c, u) {
                    var v = 0;
                    switch(c.tag){
                        case 13:
                            var b = c.stateNode, w = c.memoizedState;
                            w !== null && (v = w.retryLane);
                            break;
                        case 19:
                            b = c.stateNode;
                            break;
                        case 22:
                            b = c.stateNode._retryCache;
                            break;
                        default:
                            throw Error(i(314));
                    }
                    b !== null && b.delete(u), So(c, v);
                }
                function Pr(c, u) {
                    return Fu(c, u);
                }
                function cp(c, u, v, b) {
                    this.tag = c, this.key = v, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = b, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
                }
                function Tu(c) {
                    return c = c.prototype, !(!c || !c.isReactComponent);
                }
                function oa(c, u) {
                    var v = c.alternate;
                    return v === null ? (v = t(c.tag, u, c.key, c.mode), v.elementType = c.elementType, v.type = c.type, v.stateNode = c.stateNode, v.alternate = c, c.alternate = v) : (v.pendingProps = u, v.type = c.type, v.flags = 0, v.subtreeFlags = 0, v.deletions = null), v.flags = c.flags & 31457280, v.childLanes = c.childLanes, v.lanes = c.lanes, v.child = c.child, v.memoizedProps = c.memoizedProps, v.memoizedState = c.memoizedState, v.updateQueue = c.updateQueue, u = c.dependencies, v.dependencies = u === null ? null : {
                        lanes: u.lanes,
                        firstContext: u.firstContext
                    }, v.sibling = c.sibling, v.index = c.index, v.ref = c.ref, v.refCleanup = c.refCleanup, v;
                }
                function Au(c, u) {
                    c.flags &= 31457282;
                    var v = c.alternate;
                    return v === null ? (c.childLanes = 0, c.lanes = u, c.child = null, c.subtreeFlags = 0, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null) : (c.childLanes = v.childLanes, c.lanes = v.lanes, c.child = v.child, c.subtreeFlags = 0, c.deletions = null, c.memoizedProps = v.memoizedProps, c.memoizedState = v.memoizedState, c.updateQueue = v.updateQueue, c.type = v.type, u = v.dependencies, c.dependencies = u === null ? null : {
                        lanes: u.lanes,
                        firstContext: u.firstContext
                    }), c;
                }
                function er(c, u, v, b, w, U) {
                    var j = 0;
                    if (b = c, typeof c == "function") Tu(c) && (j = 1);
                    else if (typeof c == "string") j = Gs && Bn ? Iu(c, v, wi.current) ? 26 : nr(c) ? 27 : 5 : Gs ? Iu(c, v, wi.current) ? 26 : 5 : Bn && nr(c) ? 27 : 5;
                    else e: switch(c){
                        case Mo:
                            return ti(v.children, w, U, u);
                        case Du:
                            j = 8, w |= 24;
                            break;
                        case ih:
                            return c = t(12, v, u, w | 2), c.elementType = ih, c.lanes = U, c;
                        case sh:
                            return c = t(13, v, u, w), c.elementType = sh, c.lanes = U, c;
                        case ac:
                            return c = t(19, v, u, w), c.elementType = ac, c.lanes = U, c;
                        case hp:
                            return wu(v, w, U, u);
                        default:
                            if (typeof c == "object" && c !== null) switch(c.$$typeof){
                                case Nu:
                                case Da:
                                    j = 10;
                                    break e;
                                case fp:
                                    j = 9;
                                    break e;
                                case Uu:
                                    j = 11;
                                    break e;
                                case ah:
                                    j = 14;
                                    break e;
                                case ca:
                                    j = 16, b = null;
                                    break e;
                            }
                            j = 29, v = Error(i(130, c === null ? "null" : typeof c, "")), b = null;
                    }
                    return u = t(j, v, u, w), u.elementType = c, u.type = b, u.lanes = U, u;
                }
                function ti(c, u, v, b) {
                    return c = t(7, c, b, u), c.lanes = v, c;
                }
                function wu(c, u, v, b) {
                    c = t(22, c, b, u), c.elementType = hp, c.lanes = v;
                    var w = {
                        _visibility: 1,
                        _pendingVisibility: 1,
                        _pendingMarkers: null,
                        _retryCache: null,
                        _transitions: null,
                        _current: null,
                        detach: function() {
                            var U = w._current;
                            if (U === null) throw Error(i(456));
                            if ((w._pendingVisibility & 2) === 0) {
                                var j = We(U, 2);
                                j !== null && (w._pendingVisibility |= 2, Ii(j, U, 2));
                            }
                        },
                        attach: function() {
                            var U = w._current;
                            if (U === null) throw Error(i(456));
                            if ((w._pendingVisibility & 2) !== 0) {
                                var j = We(U, 2);
                                j !== null && (w._pendingVisibility &= -3, Ii(j, U, 2));
                            }
                        }
                    };
                    return c.stateNode = w, c;
                }
                function eh(c, u, v) {
                    return c = t(6, c, null, u), c.lanes = v, c;
                }
                function up(c, u, v) {
                    return u = t(4, c.children !== null ? c.children : [], c.key, u), u.lanes = v, u.stateNode = {
                        containerInfo: c.containerInfo,
                        pendingChildren: null,
                        implementation: c.implementation
                    }, u;
                }
                function Jy(c, u, v, b, w, U, j, ne) {
                    this.tag = 1, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Eo, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = L(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = L(0), this.hiddenUpdates = L(null), this.identifierPrefix = b, this.onUncaughtError = w, this.onCaughtError = U, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = ne, this.incompleteTransitions = new Map;
                }
                function pg(c, u, v, b, w, U, j, ne, ye, Oe, $e, ft) {
                    return c = new Jy(c, u, v, j, ne, ye, Oe, ft), u = 1, U === !0 && (u |= 24), U = t(3, null, null, u), c.current = U, U.stateNode = c, u = ho(), u.refCount++, c.pooledCache = u, u.refCount++, U.memoizedState = {
                        element: b,
                        isDehydrated: v,
                        cache: u
                    }, vt(U), c;
                }
                function xi(c) {
                    return c ? (c = Co, c) : Co;
                }
                function th(c) {
                    var u = c._reactInternals;
                    if (u === void 0) throw typeof c.render == "function" ? Error(i(188)) : (c = Object.keys(c).join(","), Error(i(268, c)));
                    return c = x(u), c = c !== null ? M(c) : null, c === null ? null : lc(c.stateNode);
                }
                function nc(c, u, v, b, w, U) {
                    w = xi(w), b.context === null ? b.context = w : b.pendingContext = w, b = He(u), b.payload = {
                        element: v
                    }, U = U === void 0 ? null : U, U !== null && (b.callback = U), v = st(c, b, u), v !== null && (Ii(v, c, u), St(v, c, u));
                }
                function ic(c, u) {
                    if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
                        var v = c.retryLane;
                        c.retryLane = v !== 0 && v < u ? v : u;
                    }
                }
                function Ru(c, u) {
                    ic(c, u), (c = c.alternate) && ic(c, u);
                }
                var jt = {}, sc = Ad(), Fs = yA(), nh = Object.assign, $y = Symbol.for("react.element"), Cu = Symbol.for("react.transitional.element"), la = Symbol.for("react.portal"), Mo = Symbol.for("react.fragment"), Du = Symbol.for("react.strict_mode"), ih = Symbol.for("react.profiler"), Nu = Symbol.for("react.provider"), fp = Symbol.for("react.consumer"), Da = Symbol.for("react.context"), Uu = Symbol.for("react.forward_ref"), sh = Symbol.for("react.suspense"), ac = Symbol.for("react.suspense_list"), ah = Symbol.for("react.memo"), ca = Symbol.for("react.lazy"), hp = Symbol.for("react.offscreen"), mg = Symbol.for("react.memo_cache_sentinel"), Hr = Symbol.iterator, dp = Symbol.for("react.client.reference"), Ht = sc.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, tr, Fr, nl = !1, rc = Array.isArray, pp = e.rendererVersion, Lu = e.rendererPackageName, oc = e.extraDevToolsConfig, lc = e.getPublicInstance, gg = e.getRootHostContext, cc = e.getChildHostContext, rh = e.prepareForCommit, vg = e.resetAfterCommit, mp = e.createInstance, Ou = e.appendInitialChild, Gr = e.finalizeInitialChildren, qt = e.shouldSetTextContent, Nn = e.createTextInstance, Si = e.scheduleTimeout, oh = e.cancelTimeout, Eo = e.noTimeout, gs = e.isPrimaryRenderer;
                e.warnsIfNotActing;
                var Ai = e.supportsMutation, ua = e.supportsPersistence, Ki = e.supportsHydration, yg = e.getInstanceFromNode;
                e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
                var oi = e.preparePortalMount;
                e.prepareScopeUpdate, e.getInstanceFromScope;
                var ss = e.setCurrentUpdatePriority, Vr = e.getCurrentUpdatePriority, _g = e.resolveUpdatePriority;
                e.resolveEventType, e.resolveEventTimeStamp;
                var xg = e.shouldAttemptEagerTransition, e_ = e.detachDeletedInstance;
                e.requestPostPaintCallback;
                var gp = e.maySuspendCommit, lh = e.preloadInstance, vp = e.startSuspendingCommit, vs = e.suspendInstance, bi = e.waitForCommitToBeReady, To = e.NotPendingTransition, Na = e.HostTransitionContext, ch = e.resetFormInstance;
                e.bindToConsole;
                var yp = e.supportsMicrotasks, kr = e.scheduleMicrotask, Ao = e.supportsTestSelectors, _p = e.findFiberRoot, xp = e.getBoundingRect, Sg = e.getTextContent, uc = e.isHiddenSubtree, bg = e.matchAccessibilityRole, Mg = e.setFocusIfFocusable, Eg = e.setupIntersectionObserver, Tg = e.appendChild, Sp = e.appendChildToContainer, Ag = e.commitTextUpdate, t_ = e.commitMount, wg = e.commitUpdate, Rg = e.insertBefore, Cg = e.insertInContainerBefore, bp = e.removeChild, Dg = e.removeChildFromContainer, Mp = e.resetTextContent, Ng = e.hideInstance, Ug = e.hideTextInstance, Lg = e.unhideInstance, n_ = e.unhideTextInstance, Og = e.clearContainer, fc = e.cloneInstance, zu = e.createContainerChildSet, Ep = e.appendChildToContainerChildSet, uh = e.finalizeContainerChildren, hc = e.replaceContainerChildren, Tp = e.cloneHiddenInstance, Ap = e.cloneHiddenTextInstance, fh = e.isSuspenseInstancePending, hh = e.isSuspenseInstanceFallback, zg = e.getSuspenseInstanceFallbackErrorDetails, Bg = e.registerSuspenseInstanceRetry, wp = e.canHydrateFormStateMarker, Ig = e.isFormStateMarkerMatching, Rp = e.getNextHydratableSibling, dh = e.getFirstHydratableChild, Pg = e.getFirstHydratableChildWithinContainer, Hg = e.getFirstHydratableChildWithinSuspenseInstance, i_ = e.canHydrateInstance, Cp = e.canHydrateTextInstance, Fg = e.canHydrateSuspenseInstance, Gg = e.hydrateInstance, Dp = e.hydrateTextInstance, Vg = e.hydrateSuspenseInstance, kg = e.getNextHydratableInstanceAfterSuspenseInstance, s_ = e.commitHydratedContainer, a_ = e.commitHydratedSuspenseInstance, Xg = e.clearSuspenseBoundary, Bu = e.clearSuspenseBoundaryFromContainer, ph = e.shouldDeleteUnhydratedTailInstances;
                e.diffHydratedPropsForDevWarnings, e.diffHydratedTextForDevWarnings, e.describeHydratableInstanceForDevWarnings;
                var mh = e.validateHydratableInstance, jg = e.validateHydratableTextInstance, Gs = e.supportsResources, Iu = e.isHostHoistableType, gh = e.getHoistableRoot, Np = e.getResource, qg = e.acquireResource, il = e.releaseResource, Pu = e.hydrateHoistable, Hu = e.mountHoistable, dc = e.unmountHoistable, vh = e.createHoistableInstance, Yg = e.prepareToCommitHoistables, Wg = e.mayResourceSuspendCommit, sl = e.preloadResource, Zg = e.suspendResource, Bn = e.supportsSingletons, Ua = e.resolveSingletonInstance, wo = e.clearSingleton, Kg = e.acquireSingletonInstance, Ro = e.releaseSingletonInstance, nr = e.isHostSingletonType, li = [], Xr = -1, Co = {}, ys = Math.clz32 ? Math.clz32 : N, Qg = Math.log, Jg = Math.LN2, ir = 128, al = 4194304, Fu = Fs.unstable_scheduleCallback, yh = Fs.unstable_cancelCallback, $g = Fs.unstable_shouldYield, _h = Fs.unstable_requestPaint, fa = Fs.unstable_now, xh = Fs.unstable_ImmediatePriority, e0 = Fs.unstable_UserBlockingPriority, Sh = Fs.unstable_NormalPriority, r_ = Fs.unstable_IdlePriority, t0 = Fs.log, Pi = Fs.unstable_setDisableYieldValue, ci = null, Ds = null, Ns = typeof Object.is == "function" ? Object.is : Q, Up = new WeakMap, rl = [], ol = 0, ll = null, pc = 0, Vs = [], ks = 0, Do = null, La = 1, Oa = "", wi = T(null), mc = T(null), sr = T(null), cl = T(null), Qi = null, Ji = null, yn = !1, ha = null, Hi = !1, Gu = Error(i(519)), da = [], ul = 0, za = 0, Vu = null, jr = null, fl = !1, Vn = !1, Lp = !1, gc = 0, vc = null, hl = 0, Xs = 0, dl = null, qr = !1, pl = !1, ar = Object.prototype.hasOwnProperty, yc = Error(i(460)), ku = Error(i(474)), Xu = {
                    then: function() {}
                }, No = null, Uo = null, Lo = 0, Oo = Zn(!0), rr = Zn(!1), kn = T(null), _c = T(0), js = T(null), In = null, Ri = T(0), Yr = 0, $t = null, Ut = null, _n = null, pa = !1, ml = !1, zo = !1, bh = 0, gl = 0, Fi = null, Ba = 0, Mh = function() {
                    return {
                        lastEffect: null,
                        events: null,
                        stores: null,
                        memoCache: null
                    };
                }, ni = {
                    readContext: qi,
                    use: we,
                    useCallback: Un,
                    useContext: Un,
                    useEffect: Un,
                    useImperativeHandle: Un,
                    useLayoutEffect: Un,
                    useInsertionEffect: Un,
                    useMemo: Un,
                    useReducer: Un,
                    useRef: Un,
                    useState: Un,
                    useDebugValue: Un,
                    useDeferredValue: Un,
                    useTransition: Un,
                    useSyncExternalStore: Un,
                    useId: Un
                };
                ni.useCacheRefresh = Un, ni.useMemoCache = Un, ni.useHostTransitionStatus = Un, ni.useFormState = Un, ni.useActionState = Un, ni.useOptimistic = Un;
                var Bo = {
                    readContext: qi,
                    use: we,
                    useCallback: function(c, u) {
                        return k().memoizedState = [
                            c,
                            u === void 0 ? null : u
                        ], c;
                    },
                    useContext: qi,
                    useEffect: Of,
                    useImperativeHandle: function(c, u, v) {
                        v = v != null ? v.concat([
                            c
                        ]) : null, iu(4194308, 4, zf.bind(null, u, c), v);
                    },
                    useLayoutEffect: function(c, u) {
                        return iu(4194308, 4, c, u);
                    },
                    useInsertionEffect: function(c, u) {
                        iu(4, 2, c, u);
                    },
                    useMemo: function(c, u) {
                        var v = k();
                        u = u === void 0 ? null : u;
                        var b = c();
                        if (zo) {
                            K(!0);
                            try {
                                c();
                            } finally{
                                K(!1);
                            }
                        }
                        return v.memoizedState = [
                            b,
                            u
                        ], b;
                    },
                    useReducer: function(c, u, v) {
                        var b = k();
                        if (v !== void 0) {
                            var w = v(u);
                            if (zo) {
                                K(!0);
                                try {
                                    v(u);
                                } finally{
                                    K(!1);
                                }
                            }
                        } else w = u;
                        return b.memoizedState = b.baseState = w, c = {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: c,
                            lastRenderedState: w
                        }, b.queue = c, c = c.dispatch = If.bind(null, $t, c), [
                            b.memoizedState,
                            c
                        ];
                    },
                    useRef: function(c) {
                        var u = k();
                        return c = {
                            current: c
                        }, u.memoizedState = c;
                    },
                    useState: function(c) {
                        c = Jt(c);
                        var u = c.queue, v = Hd.bind(null, $t, u);
                        return u.dispatch = v, [
                            c.memoizedState,
                            v
                        ];
                    },
                    useDebugValue: oo,
                    useDeferredValue: function(c, u) {
                        var v = k();
                        return ru(v, c, u);
                    },
                    useTransition: function() {
                        var c = Jt(!1);
                        return c = Fl.bind(null, $t, c.queue, !0, !1), k().memoizedState = c, [
                            !1,
                            c
                        ];
                    },
                    useSyncExternalStore: function(c, u, v) {
                        var b = $t, w = k();
                        if (yn) {
                            if (v === void 0) throw Error(i(407));
                            v = v();
                        } else {
                            if (v = u(), Rn === null) throw Error(i(349));
                            (cn & 60) !== 0 || wt(b, u, v);
                        }
                        w.memoizedState = v;
                        var U = {
                            value: v,
                            getSnapshot: u
                        };
                        return w.queue = U, Of(Kt.bind(null, b, U, c), [
                            c
                        ]), b.flags |= 2048, hs(9, Et.bind(null, b, U, v, u), {
                            destroy: void 0
                        }, null), v;
                    },
                    useId: function() {
                        var c = k(), u = Rn.identifierPrefix;
                        if (yn) {
                            var v = Oa, b = La;
                            v = (b & ~(1 << 32 - ys(b) - 1)).toString(32) + v, u = ":" + u + "R" + v, v = bh++, 0 < v && (u += "H" + v.toString(32)), u += ":";
                        } else v = Ba++, u = ":" + u + "r" + v.toString(32) + ":";
                        return c.memoizedState = u;
                    },
                    useCacheRefresh: function() {
                        return k().memoizedState = Pd.bind(null, $t);
                    }
                };
                Bo.useMemoCache = pe, Bo.useHostTransitionStatus = ou, Bo.useFormState = Ln, Bo.useActionState = Ln, Bo.useOptimistic = function(c) {
                    var u = k();
                    u.memoizedState = u.baseState = c;
                    var v = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: null,
                        lastRenderedState: null
                    };
                    return u.queue = v, u = Vl.bind(null, $t, !0, v), v.dispatch = u, [
                        c,
                        u
                    ];
                };
                var _s = {
                    readContext: qi,
                    use: we,
                    useCallback: Jo,
                    useContext: qi,
                    useEffect: zd,
                    useImperativeHandle: Bf,
                    useInsertionEffect: Ym,
                    useLayoutEffect: au,
                    useMemo: Bd,
                    useReducer: at,
                    useRef: Ka,
                    useState: function() {
                        return at(je);
                    },
                    useDebugValue: oo,
                    useDeferredValue: function(c, u) {
                        var v = ce();
                        return Id(v, Ut.memoizedState, c, u);
                    },
                    useTransition: function() {
                        var c = at(je)[0], u = ce().memoizedState;
                        return [
                            typeof c == "boolean" ? c : Ae(c),
                            u
                        ];
                    },
                    useSyncExternalStore: Lt,
                    useId: Gl
                };
                _s.useCacheRefresh = wr, _s.useMemoCache = pe, _s.useHostTransitionStatus = ou, _s.useFormState = Xi, _s.useActionState = Xi, _s.useOptimistic = function(c, u) {
                    var v = ce();
                    return Tn(v, Ut, c, u);
                };
                var qs = {
                    readContext: qi,
                    use: we,
                    useCallback: Jo,
                    useContext: qi,
                    useEffect: zd,
                    useImperativeHandle: Bf,
                    useInsertionEffect: Ym,
                    useLayoutEffect: au,
                    useMemo: Bd,
                    useReducer: mt,
                    useRef: Ka,
                    useState: function() {
                        return mt(je);
                    },
                    useDebugValue: oo,
                    useDeferredValue: function(c, u) {
                        var v = ce();
                        return Ut === null ? ru(v, c, u) : Id(v, Ut.memoizedState, c, u);
                    },
                    useTransition: function() {
                        var c = mt(je)[0], u = ce().memoizedState;
                        return [
                            typeof c == "boolean" ? c : Ae(c),
                            u
                        ];
                    },
                    useSyncExternalStore: Lt,
                    useId: Gl
                };
                qs.useCacheRefresh = wr, qs.useMemoCache = pe, qs.useHostTransitionStatus = ou, qs.useFormState = zi, qs.useActionState = zi, qs.useOptimistic = function(c, u) {
                    var v = ce();
                    return Ut !== null ? Tn(v, Ut, c, u) : (v.baseState = c, [
                        c,
                        v.queue.dispatch
                    ]);
                };
                var or = {
                    isMounted: function(c) {
                        return (c = c._reactInternals) ? y(c) === c : !1;
                    },
                    enqueueSetState: function(c, u, v) {
                        c = c._reactInternals;
                        var b = ri(), w = He(b);
                        w.payload = u, v != null && (w.callback = v), u = st(c, w, b), u !== null && (Ii(u, c, b), St(u, c, b));
                    },
                    enqueueReplaceState: function(c, u, v) {
                        c = c._reactInternals;
                        var b = ri(), w = He(b);
                        w.tag = 1, w.payload = u, v != null && (w.callback = v), u = st(c, w, b), u !== null && (Ii(u, c, b), St(u, c, b));
                    },
                    enqueueForceUpdate: function(c, u) {
                        c = c._reactInternals;
                        var v = ri(), b = He(v);
                        b.tag = 2, u != null && (b.callback = u), u = st(c, b, v), u !== null && (Ii(u, c, v), St(u, c, v));
                    }
                }, Eh = typeof reportError == "function" ? reportError : function(c) {
                    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                        var u = new window.ErrorEvent("error", {
                            bubbles: !0,
                            cancelable: !0,
                            message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
                            error: c
                        });
                        if (!window.dispatchEvent(u)) return;
                    } else if (typeof process == "object" && typeof process.emit == "function") {
                        process.emit("uncaughtException", c);
                        return;
                    }
                    console.error(c);
                }, Th = Error(i(461)), Pn = !1, Ah = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                }, Wr = T(null), Ia = null, Ys = null, xc = typeof AbortController < "u" ? AbortController : function() {
                    var c = [], u = this.signal = {
                        aborted: !1,
                        addEventListener: function(v, b) {
                            c.push(b);
                        }
                    };
                    this.abort = function() {
                        u.aborted = !0, c.forEach(function(v) {
                            return v();
                        });
                    };
                }, n0 = Fs.unstable_scheduleCallback, i0 = Fs.unstable_NormalPriority, Xn = {
                    $$typeof: Da,
                    Consumer: null,
                    Provider: null,
                    _currentValue: null,
                    _currentValue2: null,
                    _threadCount: 0
                }, Op = Ht.S;
                Ht.S = function(c, u) {
                    typeof u == "object" && u !== null && typeof u.then == "function" && Ne(c, u), Op !== null && Op(c, u);
                };
                var lr = T(null), cr = !1, ii = !1, zp = !1, wn = typeof WeakSet == "function" ? WeakSet : Set, kt = null, an = !1, Ct = null, Qt = !1, $n = null, Ws = 8192, Sc = {
                    getCacheForType: function(c) {
                        var u = qi(Xn), v = u.data.get(c);
                        return v === void 0 && (v = c(), u.data.set(c, v)), v;
                    }
                }, bc = 0, ma = 1, Yn = 2, Pa = 3, ur = 4;
                if (typeof Symbol == "function" && Symbol.for) {
                    var vl = Symbol.for;
                    bc = vl("selector.component"), ma = vl("selector.has_pseudo_class"), Yn = vl("selector.role"), Pa = vl("selector.test_id"), ur = vl("selector.text");
                }
                var ga = typeof WeakMap == "function" ? WeakMap : Map, xn = 0, Rn = null, Ot = null, cn = 0, On = 0, as = null, va = !1, Zs = !1, Ci = !1, rs = 0, Hn = 0, Ks = 0, Zr = 0, ju = 0, Qs = 0, fr = 0, yl = null, si = null, wh = !1, xs = 0, Mc = 1 / 0, qu = null, Io = null, Ha = !1, hr = null, _l = 0, Po = 0, Rh = null, Ec = 0, Ch = null;
                return jt.attemptContinuousHydration = function(c) {
                    if (c.tag === 13) {
                        var u = We(c, 67108864);
                        u !== null && Ii(u, c, 67108864), Ru(c, 67108864);
                    }
                }, jt.attemptHydrationAtCurrentPriority = function(c) {
                    if (c.tag === 13) {
                        var u = ri(), v = We(c, u);
                        v !== null && Ii(v, c, u), Ru(c, u);
                    }
                }, jt.attemptSynchronousHydration = function(c) {
                    switch(c.tag){
                        case 3:
                            if (c = c.stateNode, c.current.memoizedState.isDehydrated) {
                                var u = D(c.pendingLanes);
                                if (u !== 0) {
                                    for(c.pendingLanes |= 2, c.entangledLanes |= 2; u;){
                                        var v = 1 << 31 - ys(u);
                                        c.entanglements[1] |= v, u &= ~v;
                                    }
                                    Xe(c), (xn & 6) === 0 && (Mc = fa() + 500, ot(0));
                                }
                            }
                            break;
                        case 13:
                            u = We(c, 2), u !== null && Ii(u, c, 2), Eu(), Ru(c, 2);
                    }
                }, jt.batchedUpdates = function(c, u) {
                    return c(u);
                }, jt.createComponentSelector = function(c) {
                    return {
                        $$typeof: bc,
                        value: c
                    };
                }, jt.createContainer = function(c, u, v, b, w, U, j, ne, ye, Oe) {
                    return pg(c, u, !1, null, v, b, U, j, ne, ye, Oe, null);
                }, jt.createHasPseudoClassSelector = function(c) {
                    return {
                        $$typeof: ma,
                        value: c
                    };
                }, jt.createHydrationContainer = function(c, u, v, b, w, U, j, ne, ye, Oe, $e, ft, gt) {
                    return c = pg(v, b, !0, c, w, U, ne, ye, Oe, $e, ft, gt), c.context = xi(null), v = c.current, b = ri(), w = He(b), w.callback = u ?? null, st(v, w, b), c.current.lanes = b, q(c, b), Xe(c), c;
                }, jt.createPortal = function(c, u, v) {
                    var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                    return {
                        $$typeof: la,
                        key: b == null ? null : "" + b,
                        children: c,
                        containerInfo: u,
                        implementation: v
                    };
                }, jt.createRoleSelector = function(c) {
                    return {
                        $$typeof: Yn,
                        value: c
                    };
                }, jt.createTestNameSelector = function(c) {
                    return {
                        $$typeof: Pa,
                        value: c
                    };
                }, jt.createTextSelector = function(c) {
                    return {
                        $$typeof: ur,
                        value: c
                    };
                }, jt.defaultOnCaughtError = function(c) {
                    console.error(c);
                }, jt.defaultOnRecoverableError = function(c) {
                    Eh(c);
                }, jt.defaultOnUncaughtError = function(c) {
                    Eh(c);
                }, jt.deferredUpdates = function(c) {
                    var u = Ht.T, v = Vr();
                    try {
                        return ss(32), Ht.T = null, c();
                    } finally{
                        ss(v), Ht.T = u;
                    }
                }, jt.discreteUpdates = function(c, u, v, b, w) {
                    var U = Ht.T, j = Vr();
                    try {
                        return ss(2), Ht.T = null, c(u, v, b, w);
                    } finally{
                        ss(j), Ht.T = U, xn === 0 && (Mc = fa() + 500);
                    }
                }, jt.findAllNodes = bu, jt.findBoundingRects = function(c, u) {
                    if (!Ao) throw Error(i(363));
                    u = bu(c, u), c = [];
                    for(var v = 0; v < u.length; v++)c.push(xp(u[v]));
                    for(u = c.length - 1; 0 < u; u--){
                        v = c[u];
                        for(var b = v.x, w = b + v.width, U = v.y, j = U + v.height, ne = u - 1; 0 <= ne; ne--)if (u !== ne) {
                            var ye = c[ne], Oe = ye.x, $e = Oe + ye.width, ft = ye.y, gt = ft + ye.height;
                            if (b >= Oe && U >= ft && w <= $e && j <= gt) {
                                c.splice(u, 1);
                                break;
                            } else if (b !== Oe || v.width !== ye.width || gt < U || ft > j) {
                                if (!(U !== ft || v.height !== ye.height || $e < b || Oe > w)) {
                                    Oe > b && (ye.width += Oe - b, ye.x = b), $e < w && (ye.width = w - Oe), c.splice(u, 1);
                                    break;
                                }
                            } else {
                                ft > U && (ye.height += ft - U, ye.y = U), gt < j && (ye.height = j - ft), c.splice(u, 1);
                                break;
                            }
                        }
                    }
                    return c;
                }, jt.findHostInstance = th, jt.findHostInstanceWithNoPortals = function(c) {
                    return c = x(c), c = c !== null ? R(c) : null, c === null ? null : lc(c.stateNode);
                }, jt.findHostInstanceWithWarning = function(c) {
                    return th(c);
                }, jt.flushPassiveEffects = Ca, jt.flushSyncFromReconciler = function(c) {
                    var u = xn;
                    xn |= 1;
                    var v = Ht.T, b = Vr();
                    try {
                        if (ss(2), Ht.T = null, c) return c();
                    } finally{
                        ss(b), Ht.T = v, xn = u, (xn & 6) === 0 && ot(0);
                    }
                }, jt.flushSyncWork = Eu, jt.focusWithin = function(c, u) {
                    if (!Ao) throw Error(i(363));
                    for(c = Jl(c), u = Rs(c, u), u = Array.from(u), c = 0; c < u.length;){
                        var v = u[c++], b = v.tag;
                        if (!uc(v)) {
                            if ((b === 5 || b === 26 || b === 27) && Mg(v.stateNode)) return !0;
                            for(v = v.child; v !== null;)u.push(v), v = v.sibling;
                        }
                    }
                    return !1;
                }, jt.getFindAllNodesFailureDescription = function(c, u) {
                    if (!Ao) throw Error(i(363));
                    var v = 0, b = [];
                    c = [
                        Jl(c),
                        0
                    ];
                    for(var w = 0; w < c.length;){
                        var U = c[w++], j = U.tag, ne = c[w++], ye = u[ne];
                        if ((j !== 5 && j !== 26 && j !== 27 || !uc(U)) && (vo(U, ye) && (b.push(ip(ye)), ne++, ne > v && (v = ne)), ne < u.length)) for(U = U.child; U !== null;)c.push(U, ne), U = U.sibling;
                    }
                    if (v < u.length) {
                        for(c = []; v < u.length; v++)c.push(ip(u[v]));
                        return `findAllNodes was able to match part of the selector:
  ` + (b.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ");
                    }
                    return null;
                }, jt.getPublicRootInstance = function(c) {
                    if (c = c.current, !c.child) return null;
                    switch(c.child.tag){
                        case 27:
                        case 5:
                            return lc(c.child.stateNode);
                        default:
                            return c.child.stateNode;
                    }
                }, jt.injectIntoDevTools = function() {
                    var c = {
                        bundleType: 0,
                        version: pp,
                        rendererPackageName: Lu,
                        currentDispatcherRef: Ht,
                        findFiberByHostInstance: yg,
                        reconcilerVersion: "19.0.0"
                    };
                    if (oc !== null && (c.rendererConfig = oc), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") c = !1;
                    else {
                        var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                        if (u.isDisabled || !u.supportsFiber) c = !0;
                        else {
                            try {
                                ci = u.inject(c), Ds = u;
                            } catch  {}
                            c = !!u.checkDCE;
                        }
                    }
                    return c;
                }, jt.isAlreadyRendering = function() {
                    return !1;
                }, jt.observeVisibleRects = function(c, u, v, b) {
                    if (!Ao) throw Error(i(363));
                    c = bu(c, u);
                    var w = Eg(c, v, b).disconnect;
                    return {
                        disconnect: function() {
                            w();
                        }
                    };
                }, jt.shouldError = function() {
                    return null;
                }, jt.shouldSuspend = function() {
                    return !1;
                }, jt.startHostTransition = function(c, u, v, b) {
                    if (c.tag !== 5) throw Error(i(476));
                    var w = Qa(c).queue;
                    Fl(c, w, u, To, v === null ? n : function() {
                        var U = Qa(c).next.queue;
                        return lo(c, U, {}, ri()), v(b);
                    });
                }, jt.updateContainer = function(c, u, v, b) {
                    var w = u.current, U = ri();
                    return nc(w, U, c, u, v, b), U;
                }, jt.updateContainerSync = function(c, u, v, b) {
                    return u.tag === 0 && Ca(), nc(u.current, 2, c, u, v, b), 2;
                }, jt;
            }, r.exports.default = r.exports, Object.defineProperty(r.exports, "__esModule", {
                value: !0
            });
        })(Ux)), Ux.exports;
    }
    var Q1;
    function NO() {
        return Q1 || (Q1 = 1, Nx.exports = DO()), Nx.exports;
    }
    var UO = NO();
    const LO = hy(UO);
    var J1 = yA();
    function ub(r, e, t) {
        if (!r) return;
        if (t(r) === !0) return r;
        let n = e ? r.return : r.child;
        for(; n;){
            const i = ub(n, e, t);
            if (i) return i;
            n = e ? null : n.sibling;
        }
    }
    function _A(r) {
        try {
            return Object.defineProperties(r, {
                _currentRenderer: {
                    get () {
                        return null;
                    },
                    set () {}
                },
                _currentRenderer2: {
                    get () {
                        return null;
                    },
                    set () {}
                }
            });
        } catch  {
            return r;
        }
    }
    const fb = _A(qe.createContext(null));
    class xA extends qe.Component {
        render() {
            return qe.createElement(fb.Provider, {
                value: this._reactInternals
            }, this.props.children);
        }
    }
    function SA() {
        const r = qe.useContext(fb);
        if (r === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
        const e = qe.useId();
        return qe.useMemo(()=>{
            for (const t of [
                r,
                r?.alternate
            ]){
                if (!t) continue;
                const n = ub(t, !1, (i)=>{
                    let a = i.memoizedState;
                    for(; a;){
                        if (a.memoizedState === e) return !0;
                        a = a.next;
                    }
                });
                if (n) return n;
            }
        }, [
            r,
            e
        ]);
    }
    const OO = Symbol.for("react.context"), zO = (r)=>r !== null && typeof r == "object" && "$$typeof" in r && r.$$typeof === OO;
    function BO() {
        const r = SA(), [e] = qe.useState(()=>new Map);
        e.clear();
        let t = r;
        for(; t;){
            const n = t.type;
            zO(n) && n !== fb && !e.has(n) && e.set(n, qe.use(_A(n))), t = t.return;
        }
        return e;
    }
    function IO() {
        const r = BO();
        return qe.useMemo(()=>Array.from(r.keys()).reduce((e, t)=>(n)=>qe.createElement(e, null, qe.createElement(t.Provider, {
                        ...n,
                        value: r.get(t)
                    })), (e)=>qe.createElement(xA, {
                    ...e
                })), [
            r
        ]);
    }
    function bA(r) {
        let e = r.root;
        for(; e.getState().previousRoot;)e = e.getState().previousRoot;
        return e;
    }
    const MA = (r)=>r && r.isOrthographicCamera, PO = (r)=>r && r.hasOwnProperty("current"), HO = (r)=>r != null && (typeof r == "string" || typeof r == "number" || r.isColor), jm = ((r, e)=>typeof window < "u" && (((r = window.document) == null ? void 0 : r.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative"))() ? qe.useLayoutEffect : qe.useEffect;
    function EA(r) {
        const e = qe.useRef(r);
        return jm(()=>void (e.current = r), [
            r
        ]), e;
    }
    function FO() {
        const r = SA(), e = IO();
        return qe.useMemo(()=>({ children: t })=>{
                const i = !!ub(r, !0, (a)=>a.type === qe.StrictMode) ? qe.StrictMode : qe.Fragment;
                return ae.jsx(i, {
                    children: ae.jsx(e, {
                        children: t
                    })
                });
            }, [
            r,
            e
        ]);
    }
    function GO({ set: r }) {
        return jm(()=>(r(new Promise(()=>null)), ()=>r(!1)), [
            r
        ]), null;
    }
    const VO = ((r)=>(r = class extends qe.Component {
            constructor(...t){
                super(...t), this.state = {
                    error: !1
                };
            }
            componentDidCatch(t) {
                this.props.set(t);
            }
            render() {
                return this.state.error ? null : this.props.children;
            }
        }, r.getDerivedStateFromError = ()=>({
                error: !0
            }), r))();
    function TA(r) {
        var e;
        const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
        return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r;
    }
    function ed(r) {
        var e;
        return (e = r.__r3f) == null ? void 0 : e.root.getState();
    }
    const fi = {
        obj: (r)=>r === Object(r) && !fi.arr(r) && typeof r != "function",
        fun: (r)=>typeof r == "function",
        str: (r)=>typeof r == "string",
        num: (r)=>typeof r == "number",
        boo: (r)=>typeof r == "boolean",
        und: (r)=>r === void 0,
        nul: (r)=>r === null,
        arr: (r)=>Array.isArray(r),
        equ (r, e, { arrays: t = "shallow", objects: n = "reference", strict: i = !0 } = {}) {
            if (typeof r != typeof e || !!r != !!e) return !1;
            if (fi.str(r) || fi.num(r) || fi.boo(r)) return r === e;
            const a = fi.obj(r);
            if (a && n === "reference") return r === e;
            const l = fi.arr(r);
            if (l && t === "reference") return r === e;
            if ((l || a) && r === e) return !0;
            let f;
            for(f in r)if (!(f in e)) return !1;
            if (a && t === "shallow" && n === "shallow") {
                for(f in i ? e : r)if (!fi.equ(r[f], e[f], {
                    strict: i,
                    objects: "reference"
                })) return !1;
            } else for(f in i ? e : r)if (r[f] !== e[f]) return !1;
            if (fi.und(f)) {
                if (l && r.length === 0 && e.length === 0 || a && Object.keys(r).length === 0 && Object.keys(e).length === 0) return !0;
                if (r !== e) return !1;
            }
            return !0;
        }
    };
    function kO(r) {
        r.type !== "Scene" && (r.dispose == null || r.dispose());
        for(const e in r){
            const t = r[e];
            t?.type !== "Scene" && (t == null || t.dispose == null || t.dispose());
        }
    }
    const AA = [
        "children",
        "key",
        "ref"
    ];
    function XO(r) {
        const e = {};
        for(const t in r)AA.includes(t) || (e[t] = r[t]);
        return e;
    }
    function oy(r, e, t, n) {
        const i = r;
        let a = i?.__r3f;
        return a || (a = {
            root: e,
            type: t,
            parent: null,
            children: [],
            props: XO(n),
            object: i,
            eventCount: 0,
            handlers: {},
            isHidden: !1
        }, i && (i.__r3f = a)), a;
    }
    function Om(r, e) {
        let t = r[e];
        if (!e.includes("-")) return {
            root: r,
            key: e,
            target: t
        };
        t = r;
        for (const i of e.split("-")){
            var n;
            e = i, r = t, t = (n = t) == null ? void 0 : n[e];
        }
        return {
            root: r,
            key: e,
            target: t
        };
    }
    const $1 = /-\d+$/;
    function ly(r, e) {
        if (fi.str(e.props.attach)) {
            if ($1.test(e.props.attach)) {
                const i = e.props.attach.replace($1, ""), { root: a, key: l } = Om(r.object, i);
                Array.isArray(a[l]) || (a[l] = []);
            }
            const { root: t, key: n } = Om(r.object, e.props.attach);
            e.previousAttach = t[n], t[n] = e.object;
        } else fi.fun(e.props.attach) && (e.previousAttach = e.props.attach(r.object, e.object));
    }
    function cy(r, e) {
        if (fi.str(e.props.attach)) {
            const { root: t, key: n } = Om(r.object, e.props.attach), i = e.previousAttach;
            i === void 0 ? delete t[n] : t[n] = i;
        } else e.previousAttach == null || e.previousAttach(r.object, e.object);
        delete e.previousAttach;
    }
    const dS = [
        ...AA,
        "args",
        "dispose",
        "attach",
        "object",
        "onUpdate",
        "dispose"
    ], eE = new Map;
    function jO(r) {
        let e = eE.get(r.constructor);
        try {
            e || (e = new r.constructor, eE.set(r.constructor, e));
        } catch  {}
        return e;
    }
    function qO(r, e) {
        const t = {};
        for(const n in e)if (!dS.includes(n) && !fi.equ(e[n], r.props[n])) {
            t[n] = e[n];
            for(const i in e)i.startsWith(`${n}-`) && (t[i] = e[i]);
        }
        for(const n in r.props){
            if (dS.includes(n) || e.hasOwnProperty(n)) continue;
            const { root: i, key: a } = Om(r.object, n);
            if (i.constructor && i.constructor.length === 0) {
                const l = jO(i);
                fi.und(l) || (t[a] = l[a]);
            } else t[a] = 0;
        }
        return t;
    }
    const YO = [
        "map",
        "emissiveMap",
        "sheenColorMap",
        "specularColorMap",
        "envMap"
    ], WO = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
    function Gc(r, e) {
        var t;
        const n = r.__r3f, i = n && bA(n).getState(), a = n?.eventCount;
        for(const f in e){
            let d = e[f];
            if (dS.includes(f)) continue;
            if (n && WO.test(f)) {
                typeof d == "function" ? n.handlers[f] = d : delete n.handlers[f], n.eventCount = Object.keys(n.handlers).length;
                continue;
            }
            if (d === void 0) continue;
            let { root: p, key: g, target: y } = Om(r, f);
            if (y instanceof Sd && d instanceof Sd) y.mask = d.mask;
            else if (y instanceof tt && HO(d)) y.set(d);
            else if (y !== null && typeof y == "object" && typeof y.set == "function" && typeof y.copy == "function" && d != null && d.constructor && y.constructor === d.constructor) y.copy(d);
            else if (y !== null && typeof y == "object" && typeof y.set == "function" && Array.isArray(d)) typeof y.fromArray == "function" ? y.fromArray(d) : y.set(...d);
            else if (y !== null && typeof y == "object" && typeof y.set == "function" && typeof d == "number") typeof y.setScalar == "function" ? y.setScalar(d) : y.set(d);
            else {
                var l;
                p[g] = d, i && !i.linear && YO.includes(g) && (l = p[g]) != null && l.isTexture && p[g].format === Is && p[g].type === br && (p[g].colorSpace = Bs);
            }
        }
        if (n != null && n.parent && i != null && i.internal && (t = n.object) != null && t.isObject3D && a !== n.eventCount) {
            const f = n.object, d = i.internal.interaction.indexOf(f);
            d > -1 && i.internal.interaction.splice(d, 1), n.eventCount && f.raycast !== null && i.internal.interaction.push(f);
        }
        return n && n.props.attach === void 0 && (n.object.isBufferGeometry ? n.props.attach = "geometry" : n.object.isMaterial && (n.props.attach = "material")), n && Od(n), r;
    }
    function Od(r) {
        var e;
        if (!r.parent) return;
        r.props.onUpdate == null || r.props.onUpdate(r.object);
        const t = (e = r.root) == null || e.getState == null ? void 0 : e.getState();
        t && t.internal.frames === 0 && t.invalidate();
    }
    function ZO(r, e) {
        r.manual || (MA(r) ? (r.left = e.width / -2, r.right = e.width / 2, r.top = e.height / 2, r.bottom = e.height / -2) : r.aspect = e.width / e.height, r.updateProjectionMatrix());
    }
    const Sa = (r)=>r?.isObject3D;
    function fv(r) {
        return (r.eventObject || r.object).uuid + "/" + r.index + r.instanceId;
    }
    function wA(r, e, t, n) {
        const i = t.get(e);
        i && (t.delete(e), t.size === 0 && (r.delete(n), i.target.releasePointerCapture(n)));
    }
    function KO(r, e) {
        const { internal: t } = r.getState();
        t.interaction = t.interaction.filter((n)=>n !== e), t.initialHits = t.initialHits.filter((n)=>n !== e), t.hovered.forEach((n, i)=>{
            (n.eventObject === e || n.object === e) && t.hovered.delete(i);
        }), t.capturedMap.forEach((n, i)=>{
            wA(t.capturedMap, e, n, i);
        });
    }
    function QO(r) {
        function e(d) {
            const { internal: p } = r.getState(), g = d.offsetX - p.initialClick[0], y = d.offsetY - p.initialClick[1];
            return Math.round(Math.sqrt(g * g + y * y));
        }
        function t(d) {
            return d.filter((p)=>[
                    "Move",
                    "Over",
                    "Enter",
                    "Out",
                    "Leave"
                ].some((g)=>{
                    var y;
                    return (y = p.__r3f) == null ? void 0 : y.handlers["onPointer" + g];
                }));
        }
        function n(d, p) {
            const g = r.getState(), y = new Set, _ = [], x = p ? p(g.internal.interaction) : g.internal.interaction;
            for(let E = 0; E < x.length; E++){
                const C = ed(x[E]);
                C && (C.raycaster.camera = void 0);
            }
            g.previousRoot || g.events.compute == null || g.events.compute(d, g);
            function M(E) {
                const C = ed(E);
                if (!C || !C.events.enabled || C.raycaster.camera === null) return [];
                if (C.raycaster.camera === void 0) {
                    var N;
                    C.events.compute == null || C.events.compute(d, C, (N = C.previousRoot) == null ? void 0 : N.getState()), C.raycaster.camera === void 0 && (C.raycaster.camera = null);
                }
                return C.raycaster.camera ? C.raycaster.intersectObject(E, !0) : [];
            }
            let R = x.flatMap(M).sort((E, C)=>{
                const N = ed(E.object), D = ed(C.object);
                return !N || !D ? E.distance - C.distance : D.events.priority - N.events.priority || E.distance - C.distance;
            }).filter((E)=>{
                const C = fv(E);
                return y.has(C) ? !1 : (y.add(C), !0);
            });
            g.events.filter && (R = g.events.filter(R, g));
            for (const E of R){
                let C = E.object;
                for(; C;){
                    var T;
                    (T = C.__r3f) != null && T.eventCount && _.push({
                        ...E,
                        eventObject: C
                    }), C = C.parent;
                }
            }
            if ("pointerId" in d && g.internal.capturedMap.has(d.pointerId)) for (let E of g.internal.capturedMap.get(d.pointerId).values())y.has(fv(E.intersection)) || _.push(E.intersection);
            return _;
        }
        function i(d, p, g, y) {
            if (d.length) {
                const _ = {
                    stopped: !1
                };
                for (const x of d){
                    let M = ed(x.object);
                    if (M || x.object.traverseAncestors((R)=>{
                        const T = ed(R);
                        if (T) return M = T, !1;
                    }), M) {
                        const { raycaster: R, pointer: T, camera: E, internal: C } = M, N = new Y(T.x, T.y, 0).unproject(E), D = (z)=>{
                            var L, q;
                            return (L = (q = C.capturedMap.get(z)) == null ? void 0 : q.has(x.eventObject)) != null ? L : !1;
                        }, I = (z)=>{
                            const L = {
                                intersection: x,
                                target: p.target
                            };
                            C.capturedMap.has(z) ? C.capturedMap.get(z).set(x.eventObject, L) : C.capturedMap.set(z, new Map([
                                [
                                    x.eventObject,
                                    L
                                ]
                            ])), p.target.setPointerCapture(z);
                        }, O = (z)=>{
                            const L = C.capturedMap.get(z);
                            L && wA(C.capturedMap, x.eventObject, L, z);
                        };
                        let P = {};
                        for(let z in p){
                            let L = p[z];
                            typeof L != "function" && (P[z] = L);
                        }
                        let F = {
                            ...x,
                            ...P,
                            pointer: T,
                            intersections: d,
                            stopped: _.stopped,
                            delta: g,
                            unprojectedPoint: N,
                            ray: R.ray,
                            camera: E,
                            stopPropagation () {
                                const z = "pointerId" in p && C.capturedMap.get(p.pointerId);
                                if ((!z || z.has(x.eventObject)) && (F.stopped = _.stopped = !0, C.hovered.size && Array.from(C.hovered.values()).find((L)=>L.eventObject === x.eventObject))) {
                                    const L = d.slice(0, d.indexOf(x));
                                    a([
                                        ...L,
                                        x
                                    ]);
                                }
                            },
                            target: {
                                hasPointerCapture: D,
                                setPointerCapture: I,
                                releasePointerCapture: O
                            },
                            currentTarget: {
                                hasPointerCapture: D,
                                setPointerCapture: I,
                                releasePointerCapture: O
                            },
                            nativeEvent: p
                        };
                        if (y(F), _.stopped === !0) break;
                    }
                }
            }
            return d;
        }
        function a(d) {
            const { internal: p } = r.getState();
            for (const g of p.hovered.values())if (!d.length || !d.find((y)=>y.object === g.object && y.index === g.index && y.instanceId === g.instanceId)) {
                const _ = g.eventObject.__r3f;
                if (p.hovered.delete(fv(g)), _ != null && _.eventCount) {
                    const x = _.handlers, M = {
                        ...g,
                        intersections: d
                    };
                    x.onPointerOut == null || x.onPointerOut(M), x.onPointerLeave == null || x.onPointerLeave(M);
                }
            }
        }
        function l(d, p) {
            for(let g = 0; g < p.length; g++){
                const y = p[g].__r3f;
                y == null || y.handlers.onPointerMissed == null || y.handlers.onPointerMissed(d);
            }
        }
        function f(d) {
            switch(d){
                case "onPointerLeave":
                case "onPointerCancel":
                    return ()=>a([]);
                case "onLostPointerCapture":
                    return (p)=>{
                        const { internal: g } = r.getState();
                        "pointerId" in p && g.capturedMap.has(p.pointerId) && requestAnimationFrame(()=>{
                            g.capturedMap.has(p.pointerId) && (g.capturedMap.delete(p.pointerId), a([]));
                        });
                    };
            }
            return function(g) {
                const { onPointerMissed: y, internal: _ } = r.getState();
                _.lastEvent.current = g;
                const x = d === "onPointerMove", M = d === "onClick" || d === "onContextMenu" || d === "onDoubleClick", T = n(g, x ? t : void 0), E = M ? e(g) : 0;
                d === "onPointerDown" && (_.initialClick = [
                    g.offsetX,
                    g.offsetY
                ], _.initialHits = T.map((N)=>N.eventObject)), M && !T.length && E <= 2 && (l(g, _.interaction), y && y(g)), x && a(T);
                function C(N) {
                    const D = N.eventObject, I = D.__r3f;
                    if (!(I != null && I.eventCount)) return;
                    const O = I.handlers;
                    if (x) {
                        if (O.onPointerOver || O.onPointerEnter || O.onPointerOut || O.onPointerLeave) {
                            const P = fv(N), F = _.hovered.get(P);
                            F ? F.stopped && N.stopPropagation() : (_.hovered.set(P, N), O.onPointerOver == null || O.onPointerOver(N), O.onPointerEnter == null || O.onPointerEnter(N));
                        }
                        O.onPointerMove == null || O.onPointerMove(N);
                    } else {
                        const P = O[d];
                        P ? (!M || _.initialHits.includes(D)) && (l(g, _.interaction.filter((F)=>!_.initialHits.includes(F))), P(N)) : M && _.initialHits.includes(D) && l(g, _.interaction.filter((F)=>!_.initialHits.includes(F)));
                    }
                }
                i(T, g, E, C);
            };
        }
        return {
            handlePointer: f
        };
    }
    const tE = (r)=>!!(r != null && r.render), RA = qe.createContext(null), JO = (r, e)=>{
        const t = RO((f, d)=>{
            const p = new Y, g = new Y, y = new Y;
            function _(E = d().camera, C = g, N = d().size) {
                const { width: D, height: I, top: O, left: P } = N, F = D / I;
                C.isVector3 ? y.copy(C) : y.set(...C);
                const z = E.getWorldPosition(p).distanceTo(y);
                if (MA(E)) return {
                    width: D / E.zoom,
                    height: I / E.zoom,
                    top: O,
                    left: P,
                    factor: 1,
                    distance: z,
                    aspect: F
                };
                {
                    const L = E.fov * Math.PI / 180, q = 2 * Math.tan(L / 2) * z, oe = q * (D / I);
                    return {
                        width: oe,
                        height: q,
                        top: O,
                        left: P,
                        factor: D / oe,
                        distance: z,
                        aspect: F
                    };
                }
            }
            let x;
            const M = (E)=>f((C)=>({
                        performance: {
                            ...C.performance,
                            current: E
                        }
                    })), R = new Ie;
            return {
                set: f,
                get: d,
                gl: null,
                camera: null,
                raycaster: null,
                events: {
                    priority: 1,
                    enabled: !0,
                    connected: !1
                },
                scene: null,
                xr: null,
                invalidate: (E = 1)=>r(d(), E),
                advance: (E, C)=>e(E, C, d()),
                legacy: !1,
                linear: !1,
                flat: !1,
                controls: null,
                clock: new sb,
                pointer: R,
                mouse: R,
                frameloop: "always",
                onPointerMissed: void 0,
                performance: {
                    current: 1,
                    min: .5,
                    max: 1,
                    debounce: 200,
                    regress: ()=>{
                        const E = d();
                        x && clearTimeout(x), E.performance.current !== E.performance.min && M(E.performance.min), x = setTimeout(()=>M(d().performance.max), E.performance.debounce);
                    }
                },
                size: {
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0
                },
                viewport: {
                    initialDpr: 0,
                    dpr: 0,
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    aspect: 0,
                    distance: 0,
                    factor: 0,
                    getCurrentViewport: _
                },
                setEvents: (E)=>f((C)=>({
                            ...C,
                            events: {
                                ...C.events,
                                ...E
                            }
                        })),
                setSize: (E, C, N = 0, D = 0)=>{
                    const I = d().camera, O = {
                        width: E,
                        height: C,
                        top: N,
                        left: D
                    };
                    f((P)=>({
                            size: O,
                            viewport: {
                                ...P.viewport,
                                ..._(I, g, O)
                            }
                        }));
                },
                setDpr: (E)=>f((C)=>{
                        const N = TA(E);
                        return {
                            viewport: {
                                ...C.viewport,
                                dpr: N,
                                initialDpr: C.viewport.initialDpr || N
                            }
                        };
                    }),
                setFrameloop: (E = "always")=>{
                    const C = d().clock;
                    C.stop(), C.elapsedTime = 0, E !== "never" && (C.start(), C.elapsedTime = 0), f(()=>({
                            frameloop: E
                        }));
                },
                previousRoot: void 0,
                internal: {
                    interaction: [],
                    hovered: new Map,
                    subscribers: [],
                    initialClick: [
                        0,
                        0
                    ],
                    initialHits: [],
                    capturedMap: new Map,
                    lastEvent: qe.createRef(),
                    active: !1,
                    frames: 0,
                    priority: 0,
                    subscribe: (E, C, N)=>{
                        const D = d().internal;
                        return D.priority = D.priority + (C > 0 ? 1 : 0), D.subscribers.push({
                            ref: E,
                            priority: C,
                            store: N
                        }), D.subscribers = D.subscribers.sort((I, O)=>I.priority - O.priority), ()=>{
                            const I = d().internal;
                            I != null && I.subscribers && (I.priority = I.priority - (C > 0 ? 1 : 0), I.subscribers = I.subscribers.filter((O)=>O.ref !== E));
                        };
                    }
                }
            };
        }), n = t.getState();
        let i = n.size, a = n.viewport.dpr, l = n.camera;
        return t.subscribe(()=>{
            const { camera: f, size: d, viewport: p, gl: g, set: y } = t.getState();
            if (d.width !== i.width || d.height !== i.height || p.dpr !== a) {
                i = d, a = p.dpr, ZO(f, d), p.dpr > 0 && g.setPixelRatio(p.dpr);
                const _ = typeof HTMLCanvasElement < "u" && g.domElement instanceof HTMLCanvasElement;
                g.setSize(d.width, d.height, _);
            }
            f !== l && (l = f, y((_)=>({
                    viewport: {
                        ..._.viewport,
                        ..._.viewport.getCurrentViewport(f)
                    }
                })));
        }), t.subscribe((f)=>r(f)), t;
    };
    function CA() {
        const r = qe.useContext(RA);
        if (!r) throw new Error("R3F: Hooks can only be used within the Canvas component!");
        return r;
    }
    function Va(r = (t)=>t, e) {
        return CA()(r, e);
    }
    function DA(r, e = 0) {
        const t = CA(), n = t.getState().internal.subscribe, i = EA(r);
        return jm(()=>n(i, e, t), [
            e,
            n,
            t
        ]), null;
    }
    function $O(r) {
        const e = LO(r);
        return e.injectIntoDevTools({
            bundleType: 0,
            rendererPackageName: "@react-three/fiber",
            version: qe.version
        }), e;
    }
    const NA = 0, Td = {}, ez = /^three(?=[A-Z])/, Wy = (r)=>`${r[0].toUpperCase()}${r.slice(1)}`;
    let tz = 0;
    const nz = (r)=>typeof r == "function";
    function iz(r) {
        if (nz(r)) {
            const e = `${tz++}`;
            return Td[e] = r, e;
        } else Object.assign(Td, r);
    }
    function UA(r, e) {
        const t = Wy(r), n = Td[t];
        if (r !== "primitive" && !n) throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
        if (r === "primitive" && !e.object) throw new Error("R3F: Primitives without 'object' are invalid!");
        if (e.args !== void 0 && !Array.isArray(e.args)) throw new Error("R3F: The args prop must be an array!");
    }
    function sz(r, e, t) {
        var n;
        return r = Wy(r) in Td ? r : r.replace(ez, ""), UA(r, e), r === "primitive" && (n = e.object) != null && n.__r3f && delete e.object.__r3f, oy(e.object, t, r, e);
    }
    function az(r) {
        if (!r.isHidden) {
            var e;
            r.props.attach && (e = r.parent) != null && e.object ? cy(r.parent, r) : Sa(r.object) && (r.object.visible = !1), r.isHidden = !0, Od(r);
        }
    }
    function LA(r) {
        if (r.isHidden) {
            var e;
            r.props.attach && (e = r.parent) != null && e.object ? ly(r.parent, r) : Sa(r.object) && r.props.visible !== !1 && (r.object.visible = !0), r.isHidden = !1, Od(r);
        }
    }
    function hb(r, e, t) {
        const n = e.root.getState();
        if (!(!r.parent && r.object !== n.scene)) {
            if (!e.object) {
                var i, a;
                const l = Td[Wy(e.type)];
                e.object = (i = e.props.object) != null ? i : new l(...(a = e.props.args) != null ? a : []), e.object.__r3f = e;
            }
            if (Gc(e.object, e.props), e.props.attach) ly(r, e);
            else if (Sa(e.object) && Sa(r.object)) {
                const l = r.object.children.indexOf(t?.object);
                if (t && l !== -1) {
                    const f = r.object.children.indexOf(e.object);
                    if (f !== -1) {
                        r.object.children.splice(f, 1);
                        const d = f < l ? l - 1 : l;
                        r.object.children.splice(d, 0, e.object);
                    } else e.object.parent = r.object, r.object.children.splice(l, 0, e.object), e.object.dispatchEvent({
                        type: "added"
                    }), r.object.dispatchEvent({
                        type: "childadded",
                        child: e.object
                    });
                } else r.object.add(e.object);
            }
            for (const l of e.children)hb(e, l);
            Od(e);
        }
    }
    function zx(r, e) {
        e && (e.parent = r, r.children.push(e), hb(r, e));
    }
    function nE(r, e, t) {
        if (!e || !t) return;
        e.parent = r;
        const n = r.children.indexOf(t);
        n !== -1 ? r.children.splice(n, 0, e) : r.children.push(e), hb(r, e, t);
    }
    function OA(r) {
        if (typeof r.dispose == "function") {
            const e = ()=>{
                try {
                    r.dispose();
                } catch  {}
            };
            typeof IS_REACT_ACT_ENVIRONMENT < "u" ? e() : J1.unstable_scheduleCallback(J1.unstable_IdlePriority, e);
        }
    }
    function pS(r, e, t) {
        if (!e) return;
        e.parent = null;
        const n = r.children.indexOf(e);
        n !== -1 && r.children.splice(n, 1), e.props.attach ? cy(r, e) : Sa(e.object) && Sa(r.object) && (r.object.remove(e.object), KO(bA(e), e.object));
        const i = e.props.dispose !== null && t !== !1;
        for(let a = e.children.length - 1; a >= 0; a--){
            const l = e.children[a];
            pS(e, l, i);
        }
        e.children.length = 0, delete e.object.__r3f, i && e.type !== "primitive" && e.object.type !== "Scene" && OA(e.object), t === void 0 && Od(e);
    }
    function rz(r, e) {
        for (const t of [
            r,
            r.alternate
        ])if (t !== null) if (typeof t.ref == "function") {
            t.refCleanup == null || t.refCleanup();
            const n = t.ref(e);
            typeof n == "function" && (t.refCleanup = n);
        } else t.ref && (t.ref.current = e);
    }
    const _v = [];
    function oz() {
        for (const [t] of _v){
            const n = t.parent;
            if (n) {
                t.props.attach ? cy(n, t) : Sa(t.object) && Sa(n.object) && n.object.remove(t.object);
                for (const i of t.children)i.props.attach ? cy(t, i) : Sa(i.object) && Sa(t.object) && t.object.remove(i.object);
            }
            t.isHidden && LA(t), t.object.__r3f && delete t.object.__r3f, t.type !== "primitive" && OA(t.object);
        }
        for (const [t, n, i] of _v){
            t.props = n;
            const a = t.parent;
            if (a) {
                var r, e;
                const l = Td[Wy(t.type)];
                t.object = (r = t.props.object) != null ? r : new l(...(e = t.props.args) != null ? e : []), t.object.__r3f = t, rz(i, t.object), Gc(t.object, t.props), t.props.attach ? ly(a, t) : Sa(t.object) && Sa(a.object) && a.object.add(t.object);
                for (const f of t.children)f.props.attach ? ly(t, f) : Sa(f.object) && Sa(t.object) && t.object.add(f.object);
                Od(t);
            }
        }
        _v.length = 0;
    }
    const Bx = ()=>{}, iE = {};
    let hv = NA;
    const lz = 0, cz = 4, mS = $O({
        isPrimaryRenderer: !1,
        warnsIfNotActing: !1,
        supportsMutation: !0,
        supportsPersistence: !1,
        supportsHydration: !1,
        createInstance: sz,
        removeChild: pS,
        appendChild: zx,
        appendInitialChild: zx,
        insertBefore: nE,
        appendChildToContainer (r, e) {
            const t = r.getState().scene.__r3f;
            !e || !t || zx(t, e);
        },
        removeChildFromContainer (r, e) {
            const t = r.getState().scene.__r3f;
            !e || !t || pS(t, e);
        },
        insertInContainerBefore (r, e, t) {
            const n = r.getState().scene.__r3f;
            !e || !t || !n || nE(n, e, t);
        },
        getRootHostContext: ()=>iE,
        getChildHostContext: ()=>iE,
        commitUpdate (r, e, t, n, i) {
            var a, l, f;
            UA(e, n);
            let d = !1;
            if ((r.type === "primitive" && t.object !== n.object || ((a = n.args) == null ? void 0 : a.length) !== ((l = t.args) == null ? void 0 : l.length) || (f = n.args) != null && f.some((g, y)=>{
                var _;
                return g !== ((_ = t.args) == null ? void 0 : _[y]);
            })) && (d = !0), d) _v.push([
                r,
                {
                    ...n
                },
                i
            ]);
            else {
                const g = qO(r, n);
                Object.keys(g).length && (Object.assign(r.props, g), Gc(r.object, g));
            }
            (i.sibling === null || (i.flags & cz) === lz) && oz();
        },
        finalizeInitialChildren: ()=>!1,
        commitMount () {},
        getPublicInstance: (r)=>r?.object,
        prepareForCommit: ()=>null,
        preparePortalMount: (r)=>oy(r.getState().scene, r, "", {}),
        resetAfterCommit: ()=>{},
        shouldSetTextContent: ()=>!1,
        clearContainer: ()=>!1,
        hideInstance: az,
        unhideInstance: LA,
        createTextInstance: Bx,
        hideTextInstance: Bx,
        unhideTextInstance: Bx,
        scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
        cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
        noTimeout: -1,
        getInstanceFromNode: ()=>null,
        beforeActiveInstanceBlur () {},
        afterActiveInstanceBlur () {},
        detachDeletedInstance () {},
        prepareScopeUpdate () {},
        getInstanceFromScope: ()=>null,
        shouldAttemptEagerTransition: ()=>!1,
        trackSchedulerEvent: ()=>{},
        resolveEventType: ()=>null,
        resolveEventTimeStamp: ()=>-1.1,
        requestPostPaintCallback () {},
        maySuspendCommit: ()=>!1,
        preloadInstance: ()=>!0,
        startSuspendingCommit () {},
        suspendInstance () {},
        waitForCommitToBeReady: ()=>null,
        NotPendingTransition: null,
        HostTransitionContext: qe.createContext(null),
        setCurrentUpdatePriority (r) {
            hv = r;
        },
        getCurrentUpdatePriority () {
            return hv;
        },
        resolveUpdatePriority () {
            var r;
            if (hv !== NA) return hv;
            switch(typeof window < "u" && ((r = window.event) == null ? void 0 : r.type)){
                case "click":
                case "contextmenu":
                case "dblclick":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                    return yv.DiscreteEventPriority;
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerenter":
                case "pointerleave":
                case "wheel":
                    return yv.ContinuousEventPriority;
                default:
                    return yv.DefaultEventPriority;
            }
        },
        resetFormInstance () {}
    }), Rf = new Map, td = {
        objects: "shallow",
        strict: !1
    };
    function uz(r, e) {
        if (!e && typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement && r.parentElement) {
            const { width: t, height: n, top: i, left: a } = r.parentElement.getBoundingClientRect();
            return {
                width: t,
                height: n,
                top: i,
                left: a
            };
        } else if (!e && typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas) return {
            width: r.width,
            height: r.height,
            top: 0,
            left: 0
        };
        return {
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            ...e
        };
    }
    function fz(r) {
        const e = Rf.get(r), t = e?.fiber, n = e?.store;
        e && console.warn("R3F.createRoot should only be called once!");
        const i = typeof reportError == "function" ? reportError : console.error, a = n || JO(yS, aE), l = t || mS.createContainer(a, yv.ConcurrentRoot, null, !1, null, "", i, i, i, null);
        e || Rf.set(r, {
            fiber: l,
            store: a
        });
        let f, d, p = !1, g = null;
        return {
            async configure (y = {}) {
                let _;
                g = new Promise(($)=>_ = $);
                let { gl: x, size: M, scene: R, events: T, onCreated: E, shadows: C = !1, linear: N = !1, flat: D = !1, legacy: I = !1, orthographic: O = !1, frameloop: P = "always", dpr: F = [
                    1,
                    2
                ], performance: z, raycaster: L, camera: q, onPointerMissed: oe } = y, se = a.getState(), ge = se.gl;
                if (!se.gl) {
                    const $ = {
                        canvas: r,
                        powerPreference: "high-performance",
                        antialias: !0,
                        alpha: !0
                    }, me = typeof x == "function" ? await x($) : x;
                    tE(me) ? ge = me : ge = new vA({
                        ...$,
                        ...x
                    }), se.set({
                        gl: ge
                    });
                }
                let _e = se.raycaster;
                _e || se.set({
                    raycaster: _e = new cA
                });
                const { params: H, ...K } = L || {};
                if (fi.equ(K, _e, td) || Gc(_e, {
                    ...K
                }), fi.equ(H, _e.params, td) || Gc(_e, {
                    params: {
                        ..._e.params,
                        ...H
                    }
                }), !se.camera || se.camera === d && !fi.equ(d, q, td)) {
                    d = q;
                    const $ = q?.isCamera, me = $ ? q : O ? new Yo(0, 0, 0, 0, .1, 1e3) : new hi(75, 0, .1, 1e3);
                    $ || (me.position.z = 5, q && (Gc(me, q), me.manual || ("aspect" in q || "left" in q || "right" in q || "bottom" in q || "top" in q) && (me.manual = !0, me.updateProjectionMatrix())), !se.camera && !(q != null && q.rotation) && me.lookAt(0, 0, 0)), se.set({
                        camera: me
                    }), _e.camera = me;
                }
                if (!se.scene) {
                    let $;
                    R != null && R.isScene ? ($ = R, oy($, a, "", {})) : ($ = new IS, oy($, a, "", {}), R && Gc($, R)), se.set({
                        scene: $
                    });
                }
                T && !se.events.handlers && se.set({
                    events: T(a)
                });
                const Q = uz(r, M);
                if (fi.equ(Q, se.size, td) || se.setSize(Q.width, Q.height, Q.top, Q.left), F && se.viewport.dpr !== TA(F) && se.setDpr(F), se.frameloop !== P && se.setFrameloop(P), se.onPointerMissed || se.set({
                    onPointerMissed: oe
                }), z && !fi.equ(z, se.performance, td) && se.set(($)=>({
                        performance: {
                            ...$.performance,
                            ...z
                        }
                    })), !se.xr) {
                    var fe;
                    const $ = (J, ue)=>{
                        const he = a.getState();
                        he.frameloop !== "never" && aE(J, !0, he, ue);
                    }, me = ()=>{
                        const J = a.getState();
                        J.gl.xr.enabled = J.gl.xr.isPresenting, J.gl.xr.setAnimationLoop(J.gl.xr.isPresenting ? $ : null), J.gl.xr.isPresenting || yS(J);
                    }, ve = {
                        connect () {
                            const J = a.getState().gl;
                            J.xr.addEventListener("sessionstart", me), J.xr.addEventListener("sessionend", me);
                        },
                        disconnect () {
                            const J = a.getState().gl;
                            J.xr.removeEventListener("sessionstart", me), J.xr.removeEventListener("sessionend", me);
                        }
                    };
                    typeof ((fe = ge.xr) == null ? void 0 : fe.addEventListener) == "function" && ve.connect(), se.set({
                        xr: ve
                    });
                }
                if (ge.shadowMap) {
                    const $ = ge.shadowMap.enabled, me = ge.shadowMap.type;
                    if (ge.shadowMap.enabled = !!C, fi.boo(C)) ge.shadowMap.type = hm;
                    else if (fi.str(C)) {
                        var X;
                        const ve = {
                            basic: wE,
                            percentage: dy,
                            soft: hm,
                            variance: to
                        };
                        ge.shadowMap.type = (X = ve[C]) != null ? X : hm;
                    } else fi.obj(C) && Object.assign(ge.shadowMap, C);
                    ($ !== ge.shadowMap.enabled || me !== ge.shadowMap.type) && (ge.shadowMap.needsUpdate = !0);
                }
                return Sn.enabled = !I, p || (ge.outputColorSpace = N ? qc : Bs, ge.toneMapping = D ? jo : MS), se.legacy !== I && se.set(()=>({
                        legacy: I
                    })), se.linear !== N && se.set(()=>({
                        linear: N
                    })), se.flat !== D && se.set(()=>({
                        flat: D
                    })), x && !fi.fun(x) && !tE(x) && !fi.equ(x, ge, td) && Gc(ge, x), f = E, p = !0, _(), this;
            },
            render (y) {
                return !p && !g && this.configure(), g.then(()=>{
                    mS.updateContainer(ae.jsx(hz, {
                        store: a,
                        children: y,
                        onCreated: f,
                        rootElement: r
                    }), l, null, ()=>{});
                }), a;
            },
            unmount () {
                zA(r);
            }
        };
    }
    function hz({ store: r, children: e, onCreated: t, rootElement: n }) {
        return jm(()=>{
            const i = r.getState();
            i.set((a)=>({
                    internal: {
                        ...a.internal,
                        active: !0
                    }
                })), t && t(i), r.getState().events.connected || i.events.connect == null || i.events.connect(n);
        }, []), ae.jsx(RA.Provider, {
            value: r,
            children: e
        });
    }
    function zA(r, e) {
        const t = Rf.get(r), n = t?.fiber;
        if (n) {
            const i = t?.store.getState();
            i && (i.internal.active = !1), mS.updateContainer(null, n, null, ()=>{
                i && setTimeout(()=>{
                    try {
                        var a, l, f, d;
                        i.events.disconnect == null || i.events.disconnect(), (a = i.gl) == null || (l = a.renderLists) == null || l.dispose == null || l.dispose(), (f = i.gl) == null || f.forceContextLoss == null || f.forceContextLoss(), (d = i.gl) != null && d.xr && i.xr.disconnect(), kO(i.scene), Rf.delete(r);
                    } catch  {}
                }, 500);
            });
        }
    }
    const dz = new Set, pz = new Set, mz = new Set;
    function Ix(r, e) {
        if (r.size) for (const { callback: t } of r.values())t(e);
    }
    function Sm(r, e) {
        switch(r){
            case "before":
                return Ix(dz, e);
            case "after":
                return Ix(pz, e);
            case "tail":
                return Ix(mz, e);
        }
    }
    let Px, Hx;
    function gS(r, e, t) {
        let n = e.clock.getDelta();
        e.frameloop === "never" && typeof r == "number" && (n = r - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = r), Px = e.internal.subscribers;
        for(let i = 0; i < Px.length; i++)Hx = Px[i], Hx.ref.current(Hx.store.getState(), n, t);
        return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
    }
    let uy = !1, vS = !1, Fx, sE, nd;
    function BA(r) {
        sE = requestAnimationFrame(BA), uy = !0, Fx = 0, Sm("before", r), vS = !0;
        for (const t of Rf.values()){
            var e;
            nd = t.store.getState(), nd.internal.active && (nd.frameloop === "always" || nd.internal.frames > 0) && !((e = nd.gl.xr) != null && e.isPresenting) && (Fx += gS(r, nd));
        }
        if (vS = !1, Sm("after", r), Fx === 0) return Sm("tail", r), uy = !1, cancelAnimationFrame(sE);
    }
    function yS(r, e = 1) {
        var t;
        if (!r) return Rf.forEach((n)=>yS(n.store.getState(), e));
        (t = r.gl.xr) != null && t.isPresenting || !r.internal.active || r.frameloop === "never" || (e > 1 ? r.internal.frames = Math.min(60, r.internal.frames + e) : vS ? r.internal.frames = 2 : r.internal.frames = 1, uy || (uy = !0, requestAnimationFrame(BA)));
    }
    function aE(r, e = !0, t, n) {
        if (e && Sm("before", r), t) gS(r, t, n);
        else for (const i of Rf.values())gS(r, i.store.getState());
        e && Sm("after", r);
    }
    const Gx = {
        onClick: [
            "click",
            !1
        ],
        onContextMenu: [
            "contextmenu",
            !1
        ],
        onDoubleClick: [
            "dblclick",
            !1
        ],
        onWheel: [
            "wheel",
            !0
        ],
        onPointerDown: [
            "pointerdown",
            !0
        ],
        onPointerUp: [
            "pointerup",
            !0
        ],
        onPointerLeave: [
            "pointerleave",
            !0
        ],
        onPointerMove: [
            "pointermove",
            !0
        ],
        onPointerCancel: [
            "pointercancel",
            !0
        ],
        onLostPointerCapture: [
            "lostpointercapture",
            !0
        ]
    };
    function gz(r) {
        const { handlePointer: e } = QO(r);
        return {
            priority: 1,
            enabled: !0,
            compute (t, n, i) {
                n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
            },
            connected: void 0,
            handlers: Object.keys(Gx).reduce((t, n)=>({
                    ...t,
                    [n]: e(n)
                }), {}),
            update: ()=>{
                var t;
                const { events: n, internal: i } = r.getState();
                (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current);
            },
            connect: (t)=>{
                const { set: n, events: i } = r.getState();
                if (i.disconnect == null || i.disconnect(), n((a)=>({
                        events: {
                            ...a.events,
                            connected: t
                        }
                    })), i.handlers) for(const a in i.handlers){
                    const l = i.handlers[a], [f, d] = Gx[a];
                    t.addEventListener(f, l, {
                        passive: d
                    });
                }
            },
            disconnect: ()=>{
                const { set: t, events: n } = r.getState();
                if (n.connected) {
                    if (n.handlers) for(const i in n.handlers){
                        const a = n.handlers[i], [l] = Gx[i];
                        n.connected.removeEventListener(l, a);
                    }
                    t((i)=>({
                            events: {
                                ...i.events,
                                connected: void 0
                            }
                        }));
                }
            }
        };
    }
    function rE(r, e) {
        let t;
        return (...n)=>{
            window.clearTimeout(t), t = window.setTimeout(()=>r(...n), e);
        };
    }
    function vz({ debounce: r, scroll: e, polyfill: t, offsetSize: n } = {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    }) {
        const i = t || (typeof window > "u" ? class {
        } : window.ResizeObserver);
        if (!i) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
        const [a, l] = qe.useState({
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            bottom: 0,
            right: 0,
            x: 0,
            y: 0
        }), f = qe.useRef({
            element: null,
            scrollContainers: null,
            resizeObserver: null,
            lastBounds: a,
            orientationHandler: null
        }), d = r ? typeof r == "number" ? r : r.scroll : null, p = r ? typeof r == "number" ? r : r.resize : null, g = qe.useRef(!1);
        qe.useEffect(()=>(g.current = !0, ()=>void (g.current = !1)));
        const [y, _, x] = qe.useMemo(()=>{
            const E = ()=>{
                if (!f.current.element) return;
                const { left: C, top: N, width: D, height: I, bottom: O, right: P, x: F, y: z } = f.current.element.getBoundingClientRect(), L = {
                    left: C,
                    top: N,
                    width: D,
                    height: I,
                    bottom: O,
                    right: P,
                    x: F,
                    y: z
                };
                f.current.element instanceof HTMLElement && n && (L.height = f.current.element.offsetHeight, L.width = f.current.element.offsetWidth), Object.freeze(L), g.current && !Sz(f.current.lastBounds, L) && l(f.current.lastBounds = L);
            };
            return [
                E,
                p ? rE(E, p) : E,
                d ? rE(E, d) : E
            ];
        }, [
            l,
            n,
            d,
            p
        ]);
        function M() {
            f.current.scrollContainers && (f.current.scrollContainers.forEach((E)=>E.removeEventListener("scroll", x, !0)), f.current.scrollContainers = null), f.current.resizeObserver && (f.current.resizeObserver.disconnect(), f.current.resizeObserver = null), f.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", f.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", f.current.orientationHandler));
        }
        function R() {
            f.current.element && (f.current.resizeObserver = new i(x), f.current.resizeObserver.observe(f.current.element), e && f.current.scrollContainers && f.current.scrollContainers.forEach((E)=>E.addEventListener("scroll", x, {
                    capture: !0,
                    passive: !0
                })), f.current.orientationHandler = ()=>{
                x();
            }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", f.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", f.current.orientationHandler));
        }
        const T = (E)=>{
            !E || E === f.current.element || (M(), f.current.element = E, f.current.scrollContainers = IA(E), R());
        };
        return _z(x, !!e), yz(_), qe.useEffect(()=>{
            M(), R();
        }, [
            e,
            x,
            _
        ]), qe.useEffect(()=>M, []), [
            T,
            a,
            y
        ];
    }
    function yz(r) {
        qe.useEffect(()=>{
            const e = r;
            return window.addEventListener("resize", e), ()=>void window.removeEventListener("resize", e);
        }, [
            r
        ]);
    }
    function _z(r, e) {
        qe.useEffect(()=>{
            if (e) {
                const t = r;
                return window.addEventListener("scroll", t, {
                    capture: !0,
                    passive: !0
                }), ()=>void window.removeEventListener("scroll", t, !0);
            }
        }, [
            r,
            e
        ]);
    }
    function IA(r) {
        const e = [];
        if (!r || r === document.body) return e;
        const { overflow: t, overflowX: n, overflowY: i } = window.getComputedStyle(r);
        return [
            t,
            n,
            i
        ].some((a)=>a === "auto" || a === "scroll") && e.push(r), [
            ...e,
            ...IA(r.parentElement)
        ];
    }
    const xz = [
        "x",
        "y",
        "top",
        "bottom",
        "left",
        "right",
        "width",
        "height"
    ], Sz = (r, e)=>xz.every((t)=>r[t] === e[t]);
    function bz({ ref: r, children: e, fallback: t, resize: n, style: i, gl: a, events: l = gz, eventSource: f, eventPrefix: d, shadows: p, linear: g, flat: y, legacy: _, orthographic: x, frameloop: M, dpr: R, performance: T, raycaster: E, camera: C, scene: N, onPointerMissed: D, onCreated: I, ...O }) {
        qe.useMemo(()=>iz(mO), []);
        const P = FO(), [F, z] = vz({
            scroll: !0,
            debounce: {
                scroll: 50,
                resize: 0
            },
            ...n
        }), L = qe.useRef(null), q = qe.useRef(null);
        qe.useImperativeHandle(r, ()=>L.current);
        const oe = EA(D), [se, ge] = qe.useState(!1), [_e, H] = qe.useState(!1);
        if (se) throw se;
        if (_e) throw _e;
        const K = qe.useRef(null);
        jm(()=>{
            const fe = L.current;
            if (z.width > 0 && z.height > 0 && fe) {
                K.current || (K.current = fz(fe));
                async function X() {
                    await K.current.configure({
                        gl: a,
                        scene: N,
                        events: l,
                        shadows: p,
                        linear: g,
                        flat: y,
                        legacy: _,
                        orthographic: x,
                        frameloop: M,
                        dpr: R,
                        performance: T,
                        raycaster: E,
                        camera: C,
                        size: z,
                        onPointerMissed: (...$)=>oe.current == null ? void 0 : oe.current(...$),
                        onCreated: ($)=>{
                            $.events.connect == null || $.events.connect(f ? PO(f) ? f.current : f : q.current), d && $.setEvents({
                                compute: (me, ve)=>{
                                    const J = me[d + "X"], ue = me[d + "Y"];
                                    ve.pointer.set(J / ve.size.width * 2 - 1, -(ue / ve.size.height) * 2 + 1), ve.raycaster.setFromCamera(ve.pointer, ve.camera);
                                }
                            }), I?.($);
                        }
                    }), K.current.render(ae.jsx(P, {
                        children: ae.jsx(VO, {
                            set: H,
                            children: ae.jsx(qe.Suspense, {
                                fallback: ae.jsx(GO, {
                                    set: ge
                                }),
                                children: e ?? null
                            })
                        })
                    }));
                }
                X();
            }
        }), qe.useEffect(()=>{
            const fe = L.current;
            if (fe) return ()=>zA(fe);
        }, []);
        const Q = f ? "none" : "auto";
        return ae.jsx("div", {
            ref: q,
            style: {
                position: "relative",
                width: "100%",
                height: "100%",
                overflow: "hidden",
                pointerEvents: Q,
                ...i
            },
            ...O,
            children: ae.jsx("div", {
                ref: F,
                style: {
                    width: "100%",
                    height: "100%"
                },
                children: ae.jsx("canvas", {
                    ref: L,
                    style: {
                        display: "block"
                    },
                    children: t
                })
            })
        });
    }
    function Mz(r) {
        return ae.jsx(xA, {
            children: ae.jsx(bz, {
                ...r
            })
        });
    }
    function fy() {
        return fy = Object.assign ? Object.assign.bind() : function(r) {
            for(var e = 1; e < arguments.length; e++){
                var t = arguments[e];
                for(var n in t)({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
            }
            return r;
        }, fy.apply(null, arguments);
    }
    const PA = parseInt(zm.replace(/\D+/g, "")), Ez = PA >= 125 ? "uv1" : "uv2";
    function oE(r, e) {
        if (e === sT) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
        if (e === ny || e === US) {
            let t = r.getIndex();
            if (t === null) {
                const l = [], f = r.getAttribute("position");
                if (f !== void 0) {
                    for(let d = 0; d < f.count; d++)l.push(d);
                    r.setIndex(l), t = r.getIndex();
                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r;
            }
            const n = t.count - 2, i = [];
            if (t) if (e === ny) for(let l = 1; l <= n; l++)i.push(t.getX(0)), i.push(t.getX(l)), i.push(t.getX(l + 1));
            else for(let l = 0; l < n; l++)l % 2 === 0 ? (i.push(t.getX(l)), i.push(t.getX(l + 1)), i.push(t.getX(l + 2))) : (i.push(t.getX(l + 2)), i.push(t.getX(l + 1)), i.push(t.getX(l)));
            i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const a = r.clone();
            return a.setIndex(i), a.clearGroups(), a;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r;
    }
    var _r = Uint8Array, Xc = Uint16Array, _S = Uint32Array, HA = new _r([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        0,
        0,
        0
    ]), FA = new _r([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        0,
        0
    ]), Tz = new _r([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]), GA = function(r, e) {
        for(var t = new Xc(31), n = 0; n < 31; ++n)t[n] = e += 1 << r[n - 1];
        for(var i = new _S(t[30]), n = 1; n < 30; ++n)for(var a = t[n]; a < t[n + 1]; ++a)i[a] = a - t[n] << 5 | n;
        return [
            t,
            i
        ];
    }, VA = GA(HA, 2), kA = VA[0], Az = VA[1];
    kA[28] = 258, Az[258] = 28;
    var wz = GA(FA, 0), Rz = wz[0], xS = new Xc(32768);
    for(var ei = 0; ei < 32768; ++ei){
        var Pc = (ei & 43690) >>> 1 | (ei & 21845) << 1;
        Pc = (Pc & 52428) >>> 2 | (Pc & 13107) << 2, Pc = (Pc & 61680) >>> 4 | (Pc & 3855) << 4, xS[ei] = ((Pc & 65280) >>> 8 | (Pc & 255) << 8) >>> 1;
    }
    var bm = (function(r, e, t) {
        for(var n = r.length, i = 0, a = new Xc(e); i < n; ++i)++a[r[i] - 1];
        var l = new Xc(e);
        for(i = 0; i < e; ++i)l[i] = l[i - 1] + a[i - 1] << 1;
        var f;
        if (t) {
            f = new Xc(1 << e);
            var d = 15 - e;
            for(i = 0; i < n; ++i)if (r[i]) for(var p = i << 4 | r[i], g = e - r[i], y = l[r[i] - 1]++ << g, _ = y | (1 << g) - 1; y <= _; ++y)f[xS[y] >>> d] = p;
        } else for(f = new Xc(n), i = 0; i < n; ++i)r[i] && (f[i] = xS[l[r[i] - 1]++] >>> 15 - r[i]);
        return f;
    }), qm = new _r(288);
    for(var ei = 0; ei < 144; ++ei)qm[ei] = 8;
    for(var ei = 144; ei < 256; ++ei)qm[ei] = 9;
    for(var ei = 256; ei < 280; ++ei)qm[ei] = 7;
    for(var ei = 280; ei < 288; ++ei)qm[ei] = 8;
    var XA = new _r(32);
    for(var ei = 0; ei < 32; ++ei)XA[ei] = 5;
    var Cz = bm(qm, 9, 1), Dz = bm(XA, 5, 1), Vx = function(r) {
        for(var e = r[0], t = 1; t < r.length; ++t)r[t] > e && (e = r[t]);
        return e;
    }, eo = function(r, e, t) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8) >> (e & 7) & t;
    }, kx = function(r, e) {
        var t = e / 8 | 0;
        return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);
    }, Nz = function(r) {
        return (r / 8 | 0) + (r & 7 && 1);
    }, Uz = function(r, e, t) {
        (t == null || t > r.length) && (t = r.length);
        var n = new (r instanceof Xc ? Xc : r instanceof _S ? _S : _r)(t - e);
        return n.set(r.subarray(e, t)), n;
    }, Lz = function(r, e, t) {
        var n = r.length;
        if (!n || t && !t.l && n < 5) return e || new _r(0);
        var i = !e || t, a = !t || t.i;
        t || (t = {}), e || (e = new _r(n * 3));
        var l = function(he) {
            var De = e.length;
            if (he > De) {
                var Pe = new _r(Math.max(De * 2, he));
                Pe.set(e), e = Pe;
            }
        }, f = t.f || 0, d = t.p || 0, p = t.b || 0, g = t.l, y = t.d, _ = t.m, x = t.n, M = n * 8;
        do {
            if (!g) {
                t.f = f = eo(r, d, 1);
                var R = eo(r, d + 1, 3);
                if (d += 3, R) if (R == 1) g = Cz, y = Dz, _ = 9, x = 5;
                else if (R == 2) {
                    var N = eo(r, d, 31) + 257, D = eo(r, d + 10, 15) + 4, I = N + eo(r, d + 5, 31) + 1;
                    d += 14;
                    for(var O = new _r(I), P = new _r(19), F = 0; F < D; ++F)P[Tz[F]] = eo(r, d + F * 3, 7);
                    d += D * 3;
                    for(var z = Vx(P), L = (1 << z) - 1, q = bm(P, z, 1), F = 0; F < I;){
                        var oe = q[eo(r, d, L)];
                        d += oe & 15;
                        var T = oe >>> 4;
                        if (T < 16) O[F++] = T;
                        else {
                            var se = 0, ge = 0;
                            for(T == 16 ? (ge = 3 + eo(r, d, 3), d += 2, se = O[F - 1]) : T == 17 ? (ge = 3 + eo(r, d, 7), d += 3) : T == 18 && (ge = 11 + eo(r, d, 127), d += 7); ge--;)O[F++] = se;
                        }
                    }
                    var _e = O.subarray(0, N), H = O.subarray(N);
                    _ = Vx(_e), x = Vx(H), g = bm(_e, _, 1), y = bm(H, x, 1);
                } else throw "invalid block type";
                else {
                    var T = Nz(d) + 4, E = r[T - 4] | r[T - 3] << 8, C = T + E;
                    if (C > n) {
                        if (a) throw "unexpected EOF";
                        break;
                    }
                    i && l(p + E), e.set(r.subarray(T, C), p), t.b = p += E, t.p = d = C * 8;
                    continue;
                }
                if (d > M) {
                    if (a) throw "unexpected EOF";
                    break;
                }
            }
            i && l(p + 131072);
            for(var K = (1 << _) - 1, Q = (1 << x) - 1, fe = d;; fe = d){
                var se = g[kx(r, d) & K], X = se >>> 4;
                if (d += se & 15, d > M) {
                    if (a) throw "unexpected EOF";
                    break;
                }
                if (!se) throw "invalid length/literal";
                if (X < 256) e[p++] = X;
                else if (X == 256) {
                    fe = d, g = null;
                    break;
                } else {
                    var $ = X - 254;
                    if (X > 264) {
                        var F = X - 257, me = HA[F];
                        $ = eo(r, d, (1 << me) - 1) + kA[F], d += me;
                    }
                    var ve = y[kx(r, d) & Q], J = ve >>> 4;
                    if (!ve) throw "invalid distance";
                    d += ve & 15;
                    var H = Rz[J];
                    if (J > 3) {
                        var me = FA[J];
                        H += kx(r, d) & (1 << me) - 1, d += me;
                    }
                    if (d > M) {
                        if (a) throw "unexpected EOF";
                        break;
                    }
                    i && l(p + 131072);
                    for(var ue = p + $; p < ue; p += 4)e[p] = e[p - H], e[p + 1] = e[p + 1 - H], e[p + 2] = e[p + 2 - H], e[p + 3] = e[p + 3 - H];
                    p = ue;
                }
            }
            t.l = g, t.p = fe, t.b = p, g && (f = 1, t.m = _, t.d = y, t.n = x);
        }while (!f);
        return p == e.length ? e : Uz(e, 0, p);
    }, Oz = new _r(0), zz = function(r) {
        if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31) throw "invalid zlib data";
        if (r[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
    };
    function Bz(r, e) {
        return Lz((zz(r), r.subarray(2, -4)), e);
    }
    var Iz = typeof TextDecoder < "u" && new TextDecoder, Pz = 0;
    try {
        Iz.decode(Oz, {
            stream: !0
        }), Pz = 1;
    } catch  {}
    var Hz = Object.defineProperty, Fz = (r, e, t)=>e in r ? Hz(r, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }) : r[e] = t, Gz = (r, e, t)=>(Fz(r, e + "", t), t);
    class Vz {
        constructor(){
            Gz(this, "_listeners");
        }
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            const n = this._listeners;
            n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
            if (this._listeners === void 0) return !1;
            const n = this._listeners;
            return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
            if (this._listeners === void 0) return;
            const i = this._listeners[e];
            if (i !== void 0) {
                const a = i.indexOf(t);
                a !== -1 && i.splice(a, 1);
            }
        }
        dispatchEvent(e) {
            if (this._listeners === void 0) return;
            const n = this._listeners[e.type];
            if (n !== void 0) {
                e.target = this;
                const i = n.slice(0);
                for(let a = 0, l = i.length; a < l; a++)i[a].call(this, e);
                e.target = null;
            }
        }
    }
    var kz = Object.defineProperty, Xz = (r, e, t)=>e in r ? kz(r, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }) : r[e] = t, zt = (r, e, t)=>(Xz(r, typeof e != "symbol" ? e + "" : e, t), t);
    const dv = new Df, lE = new Cl, jz = Math.cos(70 * (Math.PI / 180)), cE = (r, e)=>(r % e + e) % e;
    let qz = class extends Vz {
        constructor(e, t){
            super(), zt(this, "object"), zt(this, "domElement"), zt(this, "enabled", !0), zt(this, "target", new Y), zt(this, "minDistance", 0), zt(this, "maxDistance", 1 / 0), zt(this, "minZoom", 0), zt(this, "maxZoom", 1 / 0), zt(this, "minPolarAngle", 0), zt(this, "maxPolarAngle", Math.PI), zt(this, "minAzimuthAngle", -1 / 0), zt(this, "maxAzimuthAngle", 1 / 0), zt(this, "enableDamping", !1), zt(this, "dampingFactor", .05), zt(this, "enableZoom", !0), zt(this, "zoomSpeed", 1), zt(this, "enableRotate", !0), zt(this, "rotateSpeed", 1), zt(this, "enablePan", !0), zt(this, "panSpeed", 1), zt(this, "screenSpacePanning", !0), zt(this, "keyPanSpeed", 7), zt(this, "zoomToCursor", !1), zt(this, "autoRotate", !1), zt(this, "autoRotateSpeed", 2), zt(this, "reverseOrbit", !1), zt(this, "reverseHorizontalOrbit", !1), zt(this, "reverseVerticalOrbit", !1), zt(this, "keys", {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown"
            }), zt(this, "mouseButtons", {
                LEFT: uf.ROTATE,
                MIDDLE: uf.DOLLY,
                RIGHT: uf.PAN
            }), zt(this, "touches", {
                ONE: ff.ROTATE,
                TWO: ff.DOLLY_PAN
            }), zt(this, "target0"), zt(this, "position0"), zt(this, "zoom0"), zt(this, "_domElementKeyEvents", null), zt(this, "getPolarAngle"), zt(this, "getAzimuthalAngle"), zt(this, "setPolarAngle"), zt(this, "setAzimuthalAngle"), zt(this, "getDistance"), zt(this, "getZoomScale"), zt(this, "listenToKeyEvents"), zt(this, "stopListenToKeyEvents"), zt(this, "saveState"), zt(this, "reset"), zt(this, "update"), zt(this, "connect"), zt(this, "dispose"), zt(this, "dollyIn"), zt(this, "dollyOut"), zt(this, "getScale"), zt(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = ()=>g.phi, this.getAzimuthalAngle = ()=>g.theta, this.setPolarAngle = (ie)=>{
                let xe = cE(ie, 2 * Math.PI), Ze = g.phi;
                Ze < 0 && (Ze += 2 * Math.PI), xe < 0 && (xe += 2 * Math.PI);
                let te = Math.abs(xe - Ze);
                2 * Math.PI - te < te && (xe < Ze ? xe += 2 * Math.PI : Ze += 2 * Math.PI), y.phi = xe - Ze, n.update();
            }, this.setAzimuthalAngle = (ie)=>{
                let xe = cE(ie, 2 * Math.PI), Ze = g.theta;
                Ze < 0 && (Ze += 2 * Math.PI), xe < 0 && (xe += 2 * Math.PI);
                let te = Math.abs(xe - Ze);
                2 * Math.PI - te < te && (xe < Ze ? xe += 2 * Math.PI : Ze += 2 * Math.PI), y.theta = xe - Ze, n.update();
            }, this.getDistance = ()=>n.object.position.distanceTo(n.target), this.listenToKeyEvents = (ie)=>{
                ie.addEventListener("keydown", Ne), this._domElementKeyEvents = ie;
            }, this.stopListenToKeyEvents = ()=>{
                this._domElementKeyEvents.removeEventListener("keydown", Ne), this._domElementKeyEvents = null;
            }, this.saveState = ()=>{
                n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
            }, this.reset = ()=>{
                n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), d = f.NONE;
            }, this.update = (()=>{
                const ie = new Y, xe = new Y(0, 1, 0), Ze = new mi().setFromUnitVectors(e.up, xe), te = Ze.clone().invert(), Qe = new Y, Ve = new mi, rt = 2 * Math.PI;
                return function() {
                    const Fe = n.object.position;
                    Ze.setFromUnitVectors(e.up, xe), te.copy(Ze).invert(), ie.copy(Fe).sub(n.target), ie.applyQuaternion(Ze), g.setFromVector3(ie), n.autoRotate && d === f.NONE && ge(oe()), n.enableDamping ? (g.theta += y.theta * n.dampingFactor, g.phi += y.phi * n.dampingFactor) : (g.theta += y.theta, g.phi += y.phi);
                    let ct = n.minAzimuthAngle, Mt = n.maxAzimuthAngle;
                    isFinite(ct) && isFinite(Mt) && (ct < -Math.PI ? ct += rt : ct > Math.PI && (ct -= rt), Mt < -Math.PI ? Mt += rt : Mt > Math.PI && (Mt -= rt), ct <= Mt ? g.theta = Math.max(ct, Math.min(Mt, g.theta)) : g.theta = g.theta > (ct + Mt) / 2 ? Math.max(ct, g.theta) : Math.min(Mt, g.theta)), g.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, g.phi)), g.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(x, n.dampingFactor) : n.target.add(x), n.zoomToCursor && z || n.object.isOrthographicCamera ? g.radius = ve(g.radius) : g.radius = ve(g.radius * _), ie.setFromSpherical(g), ie.applyQuaternion(te), Fe.copy(n.target).add(ie), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (y.theta *= 1 - n.dampingFactor, y.phi *= 1 - n.dampingFactor, x.multiplyScalar(1 - n.dampingFactor)) : (y.set(0, 0, 0), x.set(0, 0, 0));
                    let tn = !1;
                    if (n.zoomToCursor && z) {
                        let Zt = null;
                        if (n.object instanceof hi && n.object.isPerspectiveCamera) {
                            const gi = ie.length();
                            Zt = ve(gi * _);
                            const Zn = gi - Zt;
                            n.object.position.addScaledVector(P, Zn), n.object.updateMatrixWorld();
                        } else if (n.object.isOrthographicCamera) {
                            const gi = new Y(F.x, F.y, 0);
                            gi.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / _)), n.object.updateProjectionMatrix(), tn = !0;
                            const Zn = new Y(F.x, F.y, 0);
                            Zn.unproject(n.object), n.object.position.sub(Zn).add(gi), n.object.updateMatrixWorld(), Zt = ie.length();
                        } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
                        Zt !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Zt).add(n.object.position) : (dv.origin.copy(n.object.position), dv.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(dv.direction)) < jz ? e.lookAt(n.target) : (lE.setFromNormalAndCoplanarPoint(n.object.up, n.target), dv.intersectPlane(lE, n.target))));
                    } else n.object instanceof Yo && n.object.isOrthographicCamera && (tn = _ !== 1, tn && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / _)), n.object.updateProjectionMatrix()));
                    return _ = 1, z = !1, tn || Qe.distanceToSquared(n.object.position) > p || 8 * (1 - Ve.dot(n.object.quaternion)) > p ? (n.dispatchEvent(i), Qe.copy(n.object.position), Ve.copy(n.object.quaternion), tn = !1, !0) : !1;
                };
            })(), this.connect = (ie)=>{
                n.domElement = ie, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", vt), n.domElement.addEventListener("pointerdown", It), n.domElement.addEventListener("pointercancel", G), n.domElement.addEventListener("wheel", Le);
            }, this.dispose = ()=>{
                var ie, xe, Ze, te, Qe, Ve;
                n.domElement && (n.domElement.style.touchAction = "auto"), (ie = n.domElement) == null || ie.removeEventListener("contextmenu", vt), (xe = n.domElement) == null || xe.removeEventListener("pointerdown", It), (Ze = n.domElement) == null || Ze.removeEventListener("pointercancel", G), (te = n.domElement) == null || te.removeEventListener("wheel", Le), (Qe = n.domElement) == null || Qe.ownerDocument.removeEventListener("pointermove", Z), (Ve = n.domElement) == null || Ve.ownerDocument.removeEventListener("pointerup", G), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Ne);
            };
            const n = this, i = {
                type: "change"
            }, a = {
                type: "start"
            }, l = {
                type: "end"
            }, f = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
            let d = f.NONE;
            const p = 1e-6, g = new cS, y = new cS;
            let _ = 1;
            const x = new Y, M = new Ie, R = new Ie, T = new Ie, E = new Ie, C = new Ie, N = new Ie, D = new Ie, I = new Ie, O = new Ie, P = new Y, F = new Ie;
            let z = !1;
            const L = [], q = {};
            function oe() {
                return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
            }
            function se() {
                return Math.pow(.95, n.zoomSpeed);
            }
            function ge(ie) {
                n.reverseOrbit || n.reverseHorizontalOrbit ? y.theta += ie : y.theta -= ie;
            }
            function _e(ie) {
                n.reverseOrbit || n.reverseVerticalOrbit ? y.phi += ie : y.phi -= ie;
            }
            const H = (()=>{
                const ie = new Y;
                return function(Ze, te) {
                    ie.setFromMatrixColumn(te, 0), ie.multiplyScalar(-Ze), x.add(ie);
                };
            })(), K = (()=>{
                const ie = new Y;
                return function(Ze, te) {
                    n.screenSpacePanning === !0 ? ie.setFromMatrixColumn(te, 1) : (ie.setFromMatrixColumn(te, 0), ie.crossVectors(n.object.up, ie)), ie.multiplyScalar(Ze), x.add(ie);
                };
            })(), Q = (()=>{
                const ie = new Y;
                return function(Ze, te) {
                    const Qe = n.domElement;
                    if (Qe && n.object instanceof hi && n.object.isPerspectiveCamera) {
                        const Ve = n.object.position;
                        ie.copy(Ve).sub(n.target);
                        let rt = ie.length();
                        rt *= Math.tan(n.object.fov / 2 * Math.PI / 180), H(2 * Ze * rt / Qe.clientHeight, n.object.matrix), K(2 * te * rt / Qe.clientHeight, n.object.matrix);
                    } else Qe && n.object instanceof Yo && n.object.isOrthographicCamera ? (H(Ze * (n.object.right - n.object.left) / n.object.zoom / Qe.clientWidth, n.object.matrix), K(te * (n.object.top - n.object.bottom) / n.object.zoom / Qe.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
                };
            })();
            function fe(ie) {
                n.object instanceof hi && n.object.isPerspectiveCamera || n.object instanceof Yo && n.object.isOrthographicCamera ? _ = ie : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
            }
            function X(ie) {
                fe(_ / ie);
            }
            function $(ie) {
                fe(_ * ie);
            }
            function me(ie) {
                if (!n.zoomToCursor || !n.domElement) return;
                z = !0;
                const xe = n.domElement.getBoundingClientRect(), Ze = ie.clientX - xe.left, te = ie.clientY - xe.top, Qe = xe.width, Ve = xe.height;
                F.x = Ze / Qe * 2 - 1, F.y = -(te / Ve) * 2 + 1, P.set(F.x, F.y, 1).unproject(n.object).sub(n.object.position).normalize();
            }
            function ve(ie) {
                return Math.max(n.minDistance, Math.min(n.maxDistance, ie));
            }
            function J(ie) {
                M.set(ie.clientX, ie.clientY);
            }
            function ue(ie) {
                me(ie), D.set(ie.clientX, ie.clientY);
            }
            function he(ie) {
                E.set(ie.clientX, ie.clientY);
            }
            function De(ie) {
                R.set(ie.clientX, ie.clientY), T.subVectors(R, M).multiplyScalar(n.rotateSpeed);
                const xe = n.domElement;
                xe && (ge(2 * Math.PI * T.x / xe.clientHeight), _e(2 * Math.PI * T.y / xe.clientHeight)), M.copy(R), n.update();
            }
            function Pe(ie) {
                I.set(ie.clientX, ie.clientY), O.subVectors(I, D), O.y > 0 ? X(se()) : O.y < 0 && $(se()), D.copy(I), n.update();
            }
            function _t(ie) {
                C.set(ie.clientX, ie.clientY), N.subVectors(C, E).multiplyScalar(n.panSpeed), Q(N.x, N.y), E.copy(C), n.update();
            }
            function xt(ie) {
                me(ie), ie.deltaY < 0 ? $(se()) : ie.deltaY > 0 && X(se()), n.update();
            }
            function on(ie) {
                let xe = !1;
                switch(ie.code){
                    case n.keys.UP:
                        Q(0, n.keyPanSpeed), xe = !0;
                        break;
                    case n.keys.BOTTOM:
                        Q(0, -n.keyPanSpeed), xe = !0;
                        break;
                    case n.keys.LEFT:
                        Q(n.keyPanSpeed, 0), xe = !0;
                        break;
                    case n.keys.RIGHT:
                        Q(-n.keyPanSpeed, 0), xe = !0;
                        break;
                }
                xe && (ie.preventDefault(), n.update());
            }
            function Vt() {
                if (L.length == 1) M.set(L[0].pageX, L[0].pageY);
                else {
                    const ie = .5 * (L[0].pageX + L[1].pageX), xe = .5 * (L[0].pageY + L[1].pageY);
                    M.set(ie, xe);
                }
            }
            function Nt() {
                if (L.length == 1) E.set(L[0].pageX, L[0].pageY);
                else {
                    const ie = .5 * (L[0].pageX + L[1].pageX), xe = .5 * (L[0].pageY + L[1].pageY);
                    E.set(ie, xe);
                }
            }
            function W() {
                const ie = L[0].pageX - L[1].pageX, xe = L[0].pageY - L[1].pageY, Ze = Math.sqrt(ie * ie + xe * xe);
                D.set(0, Ze);
            }
            function et() {
                n.enableZoom && W(), n.enablePan && Nt();
            }
            function Ye() {
                n.enableZoom && W(), n.enableRotate && Vt();
            }
            function We(ie) {
                if (L.length == 1) R.set(ie.pageX, ie.pageY);
                else {
                    const Ze = St(ie), te = .5 * (ie.pageX + Ze.x), Qe = .5 * (ie.pageY + Ze.y);
                    R.set(te, Qe);
                }
                T.subVectors(R, M).multiplyScalar(n.rotateSpeed);
                const xe = n.domElement;
                xe && (ge(2 * Math.PI * T.x / xe.clientHeight), _e(2 * Math.PI * T.y / xe.clientHeight)), M.copy(R);
            }
            function Be(ie) {
                if (L.length == 1) C.set(ie.pageX, ie.pageY);
                else {
                    const xe = St(ie), Ze = .5 * (ie.pageX + xe.x), te = .5 * (ie.pageY + xe.y);
                    C.set(Ze, te);
                }
                N.subVectors(C, E).multiplyScalar(n.panSpeed), Q(N.x, N.y), E.copy(C);
            }
            function ut(ie) {
                const xe = St(ie), Ze = ie.pageX - xe.x, te = ie.pageY - xe.y, Qe = Math.sqrt(Ze * Ze + te * te);
                I.set(0, Qe), O.set(0, Math.pow(I.y / D.y, n.zoomSpeed)), X(O.y), D.copy(I);
            }
            function Xe(ie) {
                n.enableZoom && ut(ie), n.enablePan && Be(ie);
            }
            function ot(ie) {
                n.enableZoom && ut(ie), n.enableRotate && We(ie);
            }
            function It(ie) {
                var xe, Ze;
                n.enabled !== !1 && (L.length === 0 && ((xe = n.domElement) == null || xe.ownerDocument.addEventListener("pointermove", Z), (Ze = n.domElement) == null || Ze.ownerDocument.addEventListener("pointerup", G)), yt(ie), ie.pointerType === "touch" ? lt(ie) : Se(ie));
            }
            function Z(ie) {
                n.enabled !== !1 && (ie.pointerType === "touch" ? it(ie) : Ue(ie));
            }
            function G(ie) {
                var xe, Ze, te;
                He(ie), L.length === 0 && ((xe = n.domElement) == null || xe.releasePointerCapture(ie.pointerId), (Ze = n.domElement) == null || Ze.ownerDocument.removeEventListener("pointermove", Z), (te = n.domElement) == null || te.ownerDocument.removeEventListener("pointerup", G)), n.dispatchEvent(l), d = f.NONE;
            }
            function Se(ie) {
                let xe;
                switch(ie.button){
                    case 0:
                        xe = n.mouseButtons.LEFT;
                        break;
                    case 1:
                        xe = n.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        xe = n.mouseButtons.RIGHT;
                        break;
                    default:
                        xe = -1;
                }
                switch(xe){
                    case uf.DOLLY:
                        if (n.enableZoom === !1) return;
                        ue(ie), d = f.DOLLY;
                        break;
                    case uf.ROTATE:
                        if (ie.ctrlKey || ie.metaKey || ie.shiftKey) {
                            if (n.enablePan === !1) return;
                            he(ie), d = f.PAN;
                        } else {
                            if (n.enableRotate === !1) return;
                            J(ie), d = f.ROTATE;
                        }
                        break;
                    case uf.PAN:
                        if (ie.ctrlKey || ie.metaKey || ie.shiftKey) {
                            if (n.enableRotate === !1) return;
                            J(ie), d = f.ROTATE;
                        } else {
                            if (n.enablePan === !1) return;
                            he(ie), d = f.PAN;
                        }
                        break;
                    default:
                        d = f.NONE;
                }
                d !== f.NONE && n.dispatchEvent(a);
            }
            function Ue(ie) {
                if (n.enabled !== !1) switch(d){
                    case f.ROTATE:
                        if (n.enableRotate === !1) return;
                        De(ie);
                        break;
                    case f.DOLLY:
                        if (n.enableZoom === !1) return;
                        Pe(ie);
                        break;
                    case f.PAN:
                        if (n.enablePan === !1) return;
                        _t(ie);
                        break;
                }
            }
            function Le(ie) {
                n.enabled === !1 || n.enableZoom === !1 || d !== f.NONE && d !== f.ROTATE || (ie.preventDefault(), n.dispatchEvent(a), xt(ie), n.dispatchEvent(l));
            }
            function Ne(ie) {
                n.enabled === !1 || n.enablePan === !1 || on(ie);
            }
            function lt(ie) {
                switch(st(ie), L.length){
                    case 1:
                        switch(n.touches.ONE){
                            case ff.ROTATE:
                                if (n.enableRotate === !1) return;
                                Vt(), d = f.TOUCH_ROTATE;
                                break;
                            case ff.PAN:
                                if (n.enablePan === !1) return;
                                Nt(), d = f.TOUCH_PAN;
                                break;
                            default:
                                d = f.NONE;
                        }
                        break;
                    case 2:
                        switch(n.touches.TWO){
                            case ff.DOLLY_PAN:
                                if (n.enableZoom === !1 && n.enablePan === !1) return;
                                et(), d = f.TOUCH_DOLLY_PAN;
                                break;
                            case ff.DOLLY_ROTATE:
                                if (n.enableZoom === !1 && n.enableRotate === !1) return;
                                Ye(), d = f.TOUCH_DOLLY_ROTATE;
                                break;
                            default:
                                d = f.NONE;
                        }
                        break;
                    default:
                        d = f.NONE;
                }
                d !== f.NONE && n.dispatchEvent(a);
            }
            function it(ie) {
                switch(st(ie), d){
                    case f.TOUCH_ROTATE:
                        if (n.enableRotate === !1) return;
                        We(ie), n.update();
                        break;
                    case f.TOUCH_PAN:
                        if (n.enablePan === !1) return;
                        Be(ie), n.update();
                        break;
                    case f.TOUCH_DOLLY_PAN:
                        if (n.enableZoom === !1 && n.enablePan === !1) return;
                        Xe(ie), n.update();
                        break;
                    case f.TOUCH_DOLLY_ROTATE:
                        if (n.enableZoom === !1 && n.enableRotate === !1) return;
                        ot(ie), n.update();
                        break;
                    default:
                        d = f.NONE;
                }
            }
            function vt(ie) {
                n.enabled !== !1 && ie.preventDefault();
            }
            function yt(ie) {
                L.push(ie);
            }
            function He(ie) {
                delete q[ie.pointerId];
                for(let xe = 0; xe < L.length; xe++)if (L[xe].pointerId == ie.pointerId) {
                    L.splice(xe, 1);
                    return;
                }
            }
            function st(ie) {
                let xe = q[ie.pointerId];
                xe === void 0 && (xe = new Ie, q[ie.pointerId] = xe), xe.set(ie.pageX, ie.pageY);
            }
            function St(ie) {
                const xe = ie.pointerId === L[0].pointerId ? L[1] : L[0];
                return q[xe.pointerId];
            }
            this.dollyIn = (ie = se())=>{
                $(ie), n.update();
            }, this.dollyOut = (ie = se())=>{
                X(ie), n.update();
            }, this.getScale = ()=>_, this.setScale = (ie)=>{
                fe(ie), n.update();
            }, this.getZoomScale = ()=>se(), t !== void 0 && this.connect(t), this.update();
        }
    };
    function Qc(r) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(r);
        let e = "";
        for(let t = 0, n = r.length; t < n; t++)e += String.fromCharCode(r[t]);
        try {
            return decodeURIComponent(escape(e));
        } catch  {
            return e;
        }
    }
    const xf = "srgb", zl = "srgb-linear", uE = 3001, Yz = 3e3;
    class jA extends ki {
        constructor(e){
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
                return new Jz(t);
            }), this.register(function(t) {
                return new $z(t);
            }), this.register(function(t) {
                return new lB(t);
            }), this.register(function(t) {
                return new cB(t);
            }), this.register(function(t) {
                return new uB(t);
            }), this.register(function(t) {
                return new tB(t);
            }), this.register(function(t) {
                return new nB(t);
            }), this.register(function(t) {
                return new iB(t);
            }), this.register(function(t) {
                return new sB(t);
            }), this.register(function(t) {
                return new Qz(t);
            }), this.register(function(t) {
                return new aB(t);
            }), this.register(function(t) {
                return new eB(t);
            }), this.register(function(t) {
                return new oB(t);
            }), this.register(function(t) {
                return new rB(t);
            }), this.register(function(t) {
                return new Zz(t);
            }), this.register(function(t) {
                return new fB(t);
            }), this.register(function(t) {
                return new hB(t);
            });
        }
        load(e, t, n, i) {
            const a = this;
            let l;
            if (this.resourcePath !== "") l = this.resourcePath;
            else if (this.path !== "") {
                const p = Ol.extractUrlBase(e);
                l = Ol.resolveURL(p, this.path);
            } else l = Ol.extractUrlBase(e);
            this.manager.itemStart(e);
            const f = function(p) {
                i ? i(p) : console.error(p), a.manager.itemError(e), a.manager.itemEnd(e);
            }, d = new bs(this.manager);
            d.setPath(this.path), d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials), d.load(e, function(p) {
                try {
                    a.parse(p, l, function(g) {
                        t(g), a.manager.itemEnd(e);
                    }, f);
                } catch (g) {
                    f(g);
                }
            }, n, f);
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this;
        }
        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this;
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this;
        }
        register(e) {
            return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
            return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, n, i) {
            let a;
            const l = {}, f = {};
            if (typeof e == "string") a = JSON.parse(e);
            else if (e instanceof ArrayBuffer) if (Qc(new Uint8Array(e.slice(0, 4))) === qA) {
                try {
                    l[mn.KHR_BINARY_GLTF] = new dB(e);
                } catch (g) {
                    i && i(g);
                    return;
                }
                a = JSON.parse(l[mn.KHR_BINARY_GLTF].content);
            } else a = JSON.parse(Qc(new Uint8Array(e)));
            else a = e;
            if (a.asset === void 0 || a.asset.version[0] < 2) {
                i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return;
            }
            const d = new AB(a, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            d.fileLoader.setRequestHeader(this.requestHeader);
            for(let p = 0; p < this.pluginCallbacks.length; p++){
                const g = this.pluginCallbacks[p](d);
                g.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), f[g.name] = g, l[g.name] = !0;
            }
            if (a.extensionsUsed) for(let p = 0; p < a.extensionsUsed.length; ++p){
                const g = a.extensionsUsed[p], y = a.extensionsRequired || [];
                switch(g){
                    case mn.KHR_MATERIALS_UNLIT:
                        l[g] = new Kz;
                        break;
                    case mn.KHR_DRACO_MESH_COMPRESSION:
                        l[g] = new pB(a, this.dracoLoader);
                        break;
                    case mn.KHR_TEXTURE_TRANSFORM:
                        l[g] = new mB;
                        break;
                    case mn.KHR_MESH_QUANTIZATION:
                        l[g] = new gB;
                        break;
                    default:
                        y.indexOf(g) >= 0 && f[g] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + g + '".');
                }
            }
            d.setExtensions(l), d.setPlugins(f), d.parse(n, i);
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise(function(i, a) {
                n.parse(e, t, i, a);
            });
        }
    }
    function Wz() {
        let r = {};
        return {
            get: function(e) {
                return r[e];
            },
            add: function(e, t) {
                r[e] = t;
            },
            remove: function(e) {
                delete r[e];
            },
            removeAll: function() {
                r = {};
            }
        };
    }
    const mn = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class Zz {
        constructor(e){
            this.parser = e, this.name = mn.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            };
        }
        _markDefs() {
            const e = this.parser, t = this.parser.json.nodes || [];
            for(let n = 0, i = t.length; n < i; n++){
                const a = t[n];
                a.extensions && a.extensions[this.name] && a.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, a.extensions[this.name].light);
            }
        }
        _loadLight(e) {
            const t = this.parser, n = "light:" + e;
            let i = t.cache.get(n);
            if (i) return i;
            const a = t.json, d = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e];
            let p;
            const g = new tt(16777215);
            d.color !== void 0 && g.setRGB(d.color[0], d.color[1], d.color[2], zl);
            const y = d.range !== void 0 ? d.range : 0;
            switch(d.type){
                case "directional":
                    p = new jy(g), p.target.position.set(0, 0, -1), p.add(p.target);
                    break;
                case "point":
                    p = new Lm(g), p.distance = y;
                    break;
                case "spot":
                    p = new Xy(g), p.distance = y, d.spot = d.spot || {}, d.spot.innerConeAngle = d.spot.innerConeAngle !== void 0 ? d.spot.innerConeAngle : 0, d.spot.outerConeAngle = d.spot.outerConeAngle !== void 0 ? d.spot.outerConeAngle : Math.PI / 4, p.angle = d.spot.outerConeAngle, p.penumbra = 1 - d.spot.innerConeAngle / d.spot.outerConeAngle, p.target.position.set(0, 0, -1), p.add(p.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + d.type);
            }
            return p.position.set(0, 0, 0), p.decay = 2, Rl(p, d), d.intensity !== void 0 && (p.intensity = d.intensity), p.name = t.createUniqueName(d.name || "light_" + e), i = Promise.resolve(p), t.cache.add(n, i), i;
        }
        getDependency(e, t) {
            if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
            const t = this, n = this.parser, a = n.json.nodes[e], f = (a.extensions && a.extensions[this.name] || {}).light;
            return f === void 0 ? null : this._loadLight(f).then(function(d) {
                return n._getNodeRef(t.cache, f, d);
            });
        }
    }
    class Kz {
        constructor(){
            this.name = mn.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
            return ja;
        }
        extendParams(e, t, n) {
            const i = [];
            e.color = new tt(1, 1, 1), e.opacity = 1;
            const a = t.pbrMetallicRoughness;
            if (a) {
                if (Array.isArray(a.baseColorFactor)) {
                    const l = a.baseColorFactor;
                    e.color.setRGB(l[0], l[1], l[2], zl), e.opacity = l[3];
                }
                a.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", a.baseColorTexture, xf));
            }
            return Promise.all(i);
        }
    }
    class Qz {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = i.extensions[this.name].emissiveStrength;
            return a !== void 0 && (t.emissiveIntensity = a), Promise.resolve();
        }
    }
    class Jz {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            if (l.clearcoatFactor !== void 0 && (t.clearcoat = l.clearcoatFactor), l.clearcoatTexture !== void 0 && a.push(n.assignTexture(t, "clearcoatMap", l.clearcoatTexture)), l.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = l.clearcoatRoughnessFactor), l.clearcoatRoughnessTexture !== void 0 && a.push(n.assignTexture(t, "clearcoatRoughnessMap", l.clearcoatRoughnessTexture)), l.clearcoatNormalTexture !== void 0 && (a.push(n.assignTexture(t, "clearcoatNormalMap", l.clearcoatNormalTexture)), l.clearcoatNormalTexture.scale !== void 0)) {
                const f = l.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new Ie(f, f);
            }
            return Promise.all(a);
        }
    }
    class $z {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = i.extensions[this.name];
            return t.dispersion = a.dispersion !== void 0 ? a.dispersion : 0, Promise.resolve();
        }
    }
    class eB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            return l.iridescenceFactor !== void 0 && (t.iridescence = l.iridescenceFactor), l.iridescenceTexture !== void 0 && a.push(n.assignTexture(t, "iridescenceMap", l.iridescenceTexture)), l.iridescenceIor !== void 0 && (t.iridescenceIOR = l.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
                100,
                400
            ]), l.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = l.iridescenceThicknessMinimum), l.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = l.iridescenceThicknessMaximum), l.iridescenceThicknessTexture !== void 0 && a.push(n.assignTexture(t, "iridescenceThicknessMap", l.iridescenceThicknessTexture)), Promise.all(a);
        }
    }
    class tB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [];
            t.sheenColor = new tt(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const l = i.extensions[this.name];
            if (l.sheenColorFactor !== void 0) {
                const f = l.sheenColorFactor;
                t.sheenColor.setRGB(f[0], f[1], f[2], zl);
            }
            return l.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = l.sheenRoughnessFactor), l.sheenColorTexture !== void 0 && a.push(n.assignTexture(t, "sheenColorMap", l.sheenColorTexture, xf)), l.sheenRoughnessTexture !== void 0 && a.push(n.assignTexture(t, "sheenRoughnessMap", l.sheenRoughnessTexture)), Promise.all(a);
        }
    }
    class nB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            return l.transmissionFactor !== void 0 && (t.transmission = l.transmissionFactor), l.transmissionTexture !== void 0 && a.push(n.assignTexture(t, "transmissionMap", l.transmissionTexture)), Promise.all(a);
        }
    }
    class iB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            t.thickness = l.thicknessFactor !== void 0 ? l.thicknessFactor : 0, l.thicknessTexture !== void 0 && a.push(n.assignTexture(t, "thicknessMap", l.thicknessTexture)), t.attenuationDistance = l.attenuationDistance || 1 / 0;
            const f = l.attenuationColor || [
                1,
                1,
                1
            ];
            return t.attenuationColor = new tt().setRGB(f[0], f[1], f[2], zl), Promise.all(a);
        }
    }
    class sB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_IOR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = i.extensions[this.name];
            return t.ior = a.ior !== void 0 ? a.ior : 1.5, Promise.resolve();
        }
    }
    class aB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            t.specularIntensity = l.specularFactor !== void 0 ? l.specularFactor : 1, l.specularTexture !== void 0 && a.push(n.assignTexture(t, "specularIntensityMap", l.specularTexture));
            const f = l.specularColorFactor || [
                1,
                1,
                1
            ];
            return t.specularColor = new tt().setRGB(f[0], f[1], f[2], zl), l.specularColorTexture !== void 0 && a.push(n.assignTexture(t, "specularColorMap", l.specularColorTexture, xf)), Promise.all(a);
        }
    }
    class rB {
        constructor(e){
            this.parser = e, this.name = mn.EXT_MATERIALS_BUMP;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            return t.bumpScale = l.bumpFactor !== void 0 ? l.bumpFactor : 1, l.bumpTexture !== void 0 && a.push(n.assignTexture(t, "bumpMap", l.bumpTexture)), Promise.all(a);
        }
    }
    class oB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(e) {
            const n = this.parser.json.materials[e];
            return !n.extensions || !n.extensions[this.name] ? null : Er;
        }
        extendMaterialParams(e, t) {
            const n = this.parser, i = n.json.materials[e];
            if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
            const a = [], l = i.extensions[this.name];
            return l.anisotropyStrength !== void 0 && (t.anisotropy = l.anisotropyStrength), l.anisotropyRotation !== void 0 && (t.anisotropyRotation = l.anisotropyRotation), l.anisotropyTexture !== void 0 && a.push(n.assignTexture(t, "anisotropyMap", l.anisotropyTexture)), Promise.all(a);
        }
    }
    class lB {
        constructor(e){
            this.parser = e, this.name = mn.KHR_TEXTURE_BASISU;
        }
        loadTexture(e) {
            const t = this.parser, n = t.json, i = n.textures[e];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const a = i.extensions[this.name], l = t.options.ktx2Loader;
            if (!l) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null;
            }
            return t.loadTextureImage(e, a.source, l);
        }
    }
    class cB {
        constructor(e){
            this.parser = e, this.name = mn.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, i = n.json, a = i.textures[e];
            if (!a.extensions || !a.extensions[t]) return null;
            const l = a.extensions[t], f = i.images[l.source];
            let d = n.textureLoader;
            if (f.uri) {
                const p = n.options.manager.getHandler(f.uri);
                p !== null && (d = p);
            }
            return this.detectSupport().then(function(p) {
                if (p) return n.loadTextureImage(e, l.source, d);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class uB {
        constructor(e){
            this.parser = e, this.name = mn.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(e) {
            const t = this.name, n = this.parser, i = n.json, a = i.textures[e];
            if (!a.extensions || !a.extensions[t]) return null;
            const l = a.extensions[t], f = i.images[l.source];
            let d = n.textureLoader;
            if (f.uri) {
                const p = n.options.manager.getHandler(f.uri);
                p !== null && (d = p);
            }
            return this.detectSupport().then(function(p) {
                if (p) return n.loadTextureImage(e, l.source, d);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return n.loadTexture(e);
            });
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                    e(t.height === 1);
                };
            })), this.isSupported;
        }
    }
    class fB {
        constructor(e){
            this.name = mn.EXT_MESHOPT_COMPRESSION, this.parser = e;
        }
        loadBufferView(e) {
            const t = this.parser.json, n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const i = n.extensions[this.name], a = this.parser.getDependency("buffer", i.buffer), l = this.parser.options.meshoptDecoder;
                if (!l || !l.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null;
                }
                return a.then(function(f) {
                    const d = i.byteOffset || 0, p = i.byteLength || 0, g = i.count, y = i.byteStride, _ = new Uint8Array(f, d, p);
                    return l.decodeGltfBufferAsync ? l.decodeGltfBufferAsync(g, y, _, i.mode, i.filter).then(function(x) {
                        return x.buffer;
                    }) : l.ready.then(function() {
                        const x = new ArrayBuffer(g * y);
                        return l.decodeGltfBuffer(new Uint8Array(x), g, y, _, i.mode, i.filter), x;
                    });
                });
            } else return null;
        }
    }
    class hB {
        constructor(e){
            this.name = mn.EXT_MESH_GPU_INSTANCING, this.parser = e;
        }
        createNodeMesh(e) {
            const t = this.parser.json, n = t.nodes[e];
            if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
            const i = t.meshes[n.mesh];
            for (const p of i.primitives)if (p.mode !== vr.TRIANGLES && p.mode !== vr.TRIANGLE_STRIP && p.mode !== vr.TRIANGLE_FAN && p.mode !== void 0) return null;
            const l = n.extensions[this.name].attributes, f = [], d = {};
            for(const p in l)f.push(this.parser.getDependency("accessor", l[p]).then((g)=>(d[p] = g, d[p])));
            return f.length < 1 ? null : (f.push(this.parser.createNodeMesh(e)), Promise.all(f).then((p)=>{
                const g = p.pop(), y = g.isGroup ? g.children : [
                    g
                ], _ = p[0].count, x = [];
                for (const M of y){
                    const R = new pt, T = new Y, E = new mi, C = new Y(1, 1, 1), N = new HS(M.geometry, M.material, _);
                    for(let D = 0; D < _; D++)d.TRANSLATION && T.fromBufferAttribute(d.TRANSLATION, D), d.ROTATION && E.fromBufferAttribute(d.ROTATION, D), d.SCALE && C.fromBufferAttribute(d.SCALE, D), N.setMatrixAt(D, R.compose(T, E, C));
                    for(const D in d)if (D === "_COLOR_0") {
                        const I = d[D];
                        N.instanceColor = new Tf(I.array, I.itemSize, I.normalized);
                    } else D !== "TRANSLATION" && D !== "ROTATION" && D !== "SCALE" && M.geometry.setAttribute(D, d[D]);
                    hn.prototype.copy.call(N, M), this.parser.assignFinalMaterial(N), x.push(N);
                }
                return g.isGroup ? (g.clear(), g.add(...x), g) : x[0];
            }));
        }
    }
    const qA = "glTF", lm = 12, fE = {
        JSON: 1313821514,
        BIN: 5130562
    };
    class dB {
        constructor(e){
            this.name = mn.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, lm);
            if (this.header = {
                magic: Qc(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== qA) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - lm, i = new DataView(e, lm);
            let a = 0;
            for(; a < n;){
                const l = i.getUint32(a, !0);
                a += 4;
                const f = i.getUint32(a, !0);
                if (a += 4, f === fE.JSON) {
                    const d = new Uint8Array(e, lm + a, l);
                    this.content = Qc(d);
                } else if (f === fE.BIN) {
                    const d = lm + a;
                    this.body = e.slice(d, d + l);
                }
                a += l;
            }
            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
    }
    class pB {
        constructor(e, t){
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = mn.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
            const n = this.json, i = this.dracoLoader, a = e.extensions[this.name].bufferView, l = e.extensions[this.name].attributes, f = {}, d = {}, p = {};
            for(const g in l){
                const y = SS[g] || g.toLowerCase();
                f[y] = l[g];
            }
            for(const g in e.attributes){
                const y = SS[g] || g.toLowerCase();
                if (l[g] !== void 0) {
                    const _ = n.accessors[e.attributes[g]], x = fd[_.componentType];
                    p[y] = x.name, d[y] = _.normalized === !0;
                }
            }
            return t.getDependency("bufferView", a).then(function(g) {
                return new Promise(function(y, _) {
                    i.decodeDracoFile(g, function(x) {
                        for(const M in x.attributes){
                            const R = x.attributes[M], T = d[M];
                            T !== void 0 && (R.normalized = T);
                        }
                        y(x);
                    }, f, p, zl, _);
                });
            });
        }
    }
    class mB {
        constructor(){
            this.name = mn.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
            return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
        }
    }
    class gB {
        constructor(){
            this.name = mn.KHR_MESH_QUANTIZATION;
        }
    }
    class YA extends Ud {
        constructor(e, t, n, i){
            super(e, t, n, i);
        }
        copySampleValue_(e) {
            const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, a = e * i * 3 + i;
            for(let l = 0; l !== i; l++)t[l] = n[a + l];
            return t;
        }
        interpolate_(e, t, n, i) {
            const a = this.resultBuffer, l = this.sampleValues, f = this.valueSize, d = f * 2, p = f * 3, g = i - t, y = (n - t) / g, _ = y * y, x = _ * y, M = e * p, R = M - p, T = -2 * x + 3 * _, E = x - _, C = 1 - T, N = E - _ + y;
            for(let D = 0; D !== f; D++){
                const I = l[R + D + f], O = l[R + D + d] * g, P = l[M + D + f], F = l[M + D] * g;
                a[D] = C * I + N * O + T * P + E * F;
            }
            return a;
        }
    }
    const vB = new mi;
    class yB extends YA {
        interpolate_(e, t, n, i) {
            const a = super.interpolate_(e, t, n, i);
            return vB.fromArray(a).normalize().toArray(a), a;
        }
    }
    const vr = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    }, fd = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }, hE = {
        9728: cs,
        9729: pi,
        9984: my,
        9985: rd,
        9986: gf,
        9987: Xa
    }, dE = {
        33071: na,
        33648: dd,
        10497: Zo
    }, Xx = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    }, SS = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        ...PA >= 152 ? {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3"
        } : {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2"
        },
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, Hc = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }, _B = {
        CUBICSPLINE: void 0,
        LINEAR: _d,
        STEP: yd
    }, jx = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    function xB(r) {
        return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Xm({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: !1,
            depthTest: !0,
            side: Wo
        })), r.DefaultMaterial;
    }
    function cf(r, e, t) {
        for(const n in t.extensions)r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
    }
    function Rl(r, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
    }
    function SB(r, e, t) {
        let n = !1, i = !1, a = !1;
        for(let p = 0, g = e.length; p < g; p++){
            const y = e[p];
            if (y.POSITION !== void 0 && (n = !0), y.NORMAL !== void 0 && (i = !0), y.COLOR_0 !== void 0 && (a = !0), n && i && a) break;
        }
        if (!n && !i && !a) return Promise.resolve(r);
        const l = [], f = [], d = [];
        for(let p = 0, g = e.length; p < g; p++){
            const y = e[p];
            if (n) {
                const _ = y.POSITION !== void 0 ? t.getDependency("accessor", y.POSITION) : r.attributes.position;
                l.push(_);
            }
            if (i) {
                const _ = y.NORMAL !== void 0 ? t.getDependency("accessor", y.NORMAL) : r.attributes.normal;
                f.push(_);
            }
            if (a) {
                const _ = y.COLOR_0 !== void 0 ? t.getDependency("accessor", y.COLOR_0) : r.attributes.color;
                d.push(_);
            }
        }
        return Promise.all([
            Promise.all(l),
            Promise.all(f),
            Promise.all(d)
        ]).then(function(p) {
            const g = p[0], y = p[1], _ = p[2];
            return n && (r.morphAttributes.position = g), i && (r.morphAttributes.normal = y), a && (r.morphAttributes.color = _), r.morphTargetsRelative = !0, r;
        });
    }
    function bB(r, e) {
        if (r.updateMorphTargets(), e.weights !== void 0) for(let t = 0, n = e.weights.length; t < n; t++)r.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const t = e.extras.targetNames;
            if (r.morphTargetInfluences.length === t.length) {
                r.morphTargetDictionary = {};
                for(let n = 0, i = t.length; n < i; n++)r.morphTargetDictionary[t[n]] = n;
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
    function MB(r) {
        let e;
        const t = r.extensions && r.extensions[mn.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + qx(t.attributes) : e = r.indices + ":" + qx(r.attributes) + ":" + r.mode, r.targets !== void 0) for(let n = 0, i = r.targets.length; n < i; n++)e += ":" + qx(r.targets[n]);
        return e;
    }
    function qx(r) {
        let e = "";
        const t = Object.keys(r).sort();
        for(let n = 0, i = t.length; n < i; n++)e += t[n] + ":" + r[t[n]] + ";";
        return e;
    }
    function bS(r) {
        switch(r){
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
    }
    function EB(r) {
        return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
    }
    const TB = new pt;
    class AB {
        constructor(e = {}, t = {}){
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Wz, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            let n = !1, i = !1, a = -1;
            typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, a = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && a < 98 ? this.textureLoader = new eb(this.options.manager) : this.textureLoader = new sA(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new bs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
            this.extensions = e;
        }
        setPlugins(e) {
            this.plugins = e;
        }
        parse(e, t) {
            const n = this, i = this.json, a = this.extensions;
            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(l) {
                return l._markDefs && l._markDefs();
            }), Promise.all(this._invokeAll(function(l) {
                return l.beforeRoot && l.beforeRoot();
            })).then(function() {
                return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera")
                ]);
            }).then(function(l) {
                const f = {
                    scene: l[0][i.scene || 0],
                    scenes: l[0],
                    animations: l[1],
                    cameras: l[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                return cf(a, f, i), Rl(f, i), Promise.all(n._invokeAll(function(d) {
                    return d.afterRoot && d.afterRoot(f);
                })).then(function() {
                    for (const d of f.scenes)d.updateMatrixWorld();
                    e(f);
                });
            }).catch(t);
        }
        _markDefs() {
            const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
            for(let i = 0, a = t.length; i < a; i++){
                const l = t[i].joints;
                for(let f = 0, d = l.length; f < d; f++)e[l[f]].isBone = !0;
            }
            for(let i = 0, a = e.length; i < a; i++){
                const l = e[i];
                l.mesh !== void 0 && (this._addNodeRef(this.meshCache, l.mesh), l.skin !== void 0 && (n[l.mesh].isSkinnedMesh = !0)), l.camera !== void 0 && this._addNodeRef(this.cameraCache, l.camera);
            }
        }
        _addNodeRef(e, t) {
            t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const i = n.clone(), a = (l, f)=>{
                const d = this.associations.get(l);
                d != null && this.associations.set(f, d);
                for (const [p, g] of l.children.entries())a(g, f.children[p]);
            };
            return a(n, i), i.name += "_instance_" + e.uses[t]++, i;
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for(let n = 0; n < t.length; n++){
                const i = e(t[n]);
                if (i) return i;
            }
            return null;
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for(let i = 0; i < t.length; i++){
                const a = e(t[i]);
                a && n.push(a);
            }
            return n;
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let i = this.cache.get(n);
            if (!i) {
                switch(e){
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne(function(a) {
                            return a.loadNode && a.loadNode(t);
                        });
                        break;
                    case "mesh":
                        i = this._invokeOne(function(a) {
                            return a.loadMesh && a.loadMesh(t);
                        });
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne(function(a) {
                            return a.loadBufferView && a.loadBufferView(t);
                        });
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne(function(a) {
                            return a.loadMaterial && a.loadMaterial(t);
                        });
                        break;
                    case "texture":
                        i = this._invokeOne(function(a) {
                            return a.loadTexture && a.loadTexture(t);
                        });
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne(function(a) {
                            return a.loadAnimation && a.loadAnimation(t);
                        });
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne(function(a) {
                            return a != this && a.getDependency && a.getDependency(e, t);
                        }), !i) throw new Error("Unknown type: " + e);
                        break;
                }
                this.cache.add(n, i);
            }
            return i;
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
                t = Promise.all(i.map(function(a, l) {
                    return n.getDependency(e, l);
                })), this.cache.add(e, t);
            }
            return t;
        }
        loadBuffer(e) {
            const t = this.json.buffers[e], n = this.fileLoader;
            if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[mn.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise(function(a, l) {
                n.load(Ol.resolveURL(t.uri, i.path), a, void 0, function() {
                    l(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
                });
            });
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(n) {
                const i = t.byteLength || 0, a = t.byteOffset || 0;
                return n.slice(a, a + i);
            });
        }
        loadAccessor(e) {
            const t = this, n = this.json, i = this.json.accessors[e];
            if (i.bufferView === void 0 && i.sparse === void 0) {
                const l = Xx[i.type], f = fd[i.componentType], d = i.normalized === !0, p = new f(i.count * l);
                return Promise.resolve(new vn(p, l, d));
            }
            const a = [];
            return i.bufferView !== void 0 ? a.push(this.getDependency("bufferView", i.bufferView)) : a.push(null), i.sparse !== void 0 && (a.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), a.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(a).then(function(l) {
                const f = l[0], d = Xx[i.type], p = fd[i.componentType], g = p.BYTES_PER_ELEMENT, y = g * d, _ = i.byteOffset || 0, x = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, M = i.normalized === !0;
                let R, T;
                if (x && x !== y) {
                    const E = Math.floor(_ / x), C = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + E + ":" + i.count;
                    let N = t.cache.get(C);
                    N || (R = new p(f, E * x, i.count * x / g), N = new Hm(R, x / g), t.cache.add(C, N)), T = new Yc(N, d, _ % x / g, M);
                } else f === null ? R = new p(i.count * d) : R = new p(f, _, i.count * d), T = new vn(R, d, M);
                if (i.sparse !== void 0) {
                    const E = Xx.SCALAR, C = fd[i.sparse.indices.componentType], N = i.sparse.indices.byteOffset || 0, D = i.sparse.values.byteOffset || 0, I = new C(l[1], N, i.sparse.count * E), O = new p(l[2], D, i.sparse.count * d);
                    f !== null && (T = new vn(T.array.slice(), T.itemSize, T.normalized));
                    for(let P = 0, F = I.length; P < F; P++){
                        const z = I[P];
                        if (T.setX(z, O[P * d]), d >= 2 && T.setY(z, O[P * d + 1]), d >= 3 && T.setZ(z, O[P * d + 2]), d >= 4 && T.setW(z, O[P * d + 3]), d >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                    }
                }
                return T;
            });
        }
        loadTexture(e) {
            const t = this.json, n = this.options, a = t.textures[e].source, l = t.images[a];
            let f = this.textureLoader;
            if (l.uri) {
                const d = n.manager.getHandler(l.uri);
                d !== null && (f = d);
            }
            return this.loadTextureImage(e, a, f);
        }
        loadTextureImage(e, t, n) {
            const i = this, a = this.json, l = a.textures[e], f = a.images[t], d = (f.uri || f.bufferView) + ":" + l.sampler;
            if (this.textureCache[d]) return this.textureCache[d];
            const p = this.loadImageSource(t, n).then(function(g) {
                g.flipY = !1, g.name = l.name || f.name || "", g.name === "" && typeof f.uri == "string" && f.uri.startsWith("data:image/") === !1 && (g.name = f.uri);
                const _ = (a.samplers || {})[l.sampler] || {};
                return g.magFilter = hE[_.magFilter] || pi, g.minFilter = hE[_.minFilter] || Xa, g.wrapS = dE[_.wrapS] || Zo, g.wrapT = dE[_.wrapT] || Zo, i.associations.set(g, {
                    textures: e
                }), g;
            }).catch(function() {
                return null;
            });
            return this.textureCache[d] = p, p;
        }
        loadImageSource(e, t) {
            const n = this, i = this.json, a = this.options;
            if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((y)=>y.clone());
            const l = i.images[e], f = self.URL || self.webkitURL;
            let d = l.uri || "", p = !1;
            if (l.bufferView !== void 0) d = n.getDependency("bufferView", l.bufferView).then(function(y) {
                p = !0;
                const _ = new Blob([
                    y
                ], {
                    type: l.mimeType
                });
                return d = f.createObjectURL(_), d;
            });
            else if (l.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const g = Promise.resolve(d).then(function(y) {
                return new Promise(function(_, x) {
                    let M = _;
                    t.isImageBitmapLoader === !0 && (M = function(R) {
                        const T = new Qn(R);
                        T.needsUpdate = !0, _(T);
                    }), t.load(Ol.resolveURL(y, a.path), M, void 0, x);
                });
            }).then(function(y) {
                return p === !0 && f.revokeObjectURL(d), Rl(y, l), y.userData.mimeType = l.mimeType || EB(l.uri), y;
            }).catch(function(y) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", d), y;
            });
            return this.sourceCache[e] = g, g;
        }
        assignTexture(e, t, n, i) {
            const a = this;
            return this.getDependency("texture", n.index).then(function(l) {
                if (!l) return null;
                if (n.texCoord !== void 0 && n.texCoord > 0 && (l = l.clone(), l.channel = n.texCoord), a.extensions[mn.KHR_TEXTURE_TRANSFORM]) {
                    const f = n.extensions !== void 0 ? n.extensions[mn.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (f) {
                        const d = a.associations.get(l);
                        l = a.extensions[mn.KHR_TEXTURE_TRANSFORM].extendTexture(l, f), a.associations.set(l, d);
                    }
                }
                return i !== void 0 && (typeof i == "number" && (i = i === uE ? xf : zl), "colorSpace" in l ? l.colorSpace = i : l.encoding = i === xf ? uE : Yz), e[t] = l, l;
            });
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const i = t.attributes.tangent === void 0, a = t.attributes.color !== void 0, l = t.attributes.normal === void 0;
            if (e.isPoints) {
                const f = "PointsMaterial:" + n.uuid;
                let d = this.cache.get(f);
                d || (d = new kc, Li.prototype.copy.call(d, n), d.color.copy(n.color), d.map = n.map, d.sizeAttenuation = !1, this.cache.add(f, d)), n = d;
            } else if (e.isLine) {
                const f = "LineBasicMaterial:" + n.uuid;
                let d = this.cache.get(f);
                d || (d = new Vi, Li.prototype.copy.call(d, n), d.color.copy(n.color), d.map = n.map, this.cache.add(f, d)), n = d;
            }
            if (i || a || l) {
                let f = "ClonedMaterial:" + n.uuid + ":";
                i && (f += "derivative-tangents:"), a && (f += "vertex-colors:"), l && (f += "flat-shading:");
                let d = this.cache.get(f);
                d || (d = n.clone(), a && (d.vertexColors = !0), l && (d.flatShading = !0), i && (d.normalScale && (d.normalScale.y *= -1), d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)), this.cache.add(f, d), this.associations.set(d, this.associations.get(n))), n = d;
            }
            e.material = n;
        }
        getMaterialType() {
            return Xm;
        }
        loadMaterial(e) {
            const t = this, n = this.json, i = this.extensions, a = n.materials[e];
            let l;
            const f = {}, d = a.extensions || {}, p = [];
            if (d[mn.KHR_MATERIALS_UNLIT]) {
                const y = i[mn.KHR_MATERIALS_UNLIT];
                l = y.getMaterialType(), p.push(y.extendParams(f, a, t));
            } else {
                const y = a.pbrMetallicRoughness || {};
                if (f.color = new tt(1, 1, 1), f.opacity = 1, Array.isArray(y.baseColorFactor)) {
                    const _ = y.baseColorFactor;
                    f.color.setRGB(_[0], _[1], _[2], zl), f.opacity = _[3];
                }
                y.baseColorTexture !== void 0 && p.push(t.assignTexture(f, "map", y.baseColorTexture, xf)), f.metalness = y.metallicFactor !== void 0 ? y.metallicFactor : 1, f.roughness = y.roughnessFactor !== void 0 ? y.roughnessFactor : 1, y.metallicRoughnessTexture !== void 0 && (p.push(t.assignTexture(f, "metalnessMap", y.metallicRoughnessTexture)), p.push(t.assignTexture(f, "roughnessMap", y.metallicRoughnessTexture))), l = this._invokeOne(function(_) {
                    return _.getMaterialType && _.getMaterialType(e);
                }), p.push(Promise.all(this._invokeAll(function(_) {
                    return _.extendMaterialParams && _.extendMaterialParams(e, f);
                })));
            }
            a.doubleSided === !0 && (f.side = ka);
            const g = a.alphaMode || jx.OPAQUE;
            if (g === jx.BLEND ? (f.transparent = !0, f.depthWrite = !1) : (f.transparent = !1, g === jx.MASK && (f.alphaTest = a.alphaCutoff !== void 0 ? a.alphaCutoff : .5)), a.normalTexture !== void 0 && l !== ja && (p.push(t.assignTexture(f, "normalMap", a.normalTexture)), f.normalScale = new Ie(1, 1), a.normalTexture.scale !== void 0)) {
                const y = a.normalTexture.scale;
                f.normalScale.set(y, y);
            }
            if (a.occlusionTexture !== void 0 && l !== ja && (p.push(t.assignTexture(f, "aoMap", a.occlusionTexture)), a.occlusionTexture.strength !== void 0 && (f.aoMapIntensity = a.occlusionTexture.strength)), a.emissiveFactor !== void 0 && l !== ja) {
                const y = a.emissiveFactor;
                f.emissive = new tt().setRGB(y[0], y[1], y[2], zl);
            }
            return a.emissiveTexture !== void 0 && l !== ja && p.push(t.assignTexture(f, "emissiveMap", a.emissiveTexture, xf)), Promise.all(p).then(function() {
                const y = new l(f);
                return a.name && (y.name = a.name), Rl(y, a), t.associations.set(y, {
                    materials: e
                }), a.extensions && cf(i, y, a), y;
            });
        }
        createUniqueName(e) {
            const t = fn.sanitizeNodeName(e || "");
            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
        }
        loadGeometries(e) {
            const t = this, n = this.extensions, i = this.primitiveCache;
            function a(f) {
                return n[mn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(f, t).then(function(d) {
                    return pE(d, f, t);
                });
            }
            const l = [];
            for(let f = 0, d = e.length; f < d; f++){
                const p = e[f], g = MB(p), y = i[g];
                if (y) l.push(y.promise);
                else {
                    let _;
                    p.extensions && p.extensions[mn.KHR_DRACO_MESH_COMPRESSION] ? _ = a(p) : _ = pE(new Dt, p, t), i[g] = {
                        primitive: p,
                        promise: _
                    }, l.push(_);
                }
            }
            return Promise.all(l);
        }
        loadMesh(e) {
            const t = this, n = this.json, i = this.extensions, a = n.meshes[e], l = a.primitives, f = [];
            for(let d = 0, p = l.length; d < p; d++){
                const g = l[d].material === void 0 ? xB(this.cache) : this.getDependency("material", l[d].material);
                f.push(g);
            }
            return f.push(t.loadGeometries(l)), Promise.all(f).then(function(d) {
                const p = d.slice(0, d.length - 1), g = d[d.length - 1], y = [];
                for(let x = 0, M = g.length; x < M; x++){
                    const R = g[x], T = l[x];
                    let E;
                    const C = p[x];
                    if (T.mode === vr.TRIANGLES || T.mode === vr.TRIANGLE_STRIP || T.mode === vr.TRIANGLE_FAN || T.mode === void 0) E = a.isSkinnedMesh === !0 ? new Cy(R, C) : new ai(R, C), E.isSkinnedMesh === !0 && E.normalizeSkinWeights(), T.mode === vr.TRIANGLE_STRIP ? E.geometry = oE(E.geometry, US) : T.mode === vr.TRIANGLE_FAN && (E.geometry = oE(E.geometry, ny));
                    else if (T.mode === vr.LINES) E = new Ya(R, C);
                    else if (T.mode === vr.LINE_STRIP) E = new Ko(R, C);
                    else if (T.mode === vr.LINE_LOOP) E = new FS(R, C);
                    else if (T.mode === vr.POINTS) E = new cd(R, C);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + T.mode);
                    Object.keys(E.geometry.morphAttributes).length > 0 && bB(E, a), E.name = t.createUniqueName(a.name || "mesh_" + e), Rl(E, a), T.extensions && cf(i, E, T), t.assignFinalMaterial(E), y.push(E);
                }
                for(let x = 0, M = y.length; x < M; x++)t.associations.set(y[x], {
                    meshes: e,
                    primitives: x
                });
                if (y.length === 1) return a.extensions && cf(i, y[0], a), y[0];
                const _ = new Sr;
                a.extensions && cf(i, _, a), t.associations.set(_, {
                    meshes: e
                });
                for(let x = 0, M = y.length; x < M; x++)_.add(y[x]);
                return _;
            });
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e], i = n[n.type];
            if (!i) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return;
            }
            return n.type === "perspective" ? t = new hi(yr.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Yo(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Rl(t, n), Promise.resolve(t);
        }
        loadSkin(e) {
            const t = this.json.skins[e], n = [];
            for(let i = 0, a = t.joints.length; i < a; i++)n.push(this._loadNodeShallow(t.joints[i]));
            return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
                const a = i.pop(), l = i, f = [], d = [];
                for(let p = 0, g = l.length; p < g; p++){
                    const y = l[p];
                    if (y) {
                        f.push(y);
                        const _ = new pt;
                        a !== null && _.fromArray(a.array, p * 16), d.push(_);
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[p]);
                }
                return new Rd(f, d);
            });
        }
        loadAnimation(e) {
            const t = this.json, n = this, i = t.animations[e], a = i.name ? i.name : "animation_" + e, l = [], f = [], d = [], p = [], g = [];
            for(let y = 0, _ = i.channels.length; y < _; y++){
                const x = i.channels[y], M = i.samplers[x.sampler], R = x.target, T = R.node, E = i.parameters !== void 0 ? i.parameters[M.input] : M.input, C = i.parameters !== void 0 ? i.parameters[M.output] : M.output;
                R.node !== void 0 && (l.push(this.getDependency("node", T)), f.push(this.getDependency("accessor", E)), d.push(this.getDependency("accessor", C)), p.push(M), g.push(R));
            }
            return Promise.all([
                Promise.all(l),
                Promise.all(f),
                Promise.all(d),
                Promise.all(p),
                Promise.all(g)
            ]).then(function(y) {
                const _ = y[0], x = y[1], M = y[2], R = y[3], T = y[4], E = [];
                for(let C = 0, N = _.length; C < N; C++){
                    const D = _[C], I = x[C], O = M[C], P = R[C], F = T[C];
                    if (D === void 0) continue;
                    D.updateMatrix && D.updateMatrix();
                    const z = n._createAnimationTracks(D, I, O, P, F);
                    if (z) for(let L = 0; L < z.length; L++)E.push(z[L]);
                }
                return new wf(a, void 0, E);
            });
        }
        createNodeMesh(e) {
            const t = this.json, n = this, i = t.nodes[e];
            return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(a) {
                const l = n._getNodeRef(n.meshCache, i.mesh, a);
                return i.weights !== void 0 && l.traverse(function(f) {
                    if (f.isMesh) for(let d = 0, p = i.weights.length; d < p; d++)f.morphTargetInfluences[d] = i.weights[d];
                }), l;
            });
        }
        loadNode(e) {
            const t = this.json, n = this, i = t.nodes[e], a = n._loadNodeShallow(e), l = [], f = i.children || [];
            for(let p = 0, g = f.length; p < g; p++)l.push(n.getDependency("node", f[p]));
            const d = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
            return Promise.all([
                a,
                Promise.all(l),
                d
            ]).then(function(p) {
                const g = p[0], y = p[1], _ = p[2];
                _ !== null && g.traverse(function(x) {
                    x.isSkinnedMesh && x.bind(_, TB);
                });
                for(let x = 0, M = y.length; x < M; x++)g.add(y[x]);
                return g;
            });
        }
        _loadNodeShallow(e) {
            const t = this.json, n = this.extensions, i = this;
            if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
            const a = t.nodes[e], l = a.name ? i.createUniqueName(a.name) : "", f = [], d = i._invokeOne(function(p) {
                return p.createNodeMesh && p.createNodeMesh(e);
            });
            return d && f.push(d), a.camera !== void 0 && f.push(i.getDependency("camera", a.camera).then(function(p) {
                return i._getNodeRef(i.cameraCache, a.camera, p);
            })), i._invokeAll(function(p) {
                return p.createNodeAttachment && p.createNodeAttachment(e);
            }).forEach(function(p) {
                f.push(p);
            }), this.nodeCache[e] = Promise.all(f).then(function(p) {
                let g;
                if (a.isBone === !0 ? g = new Md : p.length > 1 ? g = new Sr : p.length === 1 ? g = p[0] : g = new hn, g !== p[0]) for(let y = 0, _ = p.length; y < _; y++)g.add(p[y]);
                if (a.name && (g.userData.name = a.name, g.name = l), Rl(g, a), a.extensions && cf(n, g, a), a.matrix !== void 0) {
                    const y = new pt;
                    y.fromArray(a.matrix), g.applyMatrix4(y);
                } else a.translation !== void 0 && g.position.fromArray(a.translation), a.rotation !== void 0 && g.quaternion.fromArray(a.rotation), a.scale !== void 0 && g.scale.fromArray(a.scale);
                return i.associations.has(g) || i.associations.set(g, {}), i.associations.get(g).nodes = e, g;
            }), this.nodeCache[e];
        }
        loadScene(e) {
            const t = this.extensions, n = this.json.scenes[e], i = this, a = new Sr;
            n.name && (a.name = i.createUniqueName(n.name)), Rl(a, n), n.extensions && cf(t, a, n);
            const l = n.nodes || [], f = [];
            for(let d = 0, p = l.length; d < p; d++)f.push(i.getDependency("node", l[d]));
            return Promise.all(f).then(function(d) {
                for(let g = 0, y = d.length; g < y; g++)a.add(d[g]);
                const p = (g)=>{
                    const y = new Map;
                    for (const [_, x] of i.associations)(_ instanceof Li || _ instanceof Qn) && y.set(_, x);
                    return g.traverse((_)=>{
                        const x = i.associations.get(_);
                        x != null && y.set(_, x);
                    }), y;
                };
                return i.associations = p(a), a;
            });
        }
        _createAnimationTracks(e, t, n, i, a) {
            const l = [], f = e.name ? e.name : e.uuid, d = [];
            Hc[a.path] === Hc.weights ? e.traverse(function(_) {
                _.morphTargetInfluences && d.push(_.name ? _.name : _.uuid);
            }) : d.push(f);
            let p;
            switch(Hc[a.path]){
                case Hc.weights:
                    p = Wc;
                    break;
                case Hc.rotation:
                    p = Zc;
                    break;
                case Hc.position:
                case Hc.scale:
                    p = Kc;
                    break;
                default:
                    switch(n.itemSize){
                        case 1:
                            p = Wc;
                            break;
                        case 2:
                        case 3:
                        default:
                            p = Kc;
                            break;
                    }
                    break;
            }
            const g = i.interpolation !== void 0 ? _B[i.interpolation] : _d, y = this._getArrayFromAccessor(n);
            for(let _ = 0, x = d.length; _ < x; _++){
                const M = new p(d[_] + "." + Hc[a.path], t.array, y, g);
                i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(M), l.push(M);
            }
            return l;
        }
        _getArrayFromAccessor(e) {
            let t = e.array;
            if (e.normalized) {
                const n = bS(t.constructor), i = new Float32Array(t.length);
                for(let a = 0, l = t.length; a < l; a++)i[a] = t[a] * n;
                t = i;
            }
            return t;
        }
        _createCubicSplineTrackInterpolant(e) {
            e.createInterpolant = function(n) {
                const i = this instanceof Zc ? yB : YA;
                return new i(this.times, this.values, this.getValueSize() / 3, n);
            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
        }
    }
    function wB(r, e, t) {
        const n = e.attributes, i = new Ui;
        if (n.POSITION !== void 0) {
            const f = t.json.accessors[n.POSITION], d = f.min, p = f.max;
            if (d !== void 0 && p !== void 0) {
                if (i.set(new Y(d[0], d[1], d[2]), new Y(p[0], p[1], p[2])), f.normalized) {
                    const g = bS(fd[f.componentType]);
                    i.min.multiplyScalar(g), i.max.multiplyScalar(g);
                }
            } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return;
            }
        } else return;
        const a = e.targets;
        if (a !== void 0) {
            const f = new Y, d = new Y;
            for(let p = 0, g = a.length; p < g; p++){
                const y = a[p];
                if (y.POSITION !== void 0) {
                    const _ = t.json.accessors[y.POSITION], x = _.min, M = _.max;
                    if (x !== void 0 && M !== void 0) {
                        if (d.setX(Math.max(Math.abs(x[0]), Math.abs(M[0]))), d.setY(Math.max(Math.abs(x[1]), Math.abs(M[1]))), d.setZ(Math.max(Math.abs(x[2]), Math.abs(M[2]))), _.normalized) {
                            const R = bS(fd[_.componentType]);
                            d.multiplyScalar(R);
                        }
                        f.max(d);
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
            i.expandByVector(f);
        }
        r.boundingBox = i;
        const l = new us;
        i.getCenter(l.center), l.radius = i.min.distanceTo(i.max) / 2, r.boundingSphere = l;
    }
    function pE(r, e, t) {
        const n = e.attributes, i = [];
        function a(l, f) {
            return t.getDependency("accessor", l).then(function(d) {
                r.setAttribute(f, d);
            });
        }
        for(const l in n){
            const f = SS[l] || l.toLowerCase();
            f in r.attributes || i.push(a(n[l], f));
        }
        if (e.indices !== void 0 && !r.index) {
            const l = t.getDependency("accessor", e.indices).then(function(f) {
                r.setIndex(f);
            });
            i.push(l);
        }
        return Rl(r, e), wB(r, e, t), Promise.all(i).then(function() {
            return e.targets !== void 0 ? SB(r, e.targets, t) : r;
        });
    }
    function WA(r, e, t) {
        const n = t.length - r - 1;
        if (e >= t[n]) return n - 1;
        if (e <= t[r]) return r;
        let i = r, a = n, l = Math.floor((i + a) / 2);
        for(; e < t[l] || e >= t[l + 1];)e < t[l] ? a = l : i = l, l = Math.floor((i + a) / 2);
        return l;
    }
    function RB(r, e, t, n) {
        const i = [], a = [], l = [];
        i[0] = 1;
        for(let f = 1; f <= t; ++f){
            a[f] = e - n[r + 1 - f], l[f] = n[r + f] - e;
            let d = 0;
            for(let p = 0; p < f; ++p){
                const g = l[p + 1], y = a[f - p], _ = i[p] / (g + y);
                i[p] = d + g * _, d = y * _;
            }
            i[f] = d;
        }
        return i;
    }
    function CB(r, e, t, n) {
        const i = WA(r, n, e), a = RB(i, n, r, e), l = new gn(0, 0, 0, 0);
        for(let f = 0; f <= r; ++f){
            const d = t[i - r + f], p = a[f], g = d.w * p;
            l.x += d.x * g, l.y += d.y * g, l.z += d.z * g, l.w += d.w * p;
        }
        return l;
    }
    function DB(r, e, t, n, i) {
        const a = [];
        for(let y = 0; y <= t; ++y)a[y] = 0;
        const l = [];
        for(let y = 0; y <= n; ++y)l[y] = a.slice(0);
        const f = [];
        for(let y = 0; y <= t; ++y)f[y] = a.slice(0);
        f[0][0] = 1;
        const d = a.slice(0), p = a.slice(0);
        for(let y = 1; y <= t; ++y){
            d[y] = e - i[r + 1 - y], p[y] = i[r + y] - e;
            let _ = 0;
            for(let x = 0; x < y; ++x){
                const M = p[x + 1], R = d[y - x];
                f[y][x] = M + R;
                const T = f[x][y - 1] / f[y][x];
                f[x][y] = _ + M * T, _ = R * T;
            }
            f[y][y] = _;
        }
        for(let y = 0; y <= t; ++y)l[0][y] = f[y][t];
        for(let y = 0; y <= t; ++y){
            let _ = 0, x = 1;
            const M = [];
            for(let R = 0; R <= t; ++R)M[R] = a.slice(0);
            M[0][0] = 1;
            for(let R = 1; R <= n; ++R){
                let T = 0;
                const E = y - R, C = t - R;
                y >= R && (M[x][0] = M[_][0] / f[C + 1][E], T = M[x][0] * f[E][C]);
                const N = E >= -1 ? 1 : -E, D = y - 1 <= C ? R - 1 : t - y;
                for(let O = N; O <= D; ++O)M[x][O] = (M[_][O] - M[_][O - 1]) / f[C + 1][E + O], T += M[x][O] * f[E + O][C];
                y <= C && (M[x][R] = -M[_][R - 1] / f[C + 1][y], T += M[x][R] * f[y][C]), l[R][y] = T;
                const I = _;
                _ = x, x = I;
            }
        }
        let g = t;
        for(let y = 1; y <= n; ++y){
            for(let _ = 0; _ <= t; ++_)l[y][_] *= g;
            g *= t - y;
        }
        return l;
    }
    function NB(r, e, t, n, i) {
        const a = i < r ? i : r, l = [], f = WA(r, n, e), d = DB(f, n, r, a, e), p = [];
        for(let g = 0; g < t.length; ++g){
            const y = t[g].clone(), _ = y.w;
            y.x *= _, y.y *= _, y.z *= _, p[g] = y;
        }
        for(let g = 0; g <= a; ++g){
            const y = p[f - r].clone().multiplyScalar(d[g][0]);
            for(let _ = 1; _ <= r; ++_)y.add(p[f - r + _].clone().multiplyScalar(d[g][_]));
            l[g] = y;
        }
        for(let g = a + 1; g <= i + 1; ++g)l[g] = new gn(0, 0, 0);
        return l;
    }
    function UB(r, e) {
        let t = 1;
        for(let i = 2; i <= r; ++i)t *= i;
        let n = 1;
        for(let i = 2; i <= e; ++i)n *= i;
        for(let i = 2; i <= r - e; ++i)n *= i;
        return t / n;
    }
    function LB(r) {
        const e = r.length, t = [], n = [];
        for(let a = 0; a < e; ++a){
            const l = r[a];
            t[a] = new Y(l.x, l.y, l.z), n[a] = l.w;
        }
        const i = [];
        for(let a = 0; a < e; ++a){
            const l = t[a].clone();
            for(let f = 1; f <= a; ++f)l.sub(i[a - f].clone().multiplyScalar(UB(a, f) * n[f]));
            i[a] = l.divideScalar(n[0]);
        }
        return i;
    }
    function OB(r, e, t, n, i) {
        const a = NB(r, e, t, n, i);
        return LB(a);
    }
    class mE extends Mr {
        constructor(e, t, n, i, a){
            super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = a || this.knots.length - 1;
            for(let l = 0; l < n.length; ++l){
                const f = n[l];
                this.controlPoints[l] = new gn(f.x, f.y, f.z, f.w);
            }
        }
        getPoint(e, t) {
            const n = t || new Y, i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), a = CB(this.degree, this.knots, this.controlPoints, i);
            return a.w != 1 && a.divideScalar(a.w), n.set(a.x, a.y, a.z);
        }
        getTangent(e, t) {
            const n = t || new Y, i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), a = OB(this.degree, this.knots, this.controlPoints, i, 1);
            return n.copy(a[1]).normalize(), n;
        }
    }
    let pn, Ni, xa;
    class zB extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = a.path === "" ? Ol.extractUrlBase(e) : a.path, f = new bs(this.manager);
            f.setPath(a.path), f.setResponseType("arraybuffer"), f.setRequestHeader(a.requestHeader), f.setWithCredentials(a.withCredentials), f.load(e, function(d) {
                try {
                    t(a.parse(d, l));
                } catch (p) {
                    i ? i(p) : console.error(p), a.manager.itemError(e);
                }
            }, n, i);
        }
        parse(e, t) {
            if (GB(e)) pn = new FB().parse(e);
            else {
                const i = JA(e);
                if (!VB(i)) throw new Error("THREE.FBXLoader: Unknown format.");
                if (vE(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + vE(i));
                pn = new HB().parse(i);
            }
            const n = new eb(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
            return new BB(n, this.manager).parse(pn);
        }
    }
    class BB {
        constructor(e, t){
            this.textureLoader = e, this.manager = t;
        }
        parse() {
            Ni = this.parseConnections();
            const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), i = this.parseDeformers(), a = new IB().parse(i);
            return this.parseScene(i, a, n), xa;
        }
        parseConnections() {
            const e = new Map;
            return "Connections" in pn && pn.Connections.connections.forEach(function(n) {
                const i = n[0], a = n[1], l = n[2];
                e.has(i) || e.set(i, {
                    parents: [],
                    children: []
                });
                const f = {
                    ID: a,
                    relationship: l
                };
                e.get(i).parents.push(f), e.has(a) || e.set(a, {
                    parents: [],
                    children: []
                });
                const d = {
                    ID: i,
                    relationship: l
                };
                e.get(a).children.push(d);
            }), e;
        }
        parseImages() {
            const e = {}, t = {};
            if ("Video" in pn.Objects) {
                const n = pn.Objects.Video;
                for(const i in n){
                    const a = n[i], l = parseInt(i);
                    if (e[l] = a.RelativeFilename || a.Filename, "Content" in a) {
                        const f = a.Content instanceof ArrayBuffer && a.Content.byteLength > 0, d = typeof a.Content == "string" && a.Content !== "";
                        if (f || d) {
                            const p = this.parseImage(n[i]);
                            t[a.RelativeFilename || a.Filename] = p;
                        }
                    }
                }
            }
            for(const n in e){
                const i = e[n];
                t[i] !== void 0 ? e[n] = t[i] : e[n] = e[n].split("\\").pop();
            }
            return e;
        }
        parseImage(e) {
            const t = e.Content, n = e.RelativeFilename || e.Filename, i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
            let a;
            switch(i){
                case "bmp":
                    a = "image/bmp";
                    break;
                case "jpg":
                case "jpeg":
                    a = "image/jpeg";
                    break;
                case "png":
                    a = "image/png";
                    break;
                case "tif":
                    a = "image/tiff";
                    break;
                case "tga":
                    this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), a = "image/tga";
                    break;
                default:
                    console.warn('FBXLoader: Image type "' + i + '" is not supported.');
                    return;
            }
            if (typeof t == "string") return "data:" + a + ";base64," + t;
            {
                const l = new Uint8Array(t);
                return window.URL.createObjectURL(new Blob([
                    l
                ], {
                    type: a
                }));
            }
        }
        parseTextures(e) {
            const t = new Map;
            if ("Texture" in pn.Objects) {
                const n = pn.Objects.Texture;
                for(const i in n){
                    const a = this.parseTexture(n[i], e);
                    t.set(parseInt(i), a);
                }
            }
            return t;
        }
        parseTexture(e, t) {
            const n = this.loadTexture(e, t);
            n.ID = e.id, n.name = e.attrName;
            const i = e.WrapModeU, a = e.WrapModeV, l = i !== void 0 ? i.value : 0, f = a !== void 0 ? a.value : 0;
            if (n.wrapS = l === 0 ? Zo : na, n.wrapT = f === 0 ? Zo : na, "Scaling" in e) {
                const d = e.Scaling.value;
                n.repeat.x = d[0], n.repeat.y = d[1];
            }
            return n;
        }
        loadTexture(e, t) {
            let n;
            const i = this.textureLoader.path, a = Ni.get(e.id).children;
            a !== void 0 && a.length > 0 && t[a[0].ID] !== void 0 && (n = t[a[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
            let l;
            const f = e.FileName.slice(-3).toLowerCase();
            if (f === "tga") {
                const d = this.manager.getHandler(".tga");
                d === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), l = new Qn) : (d.setPath(this.textureLoader.path), l = d.load(n));
            } else f === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), l = new Qn) : l = this.textureLoader.load(n);
            return this.textureLoader.setPath(i), l;
        }
        parseMaterials(e) {
            const t = new Map;
            if ("Material" in pn.Objects) {
                const n = pn.Objects.Material;
                for(const i in n){
                    const a = this.parseMaterial(n[i], e);
                    a !== null && t.set(parseInt(i), a);
                }
            }
            return t;
        }
        parseMaterial(e, t) {
            const n = e.id, i = e.attrName;
            let a = e.ShadingModel;
            if (typeof a == "object" && (a = a.value), !Ni.has(n)) return null;
            const l = this.parseParameters(e, t, n);
            let f;
            switch(a.toLowerCase()){
                case "phong":
                    f = new ud;
                    break;
                case "lambert":
                    f = new YS;
                    break;
                default:
                    console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', a), f = new ud;
                    break;
            }
            return f.setValues(l), f.name = i, f;
        }
        parseParameters(e, t, n) {
            const i = {};
            e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = new tt().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (i.color = new tt().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = new tt().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (i.emissive = new tt().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = new tt().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (i.specular = new tt().fromArray(e.SpecularColor.value));
            const a = this;
            return Ni.get(n).children.forEach(function(l) {
                const f = l.relationship;
                switch(f){
                    case "Bump":
                        i.bumpMap = a.getTexture(t, l.ID);
                        break;
                    case "Maya|TEX_ao_map":
                        i.aoMap = a.getTexture(t, l.ID);
                        break;
                    case "DiffuseColor":
                    case "Maya|TEX_color_map":
                        i.map = a.getTexture(t, l.ID), i.map !== void 0 && ("colorSpace" in i.map ? i.map.colorSpace = "srgb" : i.map.encoding = 3001);
                        break;
                    case "DisplacementColor":
                        i.displacementMap = a.getTexture(t, l.ID);
                        break;
                    case "EmissiveColor":
                        i.emissiveMap = a.getTexture(t, l.ID), i.emissiveMap !== void 0 && ("colorSpace" in i.emissiveMap ? i.emissiveMap.colorSpace = "srgb" : i.emissiveMap.encoding = 3001);
                        break;
                    case "NormalMap":
                    case "Maya|TEX_normal_map":
                        i.normalMap = a.getTexture(t, l.ID);
                        break;
                    case "ReflectionColor":
                        i.envMap = a.getTexture(t, l.ID), i.envMap !== void 0 && (i.envMap.mapping = hd, "colorSpace" in i.envMap ? i.envMap.colorSpace = "srgb" : i.envMap.encoding = 3001);
                        break;
                    case "SpecularColor":
                        i.specularMap = a.getTexture(t, l.ID), i.specularMap !== void 0 && ("colorSpace" in i.specularMap ? i.specularMap.colorSpace = "srgb" : i.specularMap.encoding = 3001);
                        break;
                    case "TransparentColor":
                    case "TransparencyFactor":
                        i.alphaMap = a.getTexture(t, l.ID), i.transparent = !0;
                        break;
                    case "AmbientColor":
                    case "ShininessExponent":
                    case "SpecularFactor":
                    case "VectorDisplacementColor":
                    default:
                        console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", f);
                        break;
                }
            }), i;
        }
        getTexture(e, t) {
            return "LayeredTexture" in pn.Objects && t in pn.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Ni.get(t).children[0].ID), e.get(t);
        }
        parseDeformers() {
            const e = {}, t = {};
            if ("Deformer" in pn.Objects) {
                const n = pn.Objects.Deformer;
                for(const i in n){
                    const a = n[i], l = Ni.get(parseInt(i));
                    if (a.attrType === "Skin") {
                        const f = this.parseSkeleton(l, n);
                        f.ID = i, l.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), f.geometryID = l.parents[0].ID, e[i] = f;
                    } else if (a.attrType === "BlendShape") {
                        const f = {
                            id: i
                        };
                        f.rawTargets = this.parseMorphTargets(l, n), f.id = i, l.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[i] = f;
                    }
                }
            }
            return {
                skeletons: e,
                morphTargets: t
            };
        }
        parseSkeleton(e, t) {
            const n = [];
            return e.children.forEach(function(i) {
                const a = t[i.ID];
                if (a.attrType !== "Cluster") return;
                const l = {
                    ID: i.ID,
                    indices: [],
                    weights: [],
                    transformLink: new pt().fromArray(a.TransformLink.a)
                };
                "Indexes" in a && (l.indices = a.Indexes.a, l.weights = a.Weights.a), n.push(l);
            }), {
                rawBones: n,
                bones: []
            };
        }
        parseMorphTargets(e, t) {
            const n = [];
            for(let i = 0; i < e.children.length; i++){
                const a = e.children[i], l = t[a.ID], f = {
                    name: l.attrName,
                    initialWeight: l.DeformPercent,
                    id: l.id,
                    fullWeights: l.FullWeights.a
                };
                if (l.attrType !== "BlendShapeChannel") return;
                f.geoID = Ni.get(parseInt(a.ID)).children.filter(function(d) {
                    return d.relationship === void 0;
                })[0].ID, n.push(f);
            }
            return n;
        }
        parseScene(e, t, n) {
            xa = new Sr;
            const i = this.parseModels(e.skeletons, t, n), a = pn.Objects.Model, l = this;
            i.forEach(function(d) {
                const p = a[d.ID];
                l.setLookAtProperties(d, p), Ni.get(d.ID).parents.forEach(function(y) {
                    const _ = i.get(y.ID);
                    _ !== void 0 && _.add(d);
                }), d.parent === null && xa.add(d);
            }), this.bindSkeleton(e.skeletons, t, i), this.createAmbientLight(), xa.traverse(function(d) {
                if (d.userData.transformData) {
                    d.parent && (d.userData.transformData.parentMatrix = d.parent.matrix, d.userData.transformData.parentMatrixWorld = d.parent.matrixWorld);
                    const p = KA(d.userData.transformData);
                    d.applyMatrix4(p), d.updateWorldMatrix();
                }
            });
            const f = new PB().parse();
            xa.children.length === 1 && xa.children[0].isGroup && (xa.children[0].animations = f, xa = xa.children[0]), xa.animations = f;
        }
        parseModels(e, t, n) {
            const i = new Map, a = pn.Objects.Model;
            for(const l in a){
                const f = parseInt(l), d = a[l], p = Ni.get(f);
                let g = this.buildSkeleton(p, e, f, d.attrName);
                if (!g) {
                    switch(d.attrType){
                        case "Camera":
                            g = this.createCamera(p);
                            break;
                        case "Light":
                            g = this.createLight(p);
                            break;
                        case "Mesh":
                            g = this.createMesh(p, t, n);
                            break;
                        case "NurbsCurve":
                            g = this.createCurve(p, t);
                            break;
                        case "LimbNode":
                        case "Root":
                            g = new Md;
                            break;
                        case "Null":
                        default:
                            g = new Sr;
                            break;
                    }
                    g.name = d.attrName ? fn.sanitizeNodeName(d.attrName) : "", g.ID = f;
                }
                this.getTransformData(g, d), i.set(f, g);
            }
            return i;
        }
        buildSkeleton(e, t, n, i) {
            let a = null;
            return e.parents.forEach(function(l) {
                for(const f in t){
                    const d = t[f];
                    d.rawBones.forEach(function(p, g) {
                        if (p.ID === l.ID) {
                            const y = a;
                            a = new Md, a.matrixWorld.copy(p.transformLink), a.name = i ? fn.sanitizeNodeName(i) : "", a.ID = n, d.bones[g] = a, y !== null && a.add(y);
                        }
                    });
                }
            }), a;
        }
        createCamera(e) {
            let t, n;
            if (e.children.forEach(function(i) {
                const a = pn.Objects.NodeAttribute[i.ID];
                a !== void 0 && (n = a);
            }), n === void 0) t = new hn;
            else {
                let i = 0;
                n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (i = 1);
                let a = 1;
                n.NearPlane !== void 0 && (a = n.NearPlane.value / 1e3);
                let l = 1e3;
                n.FarPlane !== void 0 && (l = n.FarPlane.value / 1e3);
                let f = window.innerWidth, d = window.innerHeight;
                n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (f = n.AspectWidth.value, d = n.AspectHeight.value);
                const p = f / d;
                let g = 45;
                n.FieldOfView !== void 0 && (g = n.FieldOfView.value);
                const y = n.FocalLength ? n.FocalLength.value : null;
                switch(i){
                    case 0:
                        t = new hi(g, p, a, l), y !== null && t.setFocalLength(y);
                        break;
                    case 1:
                        t = new Yo(-f / 2, f / 2, d / 2, -d / 2, a, l);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown camera type " + i + "."), t = new hn;
                        break;
                }
            }
            return t;
        }
        createLight(e) {
            let t, n;
            if (e.children.forEach(function(i) {
                const a = pn.Objects.NodeAttribute[i.ID];
                a !== void 0 && (n = a);
            }), n === void 0) t = new hn;
            else {
                let i;
                n.LightType === void 0 ? i = 0 : i = n.LightType.value;
                let a = 16777215;
                n.Color !== void 0 && (a = new tt().fromArray(n.Color.value));
                let l = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
                n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (l = 0);
                let f = 0;
                n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? f = 0 : f = n.FarAttenuationEnd.value);
                const d = 1;
                switch(i){
                    case 0:
                        t = new Lm(a, l, f, d);
                        break;
                    case 1:
                        t = new jy(a, l);
                        break;
                    case 2:
                        let p = Math.PI / 3;
                        n.InnerAngle !== void 0 && (p = yr.degToRad(n.InnerAngle.value));
                        let g = 0;
                        n.OuterAngle !== void 0 && (g = yr.degToRad(n.OuterAngle.value), g = Math.max(g, 1)), t = new Xy(a, l, f, p, g, d);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new Lm(a, l);
                        break;
                }
                n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
            }
            return t;
        }
        createMesh(e, t, n) {
            let i, a = null, l = null;
            const f = [];
            return e.children.forEach(function(d) {
                t.has(d.ID) && (a = t.get(d.ID)), n.has(d.ID) && f.push(n.get(d.ID));
            }), f.length > 1 ? l = f : f.length > 0 ? l = f[0] : (l = new ud({
                color: 13421772
            }), f.push(l)), "color" in a.attributes && f.forEach(function(d) {
                d.vertexColors = !0;
            }), a.FBX_Deformer ? (i = new Cy(a, l), i.normalizeSkinWeights()) : i = new ai(a, l), i;
        }
        createCurve(e, t) {
            const n = e.children.reduce(function(a, l) {
                return t.has(l.ID) && (a = t.get(l.ID)), a;
            }, null), i = new Vi({
                color: 3342591,
                linewidth: 1
            });
            return new Ko(n, i);
        }
        getTransformData(e, t) {
            const n = {};
            "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = QA(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
        }
        setLookAtProperties(e, t) {
            "LookAtProperty" in t && Ni.get(e.ID).children.forEach(function(i) {
                if (i.relationship === "LookAtProperty") {
                    const a = pn.Objects.Model[i.ID];
                    if ("Lcl_Translation" in a) {
                        const l = a.Lcl_Translation.value;
                        e.target !== void 0 ? (e.target.position.fromArray(l), xa.add(e.target)) : e.lookAt(new Y().fromArray(l));
                    }
                }
            });
        }
        bindSkeleton(e, t, n) {
            const i = this.parsePoseNodes();
            for(const a in e){
                const l = e[a];
                Ni.get(parseInt(l.ID)).parents.forEach(function(d) {
                    if (t.has(d.ID)) {
                        const p = d.ID;
                        Ni.get(p).parents.forEach(function(y) {
                            n.has(y.ID) && n.get(y.ID).bind(new Rd(l.bones), i[y.ID]);
                        });
                    }
                });
            }
        }
        parsePoseNodes() {
            const e = {};
            if ("Pose" in pn.Objects) {
                const t = pn.Objects.Pose;
                for(const n in t)if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
                    const i = t[n].PoseNode;
                    Array.isArray(i) ? i.forEach(function(a) {
                        e[a.Node] = new pt().fromArray(a.Matrix.a);
                    }) : e[i.Node] = new pt().fromArray(i.Matrix.a);
                }
            }
            return e;
        }
        createAmbientLight() {
            if ("GlobalSettings" in pn && "AmbientColor" in pn.GlobalSettings) {
                const e = pn.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], i = e[2];
                if (t !== 0 || n !== 0 || i !== 0) {
                    const a = new tt(t, n, i);
                    xa.add(new nb(a, 1));
                }
            }
        }
    }
    class IB {
        parse(e) {
            const t = new Map;
            if ("Geometry" in pn.Objects) {
                const n = pn.Objects.Geometry;
                for(const i in n){
                    const a = Ni.get(parseInt(i)), l = this.parseGeometry(a, n[i], e);
                    t.set(parseInt(i), l);
                }
            }
            return t;
        }
        parseGeometry(e, t, n) {
            switch(t.attrType){
                case "Mesh":
                    return this.parseMeshGeometry(e, t, n);
                case "NurbsCurve":
                    return this.parseNurbsGeometry(t);
            }
        }
        parseMeshGeometry(e, t, n) {
            const i = n.skeletons, a = [], l = e.parents.map(function(y) {
                return pn.Objects.Model[y.ID];
            });
            if (l.length === 0) return;
            const f = e.children.reduce(function(y, _) {
                return i[_.ID] !== void 0 && (y = i[_.ID]), y;
            }, null);
            e.children.forEach(function(y) {
                n.morphTargets[y.ID] !== void 0 && a.push(n.morphTargets[y.ID]);
            });
            const d = l[0], p = {};
            "RotationOrder" in d && (p.eulerOrder = QA(d.RotationOrder.value)), "InheritType" in d && (p.inheritType = parseInt(d.InheritType.value)), "GeometricTranslation" in d && (p.translation = d.GeometricTranslation.value), "GeometricRotation" in d && (p.rotation = d.GeometricRotation.value), "GeometricScaling" in d && (p.scale = d.GeometricScaling.value);
            const g = KA(p);
            return this.genGeometry(t, f, a, g);
        }
        genGeometry(e, t, n, i) {
            const a = new Dt;
            e.attrName && (a.name = e.attrName);
            const l = this.parseGeoNode(e, t), f = this.genBuffers(l), d = new nt(f.vertex, 3);
            if (d.applyMatrix4(i), a.setAttribute("position", d), f.colors.length > 0 && a.setAttribute("color", new nt(f.colors, 3)), t && (a.setAttribute("skinIndex", new Ty(f.weightsIndices, 4)), a.setAttribute("skinWeight", new nt(f.vertexWeights, 4)), a.FBX_Deformer = t), f.normal.length > 0) {
                const p = new Yt().getNormalMatrix(i), g = new nt(f.normal, 3);
                g.applyNormalMatrix(p), a.setAttribute("normal", g);
            }
            if (f.uvs.forEach(function(p, g) {
                Ez === "uv2" && g++;
                const y = g === 0 ? "uv" : `uv${g}`;
                a.setAttribute(y, new nt(f.uvs[g], 2));
            }), l.material && l.material.mappingType !== "AllSame") {
                let p = f.materialIndex[0], g = 0;
                if (f.materialIndex.forEach(function(y, _) {
                    y !== p && (a.addGroup(g, _ - g, p), p = y, g = _);
                }), a.groups.length > 0) {
                    const y = a.groups[a.groups.length - 1], _ = y.start + y.count;
                    _ !== f.materialIndex.length && a.addGroup(_, f.materialIndex.length - _, p);
                }
                a.groups.length === 0 && a.addGroup(0, f.materialIndex.length, f.materialIndex[0]);
            }
            return this.addMorphTargets(a, e, n, i), a;
        }
        parseGeoNode(e, t) {
            const n = {};
            if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
                n.uv = [];
                let i = 0;
                for(; e.LayerElementUV[i];)e.LayerElementUV[i].UV && n.uv.push(this.parseUVs(e.LayerElementUV[i])), i++;
            }
            return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(i, a) {
                i.indices.forEach(function(l, f) {
                    n.weightTable[l] === void 0 && (n.weightTable[l] = []), n.weightTable[l].push({
                        id: a,
                        weight: i.weights[f]
                    });
                });
            })), n;
        }
        genBuffers(e) {
            const t = {
                vertex: [],
                normal: [],
                colors: [],
                uvs: [],
                materialIndex: [],
                vertexWeights: [],
                weightsIndices: []
            };
            let n = 0, i = 0, a = !1, l = [], f = [], d = [], p = [], g = [], y = [];
            const _ = this;
            return e.vertexIndices.forEach(function(x, M) {
                let R, T = !1;
                x < 0 && (x = x ^ -1, T = !0);
                let E = [], C = [];
                if (l.push(x * 3, x * 3 + 1, x * 3 + 2), e.color) {
                    const N = pv(M, n, x, e.color);
                    d.push(N[0], N[1], N[2]);
                }
                if (e.skeleton) {
                    if (e.weightTable[x] !== void 0 && e.weightTable[x].forEach(function(N) {
                        C.push(N.weight), E.push(N.id);
                    }), C.length > 4) {
                        a || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), a = !0);
                        const N = [
                            0,
                            0,
                            0,
                            0
                        ], D = [
                            0,
                            0,
                            0,
                            0
                        ];
                        C.forEach(function(I, O) {
                            let P = I, F = E[O];
                            D.forEach(function(z, L, q) {
                                if (P > z) {
                                    q[L] = P, P = z;
                                    const oe = N[L];
                                    N[L] = F, F = oe;
                                }
                            });
                        }), E = N, C = D;
                    }
                    for(; C.length < 4;)C.push(0), E.push(0);
                    for(let N = 0; N < 4; ++N)g.push(C[N]), y.push(E[N]);
                }
                if (e.normal) {
                    const N = pv(M, n, x, e.normal);
                    f.push(N[0], N[1], N[2]);
                }
                e.material && e.material.mappingType !== "AllSame" && (R = pv(M, n, x, e.material)[0]), e.uv && e.uv.forEach(function(N, D) {
                    const I = pv(M, n, x, N);
                    p[D] === void 0 && (p[D] = []), p[D].push(I[0]), p[D].push(I[1]);
                }), i++, T && (_.genFace(t, e, l, R, f, d, p, g, y, i), n++, i = 0, l = [], f = [], d = [], p = [], g = [], y = []);
            }), t;
        }
        genFace(e, t, n, i, a, l, f, d, p, g) {
            for(let y = 2; y < g; y++)e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(y - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(y - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(y - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[y * 3]]), e.vertex.push(t.vertexPositions[n[y * 3 + 1]]), e.vertex.push(t.vertexPositions[n[y * 3 + 2]]), t.skeleton && (e.vertexWeights.push(d[0]), e.vertexWeights.push(d[1]), e.vertexWeights.push(d[2]), e.vertexWeights.push(d[3]), e.vertexWeights.push(d[(y - 1) * 4]), e.vertexWeights.push(d[(y - 1) * 4 + 1]), e.vertexWeights.push(d[(y - 1) * 4 + 2]), e.vertexWeights.push(d[(y - 1) * 4 + 3]), e.vertexWeights.push(d[y * 4]), e.vertexWeights.push(d[y * 4 + 1]), e.vertexWeights.push(d[y * 4 + 2]), e.vertexWeights.push(d[y * 4 + 3]), e.weightsIndices.push(p[0]), e.weightsIndices.push(p[1]), e.weightsIndices.push(p[2]), e.weightsIndices.push(p[3]), e.weightsIndices.push(p[(y - 1) * 4]), e.weightsIndices.push(p[(y - 1) * 4 + 1]), e.weightsIndices.push(p[(y - 1) * 4 + 2]), e.weightsIndices.push(p[(y - 1) * 4 + 3]), e.weightsIndices.push(p[y * 4]), e.weightsIndices.push(p[y * 4 + 1]), e.weightsIndices.push(p[y * 4 + 2]), e.weightsIndices.push(p[y * 4 + 3])), t.color && (e.colors.push(l[0]), e.colors.push(l[1]), e.colors.push(l[2]), e.colors.push(l[(y - 1) * 3]), e.colors.push(l[(y - 1) * 3 + 1]), e.colors.push(l[(y - 1) * 3 + 2]), e.colors.push(l[y * 3]), e.colors.push(l[y * 3 + 1]), e.colors.push(l[y * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(i), e.materialIndex.push(i), e.materialIndex.push(i)), t.normal && (e.normal.push(a[0]), e.normal.push(a[1]), e.normal.push(a[2]), e.normal.push(a[(y - 1) * 3]), e.normal.push(a[(y - 1) * 3 + 1]), e.normal.push(a[(y - 1) * 3 + 2]), e.normal.push(a[y * 3]), e.normal.push(a[y * 3 + 1]), e.normal.push(a[y * 3 + 2])), t.uv && t.uv.forEach(function(_, x) {
                e.uvs[x] === void 0 && (e.uvs[x] = []), e.uvs[x].push(f[x][0]), e.uvs[x].push(f[x][1]), e.uvs[x].push(f[x][(y - 1) * 2]), e.uvs[x].push(f[x][(y - 1) * 2 + 1]), e.uvs[x].push(f[x][y * 2]), e.uvs[x].push(f[x][y * 2 + 1]);
            });
        }
        addMorphTargets(e, t, n, i) {
            if (n.length === 0) return;
            e.morphTargetsRelative = !0, e.morphAttributes.position = [];
            const a = this;
            n.forEach(function(l) {
                l.rawTargets.forEach(function(f) {
                    const d = pn.Objects.Geometry[f.geoID];
                    d !== void 0 && a.genMorphGeometry(e, t, d, i, f.name);
                });
            });
        }
        genMorphGeometry(e, t, n, i, a) {
            const l = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], f = n.Vertices !== void 0 ? n.Vertices.a : [], d = n.Indexes !== void 0 ? n.Indexes.a : [], p = e.attributes.position.count * 3, g = new Float32Array(p);
            for(let M = 0; M < d.length; M++){
                const R = d[M] * 3;
                g[R] = f[M * 3], g[R + 1] = f[M * 3 + 1], g[R + 2] = f[M * 3 + 2];
            }
            const y = {
                vertexIndices: l,
                vertexPositions: g
            }, _ = this.genBuffers(y), x = new nt(_.vertex, 3);
            x.name = a || n.attrName, x.applyMatrix4(i), e.morphAttributes.position.push(x);
        }
        parseNormals(e) {
            const t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.Normals.a;
            let a = [];
            return n === "IndexToDirect" && ("NormalIndex" in e ? a = e.NormalIndex.a : "NormalsIndex" in e && (a = e.NormalsIndex.a)), {
                dataSize: 3,
                buffer: i,
                indices: a,
                mappingType: t,
                referenceType: n
            };
        }
        parseUVs(e) {
            const t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.UV.a;
            let a = [];
            return n === "IndexToDirect" && (a = e.UVIndex.a), {
                dataSize: 2,
                buffer: i,
                indices: a,
                mappingType: t,
                referenceType: n
            };
        }
        parseVertexColors(e) {
            const t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.Colors.a;
            let a = [];
            return n === "IndexToDirect" && (a = e.ColorIndex.a), {
                dataSize: 4,
                buffer: i,
                indices: a,
                mappingType: t,
                referenceType: n
            };
        }
        parseMaterialIndices(e) {
            const t = e.MappingInformationType, n = e.ReferenceInformationType;
            if (t === "NoMappingInformation") return {
                dataSize: 1,
                buffer: [
                    0
                ],
                indices: [
                    0
                ],
                mappingType: "AllSame",
                referenceType: n
            };
            const i = e.Materials.a, a = [];
            for(let l = 0; l < i.length; ++l)a.push(l);
            return {
                dataSize: 1,
                buffer: i,
                indices: a,
                mappingType: t,
                referenceType: n
            };
        }
        parseNurbsGeometry(e) {
            if (mE === void 0) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new Dt;
            const t = parseInt(e.Order);
            if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Dt;
            const n = t - 1, i = e.KnotVector.a, a = [], l = e.Points.a;
            for(let y = 0, _ = l.length; y < _; y += 4)a.push(new gn().fromArray(l, y));
            let f, d;
            if (e.Form === "Closed") a.push(a[0]);
            else if (e.Form === "Periodic") {
                f = n, d = i.length - 1 - f;
                for(let y = 0; y < n; ++y)a.push(a[y]);
            }
            const g = new mE(n, i, a, f, d).getPoints(a.length * 12);
            return new Dt().setFromPoints(g);
        }
    }
    class PB {
        parse() {
            const e = [], t = this.parseClips();
            if (t !== void 0) for(const n in t){
                const i = t[n], a = this.addClip(i);
                e.push(a);
            }
            return e;
        }
        parseClips() {
            if (pn.Objects.AnimationCurve === void 0) return;
            const e = this.parseAnimationCurveNodes();
            this.parseAnimationCurves(e);
            const t = this.parseAnimationLayers(e);
            return this.parseAnimStacks(t);
        }
        parseAnimationCurveNodes() {
            const e = pn.Objects.AnimationCurveNode, t = new Map;
            for(const n in e){
                const i = e[n];
                if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
                    const a = {
                        id: i.id,
                        attr: i.attrName,
                        curves: {}
                    };
                    t.set(a.id, a);
                }
            }
            return t;
        }
        parseAnimationCurves(e) {
            const t = pn.Objects.AnimationCurve;
            for(const n in t){
                const i = {
                    id: t[n].id,
                    times: t[n].KeyTime.a.map(kB),
                    values: t[n].KeyValueFloat.a
                }, a = Ni.get(i.id);
                if (a !== void 0) {
                    const l = a.parents[0].ID, f = a.parents[0].relationship;
                    f.match(/X/) ? e.get(l).curves.x = i : f.match(/Y/) ? e.get(l).curves.y = i : f.match(/Z/) ? e.get(l).curves.z = i : f.match(/d|DeformPercent/) && e.has(l) && (e.get(l).curves.morph = i);
                }
            }
        }
        parseAnimationLayers(e) {
            const t = pn.Objects.AnimationLayer, n = new Map;
            for(const i in t){
                const a = [], l = Ni.get(parseInt(i));
                l !== void 0 && (l.children.forEach(function(d, p) {
                    if (e.has(d.ID)) {
                        const g = e.get(d.ID);
                        if (g.curves.x !== void 0 || g.curves.y !== void 0 || g.curves.z !== void 0) {
                            if (a[p] === void 0) {
                                const y = Ni.get(d.ID).parents.filter(function(_) {
                                    return _.relationship !== void 0;
                                })[0].ID;
                                if (y !== void 0) {
                                    const _ = pn.Objects.Model[y.toString()];
                                    if (_ === void 0) {
                                        console.warn("THREE.FBXLoader: Encountered a unused curve.", d);
                                        return;
                                    }
                                    const x = {
                                        modelName: _.attrName ? fn.sanitizeNodeName(_.attrName) : "",
                                        ID: _.id,
                                        initialPosition: [
                                            0,
                                            0,
                                            0
                                        ],
                                        initialRotation: [
                                            0,
                                            0,
                                            0
                                        ],
                                        initialScale: [
                                            1,
                                            1,
                                            1
                                        ]
                                    };
                                    xa.traverse(function(M) {
                                        M.ID === _.id && (x.transform = M.matrix, M.userData.transformData && (x.eulerOrder = M.userData.transformData.eulerOrder));
                                    }), x.transform || (x.transform = new pt), "PreRotation" in _ && (x.preRotation = _.PreRotation.value), "PostRotation" in _ && (x.postRotation = _.PostRotation.value), a[p] = x;
                                }
                            }
                            a[p] && (a[p][g.attr] = g);
                        } else if (g.curves.morph !== void 0) {
                            if (a[p] === void 0) {
                                const y = Ni.get(d.ID).parents.filter(function(E) {
                                    return E.relationship !== void 0;
                                })[0].ID, _ = Ni.get(y).parents[0].ID, x = Ni.get(_).parents[0].ID, M = Ni.get(x).parents[0].ID, R = pn.Objects.Model[M], T = {
                                    modelName: R.attrName ? fn.sanitizeNodeName(R.attrName) : "",
                                    morphName: pn.Objects.Deformer[y].attrName
                                };
                                a[p] = T;
                            }
                            a[p][g.attr] = g;
                        }
                    }
                }), n.set(parseInt(i), a));
            }
            return n;
        }
        parseAnimStacks(e) {
            const t = pn.Objects.AnimationStack, n = {};
            for(const i in t){
                const a = Ni.get(parseInt(i)).children;
                a.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                const l = e.get(a[0].ID);
                n[i] = {
                    name: t[i].attrName,
                    layer: l
                };
            }
            return n;
        }
        addClip(e) {
            let t = [];
            const n = this;
            return e.layer.forEach(function(i) {
                t = t.concat(n.generateTracks(i));
            }), new wf(e.name, -1, t);
        }
        generateTracks(e) {
            const t = [];
            let n = new Y, i = new mi, a = new Y;
            if (e.transform && e.transform.decompose(n, i, a), n = n.toArray(), i = new $i().setFromQuaternion(i, e.eulerOrder).toArray(), a = a.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
                const l = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                l !== void 0 && t.push(l);
            }
            if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
                const l = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotation, e.postRotation, e.eulerOrder);
                l !== void 0 && t.push(l);
            }
            if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
                const l = this.generateVectorTrack(e.modelName, e.S.curves, a, "scale");
                l !== void 0 && t.push(l);
            }
            if (e.DeformPercent !== void 0) {
                const l = this.generateMorphTrack(e);
                l !== void 0 && t.push(l);
            }
            return t;
        }
        generateVectorTrack(e, t, n, i) {
            const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
            return new Kc(e + "." + i, a, l);
        }
        generateRotationTrack(e, t, n, i, a, l) {
            t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(yr.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(yr.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(yr.degToRad));
            const f = this.getTimesForAllAxes(t), d = this.getKeyframeTrackValues(f, t, n);
            i !== void 0 && (i = i.map(yr.degToRad), i.push(l), i = new $i().fromArray(i), i = new mi().setFromEuler(i)), a !== void 0 && (a = a.map(yr.degToRad), a.push(l), a = new $i().fromArray(a), a = new mi().setFromEuler(a).invert());
            const p = new mi, g = new $i, y = [];
            for(let _ = 0; _ < d.length; _ += 3)g.set(d[_], d[_ + 1], d[_ + 2], l), p.setFromEuler(g), i !== void 0 && p.premultiply(i), a !== void 0 && p.multiply(a), p.toArray(y, _ / 3 * 4);
            return new Zc(e + ".quaternion", f, y);
        }
        generateMorphTrack(e) {
            const t = e.DeformPercent.curves.morph, n = t.values.map(function(a) {
                return a / 100;
            }), i = xa.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
            return new Wc(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, n);
        }
        getTimesForAllAxes(e) {
            let t = [];
            if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, i) {
                return n - i;
            }), t.length > 1) {
                let n = 1, i = t[0];
                for(let a = 1; a < t.length; a++){
                    const l = t[a];
                    l !== i && (t[n] = l, i = l, n++);
                }
                t = t.slice(0, n);
            }
            return t;
        }
        getKeyframeTrackValues(e, t, n) {
            const i = n, a = [];
            let l = -1, f = -1, d = -1;
            return e.forEach(function(p) {
                if (t.x && (l = t.x.times.indexOf(p)), t.y && (f = t.y.times.indexOf(p)), t.z && (d = t.z.times.indexOf(p)), l !== -1) {
                    const g = t.x.values[l];
                    a.push(g), i[0] = g;
                } else a.push(i[0]);
                if (f !== -1) {
                    const g = t.y.values[f];
                    a.push(g), i[1] = g;
                } else a.push(i[1]);
                if (d !== -1) {
                    const g = t.z.values[d];
                    a.push(g), i[2] = g;
                } else a.push(i[2]);
            }), a;
        }
        interpolateRotations(e) {
            for(let t = 1; t < e.values.length; t++){
                const n = e.values[t - 1], i = e.values[t] - n, a = Math.abs(i);
                if (a >= 180) {
                    const l = a / 180, f = i / l;
                    let d = n + f;
                    const p = e.times[t - 1], y = (e.times[t] - p) / l;
                    let _ = p + y;
                    const x = [], M = [];
                    for(; _ < e.times[t];)x.push(_), _ += y, M.push(d), d += f;
                    e.times = yE(e.times, t, x), e.values = yE(e.values, t, M);
                }
            }
        }
    }
    class HB {
        getPrevNode() {
            return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
            return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
            return this.currentProp;
        }
        pushStack(e) {
            this.nodeStack.push(e), this.currentIndent += 1;
        }
        popStack() {
            this.nodeStack.pop(), this.currentIndent -= 1;
        }
        setCurrentProp(e, t) {
            this.currentProp = e, this.currentPropName = t;
        }
        parse(e) {
            this.currentIndent = 0, this.allNodes = new ZA, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
            const t = this, n = e.split(/[\r\n]+/);
            return n.forEach(function(i, a) {
                const l = i.match(/^[\s\t]*;/), f = i.match(/^[\s\t]*$/);
                if (l || f) return;
                const d = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), p = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), g = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
                d ? t.parseNodeBegin(i, d) : p ? t.parseNodeProperty(i, p, n[++a]) : g ? t.popStack() : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i);
            }), this.allNodes;
        }
        parseNodeBegin(e, t) {
            const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), i = t[2].split(",").map(function(d) {
                return d.trim().replace(/^"/, "").replace(/"$/, "");
            }), a = {
                name: n
            }, l = this.parseNodeAttr(i), f = this.getCurrentNode();
            this.currentIndent === 0 ? this.allNodes.add(n, a) : n in f ? (n === "PoseNode" ? f.PoseNode.push(a) : f[n].id !== void 0 && (f[n] = {}, f[n][f[n].id] = f[n]), l.id !== "" && (f[n][l.id] = a)) : typeof l.id == "number" ? (f[n] = {}, f[n][l.id] = a) : n !== "Properties70" && (n === "PoseNode" ? f[n] = [
                a
            ] : f[n] = a), typeof l.id == "number" && (a.id = l.id), l.name !== "" && (a.attrName = l.name), l.type !== "" && (a.attrType = l.type), this.pushStack(a);
        }
        parseNodeAttr(e) {
            let t = e[0];
            e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
            let n = "", i = "";
            return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), i = e[2]), {
                id: t,
                name: n,
                type: i
            };
        }
        parseNodeProperty(e, t, n) {
            let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(), a = t[2].replace(/^"/, "").replace(/"$/, "").trim();
            i === "Content" && a === "," && (a = n.replace(/"/g, "").replace(/,$/, "").trim());
            const l = this.getCurrentNode();
            if (l.name === "Properties70") {
                this.parseNodeSpecialProperty(e, i, a);
                return;
            }
            if (i === "C") {
                const d = a.split(",").slice(1), p = parseInt(d[0]), g = parseInt(d[1]);
                let y = a.split(",").slice(3);
                y = y.map(function(_) {
                    return _.trim().replace(/^"/, "");
                }), i = "connections", a = [
                    p,
                    g
                ], jB(a, y), l[i] === void 0 && (l[i] = []);
            }
            i === "Node" && (l.id = a), i in l && Array.isArray(l[i]) ? l[i].push(a) : i !== "a" ? l[i] = a : l.a = a, this.setCurrentProp(l, i), i === "a" && a.slice(-1) !== "," && (l.a = Wx(a));
        }
        parseNodePropertyContinued(e) {
            const t = this.getCurrentNode();
            t.a += e, e.slice(-1) !== "," && (t.a = Wx(t.a));
        }
        parseNodeSpecialProperty(e, t, n) {
            const i = n.split('",').map(function(g) {
                return g.trim().replace(/^\"/, "").replace(/\s/, "_");
            }), a = i[0], l = i[1], f = i[2], d = i[3];
            let p = i[4];
            switch(l){
                case "int":
                case "enum":
                case "bool":
                case "ULongLong":
                case "double":
                case "Number":
                case "FieldOfView":
                    p = parseFloat(p);
                    break;
                case "Color":
                case "ColorRGB":
                case "Vector3D":
                case "Lcl_Translation":
                case "Lcl_Rotation":
                case "Lcl_Scaling":
                    p = Wx(p);
                    break;
            }
            this.getPrevNode()[a] = {
                type: l,
                type2: f,
                flag: d,
                value: p
            }, this.setCurrentProp(this.getPrevNode(), a);
        }
    }
    class FB {
        parse(e) {
            const t = new gE(e);
            t.skip(23);
            const n = t.getUint32();
            if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
            const i = new ZA;
            for(; !this.endOfContent(t);){
                const a = this.parseNode(t, n);
                a !== null && i.add(a.name, a);
            }
            return i;
        }
        endOfContent(e) {
            return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
        }
        parseNode(e, t) {
            const n = {}, i = t >= 7500 ? e.getUint64() : e.getUint32(), a = t >= 7500 ? e.getUint64() : e.getUint32();
            t >= 7500 ? e.getUint64() : e.getUint32();
            const l = e.getUint8(), f = e.getString(l);
            if (i === 0) return null;
            const d = [];
            for(let _ = 0; _ < a; _++)d.push(this.parseProperty(e));
            const p = d.length > 0 ? d[0] : "", g = d.length > 1 ? d[1] : "", y = d.length > 2 ? d[2] : "";
            for(n.singleProperty = a === 1 && e.getOffset() === i; i > e.getOffset();){
                const _ = this.parseNode(e, t);
                _ !== null && this.parseSubNode(f, n, _);
            }
            return n.propertyList = d, typeof p == "number" && (n.id = p), g !== "" && (n.attrName = g), y !== "" && (n.attrType = y), f !== "" && (n.name = f), n;
        }
        parseSubNode(e, t, n) {
            if (n.singleProperty === !0) {
                const i = n.propertyList[0];
                Array.isArray(i) ? (t[n.name] = n, n.a = i) : t[n.name] = i;
            } else if (e === "Connections" && n.name === "C") {
                const i = [];
                n.propertyList.forEach(function(a, l) {
                    l !== 0 && i.push(a);
                }), t.connections === void 0 && (t.connections = []), t.connections.push(i);
            } else if (n.name === "Properties70") Object.keys(n).forEach(function(a) {
                t[a] = n[a];
            });
            else if (e === "Properties70" && n.name === "P") {
                let i = n.propertyList[0], a = n.propertyList[1];
                const l = n.propertyList[2], f = n.propertyList[3];
                let d;
                i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), a.indexOf("Lcl ") === 0 && (a = a.replace("Lcl ", "Lcl_")), a === "Color" || a === "ColorRGB" || a === "Vector" || a === "Vector3D" || a.indexOf("Lcl_") === 0 ? d = [
                    n.propertyList[4],
                    n.propertyList[5],
                    n.propertyList[6]
                ] : d = n.propertyList[4], t[i] = {
                    type: a,
                    type2: l,
                    flag: f,
                    value: d
                };
            } else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [
                t[n.name]
            ]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
        }
        parseProperty(e) {
            const t = e.getString(1);
            let n;
            switch(t){
                case "C":
                    return e.getBoolean();
                case "D":
                    return e.getFloat64();
                case "F":
                    return e.getFloat32();
                case "I":
                    return e.getInt32();
                case "L":
                    return e.getInt64();
                case "R":
                    return n = e.getUint32(), e.getArrayBuffer(n);
                case "S":
                    return n = e.getUint32(), e.getString(n);
                case "Y":
                    return e.getInt16();
                case "b":
                case "c":
                case "d":
                case "f":
                case "i":
                case "l":
                    const i = e.getUint32(), a = e.getUint32(), l = e.getUint32();
                    if (a === 0) switch(t){
                        case "b":
                        case "c":
                            return e.getBooleanArray(i);
                        case "d":
                            return e.getFloat64Array(i);
                        case "f":
                            return e.getFloat32Array(i);
                        case "i":
                            return e.getInt32Array(i);
                        case "l":
                            return e.getInt64Array(i);
                    }
                    const f = Bz(new Uint8Array(e.getArrayBuffer(l))), d = new gE(f.buffer);
                    switch(t){
                        case "b":
                        case "c":
                            return d.getBooleanArray(i);
                        case "d":
                            return d.getFloat64Array(i);
                        case "f":
                            return d.getFloat32Array(i);
                        case "i":
                            return d.getInt32Array(i);
                        case "l":
                            return d.getInt64Array(i);
                    }
                default:
                    throw new Error("THREE.FBXLoader: Unknown property type " + t);
            }
        }
    }
    class gE {
        constructor(e, t){
            this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
        }
        getOffset() {
            return this.offset;
        }
        size() {
            return this.dv.buffer.byteLength;
        }
        skip(e) {
            this.offset += e;
        }
        getBoolean() {
            return (this.getUint8() & 1) === 1;
        }
        getBooleanArray(e) {
            const t = [];
            for(let n = 0; n < e; n++)t.push(this.getBoolean());
            return t;
        }
        getUint8() {
            const e = this.dv.getUint8(this.offset);
            return this.offset += 1, e;
        }
        getInt16() {
            const e = this.dv.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, e;
        }
        getInt32() {
            const e = this.dv.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, e;
        }
        getInt32Array(e) {
            const t = [];
            for(let n = 0; n < e; n++)t.push(this.getInt32());
            return t;
        }
        getUint32() {
            const e = this.dv.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, e;
        }
        getInt64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
        }
        getInt64Array(e) {
            const t = [];
            for(let n = 0; n < e; n++)t.push(this.getInt64());
            return t;
        }
        getUint64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
        }
        getFloat32() {
            const e = this.dv.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, e;
        }
        getFloat32Array(e) {
            const t = [];
            for(let n = 0; n < e; n++)t.push(this.getFloat32());
            return t;
        }
        getFloat64() {
            const e = this.dv.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, e;
        }
        getFloat64Array(e) {
            const t = [];
            for(let n = 0; n < e; n++)t.push(this.getFloat64());
            return t;
        }
        getArrayBuffer(e) {
            const t = this.dv.buffer.slice(this.offset, this.offset + e);
            return this.offset += e, t;
        }
        getString(e) {
            let t = [];
            for(let i = 0; i < e; i++)t[i] = this.getUint8();
            const n = t.indexOf(0);
            return n >= 0 && (t = t.slice(0, n)), Qc(new Uint8Array(t));
        }
    }
    class ZA {
        add(e, t) {
            this[e] = t;
        }
    }
    function GB(r) {
        const e = "Kaydara FBX Binary  \0";
        return r.byteLength >= e.length && e === JA(r, 0, e.length);
    }
    function VB(r) {
        const e = [
            "K",
            "a",
            "y",
            "d",
            "a",
            "r",
            "a",
            "\\",
            "F",
            "B",
            "X",
            "\\",
            "B",
            "i",
            "n",
            "a",
            "r",
            "y",
            "\\",
            "\\"
        ];
        let t = 0;
        function n(i) {
            const a = r[i - 1];
            return r = r.slice(t + i), t++, a;
        }
        for(let i = 0; i < e.length; ++i)if (n(1) === e[i]) return !1;
        return !0;
    }
    function vE(r) {
        const e = /FBXVersion: (\d+)/, t = r.match(e);
        if (t) return parseInt(t[1]);
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
    }
    function kB(r) {
        return r / 46186158e3;
    }
    const XB = [];
    function pv(r, e, t, n) {
        let i;
        switch(n.mappingType){
            case "ByPolygonVertex":
                i = r;
                break;
            case "ByPolygon":
                i = e;
                break;
            case "ByVertice":
                i = t;
                break;
            case "AllSame":
                i = n.indices[0];
                break;
            default:
                console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
        }
        n.referenceType === "IndexToDirect" && (i = n.indices[i]);
        const a = i * n.dataSize, l = a + n.dataSize;
        return qB(XB, n.buffer, a, l);
    }
    const Yx = new $i, id = new Y;
    function KA(r) {
        const e = new pt, t = new pt, n = new pt, i = new pt, a = new pt, l = new pt, f = new pt, d = new pt, p = new pt, g = new pt, y = new pt, _ = new pt, x = r.inheritType ? r.inheritType : 0;
        if (r.translation && e.setPosition(id.fromArray(r.translation)), r.preRotation) {
            const L = r.preRotation.map(yr.degToRad);
            L.push(r.eulerOrder), t.makeRotationFromEuler(Yx.fromArray(L));
        }
        if (r.rotation) {
            const L = r.rotation.map(yr.degToRad);
            L.push(r.eulerOrder), n.makeRotationFromEuler(Yx.fromArray(L));
        }
        if (r.postRotation) {
            const L = r.postRotation.map(yr.degToRad);
            L.push(r.eulerOrder), i.makeRotationFromEuler(Yx.fromArray(L)), i.invert();
        }
        r.scale && a.scale(id.fromArray(r.scale)), r.scalingOffset && f.setPosition(id.fromArray(r.scalingOffset)), r.scalingPivot && l.setPosition(id.fromArray(r.scalingPivot)), r.rotationOffset && d.setPosition(id.fromArray(r.rotationOffset)), r.rotationPivot && p.setPosition(id.fromArray(r.rotationPivot)), r.parentMatrixWorld && (y.copy(r.parentMatrix), g.copy(r.parentMatrixWorld));
        const M = t.clone().multiply(n).multiply(i), R = new pt;
        R.extractRotation(g);
        const T = new pt;
        T.copyPosition(g);
        const E = T.clone().invert().multiply(g), C = R.clone().invert().multiply(E), N = a, D = new pt;
        if (x === 0) D.copy(R).multiply(M).multiply(C).multiply(N);
        else if (x === 1) D.copy(R).multiply(C).multiply(M).multiply(N);
        else {
            const q = new pt().scale(new Y().setFromMatrixScale(y)).clone().invert(), oe = C.clone().multiply(q);
            D.copy(R).multiply(M).multiply(oe).multiply(N);
        }
        const I = p.clone().invert(), O = l.clone().invert();
        let P = e.clone().multiply(d).multiply(p).multiply(t).multiply(n).multiply(i).multiply(I).multiply(f).multiply(l).multiply(a).multiply(O);
        const F = new pt().copyPosition(P), z = g.clone().multiply(F);
        return _.copyPosition(z), P = _.clone().multiply(D), P.premultiply(g.invert()), P;
    }
    function QA(r) {
        r = r || 0;
        const e = [
            "ZYX",
            "YZX",
            "XZY",
            "ZXY",
            "YXZ",
            "XYZ"
        ];
        return r === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[r];
    }
    function Wx(r) {
        return r.split(",").map(function(t) {
            return parseFloat(t);
        });
    }
    function JA(r, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = r.byteLength), Qc(new Uint8Array(r, e, t));
    }
    function jB(r, e) {
        for(let t = 0, n = r.length, i = e.length; t < i; t++, n++)r[n] = e[t];
    }
    function qB(r, e, t, n) {
        for(let i = t, a = 0; i < n; i++, a++)r[a] = e[i];
        return r;
    }
    function yE(r, e, t) {
        return r.slice(0, e).concat(t).concat(r.slice(e));
    }
    class YB extends QT {
        constructor(e){
            super(e);
        }
        parse(e) {
            function t(H) {
                switch(H.image_type){
                    case _:
                    case R:
                        (H.colormap_length > 256 || H.colormap_size !== 24 || H.colormap_type !== 1) && console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
                        break;
                    case x:
                    case M:
                    case T:
                    case E:
                        H.colormap_type && console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
                        break;
                    case y:
                        console.error("THREE.TGALoader: No data.");
                    default:
                        console.error('THREE.TGALoader: Invalid type "%s".', H.image_type);
                }
                (H.width <= 0 || H.height <= 0) && console.error("THREE.TGALoader: Invalid image size."), H.pixel_size !== 8 && H.pixel_size !== 16 && H.pixel_size !== 24 && H.pixel_size !== 32 && console.error('THREE.TGALoader: Invalid pixel size "%s".', H.pixel_size);
            }
            function n(H, K, Q, fe, X) {
                let $, me;
                const ve = Q.pixel_size >> 3, J = Q.width * Q.height * ve;
                if (K && (me = X.subarray(fe, fe += Q.colormap_length * (Q.colormap_size >> 3))), H) {
                    $ = new Uint8Array(J);
                    let ue, he, De, Pe = 0;
                    const _t = new Uint8Array(ve);
                    for(; Pe < J;)if (ue = X[fe++], he = (ue & 127) + 1, ue & 128) {
                        for(De = 0; De < ve; ++De)_t[De] = X[fe++];
                        for(De = 0; De < he; ++De)$.set(_t, Pe + De * ve);
                        Pe += ve * he;
                    } else {
                        for(he *= ve, De = 0; De < he; ++De)$[Pe + De] = X[fe++];
                        Pe += he;
                    }
                } else $ = X.subarray(fe, fe += K ? Q.width * Q.height : J);
                return {
                    pixel_data: $,
                    palettes: me
                };
            }
            function i(H, K, Q, fe, X, $, me, ve, J) {
                const ue = J;
                let he, De = 0, Pe, _t;
                const xt = L.width;
                for(_t = K; _t !== fe; _t += Q)for(Pe = X; Pe !== me; Pe += $, De++)he = ve[De], H[(Pe + xt * _t) * 4 + 3] = 255, H[(Pe + xt * _t) * 4 + 2] = ue[he * 3 + 0], H[(Pe + xt * _t) * 4 + 1] = ue[he * 3 + 1], H[(Pe + xt * _t) * 4 + 0] = ue[he * 3 + 2];
                return H;
            }
            function a(H, K, Q, fe, X, $, me, ve) {
                let J, ue = 0, he, De;
                const Pe = L.width;
                for(De = K; De !== fe; De += Q)for(he = X; he !== me; he += $, ue += 2)J = ve[ue + 0] + (ve[ue + 1] << 8), H[(he + Pe * De) * 4 + 0] = (J & 31744) >> 7, H[(he + Pe * De) * 4 + 1] = (J & 992) >> 2, H[(he + Pe * De) * 4 + 2] = (J & 31) >> 3, H[(he + Pe * De) * 4 + 3] = J & 32768 ? 0 : 255;
                return H;
            }
            function l(H, K, Q, fe, X, $, me, ve) {
                let J = 0, ue, he;
                const De = L.width;
                for(he = K; he !== fe; he += Q)for(ue = X; ue !== me; ue += $, J += 3)H[(ue + De * he) * 4 + 3] = 255, H[(ue + De * he) * 4 + 2] = ve[J + 0], H[(ue + De * he) * 4 + 1] = ve[J + 1], H[(ue + De * he) * 4 + 0] = ve[J + 2];
                return H;
            }
            function f(H, K, Q, fe, X, $, me, ve) {
                let J = 0, ue, he;
                const De = L.width;
                for(he = K; he !== fe; he += Q)for(ue = X; ue !== me; ue += $, J += 4)H[(ue + De * he) * 4 + 2] = ve[J + 0], H[(ue + De * he) * 4 + 1] = ve[J + 1], H[(ue + De * he) * 4 + 0] = ve[J + 2], H[(ue + De * he) * 4 + 3] = ve[J + 3];
                return H;
            }
            function d(H, K, Q, fe, X, $, me, ve) {
                let J, ue = 0, he, De;
                const Pe = L.width;
                for(De = K; De !== fe; De += Q)for(he = X; he !== me; he += $, ue++)J = ve[ue], H[(he + Pe * De) * 4 + 0] = J, H[(he + Pe * De) * 4 + 1] = J, H[(he + Pe * De) * 4 + 2] = J, H[(he + Pe * De) * 4 + 3] = 255;
                return H;
            }
            function p(H, K, Q, fe, X, $, me, ve) {
                let J = 0, ue, he;
                const De = L.width;
                for(he = K; he !== fe; he += Q)for(ue = X; ue !== me; ue += $, J += 2)H[(ue + De * he) * 4 + 0] = ve[J + 0], H[(ue + De * he) * 4 + 1] = ve[J + 0], H[(ue + De * he) * 4 + 2] = ve[J + 0], H[(ue + De * he) * 4 + 3] = ve[J + 1];
                return H;
            }
            function g(H, K, Q, fe, X) {
                let $, me, ve, J, ue, he;
                switch((L.flags & C) >> N){
                    default:
                    case O:
                        $ = 0, ve = 1, ue = K, me = 0, J = 1, he = Q;
                        break;
                    case D:
                        $ = 0, ve = 1, ue = K, me = Q - 1, J = -1, he = -1;
                        break;
                    case P:
                        $ = K - 1, ve = -1, ue = -1, me = 0, J = 1, he = Q;
                        break;
                    case I:
                        $ = K - 1, ve = -1, ue = -1, me = Q - 1, J = -1, he = -1;
                        break;
                }
                if (se) switch(L.pixel_size){
                    case 8:
                        d(H, me, J, he, $, ve, ue, fe);
                        break;
                    case 16:
                        p(H, me, J, he, $, ve, ue, fe);
                        break;
                    default:
                        console.error("THREE.TGALoader: Format not supported.");
                        break;
                }
                else switch(L.pixel_size){
                    case 8:
                        i(H, me, J, he, $, ve, ue, fe, X);
                        break;
                    case 16:
                        a(H, me, J, he, $, ve, ue, fe);
                        break;
                    case 24:
                        l(H, me, J, he, $, ve, ue, fe);
                        break;
                    case 32:
                        f(H, me, J, he, $, ve, ue, fe);
                        break;
                    default:
                        console.error("THREE.TGALoader: Format not supported.");
                        break;
                }
                return H;
            }
            const y = 0, _ = 1, x = 2, M = 3, R = 9, T = 10, E = 11, C = 48, N = 4, D = 0, I = 1, O = 2, P = 3;
            e.length < 19 && console.error("THREE.TGALoader: Not enough data to contain header.");
            let F = 0;
            const z = new Uint8Array(e), L = {
                id_length: z[F++],
                colormap_type: z[F++],
                image_type: z[F++],
                colormap_index: z[F++] | z[F++] << 8,
                colormap_length: z[F++] | z[F++] << 8,
                colormap_size: z[F++],
                origin: [
                    z[F++] | z[F++] << 8,
                    z[F++] | z[F++] << 8
                ],
                width: z[F++] | z[F++] << 8,
                height: z[F++] | z[F++] << 8,
                pixel_size: z[F++],
                flags: z[F++]
            };
            t(L), L.id_length + F > e.length && console.error("THREE.TGALoader: No data."), F += L.id_length;
            let q = !1, oe = !1, se = !1;
            switch(L.image_type){
                case R:
                    q = !0, oe = !0;
                    break;
                case _:
                    oe = !0;
                    break;
                case T:
                    q = !0;
                    break;
                case x:
                    break;
                case E:
                    q = !0, se = !0;
                    break;
                case M:
                    se = !0;
                    break;
            }
            const ge = new Uint8Array(L.width * L.height * 4), _e = n(q, oe, L, F, z);
            return g(ge, L.width, L.height, _e.pixel_data, _e.palettes), {
                data: ge,
                width: L.width,
                height: L.height,
                flipY: !0,
                generateMipmaps: !0,
                minFilter: Xa
            };
        }
    }
    class WB extends ki {
        constructor(e){
            super(e);
        }
        load(e, t, n, i) {
            const a = this, l = new bs(this.manager);
            l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(f));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        parse(e) {
            function t(p) {
                const g = new DataView(p), y = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8, _ = g.getUint32(80, !0);
                if (80 + 32 / 8 + _ * y === g.byteLength) return !0;
                const M = [
                    115,
                    111,
                    108,
                    105,
                    100
                ];
                for(let R = 0; R < 5; R++)if (n(M, g, R)) return !1;
                return !0;
            }
            function n(p, g, y) {
                for(let _ = 0, x = p.length; _ < x; _++)if (p[_] !== g.getUint8(y + _, !1)) return !1;
                return !0;
            }
            function i(p) {
                const g = new DataView(p), y = g.getUint32(80, !0);
                let _, x, M, R = !1, T, E, C, N, D;
                for(let L = 0; L < 70; L++)g.getUint32(L, !1) == 1129270351 && g.getUint8(L + 4) == 82 && g.getUint8(L + 5) == 61 && (R = !0, T = new Float32Array(y * 3 * 3), E = g.getUint8(L + 6) / 255, C = g.getUint8(L + 7) / 255, N = g.getUint8(L + 8) / 255, D = g.getUint8(L + 9) / 255);
                const I = 84, O = 50, P = new Dt, F = new Float32Array(y * 3 * 3), z = new Float32Array(y * 3 * 3);
                for(let L = 0; L < y; L++){
                    const q = I + L * O, oe = g.getFloat32(q, !0), se = g.getFloat32(q + 4, !0), ge = g.getFloat32(q + 8, !0);
                    if (R) {
                        const _e = g.getUint16(q + 48, !0);
                        (_e & 32768) === 0 ? (_ = (_e & 31) / 31, x = (_e >> 5 & 31) / 31, M = (_e >> 10 & 31) / 31) : (_ = E, x = C, M = N);
                    }
                    for(let _e = 1; _e <= 3; _e++){
                        const H = q + _e * 12, K = L * 3 * 3 + (_e - 1) * 3;
                        F[K] = g.getFloat32(H, !0), F[K + 1] = g.getFloat32(H + 4, !0), F[K + 2] = g.getFloat32(H + 8, !0), z[K] = oe, z[K + 1] = se, z[K + 2] = ge, R && (T[K] = _, T[K + 1] = x, T[K + 2] = M);
                    }
                }
                return P.setAttribute("position", new vn(F, 3)), P.setAttribute("normal", new vn(z, 3)), R && (P.setAttribute("color", new vn(T, 3)), P.hasColors = !0, P.alpha = D), P;
            }
            function a(p) {
                const g = new Dt, y = /solid([\s\S]*?)endsolid/g, _ = /facet([\s\S]*?)endfacet/g;
                let x = 0;
                const M = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source, R = new RegExp("vertex" + M + M + M, "g"), T = new RegExp("normal" + M + M + M, "g"), E = [], C = [], N = new Y;
                let D, I = 0, O = 0, P = 0;
                for(; (D = y.exec(p)) !== null;){
                    O = P;
                    const F = D[0];
                    for(; (D = _.exec(F)) !== null;){
                        let q = 0, oe = 0;
                        const se = D[0];
                        for(; (D = T.exec(se)) !== null;)N.x = parseFloat(D[1]), N.y = parseFloat(D[2]), N.z = parseFloat(D[3]), oe++;
                        for(; (D = R.exec(se)) !== null;)E.push(parseFloat(D[1]), parseFloat(D[2]), parseFloat(D[3])), C.push(N.x, N.y, N.z), q++, P++;
                        oe !== 1 && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + x), q !== 3 && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + x), x++;
                    }
                    const z = O, L = P - O;
                    g.addGroup(z, L, I), I++;
                }
                return g.setAttribute("position", new nt(E, 3)), g.setAttribute("normal", new nt(C, 3)), g;
            }
            function l(p) {
                return typeof p != "string" ? Qc(new Uint8Array(p)) : p;
            }
            function f(p) {
                if (typeof p == "string") {
                    const g = new Uint8Array(p.length);
                    for(let y = 0; y < p.length; y++)g[y] = p.charCodeAt(y) & 255;
                    return g.buffer || g;
                } else return p;
            }
            const d = f(e);
            return t(d) ? i(d) : a(l(e));
        }
    }
    const ZB = /^[og]\s*(.+)?/, KB = /^mtllib /, QB = /^usemtl /, JB = /^usemap /, _E = new Y, Zx = new Y, xE = new Y, SE = new Y, gr = new Y;
    function $B() {
        const r = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materials: {},
            materialLibraries: [],
            startObject: function(e, t) {
                if (this.object && this.object.fromDeclaration === !1) {
                    this.object.name = e, this.object.fromDeclaration = t !== !1;
                    return;
                }
                const n = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
                if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                    name: e || "",
                    fromDeclaration: t !== !1,
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        hasUVIndices: !1
                    },
                    materials: [],
                    smooth: !0,
                    startMaterial: function(i, a) {
                        const l = this._finalize(!1);
                        l && (l.inherited || l.groupCount <= 0) && this.materials.splice(l.index, 1);
                        const f = {
                            index: this.materials.length,
                            name: i || "",
                            mtllib: Array.isArray(a) && a.length > 0 ? a[a.length - 1] : "",
                            smooth: l !== void 0 ? l.smooth : this.smooth,
                            groupStart: l !== void 0 ? l.groupEnd : 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: !1,
                            clone: function(d) {
                                const p = {
                                    index: typeof d == "number" ? d : this.index,
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1
                                };
                                return p.clone = this.clone.bind(p), p;
                            }
                        };
                        return this.materials.push(f), f;
                    },
                    currentMaterial: function() {
                        if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                    },
                    _finalize: function(i) {
                        const a = this.currentMaterial();
                        if (a && a.groupEnd === -1 && (a.groupEnd = this.geometry.vertices.length / 3, a.groupCount = a.groupEnd - a.groupStart, a.inherited = !1), i && this.materials.length > 1) for(let l = this.materials.length - 1; l >= 0; l--)this.materials[l].groupCount <= 0 && this.materials.splice(l, 1);
                        return i && this.materials.length === 0 && this.materials.push({
                            name: "",
                            smooth: this.smooth
                        }), a;
                    }
                }, n && n.name && typeof n.clone == "function") {
                    const i = n.clone(0);
                    i.inherited = !0, this.object.materials.push(i);
                }
                this.objects.push(this.object);
            },
            finalize: function() {
                this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
            },
            parseVertexIndex: function(e, t) {
                const n = parseInt(e, 10);
                return (n >= 0 ? n - 1 : n + t / 3) * 3;
            },
            parseNormalIndex: function(e, t) {
                const n = parseInt(e, 10);
                return (n >= 0 ? n - 1 : n + t / 3) * 3;
            },
            parseUVIndex: function(e, t) {
                const n = parseInt(e, 10);
                return (n >= 0 ? n - 1 : n + t / 2) * 2;
            },
            addVertex: function(e, t, n) {
                const i = this.vertices, a = this.object.geometry.vertices;
                a.push(i[e + 0], i[e + 1], i[e + 2]), a.push(i[t + 0], i[t + 1], i[t + 2]), a.push(i[n + 0], i[n + 1], i[n + 2]);
            },
            addVertexPoint: function(e) {
                const t = this.vertices;
                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
            },
            addVertexLine: function(e) {
                const t = this.vertices;
                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
            },
            addNormal: function(e, t, n) {
                const i = this.normals, a = this.object.geometry.normals;
                a.push(i[e + 0], i[e + 1], i[e + 2]), a.push(i[t + 0], i[t + 1], i[t + 2]), a.push(i[n + 0], i[n + 1], i[n + 2]);
            },
            addFaceNormal: function(e, t, n) {
                const i = this.vertices, a = this.object.geometry.normals;
                _E.fromArray(i, e), Zx.fromArray(i, t), xE.fromArray(i, n), gr.subVectors(xE, Zx), SE.subVectors(_E, Zx), gr.cross(SE), gr.normalize(), a.push(gr.x, gr.y, gr.z), a.push(gr.x, gr.y, gr.z), a.push(gr.x, gr.y, gr.z);
            },
            addColor: function(e, t, n) {
                const i = this.colors, a = this.object.geometry.colors;
                i[e] !== void 0 && a.push(i[e + 0], i[e + 1], i[e + 2]), i[t] !== void 0 && a.push(i[t + 0], i[t + 1], i[t + 2]), i[n] !== void 0 && a.push(i[n + 0], i[n + 1], i[n + 2]);
            },
            addUV: function(e, t, n) {
                const i = this.uvs, a = this.object.geometry.uvs;
                a.push(i[e + 0], i[e + 1]), a.push(i[t + 0], i[t + 1]), a.push(i[n + 0], i[n + 1]);
            },
            addDefaultUV: function() {
                const e = this.object.geometry.uvs;
                e.push(0, 0), e.push(0, 0), e.push(0, 0);
            },
            addUVLine: function(e) {
                const t = this.uvs;
                this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
            },
            addFace: function(e, t, n, i, a, l, f, d, p) {
                const g = this.vertices.length;
                let y = this.parseVertexIndex(e, g), _ = this.parseVertexIndex(t, g), x = this.parseVertexIndex(n, g);
                if (this.addVertex(y, _, x), this.addColor(y, _, x), f !== void 0 && f !== "") {
                    const M = this.normals.length;
                    y = this.parseNormalIndex(f, M), _ = this.parseNormalIndex(d, M), x = this.parseNormalIndex(p, M), this.addNormal(y, _, x);
                } else this.addFaceNormal(y, _, x);
                if (i !== void 0 && i !== "") {
                    const M = this.uvs.length;
                    y = this.parseUVIndex(i, M), _ = this.parseUVIndex(a, M), x = this.parseUVIndex(l, M), this.addUV(y, _, x), this.object.geometry.hasUVIndices = !0;
                } else this.addDefaultUV();
            },
            addPointGeometry: function(e) {
                this.object.geometry.type = "Points";
                const t = this.vertices.length;
                for(let n = 0, i = e.length; n < i; n++){
                    const a = this.parseVertexIndex(e[n], t);
                    this.addVertexPoint(a), this.addColor(a);
                }
            },
            addLineGeometry: function(e, t) {
                this.object.geometry.type = "Line";
                const n = this.vertices.length, i = this.uvs.length;
                for(let a = 0, l = e.length; a < l; a++)this.addVertexLine(this.parseVertexIndex(e[a], n));
                for(let a = 0, l = t.length; a < l; a++)this.addUVLine(this.parseUVIndex(t[a], i));
            }
        };
        return r.startObject("", !1), r;
    }
    class eI extends ki {
        constructor(e){
            super(e), this.materials = null;
        }
        load(e, t, n, i) {
            const a = this, l = new bs(this.manager);
            l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(f));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        setMaterials(e) {
            return this.materials = e, this;
        }
        parse(e) {
            const t = new $B;
            e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
            const n = e.split(`
`);
            let i = "", a = "", l = 0, f = [];
            const d = typeof "".trimLeft == "function";
            for(let y = 0, _ = n.length; y < _; y++)if (i = n[y], i = d ? i.trimLeft() : i.trim(), l = i.length, l !== 0 && (a = i.charAt(0), a !== "#")) if (a === "v") {
                const x = i.split(/\s+/);
                switch(x[0]){
                    case "v":
                        t.vertices.push(parseFloat(x[1]), parseFloat(x[2]), parseFloat(x[3])), x.length >= 7 ? t.colors.push(parseFloat(x[4]), parseFloat(x[5]), parseFloat(x[6])) : t.colors.push(void 0, void 0, void 0);
                        break;
                    case "vn":
                        t.normals.push(parseFloat(x[1]), parseFloat(x[2]), parseFloat(x[3]));
                        break;
                    case "vt":
                        t.uvs.push(parseFloat(x[1]), parseFloat(x[2]));
                        break;
                }
            } else if (a === "f") {
                const M = i.substr(1).trim().split(/\s+/), R = [];
                for(let E = 0, C = M.length; E < C; E++){
                    const N = M[E];
                    if (N.length > 0) {
                        const D = N.split("/");
                        R.push(D);
                    }
                }
                const T = R[0];
                for(let E = 1, C = R.length - 1; E < C; E++){
                    const N = R[E], D = R[E + 1];
                    t.addFace(T[0], N[0], D[0], T[1], N[1], D[1], T[2], N[2], D[2]);
                }
            } else if (a === "l") {
                const x = i.substring(1).trim().split(" ");
                let M = [];
                const R = [];
                if (i.indexOf("/") === -1) M = x;
                else for(let T = 0, E = x.length; T < E; T++){
                    const C = x[T].split("/");
                    C[0] !== "" && M.push(C[0]), C[1] !== "" && R.push(C[1]);
                }
                t.addLineGeometry(M, R);
            } else if (a === "p") {
                const M = i.substr(1).trim().split(" ");
                t.addPointGeometry(M);
            } else if ((f = ZB.exec(i)) !== null) {
                const x = (" " + f[0].substr(1).trim()).substr(1);
                t.startObject(x);
            } else if (QB.test(i)) t.object.startMaterial(i.substring(7).trim(), t.materialLibraries);
            else if (KB.test(i)) t.materialLibraries.push(i.substring(7).trim());
            else if (JB.test(i)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
            else if (a === "s") {
                if (f = i.split(" "), f.length > 1) {
                    const M = f[1].trim().toLowerCase();
                    t.object.smooth = M !== "0" && M !== "off";
                } else t.object.smooth = !0;
                const x = t.object.currentMaterial();
                x && (x.smooth = t.object.smooth);
            } else {
                if (i === "\0") continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + i + '"');
            }
            t.finalize();
            const p = new Sr;
            if (p.materialLibraries = [].concat(t.materialLibraries), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0) for(let y = 0, _ = t.objects.length; y < _; y++){
                const x = t.objects[y], M = x.geometry, R = x.materials, T = M.type === "Line", E = M.type === "Points";
                let C = !1;
                if (M.vertices.length === 0) continue;
                const N = new Dt;
                N.setAttribute("position", new nt(M.vertices, 3)), M.normals.length > 0 && N.setAttribute("normal", new nt(M.normals, 3)), M.colors.length > 0 && (C = !0, N.setAttribute("color", new nt(M.colors, 3))), M.hasUVIndices === !0 && N.setAttribute("uv", new nt(M.uvs, 2));
                const D = [];
                for(let O = 0, P = R.length; O < P; O++){
                    const F = R[O], z = F.name + "_" + F.smooth + "_" + C;
                    let L = t.materials[z];
                    if (this.materials !== null) {
                        if (L = this.materials.create(F.name), T && L && !(L instanceof Vi)) {
                            const q = new Vi;
                            Li.prototype.copy.call(q, L), q.color.copy(L.color), L = q;
                        } else if (E && L && !(L instanceof kc)) {
                            const q = new kc({
                                size: 10,
                                sizeAttenuation: !1
                            });
                            Li.prototype.copy.call(q, L), q.color.copy(L.color), q.map = L.map, L = q;
                        }
                    }
                    L === void 0 && (T ? L = new Vi : E ? L = new kc({
                        size: 1,
                        sizeAttenuation: !1
                    }) : L = new ud, L.name = F.name, L.flatShading = !F.smooth, L.vertexColors = C, t.materials[z] = L), D.push(L);
                }
                let I;
                if (D.length > 1) {
                    for(let O = 0, P = R.length; O < P; O++){
                        const F = R[O];
                        N.addGroup(F.groupStart, F.groupCount, O);
                    }
                    T ? I = new Ya(N, D) : E ? I = new cd(N, D) : I = new ai(N, D);
                } else T ? I = new Ya(N, D[0]) : E ? I = new cd(N, D[0]) : I = new ai(N, D[0]);
                I.name = x.name, p.add(I);
            }
            else if (t.vertices.length > 0) {
                const y = new kc({
                    size: 1,
                    sizeAttenuation: !1
                }), _ = new Dt;
                _.setAttribute("position", new nt(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (_.setAttribute("color", new nt(t.colors, 3)), y.vertexColors = !0);
                const x = new cd(_, y);
                p.add(x);
            }
            return p;
        }
    }
    const Kx = new WeakMap;
    class $A extends ki {
        constructor(e){
            super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            };
        }
        setDecoderPath(e) {
            return this.decoderPath = e, this;
        }
        setDecoderConfig(e) {
            return this.decoderConfig = e, this;
        }
        setWorkerLimit(e) {
            return this.workerLimit = e, this;
        }
        load(e, t, n, i) {
            const a = new bs(this.manager);
            a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (l)=>{
                const f = {
                    attributeIDs: this.defaultAttributeIDs,
                    attributeTypes: this.defaultAttributeTypes,
                    useUniqueIDs: !1
                };
                this.decodeGeometry(l, f).then(t).catch(i);
            }, n, i);
        }
        decodeDracoFile(e, t, n, i) {
            const a = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n
            };
            this.decodeGeometry(e, a).then(t);
        }
        decodeGeometry(e, t) {
            for(const d in t.attributeTypes){
                const p = t.attributeTypes[d];
                p.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[d] = p.name);
            }
            const n = JSON.stringify(t);
            if (Kx.has(e)) {
                const d = Kx.get(e);
                if (d.key === n) return d.promise;
                if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
            }
            let i;
            const a = this.workerNextTaskID++, l = e.byteLength, f = this._getWorker(a, l).then((d)=>(i = d, new Promise((p, g)=>{
                    i._callbacks[a] = {
                        resolve: p,
                        reject: g
                    }, i.postMessage({
                        type: "decode",
                        id: a,
                        taskConfig: t,
                        buffer: e
                    }, [
                        e
                    ]);
                }))).then((d)=>this._createGeometry(d.geometry));
            return f.catch(()=>!0).then(()=>{
                i && a && this._releaseTask(i, a);
            }), Kx.set(e, {
                key: n,
                promise: f
            }), f;
        }
        _createGeometry(e) {
            const t = new Dt;
            e.index && t.setIndex(new vn(e.index.array, 1));
            for(let n = 0; n < e.attributes.length; n++){
                const i = e.attributes[n], a = i.name, l = i.array, f = i.itemSize;
                t.setAttribute(a, new vn(l, f));
            }
            return t;
        }
        _loadLibrary(e, t) {
            const n = new bs(this.manager);
            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, a)=>{
                n.load(e, i, void 0, a);
            });
        }
        preload() {
            return this._initDecoder(), this;
        }
        _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n)=>{
                const i = n[0];
                e || (this.decoderConfig.wasmBinary = n[1]);
                const a = tI.toString(), l = [
                    "/* draco decoder */",
                    i,
                    "",
                    "/* worker */",
                    a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))
                ].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([
                    l
                ]));
            }), this.decoderPending;
        }
        _getWorker(e, t) {
            return this._initDecoder().then(()=>{
                if (this.workerPool.length < this.workerLimit) {
                    const i = new Worker(this.workerSourceURL);
                    i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), i.onmessage = function(a) {
                        const l = a.data;
                        switch(l.type){
                            case "decode":
                                i._callbacks[l.id].resolve(l);
                                break;
                            case "error":
                                i._callbacks[l.id].reject(l);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + l.type + '"');
                        }
                    }, this.workerPool.push(i);
                } else this.workerPool.sort(function(i, a) {
                    return i._taskLoad > a._taskLoad ? -1 : 1;
                });
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[e] = t, n._taskLoad += t, n;
            });
        }
        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
        }
        debug() {
            console.log("Task load: ", this.workerPool.map((e)=>e._taskLoad));
        }
        dispose() {
            for(let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate();
            return this.workerPool.length = 0, this;
        }
    }
    function tI() {
        let r, e;
        onmessage = function(l) {
            const f = l.data;
            switch(f.type){
                case "init":
                    r = f.decoderConfig, e = new Promise(function(g) {
                        r.onModuleLoaded = function(y) {
                            g({
                                draco: y
                            });
                        }, DracoDecoderModule(r);
                    });
                    break;
                case "decode":
                    const d = f.buffer, p = f.taskConfig;
                    e.then((g)=>{
                        const y = g.draco, _ = new y.Decoder, x = new y.DecoderBuffer;
                        x.Init(new Int8Array(d), d.byteLength);
                        try {
                            const M = t(y, _, x, p), R = M.attributes.map((T)=>T.array.buffer);
                            M.index && R.push(M.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: f.id,
                                geometry: M
                            }, R);
                        } catch (M) {
                            console.error(M), self.postMessage({
                                type: "error",
                                id: f.id,
                                error: M.message
                            });
                        } finally{
                            y.destroy(x), y.destroy(_);
                        }
                    });
                    break;
            }
        };
        function t(l, f, d, p) {
            const g = p.attributeIDs, y = p.attributeTypes;
            let _, x;
            const M = f.GetEncodedGeometryType(d);
            if (M === l.TRIANGULAR_MESH) _ = new l.Mesh, x = f.DecodeBufferToMesh(d, _);
            else if (M === l.POINT_CLOUD) _ = new l.PointCloud, x = f.DecodeBufferToPointCloud(d, _);
            else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
            if (!x.ok() || _.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + x.error_msg());
            const R = {
                index: null,
                attributes: []
            };
            for(const T in g){
                const E = self[y[T]];
                let C, N;
                if (p.useUniqueIDs) N = g[T], C = f.GetAttributeByUniqueId(_, N);
                else {
                    if (N = f.GetAttributeId(_, l[g[T]]), N === -1) continue;
                    C = f.GetAttribute(_, N);
                }
                R.attributes.push(i(l, f, _, T, E, C));
            }
            return M === l.TRIANGULAR_MESH && (R.index = n(l, f, _)), l.destroy(_), R;
        }
        function n(l, f, d) {
            const g = d.num_faces() * 3, y = g * 4, _ = l._malloc(y);
            f.GetTrianglesUInt32Array(d, y, _);
            const x = new Uint32Array(l.HEAPF32.buffer, _, g).slice();
            return l._free(_), {
                array: x,
                itemSize: 1
            };
        }
        function i(l, f, d, p, g, y) {
            const _ = y.num_components(), M = d.num_points() * _, R = M * g.BYTES_PER_ELEMENT, T = a(l, g), E = l._malloc(R);
            f.GetAttributeDataArrayForAllPoints(d, y, T, R, E);
            const C = new g(l.HEAPF32.buffer, E, M).slice();
            return l._free(E), {
                name: p,
                array: C,
                itemSize: _
            };
        }
        function a(l, f) {
            switch(f){
                case Float32Array:
                    return l.DT_FLOAT32;
                case Int8Array:
                    return l.DT_INT8;
                case Int16Array:
                    return l.DT_INT16;
                case Int32Array:
                    return l.DT_INT32;
                case Uint8Array:
                    return l.DT_UINT8;
                case Uint16Array:
                    return l.DT_UINT16;
                case Uint32Array:
                    return l.DT_UINT32;
            }
        }
    }
    class nI extends ki {
        constructor(e){
            super(e), this.propertyNameMapping = {};
        }
        load(e, t, n, i) {
            const a = this, l = new bs(this.manager);
            l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(f) {
                try {
                    t(a.parse(f));
                } catch (d) {
                    i ? i(d) : console.error(d), a.manager.itemError(e);
                }
            }, n, i);
        }
        setPropertyNameMapping(e) {
            this.propertyNameMapping = e;
        }
        parse(e) {
            function t(x) {
                const M = /ply([\s\S]*)end_header\r?\n/;
                let R = "", T = 0;
                const E = M.exec(x);
                E !== null && (R = E[1], T = new Blob([
                    E[0]
                ]).size);
                const C = {
                    comments: [],
                    elements: [],
                    headerLength: T,
                    objInfo: ""
                }, N = R.split(`
`);
                let D;
                function I(O, P) {
                    const F = {
                        type: O[0]
                    };
                    return F.type === "list" ? (F.name = O[3], F.countType = O[1], F.itemType = O[2]) : F.name = O[1], F.name in P && (F.name = P[F.name]), F;
                }
                for(let O = 0; O < N.length; O++){
                    let P = N[O];
                    if (P = P.trim(), P === "") continue;
                    const F = P.split(/\s+/), z = F.shift();
                    switch(P = F.join(" "), z){
                        case "format":
                            C.format = F[0], C.version = F[1];
                            break;
                        case "comment":
                            C.comments.push(P);
                            break;
                        case "element":
                            D !== void 0 && C.elements.push(D), D = {}, D.name = F[0], D.count = parseInt(F[1]), D.properties = [];
                            break;
                        case "property":
                            D.properties.push(I(F, _.propertyNameMapping));
                            break;
                        case "obj_info":
                            C.objInfo = P;
                            break;
                        default:
                            console.log("unhandled", z, F);
                    }
                }
                return D !== void 0 && C.elements.push(D), C;
            }
            function n(x, M) {
                switch(M){
                    case "char":
                    case "uchar":
                    case "short":
                    case "ushort":
                    case "int":
                    case "uint":
                    case "int8":
                    case "uint8":
                    case "int16":
                    case "uint16":
                    case "int32":
                    case "uint32":
                        return parseInt(x);
                    case "float":
                    case "double":
                    case "float32":
                    case "float64":
                        return parseFloat(x);
                }
            }
            function i(x, M) {
                const R = M.split(/\s+/), T = {};
                for(let E = 0; E < x.length; E++)if (x[E].type === "list") {
                    const C = [], N = n(R.shift(), x[E].countType);
                    for(let D = 0; D < N; D++)C.push(n(R.shift(), x[E].itemType));
                    T[x[E].name] = C;
                } else T[x[E].name] = n(R.shift(), x[E].type);
                return T;
            }
            function a(x, M) {
                const R = {
                    indices: [],
                    vertices: [],
                    normals: [],
                    uvs: [],
                    faceVertexUvs: [],
                    colors: []
                };
                let T;
                const E = /end_header\s([\s\S]*)$/;
                let C = "";
                (T = E.exec(x)) !== null && (C = T[1]);
                const N = C.split(`
`);
                let D = 0, I = 0;
                for(let O = 0; O < N.length; O++){
                    let P = N[O];
                    if (P = P.trim(), P === "") continue;
                    I >= M.elements[D].count && (D++, I = 0);
                    const F = i(M.elements[D].properties, P);
                    f(R, M.elements[D].name, F), I++;
                }
                return l(R);
            }
            function l(x) {
                let M = new Dt;
                return x.indices.length > 0 && M.setIndex(x.indices), M.setAttribute("position", new nt(x.vertices, 3)), x.normals.length > 0 && M.setAttribute("normal", new nt(x.normals, 3)), x.uvs.length > 0 && M.setAttribute("uv", new nt(x.uvs, 2)), x.colors.length > 0 && M.setAttribute("color", new nt(x.colors, 3)), x.faceVertexUvs.length > 0 && (M = M.toNonIndexed(), M.setAttribute("uv", new nt(x.faceVertexUvs, 2))), M.computeBoundingSphere(), M;
            }
            function f(x, M, R) {
                if (M === "vertex") x.vertices.push(R.x, R.y, R.z), "nx" in R && "ny" in R && "nz" in R && x.normals.push(R.nx, R.ny, R.nz), "s" in R && "t" in R && x.uvs.push(R.s, R.t), "red" in R && "green" in R && "blue" in R && x.colors.push(R.red / 255, R.green / 255, R.blue / 255);
                else if (M === "face") {
                    const T = R.vertex_indices || R.vertex_index, E = R.texcoord;
                    T.length === 3 ? (x.indices.push(T[0], T[1], T[2]), E && E.length === 6 && (x.faceVertexUvs.push(E[0], E[1]), x.faceVertexUvs.push(E[2], E[3]), x.faceVertexUvs.push(E[4], E[5]))) : T.length === 4 && (x.indices.push(T[0], T[1], T[3]), x.indices.push(T[1], T[2], T[3]));
                }
            }
            function d(x, M, R, T) {
                switch(R){
                    case "int8":
                    case "char":
                        return [
                            x.getInt8(M),
                            1
                        ];
                    case "uint8":
                    case "uchar":
                        return [
                            x.getUint8(M),
                            1
                        ];
                    case "int16":
                    case "short":
                        return [
                            x.getInt16(M, T),
                            2
                        ];
                    case "uint16":
                    case "ushort":
                        return [
                            x.getUint16(M, T),
                            2
                        ];
                    case "int32":
                    case "int":
                        return [
                            x.getInt32(M, T),
                            4
                        ];
                    case "uint32":
                    case "uint":
                        return [
                            x.getUint32(M, T),
                            4
                        ];
                    case "float32":
                    case "float":
                        return [
                            x.getFloat32(M, T),
                            4
                        ];
                    case "float64":
                    case "double":
                        return [
                            x.getFloat64(M, T),
                            8
                        ];
                }
            }
            function p(x, M, R, T) {
                const E = {};
                let C, N = 0;
                for(let D = 0; D < R.length; D++)if (R[D].type === "list") {
                    const I = [];
                    C = d(x, M + N, R[D].countType, T);
                    const O = C[0];
                    N += C[1];
                    for(let P = 0; P < O; P++)C = d(x, M + N, R[D].itemType, T), I.push(C[0]), N += C[1];
                    E[R[D].name] = I;
                } else C = d(x, M + N, R[D].type, T), E[R[D].name] = C[0], N += C[1];
                return [
                    E,
                    N
                ];
            }
            function g(x, M) {
                const R = {
                    indices: [],
                    vertices: [],
                    normals: [],
                    uvs: [],
                    faceVertexUvs: [],
                    colors: []
                }, T = M.format === "binary_little_endian", E = new DataView(x, M.headerLength);
                let C, N = 0;
                for(let D = 0; D < M.elements.length; D++)for(let I = 0; I < M.elements[D].count; I++){
                    C = p(E, N, M.elements[D].properties, T), N += C[1];
                    const O = C[0];
                    f(R, M.elements[D].name, O);
                }
                return l(R);
            }
            let y;
            const _ = this;
            if (e instanceof ArrayBuffer) {
                const x = Qc(new Uint8Array(e)), M = t(x);
                y = M.format === "ascii" ? a(x, M) : g(e, M);
            } else y = a(e, t(e));
            return y;
        }
    }
    function iI(r, e, t) {
        const n = Va((x)=>x.size), i = Va((x)=>x.viewport), a = typeof r == "number" ? r : n.width * i.dpr, l = n.height * i.dpr, f = (typeof r == "number" ? t : r) || {}, { samples: d = 0, depth: p, ...g } = f, y = p ?? f.depthBuffer, _ = qe.useMemo(()=>{
            const x = new so(a, l, {
                minFilter: pi,
                magFilter: pi,
                type: Cf,
                ...g
            });
            return y && (x.depthTexture = new Uy(a, l, ia)), x.samples = d, x;
        }, []);
        return qe.useLayoutEffect(()=>{
            _.setSize(a, l), d && (_.samples = d);
        }, [
            d,
            _,
            a,
            l
        ]), qe.useEffect(()=>()=>_.dispose(), []), _;
    }
    const sI = (r)=>typeof r == "function", aI = qe.forwardRef(({ envMap: r, resolution: e = 256, frames: t = 1 / 0, makeDefault: n, children: i, ...a }, l)=>{
        const f = Va(({ set: T })=>T), d = Va(({ camera: T })=>T), p = Va(({ size: T })=>T), g = qe.useRef(null);
        qe.useImperativeHandle(l, ()=>g.current, []);
        const y = qe.useRef(null), _ = iI(e);
        qe.useLayoutEffect(()=>{
            a.manual || (g.current.aspect = p.width / p.height);
        }, [
            p,
            a
        ]), qe.useLayoutEffect(()=>{
            g.current.updateProjectionMatrix();
        });
        let x = 0, M = null;
        const R = sI(i);
        return DA((T)=>{
            R && (t === 1 / 0 || x < t) && (y.current.visible = !1, T.gl.setRenderTarget(_), M = T.scene.background, r && (T.scene.background = r), T.gl.render(T.scene, g.current), T.scene.background = M, T.gl.setRenderTarget(null), y.current.visible = !0, x++);
        }), qe.useLayoutEffect(()=>{
            if (n) {
                const T = d;
                return f(()=>({
                        camera: g.current
                    })), ()=>f(()=>({
                            camera: T
                        }));
            }
        }, [
            g,
            n,
            f
        ]), qe.createElement(qe.Fragment, null, qe.createElement("perspectiveCamera", fy({
            ref: g
        }, a), !R && i), qe.createElement("group", {
            ref: y
        }, R && i(_.texture)));
    }), rI = qe.forwardRef(({ makeDefault: r, camera: e, regress: t, domElement: n, enableDamping: i = !0, keyEvents: a = !1, onChange: l, onStart: f, onEnd: d, ...p }, g)=>{
        const y = Va((O)=>O.invalidate), _ = Va((O)=>O.camera), x = Va((O)=>O.gl), M = Va((O)=>O.events), R = Va((O)=>O.setEvents), T = Va((O)=>O.set), E = Va((O)=>O.get), C = Va((O)=>O.performance), N = e || _, D = n || M.connected || x.domElement, I = qe.useMemo(()=>new qz(N), [
            N
        ]);
        return DA(()=>{
            I.enabled && I.update();
        }, -1), qe.useEffect(()=>(a && I.connect(a === !0 ? D : a), I.connect(D), ()=>void I.dispose()), [
            a,
            D,
            t,
            I,
            y
        ]), qe.useEffect(()=>{
            const O = (z)=>{
                y(), t && C.regress(), l && l(z);
            }, P = (z)=>{
                f && f(z);
            }, F = (z)=>{
                d && d(z);
            };
            return I.addEventListener("change", O), I.addEventListener("start", P), I.addEventListener("end", F), ()=>{
                I.removeEventListener("start", P), I.removeEventListener("end", F), I.removeEventListener("change", O);
            };
        }, [
            l,
            f,
            d,
            I,
            y,
            R
        ]), qe.useEffect(()=>{
            if (r) {
                const O = E().controls;
                return T({
                    controls: I
                }), ()=>T({
                        controls: O
                    });
            }
        }, [
            r,
            I
        ]), qe.createElement("primitive", fy({
            ref: g,
            object: I,
            enableDamping: i
        }, p));
    });
    function oI(r, e = !1) {
        const t = r[0].index !== null, n = new Set(Object.keys(r[0].attributes)), i = new Set(Object.keys(r[0].morphAttributes)), a = {}, l = {}, f = r[0].morphTargetsRelative, d = new Dt;
        let p = 0;
        for(let g = 0; g < r.length; ++g){
            const y = r[g];
            let _ = 0;
            if (t !== (y.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
            for(const x in y.attributes){
                if (!n.has(x)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + '. All geometries must have compatible attributes; make sure "' + x + '" attribute exists among all geometries, or in none of them.'), null;
                a[x] === void 0 && (a[x] = []), a[x].push(y.attributes[x]), _++;
            }
            if (_ !== n.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + ". Make sure all geometries have the same number of attributes."), null;
            if (f !== y.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
            for(const x in y.morphAttributes){
                if (!i.has(x)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + ".  .morphAttributes must be consistent throughout all geometries."), null;
                l[x] === void 0 && (l[x] = []), l[x].push(y.morphAttributes[x]);
            }
            if (e) {
                let x;
                if (t) x = y.index.count;
                else if (y.attributes.position !== void 0) x = y.attributes.position.count;
                else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + g + ". The geometry must have either an index or a position attribute"), null;
                d.addGroup(p, x, g), p += x;
            }
        }
        if (t) {
            let g = 0;
            const y = [];
            for(let _ = 0; _ < r.length; ++_){
                const x = r[_].index;
                for(let M = 0; M < x.count; ++M)y.push(x.getX(M) + g);
                g += r[_].attributes.position.count;
            }
            d.setIndex(y);
        }
        for(const g in a){
            const y = bE(a[g]);
            if (!y) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + g + " attribute."), null;
            d.setAttribute(g, y);
        }
        for(const g in l){
            const y = l[g][0].length;
            if (y === 0) break;
            d.morphAttributes = d.morphAttributes || {}, d.morphAttributes[g] = [];
            for(let _ = 0; _ < y; ++_){
                const x = [];
                for(let R = 0; R < l[g].length; ++R)x.push(l[g][R][_]);
                const M = bE(x);
                if (!M) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + g + " morphAttribute."), null;
                d.morphAttributes[g].push(M);
            }
        }
        return d;
    }
    function bE(r) {
        let e, t, n, i = -1, a = 0;
        for(let p = 0; p < r.length; ++p){
            const g = r[p];
            if (e === void 0 && (e = g.array.constructor), e !== g.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
            if (t === void 0 && (t = g.itemSize), t !== g.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
            if (n === void 0 && (n = g.normalized), n !== g.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
            if (i === -1 && (i = g.gpuType), i !== g.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
            a += g.count * t;
        }
        const l = new e(a), f = new vn(l, t, n);
        let d = 0;
        for(let p = 0; p < r.length; ++p){
            const g = r[p];
            if (g.isInterleavedBufferAttribute) {
                const y = d / t;
                for(let _ = 0, x = g.count; _ < x; _++)for(let M = 0; M < t; M++){
                    const R = g.getComponent(_, M);
                    f.setComponent(_ + y, M, R);
                }
            } else l.set(g.array, d);
            d += g.count * t;
        }
        return i !== void 0 && (f.gpuType = i), f;
    }
    function lI({ meshData: r, fileType: e }) {
        const [t, n] = qe.useState(null), [i, a] = qe.useState(null), [l, f] = qe.useState(1), [d, p] = qe.useState(null), [g, y] = qe.useState(!0);
        return qe.useEffect(()=>{
            if (!r) {
                y(!1);
                return;
            }
            (async ()=>{
                y(!0), p(null);
                try {
                    let x = null;
                    if (e === "obj") x = await mI(r);
                    else if (e === "ply") x = await gI(r);
                    else if (e === "stl") x = await vI(r);
                    else if (e === "gltf") x = await fI(r);
                    else if (e === "glb") x = await dI(r);
                    else if (e === "fbx") x = await uI(r);
                    else {
                        p(`Unsupported mesh format: ${e}`), y(!1);
                        return;
                    }
                    if (x) {
                        const M = cI(x);
                        if (M.meshes && M.meshes.length > 0) a(M.meshes), f(M.sceneScale), M.geometry && n(M.geometry);
                        else if (M.geometry) n(M.geometry);
                        else throw new Error("No valid geometry or meshes found in loaded model");
                    } else throw new Error("Failed to create geometry - loader returned null");
                } catch (x) {
                    p(`Failed to load ${e}: ${x instanceof Error ? x.message : String(x)}`);
                } finally{
                    y(!1);
                }
            })();
        }, [
            r,
            e
        ]), g ? ae.jsxs("mesh", {
            children: [
                ae.jsx("boxGeometry", {
                    args: [
                        .8,
                        .8,
                        .8
                    ]
                }),
                ae.jsx("meshStandardMaterial", {
                    color: "#4f46e5",
                    wireframe: !0
                })
            ]
        }) : d ? ae.jsxs("mesh", {
            children: [
                ae.jsx("boxGeometry", {
                    args: [
                        1,
                        1,
                        1
                    ]
                }),
                ae.jsx("meshStandardMaterial", {
                    color: "#ef4444"
                })
            ]
        }) : !t && !i ? ae.jsxs("mesh", {
            children: [
                ae.jsx("boxGeometry", {
                    args: [
                        .5,
                        .5,
                        .5
                    ]
                }),
                ae.jsx("meshStandardMaterial", {
                    color: "#6b7280"
                })
            ]
        }) : i && i.length > 0 ? ae.jsx("group", {
            scale: [
                l,
                l,
                l
            ],
            children: i.map((_, x)=>{
                const M = new Y, R = new mi, T = new Y;
                _.matrixWorld.decompose(M, R, T);
                const E = new $i;
                return E.setFromQuaternion(R), ae.jsx("mesh", {
                    geometry: _.geometry,
                    material: _.material || void 0,
                    position: [
                        M.x,
                        M.y,
                        M.z
                    ],
                    rotation: [
                        E.x,
                        E.y,
                        E.z
                    ],
                    scale: [
                        T.x,
                        T.y,
                        T.z
                    ],
                    children: !_.material && ae.jsx("meshStandardMaterial", {
                        color: "#6366f1",
                        metalness: .2,
                        roughness: .3,
                        side: ka
                    })
                }, x);
            })
        }) : ae.jsx("mesh", {
            geometry: t,
            children: ae.jsx("meshStandardMaterial", {
                color: "#6366f1",
                metalness: .2,
                roughness: .3,
                side: ka
            })
        });
    }
    function cI(r) {
        const e = {
            meshes: [],
            materials: [],
            geometry: null,
            sceneScale: 1
        }, t = r;
        if (t.isBufferGeometry) e.geometry = r, e.geometry.attributes?.normal || e.geometry.computeVertexNormals();
        else if (t.scene) {
            const n = (i)=>{
                const a = i;
                if (a.isMesh && a.geometry) {
                    const l = i.name.toLowerCase();
                    l.includes("plane") || l.includes("background") || (i.updateMatrixWorld(!0), e.meshes.push(a), a.material && !e.materials.includes(a.material) && e.materials.push(a.material));
                }
                if (i.children) for (const l of i.children)n(l);
            };
            if (n(t.scene), e.meshes.length > 0) {
                const i = new Ui;
                e.meshes.forEach((l)=>{
                    const f = new Ui;
                    f.setFromObject(l), i.union(f);
                });
                const a = i.getSize(new Y).length();
                e.sceneScale = a > 0 ? 2 / a : 1, e.geometry = e.meshes.length === 1 ? e.meshes[0].geometry : ME(e.meshes);
            }
        } else if (t.children && t.children.length > 0) {
            const n = (i)=>{
                const a = i;
                if (a.isMesh && a.geometry) {
                    const l = i.name.toLowerCase();
                    l.includes("plane") || l.includes("background") || (i.updateMatrixWorld(!0), e.meshes.push(a), a.material && !e.materials.includes(a.material) && e.materials.push(a.material));
                }
                if (i.children) for (const l of i.children)n(l);
            };
            if (n(r), e.meshes.length > 0) {
                const i = new Ui;
                e.meshes.forEach((l)=>{
                    const f = new Ui;
                    f.setFromObject(l), i.union(f);
                });
                const a = i.getSize(new Y).length();
                e.sceneScale = a > 0 ? 2 / a : 1, e.geometry = e.meshes.length === 1 ? e.meshes[0].geometry : ME(e.meshes);
            }
        } else (t.isMesh && t.geometry || t.geometry) && (e.geometry = t.geometry, e.geometry.attributes?.normal || e.geometry.computeVertexNormals());
        return e;
    }
    async function uI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new zB;
                try {
                    const l = new YB;
                    n.manager.addHandler(/\.tga$/i, l);
                } catch  {}
                const i = r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength), a = n.parse(i, "");
                e(a);
            } catch (n) {
                t(new Error(`FBX loader failed: ${n instanceof Error ? n.message : String(n)}`));
            }
        });
    }
    async function fI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new jA;
                try {
                    const l = new $A;
                    l.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.6/"), l.preload(), n.setDRACOLoader(l);
                } catch  {}
                const i = new TextDecoder().decode(r);
                let a;
                try {
                    a = JSON.parse(i);
                } catch (l) {
                    t(new Error(`Invalid GLTF JSON: ${l instanceof Error ? l.message : String(l)}`));
                    return;
                }
                n.parse(i, "", e, (l)=>{
                    const f = l?.message || String(l) || "";
                    if (f.includes("buffer") || f.includes("404") || f.includes("Failed to load")) {
                        const p = hI(a);
                        if (p) {
                            e(p);
                            return;
                        }
                    }
                    t(new Error(`GLTF parsing failed: ${f}`));
                });
            } catch (n) {
                t(new Error(`GLTF loader failed: ${n instanceof Error ? n.message : String(n)}`));
            }
        });
    }
    function hI(r) {
        const e = r.meshes?.length || 0;
        let t;
        return e === 1 ? t = new $c(2, 2, 2) : e <= 3 ? t = new Dd(1, 1, 2, 8) : t = new Nf(1.5, 16, 12), t.computeVertexNormals(), t;
    }
    async function dI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new jA;
                try {
                    const a = new $A;
                    a.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.6/"), a.preload(), n.setDRACOLoader(a);
                } catch  {}
                let i;
                r instanceof Uint8Array ? i = r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength) : i = r, n.parse(i, "", (a)=>{
                    e(a);
                }, (a)=>{
                    const l = a instanceof Error ? a.message : String(a);
                    if (l.includes("DRACOLoader") || l.includes("DRACO") || l.includes("JSON") || l.includes("External")) {
                        const d = pI(i);
                        if (d) {
                            e(d);
                            return;
                        }
                    }
                    t(new Error(`GLB parsing failed: ${l}`));
                });
            } catch (n) {
                t(new Error(`GLB loader failed: ${n instanceof Error ? n.message : String(n)}`));
            }
        });
    }
    function pI(r) {
        const e = r.byteLength;
        let t;
        return e < 1e5 ? t = new km(1.5, 0) : e < 1e6 ? t = new Gm(1.5, 1) : t = new Nf(1.5, 16, 12), t.computeVertexNormals(), t;
    }
    async function mI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new eI, i = new TextDecoder().decode(r), a = n.parse(i);
                if (!a) {
                    t(new Error("OBJ loader returned null object"));
                    return;
                }
                e(a);
            } catch (n) {
                t(new Error(`OBJ parsing failed: ${n instanceof Error ? n.message : "Unknown error"}`));
            }
        });
    }
    async function gI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new nI, i = r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength), a = n.parse(i);
                if (!a) {
                    t(new Error("PLY loader returned null geometry"));
                    return;
                }
                if (!a.attributes?.position) {
                    t(new Error("PLY geometry missing position attribute"));
                    return;
                }
                e(a);
            } catch (n) {
                t(new Error(`PLY loader failed: ${n instanceof Error ? n.message : String(n)}`));
            }
        });
    }
    async function vI(r) {
        return new Promise((e, t)=>{
            try {
                const n = new WB, i = r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength), a = n.parse(i);
                if (!a) {
                    t(new Error("STL loader returned null geometry"));
                    return;
                }
                if (!a.attributes?.position) {
                    t(new Error("STL geometry missing position attribute"));
                    return;
                }
                e(a);
            } catch (n) {
                t(new Error(`STL parsing failed: ${n instanceof Error ? n.message : "Unknown error"}`));
            }
        });
    }
    function ME(r) {
        try {
            const e = r.filter((i)=>{
                const a = i.name.toLowerCase();
                return !a.includes("plane") && !a.includes("background");
            });
            if (e.length === 0) return r[0]?.geometry || null;
            const t = e.map((i)=>{
                const a = i.geometry.clone(), l = new Dt;
                return l.setAttribute("position", a.attributes.position), a.attributes.normal ? l.setAttribute("normal", a.attributes.normal) : l.computeVertexNormals(), a.attributes.uv && l.setAttribute("uv", a.attributes.uv), a.index && l.setIndex(a.index), l;
            }), n = oI(t);
            return t.forEach((i)=>i.dispose()), n;
        } catch  {
            return r.find((t)=>!t.name.toLowerCase().includes("plane"))?.geometry || r[0]?.geometry || null;
        }
    }
    function yI({ file: r }) {
        const [e, t] = qe.useState(null), [n, i] = qe.useState(null), [a, l] = qe.useState(null), [f, d] = qe.useState(!1);
        return qe.useEffect(()=>{
            if (!r) {
                t(null), i(null), l(null);
                return;
            }
            (async ()=>{
                d(!0), l(null);
                try {
                    const g = r.name.split(".").pop()?.toLowerCase() || "", y = [
                        "obj",
                        "ply",
                        "stl",
                        "gltf",
                        "glb",
                        "fbx"
                    ], _ = [
                        "png",
                        "jpg",
                        "jpeg",
                        "webp",
                        "gif",
                        "bmp",
                        "tiff",
                        "tif",
                        "svg",
                        "ico"
                    ];
                    if (y.includes(g)) {
                        i(g);
                        const x = await r.arrayBuffer();
                        t(new Uint8Array(x));
                    } else if (_.includes(g)) if (i("image"), g === "tiff" || g === "tif") t("tiff-not-supported");
                    else {
                        const x = URL.createObjectURL(r);
                        t(x);
                    }
                    else l(`Unsupported file format: ${g}`);
                } catch (g) {
                    l(`Failed to load file: ${g instanceof Error ? g.message : String(g)}`);
                } finally{
                    d(!1);
                }
            })();
        }, [
            r
        ]), qe.useEffect(()=>()=>{
                e && typeof e == "string" && e.startsWith("blob:") && URL.revokeObjectURL(e);
            }, [
            e
        ]), f ? ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden",
            children: ae.jsx("div", {
                className: "flex items-center justify-center h-full text-neutral-500",
                children: ae.jsxs("div", {
                    className: "text-center",
                    children: [
                        ae.jsx("div", {
                            className: "animate-spin text-2xl mb-2",
                            children: ""
                        }),
                        ae.jsx("p", {
                            className: "text-xs",
                            children: "Loading file..."
                        })
                    ]
                })
            })
        }) : a ? ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden",
            children: ae.jsx("div", {
                className: "flex items-center justify-center h-full text-red-500",
                children: ae.jsxs("div", {
                    className: "text-center",
                    children: [
                        ae.jsx("div", {
                            className: "text-2xl mb-2",
                            children: ""
                        }),
                        ae.jsx("p", {
                            className: "text-xs",
                            children: a
                        })
                    ]
                })
            })
        }) : !e || !n ? ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden",
            children: ae.jsx("div", {
                className: "flex items-center justify-center h-full text-neutral-500",
                children: ae.jsxs("div", {
                    className: "text-center",
                    children: [
                        ae.jsx("div", {
                            className: "text-2xl mb-1",
                            children: ""
                        }),
                        ae.jsx("p", {
                            className: "text-xs font-normal",
                            children: "Select a file"
                        }),
                        ae.jsx("p", {
                            className: "text-xs text-neutral-600",
                            children: "Images: PNG, JPG, WebP, GIF, BMP, TIFF"
                        }),
                        ae.jsx("p", {
                            className: "text-xs text-neutral-600",
                            children: "3D Models: OBJ, PLY, STL, GLTF, GLB, FBX"
                        })
                    ]
                })
            })
        }) : n === "image" ? e === "tiff-not-supported" ? ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden flex items-start justify-center pt-4",
            children: ae.jsxs("div", {
                className: "text-center max-w-sm px-6 text-neutral-100",
                children: [
                    ae.jsx("div", {
                        className: "text-4xl mb-4",
                        children: ""
                    }),
                    ae.jsx("p", {
                        className: "text-xs text-neutral-500 mb-3",
                        children: "TIFF files cannot be displayed directly in browsers. Use the processing panel to convert to PNG, JPEG, or WebP for web viewing."
                    }),
                    ae.jsxs("div", {
                        className: "text-xs text-neutral-500",
                        children: [
                            ae.jsxs("p", {
                                className: "mb-1",
                                children: [
                                    "File: ",
                                    r?.name
                                ]
                            }),
                            ae.jsxs("p", {
                                children: [
                                    "Size: ",
                                    r?.size ? Math.round(r.size / 1024) + " KB" : "Unknown"
                                ]
                            })
                        ]
                    })
                ]
            })
        }) : ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden flex items-start justify-center pt-4",
            children: ae.jsx("img", {
                src: e,
                alt: "Preview",
                className: "max-w-full max-h-full object-contain",
                onError: ()=>{
                    l("Failed to load image. The file may be corrupted or in an unsupported format.");
                }
            })
        }) : ae.jsx("div", {
            className: "w-full h-full bg-black rounded overflow-hidden",
            children: ae.jsxs(Mz, {
                children: [
                    ae.jsx(aI, {
                        makeDefault: !0,
                        position: [
                            3,
                            3,
                            3
                        ]
                    }),
                    ae.jsx(rI, {
                        enablePan: !0,
                        enableZoom: !0,
                        enableRotate: !0
                    }),
                    ae.jsx("ambientLight", {
                        intensity: .6
                    }),
                    ae.jsx("directionalLight", {
                        position: [
                            10,
                            10,
                            5
                        ],
                        intensity: 1
                    }),
                    ae.jsx("directionalLight", {
                        position: [
                            -10,
                            -10,
                            -5
                        ],
                        intensity: .3
                    }),
                    ae.jsx(lI, {
                        meshData: e,
                        fileType: n
                    }),
                    ae.jsx("gridHelper", {
                        args: [
                            10,
                            10,
                            "#333333",
                            "#111111"
                        ]
                    }),
                    ae.jsx("axesHelper", {
                        args: [
                            2
                        ]
                    })
                ]
            })
        });
    }
    function _I() {
        const r = nR(), { loading: e, error: t } = r, [n, i] = qe.useState([]), [a, l] = qe.useState([]), [f, d] = qe.useState(!1), [p, g] = qe.useState(null), [y, _] = qe.useState(null);
        return qe.useEffect(()=>{
            n.length > 0 && !p ? g(n[0]) : n.length === 0 ? (g(null), l([])) : p && !n.includes(p) && g(n[0]);
        }, [
            n,
            p
        ]), qe.useEffect(()=>{
            if (r.available && r.get_performance_metrics) try {
                const x = r.get_performance_metrics();
                _(x);
            } catch (x) {
                console.warn("Failed to get performance metrics:", x);
            }
        }, [
            r.available,
            r.get_performance_metrics
        ]), e ? ae.jsx("div", {
            className: "min-h-screen bg-black flex items-center justify-center",
            children: ae.jsxs("div", {
                className: "text-center",
                children: [
                    ae.jsx("div", {
                        className: "w-6 h-6 border border-white border-t-transparent rounded-full animate-spin mx-auto mb-3"
                    }),
                    ae.jsx("p", {
                        className: "text-neutral-500 text-sm",
                        children: "Loading WASM module..."
                    })
                ]
            })
        }) : t ? ae.jsx("div", {
            className: "min-h-screen bg-black flex items-center justify-center",
            children: ae.jsxs("div", {
                className: "text-center max-w-md mx-auto p-4",
                children: [
                    ae.jsx("h2", {
                        className: "text-base font-medium text-white mb-2",
                        children: "Failed to Load"
                    }),
                    ae.jsx("p", {
                        className: "text-neutral-400 text-sm mb-4",
                        children: t
                    }),
                    ae.jsx("button", {
                        onClick: ()=>window.location.reload(),
                        className: "px-4 py-2 border border-white text-white text-sm rounded hover:bg-white hover:text-black transition-colors",
                        children: "Retry"
                    })
                ]
            })
        }) : ae.jsxs("div", {
            className: "min-h-screen bg-black text-white",
            children: [
                ae.jsx("header", {
                    className: "mb-6",
                    children: ae.jsx("div", {
                        className: "max-w-6xl mx-auto px-4 py-4",
                        children: ae.jsxs("div", {
                            className: "flex items-center justify-between",
                            children: [
                                ae.jsxs("div", {
                                    className: "flex items-center",
                                    children: [
                                        ae.jsx("h1", {
                                            className: "text-xl font-light tracking-widest",
                                            children: "Pixie Juice"
                                        }),
                                        ae.jsx("span", {
                                            className: "ml-3 bg-neutral-900 text-neutral-500 text-[10px] px-1.5 py-0.5 rounded",
                                            children: "alpha"
                                        })
                                    ]
                                }),
                                y && ae.jsx("div", {
                                    className: "text-sm font-light tracking-widest text-neutral-300 hover:text-white transition-colors transition-300",
                                    children: ae.jsx("a", {
                                        href: "https://github.com/rmguney/pixie-juice",
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        children: "/rmguney"
                                    })
                                })
                            ]
                        })
                    })
                }),
                ae.jsx("div", {
                    className: "max-w-6xl mx-auto px-4 pb-12",
                    children: n.length === 0 ? ae.jsx("div", {
                        className: "flex justify-center",
                        children: ae.jsx("div", {
                            className: "max-w-md w-full",
                            children: ae.jsx(lM, {
                                selectedFiles: n,
                                setSelectedFiles: i,
                                onFileSelect: g
                            })
                        })
                    }) : ae.jsx("div", {
                        className: "flex justify-center",
                        children: ae.jsxs("div", {
                            className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 w-full",
                            children: [
                                ae.jsx("div", {
                                    className: "order-1 bg-black rounded-lg overflow-hidden",
                                    children: ae.jsx(lM, {
                                        selectedFiles: n,
                                        setSelectedFiles: i,
                                        onFileSelect: g
                                    })
                                }),
                                ae.jsxs("div", {
                                    className: "order-2 h-[300px] md:h-[400px] lg:h-[calc(100vh-150px)] bg-black rounded-lg overflow-hidden",
                                    children: [
                                        ae.jsx("div", {
                                            className: "p-4 border-b border-neutral-800",
                                            children: ae.jsx("h3", {
                                                className: "text-sm font-normal text-white text-center",
                                                children: "Preview"
                                            })
                                        }),
                                        ae.jsx("div", {
                                            className: "h-[calc(100%-56px)] p-4",
                                            children: ae.jsx(yI, {
                                                file: p
                                            })
                                        })
                                    ]
                                }),
                                ae.jsxs("div", {
                                    className: "order-3 md:order-3 lg:order-3",
                                    children: [
                                        !f && !a.length && ae.jsx(aR, {
                                            files: n,
                                            wasm: r,
                                            onProcess: l,
                                            setIsProcessing: d
                                        }),
                                        a.length > 0 && ae.jsx(rR, {
                                            results: a,
                                            onReset: ()=>{
                                                i([]), l([]), g(null);
                                            }
                                        })
                                    ]
                                })
                            ]
                        })
                    })
                })
            ]
        });
    }
    Zw.createRoot(document.getElementById("root")).render(ae.jsx(EE.StrictMode, {
        children: ae.jsx(_I, {})
    }));
})();
